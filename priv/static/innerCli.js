var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/commander/lib/error.js
var require_error = __commonJS({
  "node_modules/commander/lib/error.js"(exports2) {
    var CommanderError = class extends Error {
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError = class extends CommanderError {
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports2.CommanderError = CommanderError;
    exports2.InvalidArgumentError = InvalidArgumentError;
  }
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "node_modules/commander/lib/argument.js"(exports2) {
    var { InvalidArgumentError } = require_error();
    var Argument = class {
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      name() {
        return this._name;
      }
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      choices(values) {
        this.argChoices = values;
        this.parseArg = (arg, previous) => {
          if (!values.includes(arg)) {
            throw new InvalidArgumentError(`Allowed choices are ${values.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      argRequired() {
        this.required = true;
        return this;
      }
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports2.Argument = Argument;
    exports2.humanReadableArgName = humanReadableArgName;
  }
});

// node_modules/commander/lib/help.js
var require_help = __commonJS({
  "node_modules/commander/lib/help.js"(exports2) {
    var { humanReadableArgName } = require_argument();
    var Help = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
      }
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        if (cmd._hasImplicitHelpCommand()) {
          const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
          const helpCommand = cmd.createCommand(helpName).helpOption(false);
          helpCommand.description(cmd._helpCommandDescription);
          if (helpArgs)
            helpCommand.arguments(helpArgs);
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
        const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
        if (showShortHelpFlag || showLongHelpFlag) {
          let helpOption;
          if (!showShortHelpFlag) {
            helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
          } else if (!showLongHelpFlag) {
            helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
          } else {
            helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
          }
          visibleOptions.push(helpOption);
        }
        if (this.sortOptions) {
          const getSortKey = (option) => {
            return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
          };
          visibleOptions.sort((a, b) => {
            return getSortKey(a).localeCompare(getSortKey(b));
          });
        }
        return visibleOptions;
      }
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd._args.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd._args.find((argument) => argument.description)) {
          return cmd._args;
        }
        ;
        return [];
      }
      subcommandTerm(cmd) {
        const args = cmd._args.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
      }
      optionTerm(option) {
        return option.flags;
      }
      argumentTerm(argument) {
        return argument.name();
      }
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let parentCmdNames = "";
        for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
          parentCmdNames = parentCmd.name() + " " + parentCmdNames;
        }
        return parentCmdNames + cmdName + " " + cmd.usage();
      }
      commandDescription(cmd) {
        return cmd.description();
      }
      subcommandDescription(cmd) {
        return cmd.description();
      }
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices && !option.negate) {
          extraInfo.push(`choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
        }
        if (option.defaultValue !== void 0 && !option.negate) {
          extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(`choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
          }
          return term;
        }
        ;
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([commandDescription, ""]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      padWidth(cmd, helper) {
        return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
      }
      wrap(str, width, indent, minColumnWidth = 40) {
        if (str.match(/[\n]\s+/))
          return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth)
          return str;
        const leadingStr = str.substr(0, indent);
        const columnText = str.substr(indent);
        const indentString = " ".repeat(indent);
        const regex = new RegExp(".{1," + (columnWidth - 1) + "}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)", "g");
        const lines = columnText.match(regex) || [];
        return leadingStr + lines.map((line, i) => {
          if (line.slice(-1) === "\n") {
            line = line.slice(0, line.length - 1);
          }
          return (i > 0 ? indentString : "") + line.trimRight();
        }).join("\n");
      }
    };
    exports2.Help = Help;
  }
});

// node_modules/commander/lib/option.js
var require_option = __commonJS({
  "node_modules/commander/lib/option.js"(exports2) {
    var { InvalidArgumentError } = require_error();
    var Option = class {
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
      }
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      env(name) {
        this.envVar = name;
        return this;
      }
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      choices(values) {
        this.argChoices = values;
        this.parseArg = (arg, previous) => {
          if (!values.includes(arg)) {
            throw new InvalidArgumentError(`Allowed choices are ${values.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      is(arg) {
        return this.short === arg || this.long === arg;
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports2.Option = Option;
    exports2.splitOptionFlags = splitOptionFlags;
  }
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "node_modules/commander/lib/suggestSimilar.js"(exports2) {
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance)
        return Math.max(a.length, b.length);
      const d = [];
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0)
        return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1)
          return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports2.suggestSimilar = suggestSimilar;
  }
});

// node_modules/commander/lib/command.js
var require_command = __commonJS({
  "node_modules/commander/lib/command.js"(exports2) {
    var EventEmitter = require("events").EventEmitter;
    var childProcess = require("child_process");
    var path = require("path");
    var fs = require("fs");
    var { Argument, humanReadableArgName } = require_argument();
    var { CommanderError } = require_error();
    var { Help } = require_help();
    var { Option, splitOptionFlags } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command = class extends EventEmitter {
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this._args = [];
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = false;
        this._outputConfiguration = {
          writeOut: (str) => process.stdout.write(str),
          writeErr: (str) => process.stderr.write(str),
          getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : void 0,
          getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : void 0,
          outputError: (str, write) => write(str)
        };
        this._hidden = false;
        this._hasHelpOption = true;
        this._helpFlags = "-h, --help";
        this._helpDescription = "display help for command";
        this._helpShortFlag = "-h";
        this._helpLongFlag = "--help";
        this._addImplicitHelpCommand = void 0;
        this._helpCommandName = "help";
        this._helpCommandnameAndArgs = "help [command]";
        this._helpCommandDescription = "display help for command";
        this._helpConfiguration = {};
      }
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._hasHelpOption = sourceCommand._hasHelpOption;
        this._helpFlags = sourceCommand._helpFlags;
        this._helpDescription = sourceCommand._helpDescription;
        this._helpShortFlag = sourceCommand._helpShortFlag;
        this._helpLongFlag = sourceCommand._helpLongFlag;
        this._helpCommandName = sourceCommand._helpCommandName;
        this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
        this._helpCommandDescription = sourceCommand._helpCommandDescription;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args)
          cmd.arguments(args);
        this.commands.push(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc)
          return this;
        return cmd;
      }
      createCommand(name) {
        return new Command(name);
      }
      createHelp() {
        return Object.assign(new Help(), this.configureHelp());
      }
      configureHelp(configuration) {
        if (configuration === void 0)
          return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      configureOutput(configuration) {
        if (configuration === void 0)
          return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string")
          displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      addCommand(cmd, opts) {
        if (!cmd._name)
          throw new Error("Command passed to .addCommand() must have a name");
        function checkExplicitNames(commandArray) {
          commandArray.forEach((cmd2) => {
            if (cmd2._executableHandler && !cmd2._executableFile) {
              throw new Error(`Must specify executableFile for deeply nested executable: ${cmd2.name()}`);
            }
            checkExplicitNames(cmd2.commands);
          });
        }
        checkExplicitNames(cmd.commands);
        opts = opts || {};
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden)
          cmd._hidden = true;
        this.commands.push(cmd);
        cmd.parent = this;
        return this;
      }
      createArgument(name, description) {
        return new Argument(name, description);
      }
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      arguments(names) {
        names.split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      addArgument(argument) {
        const previousArgument = this._args.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
        }
        this._args.push(argument);
        return this;
      }
      addHelpCommand(enableOrNameAndArgs, description) {
        if (enableOrNameAndArgs === false) {
          this._addImplicitHelpCommand = false;
        } else {
          this._addImplicitHelpCommand = true;
          if (typeof enableOrNameAndArgs === "string") {
            this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
            this._helpCommandnameAndArgs = enableOrNameAndArgs;
          }
          this._helpCommandDescription = description || this._helpCommandDescription;
        }
        return this;
      }
      _hasImplicitHelpCommand() {
        if (this._addImplicitHelpCommand === void 0) {
          return this.commands.length && !this._actionHandler && !this._findCommand("help");
        }
        return this._addImplicitHelpCommand;
      }
      hook(event, listener) {
        const allowedValues = ["preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError(exitCode, code, message));
        }
        process.exit(exitCode);
      }
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this._args.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      createOption(flags, description) {
        return new Option(flags, description);
      }
      addOption(option) {
        const oname = option.name();
        const name = option.attributeName();
        let defaultValue = option.defaultValue;
        if (option.negate || option.optional || option.required || typeof defaultValue === "boolean") {
          if (option.negate) {
            const positiveLongFlag = option.long.replace(/^--no-/, "--");
            defaultValue = this._findOption(positiveLongFlag) ? this.getOptionValue(name) : true;
          }
          if (defaultValue !== void 0) {
            this.setOptionValueWithSource(name, defaultValue, "default");
          }
        }
        this.options.push(option);
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            try {
              val = option.parseArg(val, oldValue === void 0 ? defaultValue : oldValue);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `${invalidValueMessage} ${err.message}`;
                this._displayError(err.exitCode, err.code, message);
              }
              throw err;
            }
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (typeof oldValue === "boolean" || typeof oldValue === "undefined") {
            if (val == null) {
              this.setOptionValueWithSource(name, option.negate ? false : defaultValue || true, valueSource);
            } else {
              this.setOptionValueWithSource(name, val, valueSource);
            }
          } else if (val !== null) {
            this.setOptionValueWithSource(name, option.negate ? false : val, valueSource);
          }
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      _optionEx(config, flags, description, fn, defaultValue) {
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex = fn;
          fn = (val, def) => {
            const m = regex.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      option(flags, description, fn, defaultValue) {
        return this._optionEx({}, flags, description, fn, defaultValue);
      }
      requiredOption(flags, description, fn, defaultValue) {
        return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
      }
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
          throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
        }
        return this;
      }
      storeOptionsAsProperties(storeAsProperties = true) {
        this._storeOptionsAsProperties = !!storeAsProperties;
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        return this;
      }
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      setOptionValue(key, value) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        return this;
      }
      setOptionValueWithSource(key, value, source) {
        this.setOptionValue(key, value);
        this._optionValueSources[key] = source;
        return this;
      }
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0) {
          argv = process.argv;
          if (process.versions && process.versions.electron) {
            parseOptions.from = "electron";
          }
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          default:
            throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
        }
        if (!this._scriptPath && require.main) {
          this._scriptPath = require.main.filename;
        }
        this._name = this._name || this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath));
        return userArgs;
      }
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      parseAsync(argv, parseOptions) {
        return __async(this, null, function* () {
          const userArgs = this._prepareUserArgs(argv, parseOptions);
          yield this._parseCommand([], userArgs);
          return this;
        });
      }
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        this._checkForMissingMandatoryOptions();
        let scriptPath = this._scriptPath;
        if (!scriptPath && require.main) {
          scriptPath = require.main.filename;
        }
        let baseDir;
        try {
          const resolvedLink = fs.realpathSync(scriptPath);
          baseDir = path.dirname(resolvedLink);
        } catch (e) {
          baseDir = ".";
        }
        let bin = path.basename(scriptPath, path.extname(scriptPath)) + "-" + subcommand._name;
        if (subcommand._executableFile) {
          bin = subcommand._executableFile;
        }
        const localBin = path.join(baseDir, bin);
        if (fs.existsSync(localBin)) {
          bin = localBin;
        } else {
          sourceExt.forEach((ext) => {
            if (fs.existsSync(`${localBin}${ext}`)) {
              bin = `${localBin}${ext}`;
            }
          });
        }
        launchWithNode = sourceExt.includes(path.extname(bin));
        let proc;
        if (process.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(bin);
            args = incrementNodeInspectorPort(process.execArgv).concat(args);
            proc = childProcess.spawn(process.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess.spawn(bin, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(bin);
          args = incrementNodeInspectorPort(process.execArgv).concat(args);
          proc = childProcess.spawn(process.execPath, args, { stdio: "inherit" });
        }
        const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
        signals.forEach((signal) => {
          process.on(signal, () => {
            if (proc.killed === false && proc.exitCode === null) {
              proc.kill(signal);
            }
          });
        });
        const exitCallback = this._exitCallback;
        if (!exitCallback) {
          proc.on("close", process.exit.bind(process));
        } else {
          proc.on("close", () => {
            exitCallback(new CommanderError(process.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
          });
        }
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableMissing = `'${bin}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${bin}' not executable`);
          }
          if (!exitCallback) {
            process.exit(1);
          } else {
            const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand)
          this.help({ error: true });
        if (subCommand._executableHandler) {
          this._executeSubCommand(subCommand, operands.concat(unknown));
        } else {
          return subCommand._parseCommand(operands, unknown);
        }
      }
      _checkNumberOfArguments() {
        this._args.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
          return;
        }
        if (this.args.length > this._args.length) {
          this._excessArguments(this.args);
        }
      }
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            try {
              parsedValue = argument.parseArg(value, previous);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;
                this._displayError(err.exitCode, err.code, message);
              }
              throw err;
            }
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this._args.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === "function") {
          return promise.then(() => fn());
        }
        return fn();
      }
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        getCommandAndParents(this).reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback) => {
            hooks.push({ hookedCommand, callback });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
          if (operands.length === 1) {
            this.help();
          }
          return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
        }
        if (this._defaultCommandName) {
          outputHelpIfRequested(this, unknown);
          return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        outputHelpIfRequested(this, parsed.unknown);
        this._checkForMissingMandatoryOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let actionResult;
          actionResult = this._chainOrCallHooks(actionResult, "preAction");
          actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
          if (this.parent)
            this.parent.emit(commandEvent, operands, unknown);
          actionResult = this._chainOrCallHooks(actionResult, "postAction");
          return actionResult;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      _findCommand(name) {
        if (!name)
          return void 0;
        return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
      }
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      _checkForMissingMandatoryOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        }
      }
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown)
              dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0)
                  this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
              operands.push(arg);
              if (args.length > 0)
                operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0)
              dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      _displayError(exitCode, code, message) {
        this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        this._exit(exitCode, code, message);
      }
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this._displayError(1, "commander.missingArgument", message);
      }
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this._displayError(1, "commander.optionMissingArgument", message);
      }
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this._displayError(1, "commander.missingMandatoryOptionValue", message);
      }
      unknownOption(flag) {
        if (this._allowUnknownOption)
          return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this._displayError(1, "commander.unknownOption", message);
      }
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments)
          return;
        const expected = this._args.length;
        const s = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this._displayError(1, "commander.excessArguments", message);
      }
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias())
              candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this._displayError(1, "commander.unknownCommand", message);
      }
      version(str, flags, description) {
        if (str === void 0)
          return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this.options.push(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      alias(alias) {
        if (alias === void 0)
          return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        command._aliases.push(alias);
        return this;
      }
      aliases(aliases) {
        if (aliases === void 0)
          return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      usage(str) {
        if (str === void 0) {
          if (this._usage)
            return this._usage;
          const args = this._args.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(this.options.length || this._hasHelpOption ? "[options]" : [], this.commands.length ? "[command]" : [], this._args.length ? args : []).join(" ");
        }
        this._usage = str;
        return this;
      }
      name(str) {
        if (str === void 0)
          return this._name;
        this._name = str;
        return this;
      }
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write;
        if (context.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write;
        context.command = this;
        return context;
      }
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        getCommandAndParents(this).reverse().forEach((command) => command.emit("beforeAllHelp", context));
        this.emit("beforeHelp", context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context.write(helpInformation);
        this.emit(this._helpLongFlag);
        this.emit("afterHelp", context);
        getCommandAndParents(this).forEach((command) => command.emit("afterAllHelp", context));
      }
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          this._hasHelpOption = flags;
          return this;
        }
        this._helpFlags = flags || this._helpFlags;
        this._helpDescription = description || this._helpDescription;
        const helpFlags = splitOptionFlags(this._helpFlags);
        this._helpShortFlag = helpFlags.shortFlag;
        this._helpLongFlag = helpFlags.longFlag;
        return this;
      }
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
    };
    function outputHelpIfRequested(cmd, args) {
      const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
      if (helpOption) {
        cmd.outputHelp();
        cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    function getCommandAndParents(startCommand) {
      const result = [];
      for (let command = startCommand; command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    exports2.Command = Command;
  }
});

// node_modules/commander/index.js
var require_commander = __commonJS({
  "node_modules/commander/index.js"(exports2, module2) {
    var { Argument } = require_argument();
    var { Command } = require_command();
    var { CommanderError, InvalidArgumentError } = require_error();
    var { Help } = require_help();
    var { Option } = require_option();
    exports2 = module2.exports = new Command();
    exports2.program = exports2;
    exports2.Argument = Argument;
    exports2.Command = Command;
    exports2.CommanderError = CommanderError;
    exports2.Help = Help;
    exports2.InvalidArgumentError = InvalidArgumentError;
    exports2.InvalidOptionArgumentError = InvalidArgumentError;
    exports2.Option = Option;
  }
});

// node_modules/playwright-core/lib/utils/verifyNodeJsVersion.js
var require_verifyNodeJsVersion = __commonJS({
  "node_modules/playwright-core/lib/utils/verifyNodeJsVersion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var currentNodeVersion = process.versions.node;
    var semver = currentNodeVersion.split(".");
    var [major] = [+semver[0]];
    if (major < 12) {
      console.error("You are running Node.js " + currentNodeVersion + ".\nPlaywright requires Node.js 12 or higher. \nPlease update your version of Node.js.");
      process.exit(1);
    }
  }
});

// node_modules/playwright-core/lib/utils/errors.js
var require_errors = __commonJS({
  "node_modules/playwright-core/lib/utils/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isSafeCloseError = isSafeCloseError;
    exports2.kBrowserOrContextClosedError = exports2.kBrowserClosedError = exports2.TimeoutError = void 0;
    var CustomError = class extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    var TimeoutError = class extends CustomError {
    };
    exports2.TimeoutError = TimeoutError;
    var kBrowserClosedError = "Browser has been closed";
    exports2.kBrowserClosedError = kBrowserClosedError;
    var kBrowserOrContextClosedError = "Target page, context or browser has been closed";
    exports2.kBrowserOrContextClosedError = kBrowserOrContextClosedError;
    function isSafeCloseError(error) {
      return error.message.endsWith(kBrowserClosedError) || error.message.endsWith(kBrowserOrContextClosedError);
    }
  }
});

// node_modules/playwright-core/lib/protocol/serializers.js
var require_serializers = __commonJS({
  "node_modules/playwright-core/lib/protocol/serializers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.serializeError = serializeError;
    exports2.parseError = parseError;
    exports2.parseSerializedValue = parseSerializedValue;
    exports2.serializeValue = serializeValue;
    var _errors = require_errors();
    function serializeError(e) {
      if (isError(e))
        return {
          error: {
            message: e.message,
            stack: e.stack,
            name: e.name
          }
        };
      return {
        value: serializeValue(e, (value) => ({
          fallThrough: value
        }), /* @__PURE__ */ new Set())
      };
    }
    function parseError(error) {
      if (!error.error) {
        if (error.value === void 0)
          throw new Error("Serialized error must have either an error or a value");
        return parseSerializedValue(error.value, void 0);
      }
      if (error.error.name === "TimeoutError") {
        const e2 = new _errors.TimeoutError(error.error.message);
        e2.stack = error.error.stack || "";
        return e2;
      }
      const e = new Error(error.error.message);
      e.stack = error.error.stack || "";
      e.name = error.error.name;
      return e;
    }
    function parseSerializedValue(value, handles) {
      if (value.n !== void 0)
        return value.n;
      if (value.s !== void 0)
        return value.s;
      if (value.b !== void 0)
        return value.b;
      if (value.v !== void 0) {
        if (value.v === "undefined")
          return void 0;
        if (value.v === "null")
          return null;
        if (value.v === "NaN")
          return NaN;
        if (value.v === "Infinity")
          return Infinity;
        if (value.v === "-Infinity")
          return -Infinity;
        if (value.v === "-0")
          return -0;
      }
      if (value.d !== void 0)
        return new Date(value.d);
      if (value.r !== void 0)
        return new RegExp(value.r.p, value.r.f);
      if (value.a !== void 0)
        return value.a.map((a) => parseSerializedValue(a, handles));
      if (value.o !== void 0) {
        const result = {};
        for (const {
          k,
          v
        } of value.o)
          result[k] = parseSerializedValue(v, handles);
        return result;
      }
      if (value.h !== void 0) {
        if (handles === void 0)
          throw new Error("Unexpected handle");
        return handles[value.h];
      }
      throw new Error("Unexpected value");
    }
    function serializeValue(value, handleSerializer, visited) {
      const handle = handleSerializer(value);
      if ("fallThrough" in handle)
        value = handle.fallThrough;
      else
        return handle;
      if (visited.has(value))
        throw new Error("Argument is a circular structure");
      if (typeof value === "symbol")
        return {
          v: "undefined"
        };
      if (Object.is(value, void 0))
        return {
          v: "undefined"
        };
      if (Object.is(value, null))
        return {
          v: "null"
        };
      if (Object.is(value, NaN))
        return {
          v: "NaN"
        };
      if (Object.is(value, Infinity))
        return {
          v: "Infinity"
        };
      if (Object.is(value, -Infinity))
        return {
          v: "-Infinity"
        };
      if (Object.is(value, -0))
        return {
          v: "-0"
        };
      if (typeof value === "boolean")
        return {
          b: value
        };
      if (typeof value === "number")
        return {
          n: value
        };
      if (typeof value === "string")
        return {
          s: value
        };
      if (isError(value)) {
        const error = value;
        if ("captureStackTrace" in global.Error) {
          return {
            s: error.stack || ""
          };
        }
        return {
          s: `${error.name}: ${error.message}
${error.stack}`
        };
      }
      if (isDate(value))
        return {
          d: value.toJSON()
        };
      if (isRegExp(value))
        return {
          r: {
            p: value.source,
            f: value.flags
          }
        };
      if (Array.isArray(value)) {
        const a = [];
        visited.add(value);
        for (let i = 0; i < value.length; ++i)
          a.push(serializeValue(value[i], handleSerializer, visited));
        visited.delete(value);
        return {
          a
        };
      }
      if (typeof value === "object") {
        const o = [];
        visited.add(value);
        for (const name of Object.keys(value))
          o.push({
            k: name,
            v: serializeValue(value[name], handleSerializer, visited)
          });
        visited.delete(value);
        return {
          o
        };
      }
      throw new Error("Unexpected value");
    }
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isDate(obj) {
      return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
    }
    function isError(obj) {
      var _obj$__proto__;
      return obj instanceof Error || (obj === null || obj === void 0 ? void 0 : (_obj$__proto__ = obj.__proto__) === null || _obj$__proto__ === void 0 ? void 0 : _obj$__proto__.name) === "Error" || (obj === null || obj === void 0 ? void 0 : obj.__proto__) && isError(obj.__proto__);
    }
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports2) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports2.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs.statSync(base);
            linkTarget = fs.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports2.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "node_modules/fs.realpath/index.js"(exports2, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs = require("fs");
    var origRealpath = fs.realpath;
    var origRealpathSync = fs.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs.realpath = realpath;
      fs.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs.realpath = origRealpath;
      fs.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = { sep: "/" };
    try {
      path = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/glob/common.js
var require_common = __commonJS({
  "node_modules/glob/common.js"(exports2) {
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs = require("fs");
    var path = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && pattern.indexOf("/") === -1) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || Object.create(null);
      self2.statCache = options.statCache || Object.create(null);
      self2.symlinks = options.symlinks || Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports2, module2) {
    var wrappy = require_wrappy();
    var reqs = Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/rimraf/rimraf.js"(exports2, module2) {
    var assert = require("assert");
    var path = require("path");
    var fs = require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    var defaults = (options) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs[m];
        m = m + "Sync";
        options[m] = options[m] || fs[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    };
    var rimraf = (p, options, cb) => {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(() => rimraf_(p2, options, CB), timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          };
          rimraf_(p2, options, CB);
        });
      };
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, (er, stat) => {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options, er, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options, er) => {
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    };
    var rmdir = (p, options, originalEr, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf(path.join(p, f), options, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options) => {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      let results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p2, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options, null);
          else
            options.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options, er);
        }
      }
    };
    var rmdirSync = (p, options, originalEr) => {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    };
    var rmkidsSync = (p, options) => {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/playwright-core/lib/utils/ubuntuVersion.js
var require_ubuntuVersion = __commonJS({
  "node_modules/playwright-core/lib/utils/ubuntuVersion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getUbuntuVersion = getUbuntuVersion;
    exports2.getUbuntuVersionSync = getUbuntuVersionSync;
    exports2.parseOSReleaseText = parseOSReleaseText;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var os = _interopRequireWildcard2(require("os"));
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ubuntuVersionCached;
    function getUbuntuVersion() {
      return __async(this, null, function* () {
        if (ubuntuVersionCached === void 0)
          ubuntuVersionCached = yield getUbuntuVersionAsyncInternal();
        return ubuntuVersionCached;
      });
    }
    function getUbuntuVersionSync() {
      if (ubuntuVersionCached === void 0)
        ubuntuVersionCached = getUbuntuVersionSyncInternal();
      return ubuntuVersionCached;
    }
    function getUbuntuVersionAsyncInternal() {
      return __async(this, null, function* () {
        if (os.platform() !== "linux")
          return "";
        let osReleaseText = yield _fs2.default.promises.readFile("/etc/upstream-release/lsb-release", "utf8").catch((e) => "");
        if (!osReleaseText)
          osReleaseText = yield _fs2.default.promises.readFile("/etc/os-release", "utf8").catch((e) => "");
        if (!osReleaseText)
          return "";
        return parseUbuntuVersion(osReleaseText);
      });
    }
    function getUbuntuVersionSyncInternal() {
      if (os.platform() !== "linux")
        return "";
      try {
        let osReleaseText;
        if (_fs2.default.existsSync("/etc/upstream-release/lsb-release"))
          osReleaseText = _fs2.default.readFileSync("/etc/upstream-release/lsb-release", "utf8");
        else
          osReleaseText = _fs2.default.readFileSync("/etc/os-release", "utf8");
        if (!osReleaseText)
          return "";
        return parseUbuntuVersion(osReleaseText);
      } catch (e) {
        return "";
      }
    }
    function parseOSReleaseText(osReleaseText) {
      const fields = /* @__PURE__ */ new Map();
      for (const line of osReleaseText.split("\n")) {
        const tokens = line.split("=");
        const name = tokens.shift();
        let value = tokens.join("=").trim();
        if (value.startsWith('"') && value.endsWith('"'))
          value = value.substring(1, value.length - 1);
        if (!name)
          continue;
        fields.set(name.toLowerCase(), value);
      }
      return fields;
    }
    function parseUbuntuVersion(osReleaseText) {
      var _fields$get, _fields$get2;
      const fields = parseOSReleaseText(osReleaseText);
      if (fields.get("distrib_id") && ((_fields$get = fields.get("distrib_id")) === null || _fields$get === void 0 ? void 0 : _fields$get.toLowerCase()) === "ubuntu")
        return fields.get("distrib_release") || "";
      if (!fields.get("name") || ((_fields$get2 = fields.get("name")) === null || _fields$get2 === void 0 ? void 0 : _fields$get2.toLowerCase()) !== "ubuntu")
        return "";
      return fields.get("version_id") || "";
    }
  }
});

// node_modules/progress/lib/node-progress.js
var require_node_progress = __commonJS({
  "node_modules/progress/lib/node-progress.js"(exports2, module2) {
    exports2 = module2.exports = ProgressBar;
    function ProgressBar(fmt, options) {
      this.stream = options.stream || process.stderr;
      if (typeof options == "number") {
        var total = options;
        options = {};
        options.total = total;
      } else {
        options = options || {};
        if (typeof fmt != "string")
          throw new Error("format required");
        if (typeof options.total != "number")
          throw new Error("total required");
      }
      this.fmt = fmt;
      this.curr = options.curr || 0;
      this.total = options.total;
      this.width = options.width || this.total;
      this.clear = options.clear;
      this.chars = {
        complete: options.complete || "=",
        incomplete: options.incomplete || "-",
        head: options.head || (options.complete || "=")
      };
      this.renderThrottle = options.renderThrottle !== 0 ? options.renderThrottle || 16 : 0;
      this.lastRender = -Infinity;
      this.callback = options.callback || function() {
      };
      this.tokens = {};
      this.lastDraw = "";
    }
    ProgressBar.prototype.tick = function(len, tokens) {
      if (len !== 0)
        len = len || 1;
      if (typeof len == "object")
        tokens = len, len = 1;
      if (tokens)
        this.tokens = tokens;
      if (this.curr == 0)
        this.start = new Date();
      this.curr += len;
      this.render();
      if (this.curr >= this.total) {
        this.render(void 0, true);
        this.complete = true;
        this.terminate();
        this.callback(this);
        return;
      }
    };
    ProgressBar.prototype.render = function(tokens, force) {
      force = force !== void 0 ? force : false;
      if (tokens)
        this.tokens = tokens;
      if (!this.stream.isTTY)
        return;
      var now = Date.now();
      var delta = now - this.lastRender;
      if (!force && delta < this.renderThrottle) {
        return;
      } else {
        this.lastRender = now;
      }
      var ratio = this.curr / this.total;
      ratio = Math.min(Math.max(ratio, 0), 1);
      var percent = Math.floor(ratio * 100);
      var incomplete, complete, completeLength;
      var elapsed = new Date() - this.start;
      var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
      var rate = this.curr / (elapsed / 1e3);
      var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
      var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
      if (availableSpace && process.platform === "win32") {
        availableSpace = availableSpace - 1;
      }
      var width = Math.min(this.width, availableSpace);
      completeLength = Math.round(width * ratio);
      complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
      incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
      if (completeLength > 0)
        complete = complete.slice(0, -1) + this.chars.head;
      str = str.replace(":bar", complete + incomplete);
      if (this.tokens)
        for (var key in this.tokens)
          str = str.replace(":" + key, this.tokens[key]);
      if (this.lastDraw !== str) {
        this.stream.cursorTo(0);
        this.stream.write(str);
        this.stream.clearLine(1);
        this.lastDraw = str;
      }
    };
    ProgressBar.prototype.update = function(ratio, tokens) {
      var goal = Math.floor(ratio * this.total);
      var delta = goal - this.curr;
      this.tick(delta, tokens);
    };
    ProgressBar.prototype.interrupt = function(message) {
      this.stream.clearLine();
      this.stream.cursorTo(0);
      this.stream.write(message);
      this.stream.write("\n");
      this.stream.write(this.lastDraw);
    };
    ProgressBar.prototype.terminate = function() {
      if (this.clear) {
        if (this.stream.clearLine) {
          this.stream.clearLine();
          this.stream.cursorTo(0);
        }
      } else {
        this.stream.write("\n");
      }
    };
  }
});

// node_modules/progress/index.js
var require_progress = __commonJS({
  "node_modules/progress/index.js"(exports2, module2) {
    module2.exports = require_node_progress();
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify;
  }
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              const servername = opts.servername || opts.host;
              if (!servername) {
                throw new Error('Could not determine "servername"');
              }
              debug("Upgrading socket connection to TLS");
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket();
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module2.exports = createHttpsProxyAgent;
  }
});

// node_modules/playwright-core/package.json
var require_package = __commonJS({
  "node_modules/playwright-core/package.json"(exports2, module2) {
    module2.exports = {
      name: "playwright-core",
      version: "1.18.1",
      description: "A high-level API to automate web browsers",
      repository: "github:Microsoft/playwright",
      homepage: "https://playwright.dev",
      engines: {
        node: ">=12"
      },
      scripts: {
        prepare: 'babel --config-file ../../babel.config.json -s --extensions ".ts" --out-dir lib/utils/ src/utils'
      },
      author: {
        name: "Microsoft Corporation"
      },
      license: "Apache-2.0",
      exports: {
        ".": {
          import: "./index.mjs",
          require: "./index.js"
        },
        "./cli": "./cli.js",
        "./package.json": "./package.json",
        "./lib/grid/gridServer": "./lib/grid/gridServer.js",
        "./lib/grid/gridClient": "./lib/grid/gridClient.js",
        "./lib/grid/dockerGridFactory": "./lib/grid/dockerGridFactory.js",
        "./lib/utils/async": "./lib/utils/async.js",
        "./lib/utils/httpServer": "./lib/utils/httpServer.js",
        "./lib/utils/multimap": "./lib/utils/multimap.js",
        "./lib/utils/processLauncher": "./lib/utils/processLauncher.js",
        "./lib/utils/registry": "./lib/utils/registry.js",
        "./lib/utils/utils": "./lib/utils/utils.js"
      },
      types: "types/types.d.ts",
      bin: {
        playwright: "./cli.js"
      },
      dependencies: {
        commander: "^8.2.0",
        debug: "^4.1.1",
        "extract-zip": "^2.0.1",
        "https-proxy-agent": "^5.0.0",
        "jpeg-js": "^0.4.2",
        mime: "^2.4.6",
        pngjs: "^5.0.0",
        progress: "^2.0.3",
        "proper-lockfile": "^4.1.1",
        "proxy-from-env": "^1.1.0",
        rimraf: "^3.0.2",
        "socks-proxy-agent": "^6.1.0",
        "stack-utils": "^2.0.3",
        ws: "^7.4.6",
        yauzl: "^2.10.0",
        yazl: "^2.5.1"
      }
    };
  }
});

// node_modules/playwright-core/lib/utils/utils.js
var require_utils = __commonJS({
  "node_modules/playwright-core/lib/utils/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fetchData = fetchData;
    exports2.download = download;
    exports2.spawnAsync = spawnAsync;
    exports2.makeWaitForNextTask = makeWaitForNextTask;
    exports2.assert = assert;
    exports2.debugAssert = debugAssert;
    exports2.isString = isString;
    exports2.isRegExp = isRegExp;
    exports2.isObject = isObject;
    exports2.isError = isError;
    exports2.debugMode = debugMode;
    exports2.setUnderTest = setUnderTest;
    exports2.isUnderTest = isUnderTest;
    exports2.getFromENV = getFromENV;
    exports2.getAsBooleanFromENV = getAsBooleanFromENV;
    exports2.mkdirIfNeeded = mkdirIfNeeded;
    exports2.headersObjectToArray = headersObjectToArray;
    exports2.headersArrayToObject = headersArrayToObject;
    exports2.monotonicTime = monotonicTime;
    exports2.objectToArray = objectToArray;
    exports2.arrayToObject = arrayToObject;
    exports2.calculateSha1 = calculateSha1;
    exports2.createGuid = createGuid;
    exports2.removeFolders = removeFolders;
    exports2.canAccessFile = canAccessFile;
    exports2.getUserAgent = getUserAgent;
    exports2.getPlaywrightVersion = getPlaywrightVersion;
    exports2.constructURLBasedOnBaseURL = constructURLBasedOnBaseURL;
    exports2.wrapInASCIIBox = wrapInASCIIBox;
    exports2.isFilePayload = isFilePayload;
    exports2.streamToString = streamToString;
    exports2.transformCommandsForRoot = transformCommandsForRoot;
    exports2.hostPlatform = exports2.existsAsync = void 0;
    var _path2 = _interopRequireDefault2(require("path"));
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _rimraf = _interopRequireDefault2(require_rimraf());
    var crypto = _interopRequireWildcard2(require("crypto"));
    var _os2 = _interopRequireDefault2(require("os"));
    var _http = _interopRequireDefault2(require("http"));
    var _https = _interopRequireDefault2(require("https"));
    var _child_process2 = require("child_process");
    var _proxyFromEnv = require_proxy_from_env();
    var URL2 = _interopRequireWildcard2(require("url"));
    var _ubuntuVersion = require_ubuntuVersion();
    var _progress = _interopRequireDefault2(require_progress());
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ProxyAgent = require_dist();
    var existsAsync = (path) => new Promise((resolve) => _fs2.default.stat(path, (err) => resolve(!err)));
    exports2.existsAsync = existsAsync;
    function httpRequest(params, onResponse, onError) {
      const parsedUrl = URL2.parse(params.url);
      let options = __spreadValues({}, parsedUrl);
      options.method = params.method || "GET";
      options.headers = params.headers;
      const proxyURL = (0, _proxyFromEnv.getProxyForUrl)(params.url);
      if (proxyURL) {
        if (params.url.startsWith("http:")) {
          const proxy = URL2.parse(proxyURL);
          options = {
            path: parsedUrl.href,
            host: proxy.hostname,
            port: proxy.port
          };
        } else {
          const parsedProxyURL = URL2.parse(proxyURL);
          parsedProxyURL.secureProxy = parsedProxyURL.protocol === "https:";
          options.agent = new ProxyAgent(parsedProxyURL);
          options.rejectUnauthorized = false;
        }
      }
      const requestCallback = (res) => {
        const statusCode = res.statusCode || 0;
        if (statusCode >= 300 && statusCode < 400 && res.headers.location)
          httpRequest(__spreadProps(__spreadValues({}, params), {
            url: res.headers.location
          }), onResponse, onError);
        else
          onResponse(res);
      };
      const request = options.protocol === "https:" ? _https.default.request(options, requestCallback) : _http.default.request(options, requestCallback);
      request.on("error", onError);
      if (params.timeout !== void 0) {
        const rejectOnTimeout = () => {
          onError(new Error(`Request to ${params.url} timed out after ${params.timeout}ms`));
          request.abort();
        };
        if (params.timeout <= 0) {
          rejectOnTimeout();
          return;
        }
        request.setTimeout(params.timeout, rejectOnTimeout);
      }
      request.end(params.data);
    }
    function fetchData(params, onError) {
      return new Promise((resolve, reject) => {
        httpRequest(params, (response) => __async(this, null, function* () {
          if (response.statusCode !== 200) {
            const error = onError ? yield onError(params, response) : new Error(`fetch failed: server returned code ${response.statusCode}. URL: ${params.url}`);
            reject(error);
            return;
          }
          let body = "";
          response.on("data", (chunk) => body += chunk);
          response.on("error", (error) => reject(error));
          response.on("end", () => resolve(body));
        }), reject);
      });
    }
    function downloadFile(url, destinationPath, options = {}) {
      const {
        progressCallback,
        log = () => {
        }
      } = options;
      log(`running download:`);
      log(`-- from url: ${url}`);
      log(`-- to location: ${destinationPath}`);
      let fulfill = ({
        error
      }) => {
      };
      let downloadedBytes = 0;
      let totalBytes = 0;
      const promise = new Promise((x) => {
        fulfill = x;
      });
      httpRequest({
        url,
        headers: options.userAgent ? {
          "User-Agent": options.userAgent
        } : void 0
      }, (response) => {
        log(`-- response status code: ${response.statusCode}`);
        if (response.statusCode !== 200) {
          const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);
          response.resume();
          fulfill({
            error
          });
          return;
        }
        const file = _fs2.default.createWriteStream(destinationPath);
        file.on("finish", () => fulfill({
          error: null
        }));
        file.on("error", (error) => fulfill({
          error
        }));
        response.pipe(file);
        totalBytes = parseInt(response.headers["content-length"] || "0", 10);
        log(`-- total bytes: ${totalBytes}`);
        if (progressCallback)
          response.on("data", onData);
      }, (error) => fulfill({
        error
      }));
      return promise;
      function onData(chunk) {
        downloadedBytes += chunk.length;
        progressCallback(downloadedBytes, totalBytes);
      }
    }
    function download(_0, _1) {
      return __async(this, arguments, function* (url, destination, options = {}) {
        const {
          progressBarName = "file",
          retryCount = 3,
          log = () => {
          },
          userAgent
        } = options;
        for (let attempt = 1; attempt <= retryCount; ++attempt) {
          log(`downloading ${progressBarName} - attempt #${attempt}`);
          const {
            error
          } = yield downloadFile(url, destination, {
            progressCallback: getDownloadProgress(progressBarName),
            log,
            userAgent
          });
          if (!error) {
            log(`SUCCESS downloading ${progressBarName}`);
            break;
          }
          const errorMessage = (error === null || error === void 0 ? void 0 : error.message) || "";
          log(`attempt #${attempt} - ERROR: ${errorMessage}`);
          if (attempt < retryCount && (errorMessage.includes("ECONNRESET") || errorMessage.includes("ETIMEDOUT"))) {
            const millis = Math.random() * 200 + 250 * Math.pow(1.5, attempt);
            log(`sleeping ${millis}ms before retry...`);
            yield new Promise((c) => setTimeout(c, millis));
          } else {
            throw error;
          }
        }
      });
    }
    function getDownloadProgress(progressBarName) {
      let progressBar;
      let lastDownloadedBytes = 0;
      return (downloadedBytes, totalBytes) => {
        if (!process.stderr.isTTY)
          return;
        if (!progressBar) {
          progressBar = new _progress.default(`Downloading ${progressBarName} - ${toMegabytes(totalBytes)} [:bar] :percent :etas `, {
            complete: "=",
            incomplete: " ",
            width: 20,
            total: totalBytes
          });
        }
        const delta = downloadedBytes - lastDownloadedBytes;
        lastDownloadedBytes = downloadedBytes;
        progressBar.tick(delta);
      };
    }
    function toMegabytes(bytes) {
      const mb = bytes / 1024 / 1024;
      return `${Math.round(mb * 10) / 10} Mb`;
    }
    function spawnAsync(cmd, args, options = {}) {
      const process2 = (0, _child_process2.spawn)(cmd, args, options);
      return new Promise((resolve) => {
        let stdout = "";
        let stderr = "";
        if (process2.stdout)
          process2.stdout.on("data", (data) => stdout += data);
        if (process2.stderr)
          process2.stderr.on("data", (data) => stderr += data);
        process2.on("close", (code) => resolve({
          stdout,
          stderr,
          code
        }));
        process2.on("error", (error) => resolve({
          stdout,
          stderr,
          code: 0,
          error
        }));
      });
    }
    function makeWaitForNextTask() {
      if (process.versions.electron)
        return (callback) => setTimeout(callback, 0);
      if (parseInt(process.versions.node, 10) >= 11)
        return setImmediate;
      let spinning = false;
      const callbacks = [];
      const loop = () => {
        const callback = callbacks.shift();
        if (!callback) {
          spinning = false;
          return;
        }
        setImmediate(loop);
        callback();
      };
      return (callback) => {
        callbacks.push(callback);
        if (!spinning) {
          spinning = true;
          setImmediate(loop);
        }
      };
    }
    function assert(value, message) {
      if (!value)
        throw new Error(message || "Assertion error");
    }
    function debugAssert(value, message) {
      if (isUnderTest() && !value)
        throw new Error(message);
    }
    function isString(obj) {
      return typeof obj === "string" || obj instanceof String;
    }
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isObject(obj) {
      return typeof obj === "object" && obj !== null;
    }
    function isError(obj) {
      return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === "Error";
    }
    var debugEnv = getFromENV("PWDEBUG") || "";
    function debugMode() {
      if (debugEnv === "console")
        return "console";
      return debugEnv ? "inspector" : "";
    }
    var _isUnderTest = false;
    function setUnderTest() {
      _isUnderTest = true;
    }
    function isUnderTest() {
      return _isUnderTest;
    }
    function getFromENV(name) {
      let value = process.env[name];
      value = value === void 0 ? process.env[`npm_config_${name.toLowerCase()}`] : value;
      value = value === void 0 ? process.env[`npm_package_config_${name.toLowerCase()}`] : value;
      return value;
    }
    function getAsBooleanFromENV(name) {
      const value = getFromENV(name);
      return !!value && value !== "false" && value !== "0";
    }
    function mkdirIfNeeded(filePath) {
      return __async(this, null, function* () {
        yield _fs2.default.promises.mkdir(_path2.default.dirname(filePath), {
          recursive: true
        }).catch(() => {
        });
      });
    }
    function headersObjectToArray(headers, separator, setCookieSeparator) {
      if (!setCookieSeparator)
        setCookieSeparator = separator;
      const result = [];
      for (const name in headers) {
        const values = headers[name];
        if (separator) {
          const sep = name.toLowerCase() === "set-cookie" ? setCookieSeparator : separator;
          for (const value of values.split(sep))
            result.push({
              name,
              value: value.trim()
            });
        } else {
          result.push({
            name,
            value: values
          });
        }
      }
      return result;
    }
    function headersArrayToObject(headers, lowerCase) {
      const result = {};
      for (const {
        name,
        value
      } of headers)
        result[lowerCase ? name.toLowerCase() : name] = value;
      return result;
    }
    function monotonicTime() {
      const [seconds, nanoseconds] = process.hrtime();
      return seconds * 1e3 + (nanoseconds / 1e3 | 0) / 1e3;
    }
    function objectToArray(map) {
      if (!map)
        return void 0;
      const result = [];
      for (const [name, value] of Object.entries(map))
        result.push({
          name,
          value: String(value)
        });
      return result;
    }
    function arrayToObject(array) {
      if (!array)
        return void 0;
      const result = {};
      for (const {
        name,
        value
      } of array)
        result[name] = value;
      return result;
    }
    function calculateSha1(buffer) {
      const hash = crypto.createHash("sha1");
      hash.update(buffer);
      return hash.digest("hex");
    }
    function createGuid() {
      return crypto.randomBytes(16).toString("hex");
    }
    function removeFolders(dirs) {
      return __async(this, null, function* () {
        return yield Promise.all(dirs.map((dir) => {
          return new Promise((fulfill) => {
            (0, _rimraf.default)(dir, {
              maxBusyTries: 10
            }, (error) => {
              fulfill(error !== null && error !== void 0 ? error : void 0);
            });
          });
        }));
      });
    }
    function canAccessFile(file) {
      if (!file)
        return false;
      try {
        _fs2.default.accessSync(file);
        return true;
      } catch (e) {
        return false;
      }
    }
    var cachedUserAgent;
    function getUserAgent() {
      if (cachedUserAgent)
        return cachedUserAgent;
      try {
        cachedUserAgent = determineUserAgent();
      } catch (e) {
        cachedUserAgent = "Playwright/unknown";
      }
      return cachedUserAgent;
    }
    function determineUserAgent() {
      let osIdentifier = "unknown";
      let osVersion = "unknown";
      if (process.platform === "win32") {
        const version = _os2.default.release().split(".");
        osIdentifier = "windows";
        osVersion = `${version[0]}.${version[1]}`;
      } else if (process.platform === "darwin") {
        const version = (0, _child_process2.execSync)("sw_vers -productVersion").toString().trim().split(".");
        osIdentifier = "macOS";
        osVersion = `${version[0]}.${version[1]}`;
      } else if (process.platform === "linux") {
        try {
          const osReleaseText = _fs2.default.readFileSync("/etc/os-release", "utf8");
          const fields = (0, _ubuntuVersion.parseOSReleaseText)(osReleaseText);
          osIdentifier = fields.get("id") || "unknown";
          osVersion = fields.get("version_id") || "unknown";
        } catch (e) {
          osIdentifier = "linux";
        }
      }
      let langName = "unknown";
      let langVersion = "unknown";
      if (!process.env.PW_CLI_TARGET_LANG) {
        langName = "node";
        langVersion = process.version.substring(1).split(".").slice(0, 2).join(".");
      } else if (["node", "python", "java", "csharp"].includes(process.env.PW_CLI_TARGET_LANG)) {
        var _process$env$PW_CLI_T;
        langName = process.env.PW_CLI_TARGET_LANG;
        langVersion = (_process$env$PW_CLI_T = process.env.PW_CLI_TARGET_LANG_VERSION) !== null && _process$env$PW_CLI_T !== void 0 ? _process$env$PW_CLI_T : "unknown";
      }
      return `Playwright/${getPlaywrightVersion()} (${_os2.default.arch()}; ${osIdentifier} ${osVersion}) ${langName}/${langVersion}`;
    }
    function getPlaywrightVersion(majorMinorOnly = false) {
      const packageJson = require_package();
      return majorMinorOnly ? packageJson.version.split(".").slice(0, 2).join(".") : packageJson.version;
    }
    function constructURLBasedOnBaseURL(baseURL, givenURL) {
      try {
        return new URL2.URL(givenURL, baseURL).toString();
      } catch (e) {
        return givenURL;
      }
    }
    var hostPlatform = (() => {
      const platform = _os2.default.platform();
      if (platform === "darwin") {
        const ver = _os2.default.release().split(".").map((a) => parseInt(a, 10));
        let macVersion = "";
        if (ver[0] < 18) {
          macVersion = "mac10.13";
        } else if (ver[0] === 18) {
          macVersion = "mac10.14";
        } else if (ver[0] === 19) {
          macVersion = "mac10.15";
        } else {
          const LAST_STABLE_MAC_MAJOR_VERSION = 12;
          macVersion = "mac" + Math.min(ver[0] - 9, LAST_STABLE_MAC_MAJOR_VERSION);
          if (_os2.default.cpus().some((cpu) => cpu.model.includes("Apple")))
            macVersion += "-arm64";
        }
        return macVersion;
      }
      if (platform === "linux") {
        const ubuntuVersion = (0, _ubuntuVersion.getUbuntuVersionSync)();
        const archSuffix = _os2.default.arch() === "arm64" ? "-arm64" : "";
        if (parseInt(ubuntuVersion, 10) <= 19)
          return "ubuntu18.04" + archSuffix;
        return "ubuntu20.04" + archSuffix;
      }
      if (platform === "win32")
        return "win64";
      return platform;
    })();
    exports2.hostPlatform = hostPlatform;
    function wrapInASCIIBox(text, padding = 0) {
      const lines = text.split("\n");
      const maxLength = Math.max(...lines.map((line) => line.length));
      return ["\u2554" + "\u2550".repeat(maxLength + padding * 2) + "\u2557", ...lines.map((line) => "\u2551" + " ".repeat(padding) + line + " ".repeat(maxLength - line.length + padding) + "\u2551"), "\u255A" + "\u2550".repeat(maxLength + padding * 2) + "\u255D"].join("\n");
    }
    function isFilePayload(value) {
      return typeof value === "object" && value["name"] && value["mimeType"] && value["buffer"];
    }
    function streamToString(stream) {
      return new Promise((resolve, reject) => {
        const chunks = [];
        stream.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
        stream.on("error", reject);
        stream.on("end", () => resolve(Buffer.concat(chunks).toString("utf8")));
      });
    }
    function transformCommandsForRoot(commands) {
      return __async(this, null, function* () {
        const isRoot = process.getuid() === 0;
        if (isRoot)
          return {
            command: "sh",
            args: ["-c", `${commands.join("&& ")}`],
            elevatedPermissions: false
          };
        const sudoExists = yield spawnAsync("which", ["sudo"]);
        if (sudoExists.code === 0)
          return {
            command: "sudo",
            args: ["--", "sh", "-c", `${commands.join("&& ")}`],
            elevatedPermissions: true
          };
        return {
          command: "su",
          args: ["root", "-c", `${commands.join("&& ")}`],
          elevatedPermissions: true
        };
      });
    }
  }
});

// node_modules/playwright-core/lib/protocol/validatorPrimitives.js
var require_validatorPrimitives = __commonJS({
  "node_modules/playwright-core/lib/protocol/validatorPrimitives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.tEnum = exports2.tObject = exports2.tArray = exports2.tOptional = exports2.tAny = exports2.tUndefined = exports2.tBinary = exports2.tString = exports2.tBoolean = exports2.tNumber = exports2.ValidationError = void 0;
    var _utils2 = require_utils();
    var ValidationError = class extends Error {
    };
    exports2.ValidationError = ValidationError;
    var tNumber = (arg, path) => {
      if (arg instanceof Number)
        return arg.valueOf();
      if (typeof arg === "number")
        return arg;
      throw new ValidationError(`${path}: expected number, got ${typeof arg}`);
    };
    exports2.tNumber = tNumber;
    var tBoolean = (arg, path) => {
      if (arg instanceof Boolean)
        return arg.valueOf();
      if (typeof arg === "boolean")
        return arg;
      throw new ValidationError(`${path}: expected boolean, got ${typeof arg}`);
    };
    exports2.tBoolean = tBoolean;
    var tString = (arg, path) => {
      if (arg instanceof String)
        return arg.valueOf();
      if (typeof arg === "string")
        return arg;
      throw new ValidationError(`${path}: expected string, got ${typeof arg}`);
    };
    exports2.tString = tString;
    var tBinary = (arg, path) => {
      if (arg instanceof String)
        return arg.valueOf();
      if (typeof arg === "string")
        return arg;
      throw new ValidationError(`${path}: expected base64-encoded buffer, got ${typeof arg}`);
    };
    exports2.tBinary = tBinary;
    var tUndefined = (arg, path) => {
      if (Object.is(arg, void 0))
        return arg;
      throw new ValidationError(`${path}: expected undefined, got ${typeof arg}`);
    };
    exports2.tUndefined = tUndefined;
    var tAny = (arg, path) => {
      return arg;
    };
    exports2.tAny = tAny;
    var tOptional = (v) => {
      return (arg, path) => {
        if (Object.is(arg, void 0))
          return arg;
        return v(arg, path);
      };
    };
    exports2.tOptional = tOptional;
    var tArray = (v) => {
      return (arg, path) => {
        if (!Array.isArray(arg))
          throw new ValidationError(`${path}: expected array, got ${typeof arg}`);
        return arg.map((x, index) => v(x, path + "[" + index + "]"));
      };
    };
    exports2.tArray = tArray;
    var tObject = (s) => {
      return (arg, path) => {
        if (Object.is(arg, null))
          throw new ValidationError(`${path}: expected object, got null`);
        if (typeof arg !== "object")
          throw new ValidationError(`${path}: expected object, got ${typeof arg}`);
        const result = {};
        for (const [key, v] of Object.entries(s)) {
          const value = v(arg[key], path ? path + "." + key : key);
          if (!Object.is(value, void 0))
            result[key] = value;
        }
        if ((0, _utils2.isUnderTest)()) {
          for (const [key, value] of Object.entries(arg)) {
            if (key.startsWith("__testHook"))
              result[key] = value;
          }
        }
        return result;
      };
    };
    exports2.tObject = tObject;
    var tEnum = (e) => {
      return (arg, path) => {
        if (!e.includes(arg))
          throw new ValidationError(`${path}: expected one of (${e.join("|")})`);
        return arg;
      };
    };
    exports2.tEnum = tEnum;
  }
});

// node_modules/playwright-core/lib/protocol/validator.js
var require_validator = __commonJS({
  "node_modules/playwright-core/lib/protocol/validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createScheme = createScheme;
    Object.defineProperty(exports2, "Validator", {
      enumerable: true,
      get: function() {
        return _validatorPrimitives.Validator;
      }
    });
    Object.defineProperty(exports2, "ValidationError", {
      enumerable: true,
      get: function() {
        return _validatorPrimitives.ValidationError;
      }
    });
    var _validatorPrimitives = require_validatorPrimitives();
    function createScheme(tChannel) {
      const scheme = {};
      const tType = (name) => {
        return (arg, path) => {
          const v = scheme[name];
          if (!v)
            throw new _validatorPrimitives.ValidationError(path + ': unknown type "' + name + '"');
          return v(arg, path);
        };
      };
      scheme.StackFrame = (0, _validatorPrimitives.tObject)({
        file: _validatorPrimitives.tString,
        line: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        column: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        function: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.Metadata = (0, _validatorPrimitives.tObject)({
        stack: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("StackFrame"))),
        apiName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        internal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.Point = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber
      });
      scheme.Rect = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber,
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      });
      scheme.SerializedValue = (0, _validatorPrimitives.tObject)({
        n: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        b: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        s: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        v: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["null", "undefined", "NaN", "Infinity", "-Infinity", "-0"])),
        d: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        r: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          p: _validatorPrimitives.tString,
          f: _validatorPrimitives.tString
        })),
        a: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("SerializedValue"))),
        o: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          k: _validatorPrimitives.tString,
          v: tType("SerializedValue")
        }))),
        h: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.SerializedArgument = (0, _validatorPrimitives.tObject)({
        value: tType("SerializedValue"),
        handles: (0, _validatorPrimitives.tArray)(tChannel("*"))
      });
      scheme.ExpectedTextValue = (0, _validatorPrimitives.tObject)({
        string: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        regexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        regexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        matchSubstring: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        normalizeWhiteSpace: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.AXNode = (0, _validatorPrimitives.tObject)({
        role: _validatorPrimitives.tString,
        name: _validatorPrimitives.tString,
        valueString: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        valueNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        description: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        keyshortcuts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        roledescription: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        valuetext: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        disabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        expanded: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        multiline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        multiselectable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        readonly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        required: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        checked: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["checked", "unchecked", "mixed"])),
        pressed: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["pressed", "released", "mixed"])),
        level: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        valuemin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        valuemax: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        autocomplete: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        haspopup: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        invalid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        orientation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("AXNode")))
      });
      scheme.SetNetworkCookie = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: _validatorPrimitives.tString,
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        domain: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        expires: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        httpOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        secure: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        sameSite: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["Strict", "Lax", "None"]))
      });
      scheme.NetworkCookie = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: _validatorPrimitives.tString,
        domain: _validatorPrimitives.tString,
        path: _validatorPrimitives.tString,
        expires: _validatorPrimitives.tNumber,
        httpOnly: _validatorPrimitives.tBoolean,
        secure: _validatorPrimitives.tBoolean,
        sameSite: (0, _validatorPrimitives.tEnum)(["Strict", "Lax", "None"])
      });
      scheme.NameValue = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: _validatorPrimitives.tString
      });
      scheme.OriginStorage = (0, _validatorPrimitives.tObject)({
        origin: _validatorPrimitives.tString,
        localStorage: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme.SerializedError = (0, _validatorPrimitives.tObject)({
        error: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          message: _validatorPrimitives.tString,
          name: _validatorPrimitives.tString,
          stack: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        value: (0, _validatorPrimitives.tOptional)(tType("SerializedValue"))
      });
      scheme.FormField = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        file: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          name: _validatorPrimitives.tString,
          mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          buffer: _validatorPrimitives.tBinary
        }))
      });
      scheme.APIRequestContextFetchParams = (0, _validatorPrimitives.tObject)({
        url: _validatorPrimitives.tString,
        params: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
        jsonData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        formData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        multipartData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("FormField"))),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        failOnStatusCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.APIRequestContextFetchResponseBodyParams = (0, _validatorPrimitives.tObject)({
        fetchUid: _validatorPrimitives.tString
      });
      scheme.APIRequestContextFetchLogParams = (0, _validatorPrimitives.tObject)({
        fetchUid: _validatorPrimitives.tString
      });
      scheme.APIRequestContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.APIRequestContextDisposeAPIResponseParams = (0, _validatorPrimitives.tObject)({
        fetchUid: _validatorPrimitives.tString
      });
      scheme.APIRequestContextDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.APIResponse = (0, _validatorPrimitives.tObject)({
        fetchUid: _validatorPrimitives.tString,
        url: _validatorPrimitives.tString,
        status: _validatorPrimitives.tNumber,
        statusText: _validatorPrimitives.tString,
        headers: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme.LifecycleEvent = (0, _validatorPrimitives.tEnum)(["load", "domcontentloaded", "networkidle", "commit"]);
      scheme.LocalUtilsZipParams = (0, _validatorPrimitives.tObject)({
        zipFile: _validatorPrimitives.tString,
        entries: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme.RootInitializeParams = (0, _validatorPrimitives.tObject)({
        sdkLanguage: _validatorPrimitives.tString
      });
      scheme.PlaywrightSocksConnectedParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        host: _validatorPrimitives.tString,
        port: _validatorPrimitives.tNumber
      });
      scheme.PlaywrightSocksFailedParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        errorCode: _validatorPrimitives.tString
      });
      scheme.PlaywrightSocksDataParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        data: _validatorPrimitives.tBinary
      });
      scheme.PlaywrightSocksErrorParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        error: _validatorPrimitives.tString
      });
      scheme.PlaywrightSocksEndParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString
      });
      scheme.PlaywrightNewRequestParams = (0, _validatorPrimitives.tObject)({
        baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          cookies: (0, _validatorPrimitives.tArray)(tType("NetworkCookie")),
          origins: (0, _validatorPrimitives.tArray)(tType("OriginStorage"))
        }))
      });
      scheme.PlaywrightHideHighlightParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.SelectorsRegisterParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        source: _validatorPrimitives.tString,
        contentScript: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.BrowserTypeConnectParams = (0, _validatorPrimitives.tObject)({
        wsEndpoint: _validatorPrimitives.tString,
        headers: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserTypeLaunchParams = (0, _validatorPrimitives.tObject)({
        channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        firefoxUserPrefs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserTypeLaunchPersistentContextParams = (0, _validatorPrimitives.tObject)({
        channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none"])),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userDataDir: _validatorPrimitives.tString,
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserTypeConnectOverCDPParams = (0, _validatorPrimitives.tObject)({
        endpointURL: _validatorPrimitives.tString,
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserKillForTestsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserNewContextParams = (0, _validatorPrimitives.tObject)({
        noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none"])),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          cookies: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("SetNetworkCookie"))),
          origins: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("OriginStorage")))
        }))
      });
      scheme.BrowserNewBrowserCDPSessionParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserStartTracingParams = (0, _validatorPrimitives.tObject)({
        page: (0, _validatorPrimitives.tOptional)(tChannel("Page")),
        path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        categories: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
      });
      scheme.BrowserStopTracingParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.EventTargetWaitForEventInfoParams = (0, _validatorPrimitives.tObject)({
        info: (0, _validatorPrimitives.tObject)({
          waitId: _validatorPrimitives.tString,
          phase: (0, _validatorPrimitives.tEnum)(["before", "after", "log"]),
          event: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          message: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })
      });
      scheme.BrowserContextWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme.PageWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme.WebSocketWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme.ElectronApplicationWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme.AndroidDeviceWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme.BrowserContextAddCookiesParams = (0, _validatorPrimitives.tObject)({
        cookies: (0, _validatorPrimitives.tArray)(tType("SetNetworkCookie"))
      });
      scheme.BrowserContextAddInitScriptParams = (0, _validatorPrimitives.tObject)({
        source: _validatorPrimitives.tString
      });
      scheme.BrowserContextClearCookiesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextClearPermissionsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextCookiesParams = (0, _validatorPrimitives.tObject)({
        urls: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
      });
      scheme.BrowserContextExposeBindingParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.BrowserContextGrantPermissionsParams = (0, _validatorPrimitives.tObject)({
        permissions: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString),
        origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.BrowserContextNewPageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserContextSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserContextSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({
        headers: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme.BrowserContextSetGeolocationParams = (0, _validatorPrimitives.tObject)({
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        }))
      });
      scheme.BrowserContextSetHTTPCredentialsParams = (0, _validatorPrimitives.tObject)({
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        }))
      });
      scheme.BrowserContextSetNetworkInterceptionEnabledParams = (0, _validatorPrimitives.tObject)({
        enabled: _validatorPrimitives.tBoolean
      });
      scheme.BrowserContextSetOfflineParams = (0, _validatorPrimitives.tObject)({
        offline: _validatorPrimitives.tBoolean
      });
      scheme.BrowserContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextPauseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextRecorderSupplementEnableParams = (0, _validatorPrimitives.tObject)({
        language: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        startRecording: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        pauseOnNextStatement: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        launchOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        contextOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        device: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        saveStorage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        outputFile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.BrowserContextNewCDPSessionParams = (0, _validatorPrimitives.tObject)({
        page: (0, _validatorPrimitives.tOptional)(tChannel("Page")),
        frame: (0, _validatorPrimitives.tOptional)(tChannel("Frame"))
      });
      scheme.BrowserContextTracingStartParams = (0, _validatorPrimitives.tObject)({
        name: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        snapshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        sources: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.BrowserContextTracingStartChunkParams = (0, _validatorPrimitives.tObject)({
        title: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.BrowserContextTracingStopChunkParams = (0, _validatorPrimitives.tObject)({
        mode: (0, _validatorPrimitives.tEnum)(["doNotSave", "compressTrace", "compressTraceAndSources"])
      });
      scheme.BrowserContextTracingStopParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextHarExportParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.PageSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageSetFileChooserInterceptedNoReplyParams = (0, _validatorPrimitives.tObject)({
        intercepted: _validatorPrimitives.tBoolean
      });
      scheme.PageAddInitScriptParams = (0, _validatorPrimitives.tObject)({
        source: _validatorPrimitives.tString
      });
      scheme.PageCloseParams = (0, _validatorPrimitives.tObject)({
        runBeforeUnload: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.PageEmulateMediaParams = (0, _validatorPrimitives.tObject)({
        media: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["screen", "print", "null"])),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference", "null"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference", "null"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none", "null"]))
      });
      scheme.PageExposeBindingParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.PageGoBackParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme.PageGoForwardParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme.PageReloadParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme.PageScreenshotParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["png", "jpeg"])),
        quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        fullPage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        clip: (0, _validatorPrimitives.tOptional)(tType("Rect"))
      });
      scheme.PageSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({
        headers: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme.PageSetNetworkInterceptionEnabledParams = (0, _validatorPrimitives.tObject)({
        enabled: _validatorPrimitives.tBoolean
      });
      scheme.PageSetViewportSizeParams = (0, _validatorPrimitives.tObject)({
        viewportSize: (0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })
      });
      scheme.PageKeyboardDownParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString
      });
      scheme.PageKeyboardUpParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString
      });
      scheme.PageKeyboardInsertTextParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString
      });
      scheme.PageKeyboardTypeParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageKeyboardPressParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageMouseMoveParams = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber,
        steps: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageMouseDownParams = (0, _validatorPrimitives.tObject)({
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageMouseUpParams = (0, _validatorPrimitives.tObject)({
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageMouseClickParams = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageMouseWheelParams = (0, _validatorPrimitives.tObject)({
        deltaX: _validatorPrimitives.tNumber,
        deltaY: _validatorPrimitives.tNumber
      });
      scheme.PageTouchscreenTapParams = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber
      });
      scheme.PageAccessibilitySnapshotParams = (0, _validatorPrimitives.tObject)({
        interestingOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        root: (0, _validatorPrimitives.tOptional)(tChannel("ElementHandle"))
      });
      scheme.PagePdfParams = (0, _validatorPrimitives.tObject)({
        scale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        displayHeaderFooter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        headerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        footerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        printBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        landscape: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        pageRanges: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        format: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        width: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        height: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        preferCSSPageSize: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        margin: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          top: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          bottom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          left: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          right: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        }))
      });
      scheme.PageStartJSCoverageParams = (0, _validatorPrimitives.tObject)({
        resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        reportAnonymousScripts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.PageStopJSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.PageStartCSSCoverageParams = (0, _validatorPrimitives.tObject)({
        resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.PageStopCSSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.PageBringToFrontParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.FrameEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.FrameEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.FrameAddScriptTagParams = (0, _validatorPrimitives.tObject)({
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        type: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.FrameAddStyleTagParams = (0, _validatorPrimitives.tObject)({
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.FrameCheckParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameClickParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.FrameDragAndDropParams = (0, _validatorPrimitives.tObject)({
        source: _validatorPrimitives.tString,
        target: _validatorPrimitives.tString,
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        sourcePosition: (0, _validatorPrimitives.tOptional)(tType("Point")),
        targetPosition: (0, _validatorPrimitives.tOptional)(tType("Point")),
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameDblclickParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameDispatchEventParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        type: _validatorPrimitives.tString,
        eventInit: tType("SerializedArgument"),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.FrameEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.FrameFillParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        value: _validatorPrimitives.tString,
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameFocusParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameFrameElementParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.FrameHighlightParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString
      });
      scheme.FrameGetAttributeParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        name: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameGotoParams = (0, _validatorPrimitives.tObject)({
        url: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent")),
        referer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.FrameHoverParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameInnerHTMLParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameInnerTextParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameInputValueParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameIsCheckedParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameIsDisabledParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameIsEnabledParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameIsHiddenParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameIsVisibleParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameIsEditableParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FramePressParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        key: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameQuerySelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString
      });
      scheme.FrameQueryCountParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString
      });
      scheme.FrameSelectOptionParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tChannel("ElementHandle"))),
        options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        }))),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameSetContentParams = (0, _validatorPrimitives.tObject)({
        html: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme.FrameSetInputFilesParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          name: _validatorPrimitives.tString,
          mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          buffer: _validatorPrimitives.tBinary
        })),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameTapParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameTextContentParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameTitleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.FrameTypeParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        text: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameUncheckParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameWaitForTimeoutParams = (0, _validatorPrimitives.tObject)({
        timeout: _validatorPrimitives.tNumber
      });
      scheme.FrameWaitForFunctionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument"),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        pollingInterval: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameWaitForSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["attached", "detached", "visible", "hidden"])),
        omitReturnValue: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameExpectParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        expression: _validatorPrimitives.tString,
        expressionArg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        expectedText: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("ExpectedTextValue"))),
        expectedNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        expectedValue: (0, _validatorPrimitives.tOptional)(tType("SerializedArgument")),
        useInnerText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        isNot: _validatorPrimitives.tBoolean,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.WorkerEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.WorkerEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.JSHandleDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleDisposeParams = tType("JSHandleDisposeParams");
      scheme.JSHandleEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleEvaluateExpressionParams = tType("JSHandleEvaluateExpressionParams");
      scheme.JSHandleEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleEvaluateExpressionHandleParams = tType("JSHandleEvaluateExpressionHandleParams");
      scheme.JSHandleGetPropertyListParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleGetPropertyListParams = tType("JSHandleGetPropertyListParams");
      scheme.JSHandleGetPropertyParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString
      });
      scheme.ElementHandleGetPropertyParams = tType("JSHandleGetPropertyParams");
      scheme.JSHandleJsonValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleJsonValueParams = tType("JSHandleJsonValueParams");
      scheme.ElementHandleEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleBoundingBoxParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleCheckParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleClickParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleContentFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleDblclickParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleDispatchEventParams = (0, _validatorPrimitives.tObject)({
        type: _validatorPrimitives.tString,
        eventInit: tType("SerializedArgument")
      });
      scheme.ElementHandleFillParams = (0, _validatorPrimitives.tObject)({
        value: _validatorPrimitives.tString,
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleFocusParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleGetAttributeParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString
      });
      scheme.ElementHandleHoverParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleInnerHTMLParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleInnerTextParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleInputValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsCheckedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsDisabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsEditableParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsEnabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsHiddenParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsVisibleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleOwnerFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandlePressParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleQuerySelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString
      });
      scheme.ElementHandleScreenshotParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["png", "jpeg"])),
        quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleScrollIntoViewIfNeededParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.ElementHandleSelectOptionParams = (0, _validatorPrimitives.tObject)({
        elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tChannel("ElementHandle"))),
        options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        }))),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleSelectTextParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.ElementHandleSetInputFilesParams = (0, _validatorPrimitives.tObject)({
        files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          name: _validatorPrimitives.tString,
          mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          buffer: _validatorPrimitives.tBinary
        })),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleTapParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleTextContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleTypeParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.ElementHandleUncheckParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleWaitForElementStateParams = (0, _validatorPrimitives.tObject)({
        state: (0, _validatorPrimitives.tEnum)(["visible", "hidden", "stable", "enabled", "disabled", "editable"]),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.ElementHandleWaitForSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["attached", "detached", "visible", "hidden"]))
      });
      scheme.RequestResponseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.RequestRawRequestHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.RouteAbortParams = (0, _validatorPrimitives.tObject)({
        errorCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.RouteContinueParams = (0, _validatorPrimitives.tObject)({
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary)
      });
      scheme.RouteFulfillParams = (0, _validatorPrimitives.tObject)({
        status: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        body: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        isBase64: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        fetchResponseUid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.ResourceTiming = (0, _validatorPrimitives.tObject)({
        startTime: _validatorPrimitives.tNumber,
        domainLookupStart: _validatorPrimitives.tNumber,
        domainLookupEnd: _validatorPrimitives.tNumber,
        connectStart: _validatorPrimitives.tNumber,
        secureConnectionStart: _validatorPrimitives.tNumber,
        connectEnd: _validatorPrimitives.tNumber,
        requestStart: _validatorPrimitives.tNumber,
        responseStart: _validatorPrimitives.tNumber
      });
      scheme.ResponseBodyParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ResponseSecurityDetailsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ResponseServerAddrParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ResponseRawResponseHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ResponseSizesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.SecurityDetails = (0, _validatorPrimitives.tObject)({
        issuer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        protocol: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        subjectName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        validFrom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        validTo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.RequestSizes = (0, _validatorPrimitives.tObject)({
        requestBodySize: _validatorPrimitives.tNumber,
        requestHeadersSize: _validatorPrimitives.tNumber,
        responseBodySize: _validatorPrimitives.tNumber,
        responseHeadersSize: _validatorPrimitives.tNumber
      });
      scheme.RemoteAddr = (0, _validatorPrimitives.tObject)({
        ipAddress: _validatorPrimitives.tString,
        port: _validatorPrimitives.tNumber
      });
      scheme.BindingCallRejectParams = (0, _validatorPrimitives.tObject)({
        error: tType("SerializedError")
      });
      scheme.BindingCallResolveParams = (0, _validatorPrimitives.tObject)({
        result: tType("SerializedArgument")
      });
      scheme.DialogAcceptParams = (0, _validatorPrimitives.tObject)({
        promptText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.DialogDismissParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactPathAfterFinishedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactSaveAsParams = (0, _validatorPrimitives.tObject)({
        path: _validatorPrimitives.tString
      });
      scheme.ArtifactSaveAsStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactFailureParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactCancelParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactDeleteParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.StreamReadParams = (0, _validatorPrimitives.tObject)({
        size: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.StreamCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.CDPSessionSendParams = (0, _validatorPrimitives.tObject)({
        method: _validatorPrimitives.tString,
        params: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny)
      });
      scheme.CDPSessionDetachParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElectronLaunchParams = (0, _validatorPrimitives.tObject)({
        executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        cwd: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.ElectronApplicationBrowserWindowParams = (0, _validatorPrimitives.tObject)({
        page: tChannel("Page")
      });
      scheme.ElectronApplicationEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElectronApplicationEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElectronApplicationCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.AndroidDevicesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.AndroidSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: _validatorPrimitives.tNumber
      });
      scheme.AndroidSocketWriteParams = (0, _validatorPrimitives.tObject)({
        data: _validatorPrimitives.tBinary
      });
      scheme.AndroidSocketCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.AndroidDeviceWaitParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["gone"])),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceFillParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        text: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceTapParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        duration: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceDragParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        dest: tType("Point"),
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceFlingParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceLongTapParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDevicePinchCloseParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDevicePinchOpenParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceScrollParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceSwipeParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceInfoParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector")
      });
      scheme.AndroidDeviceScreenshotParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.AndroidDeviceInputTypeParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString
      });
      scheme.AndroidDeviceInputPressParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString
      });
      scheme.AndroidDeviceInputTapParams = (0, _validatorPrimitives.tObject)({
        point: tType("Point")
      });
      scheme.AndroidDeviceInputSwipeParams = (0, _validatorPrimitives.tObject)({
        segments: (0, _validatorPrimitives.tArray)(tType("Point")),
        steps: _validatorPrimitives.tNumber
      });
      scheme.AndroidDeviceInputDragParams = (0, _validatorPrimitives.tObject)({
        from: tType("Point"),
        to: tType("Point"),
        steps: _validatorPrimitives.tNumber
      });
      scheme.AndroidDeviceLaunchBrowserParams = (0, _validatorPrimitives.tObject)({
        pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none"])),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        }))
      });
      scheme.AndroidDeviceOpenParams = (0, _validatorPrimitives.tObject)({
        command: _validatorPrimitives.tString
      });
      scheme.AndroidDeviceShellParams = (0, _validatorPrimitives.tObject)({
        command: _validatorPrimitives.tString
      });
      scheme.AndroidDeviceInstallApkParams = (0, _validatorPrimitives.tObject)({
        file: _validatorPrimitives.tBinary,
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
      });
      scheme.AndroidDevicePushParams = (0, _validatorPrimitives.tObject)({
        file: _validatorPrimitives.tBinary,
        path: _validatorPrimitives.tString,
        mode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: _validatorPrimitives.tNumber
      });
      scheme.AndroidDeviceConnectToWebViewParams = (0, _validatorPrimitives.tObject)({
        pid: _validatorPrimitives.tNumber
      });
      scheme.AndroidDeviceCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.AndroidWebView = (0, _validatorPrimitives.tObject)({
        pid: _validatorPrimitives.tNumber,
        pkg: _validatorPrimitives.tString
      });
      scheme.AndroidSelector = (0, _validatorPrimitives.tObject)({
        checkable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        checked: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        clazz: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        clickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        depth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        desc: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        enabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        focusable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasChild: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          selector: tType("AndroidSelector")
        })),
        hasDescendant: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          selector: tType("AndroidSelector"),
          maxDepth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        longClickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        res: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        scrollable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        text: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.AndroidElementInfo = (0, _validatorPrimitives.tObject)({
        children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("AndroidElementInfo"))),
        clazz: _validatorPrimitives.tString,
        desc: _validatorPrimitives.tString,
        res: _validatorPrimitives.tString,
        pkg: _validatorPrimitives.tString,
        text: _validatorPrimitives.tString,
        bounds: tType("Rect"),
        checkable: _validatorPrimitives.tBoolean,
        checked: _validatorPrimitives.tBoolean,
        clickable: _validatorPrimitives.tBoolean,
        enabled: _validatorPrimitives.tBoolean,
        focusable: _validatorPrimitives.tBoolean,
        focused: _validatorPrimitives.tBoolean,
        longClickable: _validatorPrimitives.tBoolean,
        scrollable: _validatorPrimitives.tBoolean,
        selected: _validatorPrimitives.tBoolean
      });
      scheme.JsonPipeSendParams = (0, _validatorPrimitives.tObject)({
        message: _validatorPrimitives.tAny
      });
      scheme.JsonPipeCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      return scheme;
    }
  }
});

// node_modules/playwright-core/lib/protocol/callMetadata.js
var require_callMetadata = __commonJS({
  "node_modules/playwright-core/lib/protocol/callMetadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
  }
});

// node_modules/playwright-core/lib/server/instrumentation.js
var require_instrumentation = __commonJS({
  "node_modules/playwright-core/lib/server/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createInstrumentation = createInstrumentation;
    exports2.internalCallMetadata = internalCallMetadata;
    Object.defineProperty(exports2, "CallMetadata", {
      enumerable: true,
      get: function() {
        return _callMetadata.CallMetadata;
      }
    });
    exports2.SdkObject = void 0;
    var _events = require("events");
    var _utils2 = require_utils();
    var _callMetadata = require_callMetadata();
    var SdkObject = class extends _events.EventEmitter {
      constructor(parent, guidPrefix, guid) {
        super();
        this.guid = void 0;
        this.attribution = void 0;
        this.instrumentation = void 0;
        this.guid = guid || `${guidPrefix || ""}@${(0, _utils2.createGuid)()}`;
        this.setMaxListeners(0);
        this.attribution = __spreadValues({}, parent.attribution);
        this.instrumentation = parent.instrumentation;
      }
    };
    exports2.SdkObject = SdkObject;
    function createInstrumentation() {
      const listeners = /* @__PURE__ */ new Map();
      return new Proxy({}, {
        get: (obj, prop) => {
          if (prop === "addListener")
            return (listener, context) => listeners.set(listener, context);
          if (prop === "removeListener")
            return (listener) => listeners.delete(listener);
          if (!prop.startsWith("on"))
            return obj[prop];
          return (sdkObject, ...params) => __async(this, null, function* () {
            for (const [listener, context] of listeners) {
              var _prop, _ref;
              if (!context || sdkObject.attribution.context === context)
                yield (_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, sdkObject, ...params);
            }
          });
        }
      });
    }
    function internalCallMetadata() {
      return {
        id: "",
        wallTime: 0,
        startTime: 0,
        endTime: 0,
        type: "Internal",
        method: "",
        params: {},
        log: [],
        snapshots: []
      };
    }
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/stack-utils/index.js
var require_stack_utils = __commonJS({
  "node_modules/stack-utils/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var cwd = typeof process === "object" && process && typeof process.cwd === "function" ? process.cwd() : ".";
    var natives = [].concat(require("module").builtinModules, "bootstrap_node", "node").map((n) => new RegExp(`(?:\\((?:node:)?${n}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${n}(?:\\.js)?:\\d+:\\d+$)`));
    natives.push(/\((?:node:)?internal\/[^:]+:\d+:\d+\)$/, /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/, /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/);
    var StackUtils = class {
      constructor(opts) {
        opts = __spreadValues({
          ignoredPackages: []
        }, opts);
        if ("internals" in opts === false) {
          opts.internals = StackUtils.nodeInternals();
        }
        if ("cwd" in opts === false) {
          opts.cwd = cwd;
        }
        this._cwd = opts.cwd.replace(/\\/g, "/");
        this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));
        this._wrapCallSite = opts.wrapCallSite || false;
      }
      static nodeInternals() {
        return [...natives];
      }
      clean(stack, indent = 0) {
        indent = " ".repeat(indent);
        if (!Array.isArray(stack)) {
          stack = stack.split("\n");
        }
        if (!/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1])) {
          stack = stack.slice(1);
        }
        let outdent = false;
        let lastNonAtLine = null;
        const result = [];
        stack.forEach((st) => {
          st = st.replace(/\\/g, "/");
          if (this._internals.some((internal) => internal.test(st))) {
            return;
          }
          const isAtLine = /^\s*at /.test(st);
          if (outdent) {
            st = st.trimEnd().replace(/^(\s+)at /, "$1");
          } else {
            st = st.trim();
            if (isAtLine) {
              st = st.slice(3);
            }
          }
          st = st.replace(`${this._cwd}/`, "");
          if (st) {
            if (isAtLine) {
              if (lastNonAtLine) {
                result.push(lastNonAtLine);
                lastNonAtLine = null;
              }
              result.push(st);
            } else {
              outdent = true;
              lastNonAtLine = st;
            }
          }
        });
        return result.map((line) => `${indent}${line}
`).join("");
      }
      captureString(limit, fn = this.captureString) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { stackTraceLimit } = Error;
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Error.stackTraceLimit = stackTraceLimit;
        return this.clean(stack);
      }
      capture(limit, fn = this.capture) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { prepareStackTrace, stackTraceLimit } = Error;
        Error.prepareStackTrace = (obj2, site) => {
          if (this._wrapCallSite) {
            return site.map(this._wrapCallSite);
          }
          return site;
        };
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Object.assign(Error, { prepareStackTrace, stackTraceLimit });
        return stack;
      }
      at(fn = this.at) {
        const [site] = this.capture(1, fn);
        if (!site) {
          return {};
        }
        const res = {
          line: site.getLineNumber(),
          column: site.getColumnNumber()
        };
        setFile(res, site.getFileName(), this._cwd);
        if (site.isConstructor()) {
          res.constructor = true;
        }
        if (site.isEval()) {
          res.evalOrigin = site.getEvalOrigin();
        }
        if (site.isNative()) {
          res.native = true;
        }
        let typename;
        try {
          typename = site.getTypeName();
        } catch (_) {
        }
        if (typename && typename !== "Object" && typename !== "[object Object]") {
          res.type = typename;
        }
        const fname = site.getFunctionName();
        if (fname) {
          res.function = fname;
        }
        const meth = site.getMethodName();
        if (meth && fname !== meth) {
          res.method = meth;
        }
        return res;
      }
      parseLine(line) {
        const match = line && line.match(re);
        if (!match) {
          return null;
        }
        const ctor = match[1] === "new";
        let fname = match[2];
        const evalOrigin = match[3];
        const evalFile = match[4];
        const evalLine = Number(match[5]);
        const evalCol = Number(match[6]);
        let file = match[7];
        const lnum = match[8];
        const col = match[9];
        const native = match[10] === "native";
        const closeParen = match[11] === ")";
        let method;
        const res = {};
        if (lnum) {
          res.line = Number(lnum);
        }
        if (col) {
          res.column = Number(col);
        }
        if (closeParen && file) {
          let closes = 0;
          for (let i = file.length - 1; i > 0; i--) {
            if (file.charAt(i) === ")") {
              closes++;
            } else if (file.charAt(i) === "(" && file.charAt(i - 1) === " ") {
              closes--;
              if (closes === -1 && file.charAt(i - 1) === " ") {
                const before = file.slice(0, i - 1);
                const after = file.slice(i + 1);
                file = after;
                fname += ` (${before}`;
                break;
              }
            }
          }
        }
        if (fname) {
          const methodMatch = fname.match(methodRe);
          if (methodMatch) {
            fname = methodMatch[1];
            method = methodMatch[2];
          }
        }
        setFile(res, file, this._cwd);
        if (ctor) {
          res.constructor = true;
        }
        if (evalOrigin) {
          res.evalOrigin = evalOrigin;
          res.evalLine = evalLine;
          res.evalColumn = evalCol;
          res.evalFile = evalFile && evalFile.replace(/\\/g, "/");
        }
        if (native) {
          res.native = true;
        }
        if (fname) {
          res.function = fname;
        }
        if (method && fname !== method) {
          res.method = method;
        }
        return res;
      }
    };
    function setFile(result, filename, cwd2) {
      if (filename) {
        filename = filename.replace(/\\/g, "/");
        if (filename.startsWith(`${cwd2}/`)) {
          filename = filename.slice(cwd2.length + 1);
        }
        result.file = filename;
      }
    }
    function ignoredPackagesRegExp(ignoredPackages) {
      if (ignoredPackages.length === 0) {
        return [];
      }
      const packages = ignoredPackages.map((mod) => escapeStringRegexp(mod));
      return new RegExp(`[/\\\\]node_modules[/\\\\](?:${packages.join("|")})[/\\\\][^:]+:\\d+:\\d+`);
    }
    var re = new RegExp("^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$");
    var methodRe = /^(.*?) \[as (.*?)\]$/;
    module2.exports = StackUtils;
  }
});

// node_modules/playwright-core/lib/utils/stackTrace.js
var require_stackTrace = __commonJS({
  "node_modules/playwright-core/lib/utils/stackTrace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.rewriteErrorMessage = rewriteErrorMessage;
    exports2.captureRawStack = captureRawStack;
    exports2.captureStackTrace = captureStackTrace;
    exports2.splitErrorMessage = splitErrorMessage;
    var _path2 = _interopRequireDefault2(require("path"));
    var _stackUtils = _interopRequireDefault2(require_stack_utils());
    var _utils2 = require_utils();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var stackUtils = new _stackUtils.default();
    function rewriteErrorMessage(e, newMessage) {
      var _e$stack;
      const lines = (((_e$stack = e.stack) === null || _e$stack === void 0 ? void 0 : _e$stack.split("\n")) || []).filter((l) => l.startsWith("    at "));
      e.message = newMessage;
      const errorTitle = `${e.name}: ${e.message}`;
      if (lines.length)
        e.stack = `${errorTitle}
${lines.join("\n")}`;
      return e;
    }
    var CORE_DIR = _path2.default.resolve(__dirname, "..", "..");
    var CLIENT_LIB = _path2.default.join(CORE_DIR, "lib", "client");
    var CLIENT_SRC = _path2.default.join(CORE_DIR, "src", "client");
    var UTIL_LIB = _path2.default.join(CORE_DIR, "lib", "util");
    var UTIL_SRC = _path2.default.join(CORE_DIR, "src", "util");
    var TEST_DIR_SRC = _path2.default.resolve(CORE_DIR, "..", "playwright-test");
    var TEST_DIR_LIB = _path2.default.resolve(CORE_DIR, "..", "@playwright", "test");
    var COVERAGE_PATH = _path2.default.join(CORE_DIR, "..", "..", "tests", "config", "coverage.js");
    var WS_LIB = _path2.default.relative(process.cwd(), _path2.default.dirname(require.resolve("ws")));
    function captureRawStack() {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 30;
      const error = new Error();
      const stack = error.stack;
      Error.stackTraceLimit = stackTraceLimit;
      return stack;
    }
    function captureStackTrace(rawStack) {
      const stack = rawStack || captureRawStack();
      const isTesting = (0, _utils2.isUnderTest)();
      let parsedFrames = stack.split("\n").map((line) => {
        var _frame$function;
        const frame = stackUtils.parseLine(line);
        if (!frame || !frame.file)
          return null;
        if (frame.file.startsWith("internal") || frame.file.startsWith("node:"))
          return null;
        if (frame.file === "events.js" && (_frame$function = frame.function) !== null && _frame$function !== void 0 && _frame$function.endsWith(".emit"))
          return null;
        if (frame.file === "_stream_readable.js" || frame.file === "_stream_writable.js")
          return null;
        if (frame.file.startsWith(WS_LIB))
          return null;
        let fileName;
        if (frame.file.startsWith("file://"))
          fileName = new URL(frame.file).pathname;
        else
          fileName = _path2.default.resolve(process.cwd(), frame.file);
        if (isTesting && fileName.includes(COVERAGE_PATH))
          return null;
        const inClient = fileName.startsWith(CLIENT_LIB) || fileName.startsWith(CLIENT_SRC) || fileName.startsWith(UTIL_LIB) || fileName.startsWith(UTIL_SRC);
        const parsed = {
          frame: {
            file: fileName,
            line: frame.line,
            column: frame.column,
            function: frame.function
          },
          frameText: line,
          inClient
        };
        return parsed;
      }).filter(Boolean);
      let apiName = "";
      const allFrames = parsedFrames;
      const TRAP = "__PWTRAP__[";
      const expectIndex = parsedFrames.findIndex((f) => f.frameText.includes(TRAP));
      if (expectIndex !== -1) {
        const text = parsedFrames[expectIndex].frameText;
        const aliasIndex = text.indexOf(TRAP);
        apiName = text.substring(aliasIndex + TRAP.length, text.indexOf("]"));
        parsedFrames = parsedFrames.slice(expectIndex + 3);
      } else {
        for (let i = 0; i < parsedFrames.length - 1; i++) {
          if (parsedFrames[i].inClient && !parsedFrames[i + 1].inClient) {
            const frame = parsedFrames[i].frame;
            apiName = normalizeAPIName(frame.function);
            parsedFrames = parsedFrames.slice(i + 1);
            break;
          }
        }
      }
      function normalizeAPIName(name) {
        if (!name)
          return "";
        const match = name.match(/(API|JS|CDP|[A-Z])(.*)/);
        if (!match)
          return name;
        return match[1].toLowerCase() + match[2];
      }
      parsedFrames = parsedFrames.filter((f, i) => {
        if (f.frame.file.startsWith(TEST_DIR_SRC) || f.frame.file.startsWith(TEST_DIR_LIB))
          return false;
        if (i && f.frame.file.startsWith(CORE_DIR))
          return false;
        return true;
      });
      return {
        allFrames: allFrames.map((p) => p.frame),
        frames: parsedFrames.map((p) => p.frame),
        frameTexts: parsedFrames.map((p) => p.frameText),
        apiName
      };
    }
    function splitErrorMessage(message) {
      const separationIdx = message.indexOf(":");
      return {
        name: separationIdx !== -1 ? message.slice(0, separationIdx) : "",
        message: separationIdx !== -1 && separationIdx + 2 <= message.length ? message.substring(separationIdx + 2) : message
      };
    }
  }
});

// node_modules/playwright-core/lib/dispatchers/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/dispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.lookupDispatcher = lookupDispatcher;
    exports2.existingDispatcher = existingDispatcher;
    exports2.lookupNullableDispatcher = lookupNullableDispatcher;
    exports2.DispatcherConnection = exports2.Root = exports2.Dispatcher = exports2.dispatcherSymbol = void 0;
    var _events = require("events");
    var _serializers = require_serializers();
    var _validator = require_validator();
    var _utils2 = require_utils();
    var _validatorPrimitives = require_validatorPrimitives();
    var _errors = require_errors();
    var _instrumentation = require_instrumentation();
    var _stackTrace = require_stackTrace();
    var dispatcherSymbol = Symbol("dispatcher");
    exports2.dispatcherSymbol = dispatcherSymbol;
    function lookupDispatcher(object) {
      const result = object[dispatcherSymbol];
      (0, _utils2.debugAssert)(result);
      return result;
    }
    function existingDispatcher(object) {
      return object[dispatcherSymbol];
    }
    function lookupNullableDispatcher(object) {
      return object ? lookupDispatcher(object) : void 0;
    }
    var Dispatcher = class extends _events.EventEmitter {
      constructor(parent, object, type, initializer, isScope) {
        super();
        this._connection = void 0;
        this._isScope = void 0;
        this._parent = void 0;
        this._dispatchers = /* @__PURE__ */ new Map();
        this._disposed = false;
        this._guid = void 0;
        this._type = void 0;
        this._scope = void 0;
        this._object = void 0;
        this._connection = parent instanceof DispatcherConnection ? parent : parent._connection;
        this._isScope = !!isScope;
        this._parent = parent instanceof DispatcherConnection ? void 0 : parent;
        this._scope = isScope ? this : this._parent;
        const guid = object.guid;
        (0, _utils2.assert)(!this._connection._dispatchers.has(guid));
        this._connection._dispatchers.set(guid, this);
        if (this._parent) {
          (0, _utils2.assert)(!this._parent._dispatchers.has(guid));
          this._parent._dispatchers.set(guid, this);
        }
        this._type = type;
        this._guid = guid;
        this._object = object;
        object[dispatcherSymbol] = this;
        if (this._parent)
          this._connection.sendMessageToClient(this._parent._guid, type, "__create__", {
            type,
            initializer,
            guid
          }, this._parent._object);
      }
      _dispatchEvent(method, params) {
        if (this._disposed) {
          if ((0, _utils2.isUnderTest)())
            throw new Error(`${this._guid} is sending "${method}" event after being disposed`);
          return;
        }
        const sdkObject = this._object instanceof _instrumentation.SdkObject ? this._object : void 0;
        this._connection.sendMessageToClient(this._guid, this._type, method, params, sdkObject);
      }
      _dispose() {
        (0, _utils2.assert)(!this._disposed);
        this._disposed = true;
        if (this._parent)
          this._parent._dispatchers.delete(this._guid);
        this._connection._dispatchers.delete(this._guid);
        for (const dispatcher of [...this._dispatchers.values()])
          dispatcher._dispose();
        this._dispatchers.clear();
        if (this._isScope)
          this._connection.sendMessageToClient(this._guid, this._type, "__dispose__", {});
      }
      _debugScopeState() {
        return {
          _guid: this._guid,
          objects: Array.from(this._dispatchers.values()).map((o) => o._debugScopeState())
        };
      }
      waitForEventInfo() {
        return __async(this, null, function* () {
        });
      }
    };
    exports2.Dispatcher = Dispatcher;
    var Root = class extends Dispatcher {
      constructor(connection, createPlaywright) {
        super(connection, {
          guid: ""
        }, "Root", {}, true);
        this._initialized = false;
        this.createPlaywright = createPlaywright;
      }
      initialize(params) {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this.createPlaywright);
          (0, _utils2.assert)(!this._initialized);
          this._initialized = true;
          return {
            playwright: yield this.createPlaywright(this, params)
          };
        });
      }
    };
    exports2.Root = Root;
    var DispatcherConnection = class {
      sendMessageToClient(guid, type, method, params, sdkObject) {
        params = this._replaceDispatchersWithGuids(params);
        if (sdkObject) {
          var _sdkObject$attributio, _sdkObject$attributio2, _sdkObject$attributio3, _sdkObject$attributio4, _sdkObject$instrument;
          const eventMetadata = {
            id: `event@${++lastEventId}`,
            objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
            pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio = sdkObject.attribution) === null || _sdkObject$attributio === void 0 ? void 0 : (_sdkObject$attributio2 = _sdkObject$attributio.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.guid,
            frameId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio3 = sdkObject.attribution) === null || _sdkObject$attributio3 === void 0 ? void 0 : (_sdkObject$attributio4 = _sdkObject$attributio3.frame) === null || _sdkObject$attributio4 === void 0 ? void 0 : _sdkObject$attributio4.guid,
            wallTime: Date.now(),
            startTime: (0, _utils2.monotonicTime)(),
            endTime: 0,
            type,
            method,
            params: params || {},
            log: [],
            snapshots: []
          };
          (_sdkObject$instrument = sdkObject.instrumentation) === null || _sdkObject$instrument === void 0 ? void 0 : _sdkObject$instrument.onEvent(sdkObject, eventMetadata);
        }
        this.onmessage({
          guid,
          method,
          params
        });
      }
      constructor() {
        this._dispatchers = /* @__PURE__ */ new Map();
        this.onmessage = (message) => {
        };
        this._validateParams = void 0;
        this._validateMetadata = void 0;
        this._waitOperations = /* @__PURE__ */ new Map();
        const tChannel = (name) => {
          return (arg, path) => {
            if (arg && typeof arg === "object" && typeof arg.guid === "string") {
              const guid = arg.guid;
              const dispatcher = this._dispatchers.get(guid);
              if (!dispatcher)
                throw new _validator.ValidationError(`${path}: no object with guid ${guid}`);
              if (name !== "*" && dispatcher._type !== name)
                throw new _validator.ValidationError(`${path}: object with guid ${guid} has type ${dispatcher._type}, expected ${name}`);
              return dispatcher;
            }
            throw new _validator.ValidationError(`${path}: expected ${name}`);
          };
        };
        const scheme = (0, _validator.createScheme)(tChannel);
        this._validateParams = (type, method, params) => {
          const name = type + method[0].toUpperCase() + method.substring(1) + "Params";
          if (!scheme[name])
            throw new _validator.ValidationError(`Unknown scheme for ${type}.${method}`);
          return scheme[name](params, "");
        };
        this._validateMetadata = (metadata) => {
          return (0, _validatorPrimitives.tOptional)(scheme["Metadata"])(metadata, "");
        };
      }
      dispatch(message) {
        return __async(this, null, function* () {
          var _sdkObject$attributio5, _sdkObject$attributio6, _sdkObject$attributio7, _sdkObject$attributio8, _params$info;
          const {
            id,
            guid,
            method,
            params,
            metadata
          } = message;
          const dispatcher = this._dispatchers.get(guid);
          if (!dispatcher) {
            this.onmessage({
              id,
              error: (0, _serializers.serializeError)(new Error(_errors.kBrowserOrContextClosedError))
            });
            return;
          }
          if (method === "debugScopeState") {
            const rootDispatcher = this._dispatchers.get("");
            this.onmessage({
              id,
              result: rootDispatcher._debugScopeState()
            });
            return;
          }
          let validParams;
          let validMetadata;
          try {
            validParams = this._validateParams(dispatcher._type, method, params);
            validMetadata = this._validateMetadata(metadata);
            if (typeof dispatcher[method] !== "function")
              throw new Error(`Mismatching dispatcher: "${dispatcher._type}" does not implement "${method}"`);
          } catch (e) {
            this.onmessage({
              id,
              error: (0, _serializers.serializeError)(e)
            });
            return;
          }
          const sdkObject = dispatcher._object instanceof _instrumentation.SdkObject ? dispatcher._object : void 0;
          const callMetadata = {
            id: `call@${id}`,
            stack: validMetadata?.stack,
            apiName: validMetadata?.apiName,
            internal: validMetadata?.internal,
            objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
            pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio5 = sdkObject.attribution) === null || _sdkObject$attributio5 === void 0 ? void 0 : (_sdkObject$attributio6 = _sdkObject$attributio5.page) === null || _sdkObject$attributio6 === void 0 ? void 0 : _sdkObject$attributio6.guid,
            frameId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio7 = sdkObject.attribution) === null || _sdkObject$attributio7 === void 0 ? void 0 : (_sdkObject$attributio8 = _sdkObject$attributio7.frame) === null || _sdkObject$attributio8 === void 0 ? void 0 : _sdkObject$attributio8.guid,
            wallTime: Date.now(),
            startTime: (0, _utils2.monotonicTime)(),
            endTime: 0,
            type: dispatcher._type,
            method,
            params: params || {},
            log: [],
            snapshots: []
          };
          if (sdkObject && params !== null && params !== void 0 && (_params$info = params.info) !== null && _params$info !== void 0 && _params$info.waitId) {
            const info = params.info;
            switch (info.phase) {
              case "before": {
                this._waitOperations.set(info.waitId, callMetadata);
                yield sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
                this.onmessage({
                  id
                });
                return;
              }
              case "log": {
                const originalMetadata = this._waitOperations.get(info.waitId);
                originalMetadata.log.push(info.message);
                sdkObject.instrumentation.onCallLog(sdkObject, originalMetadata, "api", info.message);
                this.onmessage({
                  id
                });
                return;
              }
              case "after": {
                const originalMetadata = this._waitOperations.get(info.waitId);
                originalMetadata.endTime = (0, _utils2.monotonicTime)();
                originalMetadata.error = info.error ? {
                  error: {
                    name: "Error",
                    message: info.error
                  }
                } : void 0;
                this._waitOperations.delete(info.waitId);
                yield sdkObject.instrumentation.onAfterCall(sdkObject, originalMetadata);
                this.onmessage({
                  id
                });
                return;
              }
            }
          }
          let error;
          yield sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
          try {
            const result = yield dispatcher[method](validParams, callMetadata);
            callMetadata.result = this._replaceDispatchersWithGuids(result);
          } catch (e) {
            callMetadata.error = (0, _serializers.serializeError)(e);
            if (callMetadata.log.length)
              (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(callMetadata.log));
            error = (0, _serializers.serializeError)(e);
          } finally {
            callMetadata.endTime = (0, _utils2.monotonicTime)();
            yield sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onAfterCall(sdkObject, callMetadata);
          }
          const response = {
            id
          };
          if (callMetadata.result)
            response.result = callMetadata.result;
          if (error)
            response.error = error;
          this.onmessage(response);
        });
      }
      _replaceDispatchersWithGuids(payload) {
        if (!payload)
          return payload;
        if (payload instanceof Dispatcher)
          return {
            guid: payload._guid
          };
        if (Array.isArray(payload))
          return payload.map((p) => this._replaceDispatchersWithGuids(p));
        if (typeof payload === "object") {
          const result = {};
          for (const key of Object.keys(payload))
            result[key] = this._replaceDispatchersWithGuids(payload[key]);
          return result;
        }
        return payload;
      }
    };
    exports2.DispatcherConnection = DispatcherConnection;
    function formatLogRecording(log) {
      if (!log.length)
        return "";
      const header = ` logs `;
      const headerLength = 60;
      const leftLength = (headerLength - header.length) / 2;
      const rightLength = headerLength - header.length - leftLength;
      return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log.join("\n")}
${"=".repeat(headerLength)}`;
    }
    var lastEventId = 0;
  }
});

// node_modules/playwright-core/lib/utils/timeoutSettings.js
var require_timeoutSettings = __commonJS({
  "node_modules/playwright-core/lib/utils/timeoutSettings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TimeoutSettings = exports2.DEFAULT_TIMEOUT = void 0;
    var _utils2 = require_utils();
    var DEFAULT_TIMEOUT = 3e4;
    exports2.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var TIMEOUT = (0, _utils2.debugMode)() ? 0 : DEFAULT_TIMEOUT;
    var TimeoutSettings = class {
      constructor(parent) {
        this._parent = void 0;
        this._defaultTimeout = void 0;
        this._defaultNavigationTimeout = void 0;
        this._parent = parent;
      }
      setDefaultTimeout(timeout) {
        this._defaultTimeout = timeout;
      }
      setDefaultNavigationTimeout(timeout) {
        this._defaultNavigationTimeout = timeout;
      }
      navigationTimeout(options) {
        if (typeof options.timeout === "number")
          return options.timeout;
        if (this._defaultNavigationTimeout !== void 0)
          return this._defaultNavigationTimeout;
        if (this._defaultTimeout !== void 0)
          return this._defaultTimeout;
        if (this._parent)
          return this._parent.navigationTimeout(options);
        return TIMEOUT;
      }
      timeout(options) {
        if (typeof options.timeout === "number")
          return options.timeout;
        if (this._defaultTimeout !== void 0)
          return this._defaultTimeout;
        if (this._parent)
          return this._parent.timeout(options);
        return TIMEOUT;
      }
      static timeout(options) {
        if (typeof options.timeout === "number")
          return options.timeout;
        return TIMEOUT;
      }
    };
    exports2.TimeoutSettings = TimeoutSettings;
  }
});

// node_modules/playwright-core/lib/utils/debugLogger.js
var require_debugLogger = __commonJS({
  "node_modules/playwright-core/lib/utils/debugLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RecentLogsCollector = exports2.debugLogger = void 0;
    var _debug = _interopRequireDefault2(require_src());
    var _fs2 = _interopRequireDefault2(require("fs"));
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var debugLoggerColorMap = {
      "api": 45,
      "protocol": 34,
      "install": 34,
      "download": 34,
      "browser": 0,
      "proxy": 92,
      "error": 160,
      "channel:command": 33,
      "channel:response": 202,
      "channel:event": 207
    };
    var DebugLogger = class {
      constructor() {
        this._debuggers = /* @__PURE__ */ new Map();
        if (process.env.DEBUG_FILE) {
          const ansiRegex = new RegExp(["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"), "g");
          const stream = _fs2.default.createWriteStream(process.env.DEBUG_FILE);
          _debug.default.log = (data) => {
            stream.write(data.replace(ansiRegex, ""));
            stream.write("\n");
          };
        }
      }
      log(name, message) {
        let cachedDebugger = this._debuggers.get(name);
        if (!cachedDebugger) {
          cachedDebugger = (0, _debug.default)(`pw:${name}`);
          this._debuggers.set(name, cachedDebugger);
          cachedDebugger.color = debugLoggerColorMap[name];
        }
        cachedDebugger(message);
      }
      isEnabled(name) {
        return _debug.default.enabled(`pw:${name}`);
      }
    };
    var debugLogger = new DebugLogger();
    exports2.debugLogger = debugLogger;
    var kLogCount = 150;
    var RecentLogsCollector = class {
      constructor() {
        this._logs = [];
      }
      log(message) {
        this._logs.push(message);
        if (this._logs.length === kLogCount * 2)
          this._logs.splice(0, kLogCount);
      }
      recentLogs() {
        if (this._logs.length > kLogCount)
          return this._logs.slice(-kLogCount);
        return this._logs;
      }
    };
    exports2.RecentLogsCollector = RecentLogsCollector;
  }
});

// node_modules/playwright-core/lib/utils/eventsHelper.js
var require_eventsHelper = __commonJS({
  "node_modules/playwright-core/lib/utils/eventsHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.eventsHelper = void 0;
    var EventsHelper = class {
      static addEventListener(emitter, eventName, handler) {
        emitter.on(eventName, handler);
        return {
          emitter,
          eventName,
          handler
        };
      }
      static removeEventListeners(listeners) {
        for (const listener of listeners)
          listener.emitter.removeListener(listener.eventName, listener.handler);
        listeners.splice(0, listeners.length);
      }
    };
    var eventsHelper = EventsHelper;
    exports2.eventsHelper = eventsHelper;
  }
});

// node_modules/playwright-core/lib/server/helper.js
var require_helper = __commonJS({
  "node_modules/playwright-core/lib/server/helper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.helper = void 0;
    var _debugLogger = require_debugLogger();
    var _eventsHelper = require_eventsHelper();
    var Helper = class {
      static completeUserURL(urlString) {
        if (urlString.startsWith("localhost") || urlString.startsWith("127.0.0.1"))
          urlString = "http://" + urlString;
        return urlString;
      }
      static enclosingIntRect(rect) {
        const x = Math.floor(rect.x + 1e-3);
        const y = Math.floor(rect.y + 1e-3);
        const x2 = Math.ceil(rect.x + rect.width - 1e-3);
        const y2 = Math.ceil(rect.y + rect.height - 1e-3);
        return {
          x,
          y,
          width: x2 - x,
          height: y2 - y
        };
      }
      static enclosingIntSize(size) {
        return {
          width: Math.floor(size.width + 1e-3),
          height: Math.floor(size.height + 1e-3)
        };
      }
      static getViewportSizeFromWindowFeatures(features) {
        const widthString = features.find((f) => f.startsWith("width="));
        const heightString = features.find((f) => f.startsWith("height="));
        const width = widthString ? parseInt(widthString.substring(6), 10) : NaN;
        const height = heightString ? parseInt(heightString.substring(7), 10) : NaN;
        if (!Number.isNaN(width) && !Number.isNaN(height))
          return {
            width,
            height
          };
        return null;
      }
      static waitForEvent(progress, emitter, event, predicate) {
        const listeners = [];
        const promise = new Promise((resolve, reject) => {
          listeners.push(_eventsHelper.eventsHelper.addEventListener(emitter, event, (eventArg) => {
            try {
              if (predicate && !predicate(eventArg))
                return;
              _eventsHelper.eventsHelper.removeEventListeners(listeners);
              resolve(eventArg);
            } catch (e) {
              _eventsHelper.eventsHelper.removeEventListeners(listeners);
              reject(e);
            }
          }));
        });
        const dispose = () => _eventsHelper.eventsHelper.removeEventListeners(listeners);
        if (progress)
          progress.cleanupWhenAborted(dispose);
        return {
          promise,
          dispose
        };
      }
      static secondsToRoundishMillis(value) {
        return (value * 1e6 | 0) / 1e3;
      }
      static millisToRoundishMillis(value) {
        return (value * 1e3 | 0) / 1e3;
      }
      static debugProtocolLogger(protocolLogger) {
        return (direction, message) => {
          if (protocolLogger)
            protocolLogger(direction, message);
          if (_debugLogger.debugLogger.isEnabled("protocol"))
            _debugLogger.debugLogger.log("protocol", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(message));
        };
      }
      static formatBrowserLogs(logs) {
        if (!logs.length)
          return "";
        return "\n" + "=".repeat(20) + " Browser output: " + "=".repeat(20) + "\n" + logs.join("\n");
      }
    };
    var helper = Helper;
    exports2.helper = helper;
  }
});

// node_modules/playwright-core/lib/utils/async.js
var require_async = __commonJS({
  "node_modules/playwright-core/lib/utils/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.raceAgainstDeadline = raceAgainstDeadline;
    exports2.ManualPromise = exports2.DeadlineRunner = void 0;
    var _utils2 = require_utils();
    var _Symbol$species;
    var _Symbol$toStringTag;
    var DeadlineRunner = class {
      constructor(promise, deadline) {
        this._timer = void 0;
        this.result = new ManualPromise();
        promise.then((result) => {
          this._finish({
            result,
            timedOut: false
          });
        }).catch((e) => {
          this._finish(void 0, e);
        });
        this.updateDeadline(deadline);
      }
      _finish(success, error) {
        if (this.result.isDone())
          return;
        this.updateDeadline(0);
        if (success)
          this.result.resolve(success);
        else
          this.result.reject(error);
      }
      interrupt() {
        this.updateDeadline(-1);
      }
      updateDeadline(deadline) {
        if (this._timer) {
          clearTimeout(this._timer);
          this._timer = void 0;
        }
        if (deadline === 0)
          return;
        const timeout = deadline - (0, _utils2.monotonicTime)();
        if (timeout <= 0)
          this._finish({
            timedOut: true
          });
        else
          this._timer = setTimeout(() => this._finish({
            timedOut: true
          }), timeout);
      }
    };
    exports2.DeadlineRunner = DeadlineRunner;
    function raceAgainstDeadline(promise, deadline) {
      return __async(this, null, function* () {
        return new DeadlineRunner(promise, deadline).result;
      });
    }
    _Symbol$species = Symbol.species;
    _Symbol$toStringTag = Symbol.toStringTag;
    var ManualPromise = class extends Promise {
      constructor() {
        let resolve;
        let reject;
        super((f, r) => {
          resolve = f;
          reject = r;
        });
        this._resolve = void 0;
        this._reject = void 0;
        this._isDone = void 0;
        this._isDone = false;
        this._resolve = resolve;
        this._reject = reject;
      }
      isDone() {
        return this._isDone;
      }
      resolve(t) {
        this._isDone = true;
        this._resolve(t);
      }
      reject(e) {
        this._isDone = true;
        this._reject(e);
      }
      static get [_Symbol$species]() {
        return Promise;
      }
      get [_Symbol$toStringTag]() {
        return "ManualPromise";
      }
    };
    exports2.ManualPromise = ManualPromise;
  }
});

// node_modules/playwright-core/lib/server/progress.js
var require_progress2 = __commonJS({
  "node_modules/playwright-core/lib/server/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProgressController = void 0;
    var _errors = require_errors();
    var _utils2 = require_utils();
    var _async = require_async();
    var ProgressController = class {
      constructor(metadata, sdkObject) {
        this._forceAbortPromise = new _async.ManualPromise();
        this._cleanups = [];
        this._logName = "api";
        this._state = "before";
        this._deadline = 0;
        this._timeout = 0;
        this._lastIntermediateResult = void 0;
        this.metadata = void 0;
        this.instrumentation = void 0;
        this.sdkObject = void 0;
        this.metadata = metadata;
        this.sdkObject = sdkObject;
        this.instrumentation = sdkObject.instrumentation;
        this._forceAbortPromise.catch((e) => null);
      }
      setLogName(logName) {
        this._logName = logName;
      }
      lastIntermediateResult() {
        return this._lastIntermediateResult;
      }
      run(task, timeout) {
        return __async(this, null, function* () {
          if (timeout) {
            this._timeout = timeout;
            this._deadline = timeout ? (0, _utils2.monotonicTime)() + timeout : 0;
          }
          (0, _utils2.assert)(this._state === "before");
          this._state = "running";
          const progress = {
            log: (message) => {
              progress.logEntry({
                message
              });
            },
            logEntry: (entry) => {
              if ("message" in entry) {
                const message = entry.message;
                if (this._state === "running")
                  this.metadata.log.push(message);
                this.instrumentation.onCallLog(this.sdkObject, this.metadata, this._logName, message);
              }
              if ("intermediateResult" in entry)
                this._lastIntermediateResult = entry.intermediateResult;
            },
            timeUntilDeadline: () => this._deadline ? this._deadline - (0, _utils2.monotonicTime)() : 2147483647,
            isRunning: () => this._state === "running",
            cleanupWhenAborted: (cleanup) => {
              if (this._state === "running")
                this._cleanups.push(cleanup);
              else
                runCleanup(cleanup);
            },
            throwIfAborted: () => {
              if (this._state === "aborted")
                throw new AbortedError();
            },
            beforeInputAction: (element) => __async(this, null, function* () {
              yield this.instrumentation.onBeforeInputAction(this.sdkObject, this.metadata, element);
            }),
            metadata: this.metadata
          };
          const timeoutError = new _errors.TimeoutError(`Timeout ${this._timeout}ms exceeded.`);
          const timer = setTimeout(() => this._forceAbortPromise.reject(timeoutError), progress.timeUntilDeadline());
          try {
            const promise = task(progress);
            const result = yield Promise.race([promise, this._forceAbortPromise]);
            this._state = "finished";
            return result;
          } catch (e) {
            this._state = "aborted";
            yield Promise.all(this._cleanups.splice(0).map(runCleanup));
            throw e;
          } finally {
            clearTimeout(timer);
          }
        });
      }
    };
    exports2.ProgressController = ProgressController;
    function runCleanup(cleanup) {
      return __async(this, null, function* () {
        try {
          yield cleanup();
        } catch (e) {
        }
      });
    }
    var AbortedError = class extends Error {
    };
  }
});

// node_modules/ip/lib/ip.js
var require_ip = __commonJS({
  "node_modules/ip/lib/ip.js"(exports2) {
    "use strict";
    var ip = exports2;
    var Buffer2 = require("buffer").Buffer;
    var os = require("os");
    ip.toBuffer = function(ip2, buff, offset) {
      offset = ~~offset;
      var result;
      if (this.isV4Format(ip2)) {
        result = buff || new Buffer2(offset + 4);
        ip2.split(/\./g).map(function(byte) {
          result[offset++] = parseInt(byte, 10) & 255;
        });
      } else if (this.isV6Format(ip2)) {
        var sections = ip2.split(":", 8);
        var i;
        for (i = 0; i < sections.length; i++) {
          var isv4 = this.isV4Format(sections[i]);
          var v4Buffer;
          if (isv4) {
            v4Buffer = this.toBuffer(sections[i]);
            sections[i] = v4Buffer.slice(0, 2).toString("hex");
          }
          if (v4Buffer && ++i < 8) {
            sections.splice(i, 0, v4Buffer.slice(2, 4).toString("hex"));
          }
        }
        if (sections[0] === "") {
          while (sections.length < 8)
            sections.unshift("0");
        } else if (sections[sections.length - 1] === "") {
          while (sections.length < 8)
            sections.push("0");
        } else if (sections.length < 8) {
          for (i = 0; i < sections.length && sections[i] !== ""; i++)
            ;
          var argv = [i, 1];
          for (i = 9 - sections.length; i > 0; i--) {
            argv.push("0");
          }
          sections.splice.apply(sections, argv);
        }
        result = buff || new Buffer2(offset + 16);
        for (i = 0; i < sections.length; i++) {
          var word = parseInt(sections[i], 16);
          result[offset++] = word >> 8 & 255;
          result[offset++] = word & 255;
        }
      }
      if (!result) {
        throw Error("Invalid ip address: " + ip2);
      }
      return result;
    };
    ip.toString = function(buff, offset, length) {
      offset = ~~offset;
      length = length || buff.length - offset;
      var result = [];
      if (length === 4) {
        for (var i = 0; i < length; i++) {
          result.push(buff[offset + i]);
        }
        result = result.join(".");
      } else if (length === 16) {
        for (var i = 0; i < length; i += 2) {
          result.push(buff.readUInt16BE(offset + i).toString(16));
        }
        result = result.join(":");
        result = result.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
        result = result.replace(/:{3,4}/, "::");
      }
      return result;
    };
    var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
    var ipv6Regex = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;
    ip.isV4Format = function(ip2) {
      return ipv4Regex.test(ip2);
    };
    ip.isV6Format = function(ip2) {
      return ipv6Regex.test(ip2);
    };
    function _normalizeFamily(family) {
      return family ? family.toLowerCase() : "ipv4";
    }
    ip.fromPrefixLen = function(prefixlen, family) {
      if (prefixlen > 32) {
        family = "ipv6";
      } else {
        family = _normalizeFamily(family);
      }
      var len = 4;
      if (family === "ipv6") {
        len = 16;
      }
      var buff = new Buffer2(len);
      for (var i = 0, n = buff.length; i < n; ++i) {
        var bits = 8;
        if (prefixlen < 8) {
          bits = prefixlen;
        }
        prefixlen -= bits;
        buff[i] = ~(255 >> bits) & 255;
      }
      return ip.toString(buff);
    };
    ip.mask = function(addr, mask) {
      addr = ip.toBuffer(addr);
      mask = ip.toBuffer(mask);
      var result = new Buffer2(Math.max(addr.length, mask.length));
      var i = 0;
      if (addr.length === mask.length) {
        for (i = 0; i < addr.length; i++) {
          result[i] = addr[i] & mask[i];
        }
      } else if (mask.length === 4) {
        for (i = 0; i < mask.length; i++) {
          result[i] = addr[addr.length - 4 + i] & mask[i];
        }
      } else {
        for (var i = 0; i < result.length - 6; i++) {
          result[i] = 0;
        }
        result[10] = 255;
        result[11] = 255;
        for (i = 0; i < addr.length; i++) {
          result[i + 12] = addr[i] & mask[i + 12];
        }
        i = i + 12;
      }
      for (; i < result.length; i++)
        result[i] = 0;
      return ip.toString(result);
    };
    ip.cidr = function(cidrString) {
      var cidrParts = cidrString.split("/");
      var addr = cidrParts[0];
      if (cidrParts.length !== 2)
        throw new Error("invalid CIDR subnet: " + addr);
      var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
      return ip.mask(addr, mask);
    };
    ip.subnet = function(addr, mask) {
      var networkAddress = ip.toLong(ip.mask(addr, mask));
      var maskBuffer = ip.toBuffer(mask);
      var maskLength = 0;
      for (var i = 0; i < maskBuffer.length; i++) {
        if (maskBuffer[i] === 255) {
          maskLength += 8;
        } else {
          var octet = maskBuffer[i] & 255;
          while (octet) {
            octet = octet << 1 & 255;
            maskLength++;
          }
        }
      }
      var numberOfAddresses = Math.pow(2, 32 - maskLength);
      return {
        networkAddress: ip.fromLong(networkAddress),
        firstAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),
        lastAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress + numberOfAddresses - 1) : ip.fromLong(networkAddress + numberOfAddresses - 2),
        broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
        subnetMask: mask,
        subnetMaskLength: maskLength,
        numHosts: numberOfAddresses <= 2 ? numberOfAddresses : numberOfAddresses - 2,
        length: numberOfAddresses,
        contains: function(other) {
          return networkAddress === ip.toLong(ip.mask(other, mask));
        }
      };
    };
    ip.cidrSubnet = function(cidrString) {
      var cidrParts = cidrString.split("/");
      var addr = cidrParts[0];
      if (cidrParts.length !== 2)
        throw new Error("invalid CIDR subnet: " + addr);
      var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
      return ip.subnet(addr, mask);
    };
    ip.not = function(addr) {
      var buff = ip.toBuffer(addr);
      for (var i = 0; i < buff.length; i++) {
        buff[i] = 255 ^ buff[i];
      }
      return ip.toString(buff);
    };
    ip.or = function(a, b) {
      a = ip.toBuffer(a);
      b = ip.toBuffer(b);
      if (a.length === b.length) {
        for (var i = 0; i < a.length; ++i) {
          a[i] |= b[i];
        }
        return ip.toString(a);
      } else {
        var buff = a;
        var other = b;
        if (b.length > a.length) {
          buff = b;
          other = a;
        }
        var offset = buff.length - other.length;
        for (var i = offset; i < buff.length; ++i) {
          buff[i] |= other[i - offset];
        }
        return ip.toString(buff);
      }
    };
    ip.isEqual = function(a, b) {
      a = ip.toBuffer(a);
      b = ip.toBuffer(b);
      if (a.length === b.length) {
        for (var i = 0; i < a.length; i++) {
          if (a[i] !== b[i])
            return false;
        }
        return true;
      }
      if (b.length === 4) {
        var t = b;
        b = a;
        a = t;
      }
      for (var i = 0; i < 10; i++) {
        if (b[i] !== 0)
          return false;
      }
      var word = b.readUInt16BE(10);
      if (word !== 0 && word !== 65535)
        return false;
      for (var i = 0; i < 4; i++) {
        if (a[i] !== b[i + 12])
          return false;
      }
      return true;
    };
    ip.isPrivate = function(addr) {
      return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^f[cd][0-9a-f]{2}:/i.test(addr) || /^fe80:/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    };
    ip.isPublic = function(addr) {
      return !ip.isPrivate(addr);
    };
    ip.isLoopback = function(addr) {
      return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    };
    ip.loopback = function(family) {
      family = _normalizeFamily(family);
      if (family !== "ipv4" && family !== "ipv6") {
        throw new Error("family must be ipv4 or ipv6");
      }
      return family === "ipv4" ? "127.0.0.1" : "fe80::1";
    };
    ip.address = function(name, family) {
      var interfaces = os.networkInterfaces();
      var all;
      family = _normalizeFamily(family);
      if (name && name !== "private" && name !== "public") {
        var res = interfaces[name].filter(function(details) {
          var itemFamily = details.family.toLowerCase();
          return itemFamily === family;
        });
        if (res.length === 0)
          return void 0;
        return res[0].address;
      }
      var all = Object.keys(interfaces).map(function(nic) {
        var addresses = interfaces[nic].filter(function(details) {
          details.family = details.family.toLowerCase();
          if (details.family !== family || ip.isLoopback(details.address)) {
            return false;
          } else if (!name) {
            return true;
          }
          return name === "public" ? ip.isPrivate(details.address) : ip.isPublic(details.address);
        });
        return addresses.length ? addresses[0].address : void 0;
      }).filter(Boolean);
      return !all.length ? ip.loopback(family) : all[0];
    };
    ip.toLong = function(ip2) {
      var ipl = 0;
      ip2.split(".").forEach(function(octet) {
        ipl <<= 8;
        ipl += parseInt(octet);
      });
      return ipl >>> 0;
    };
    ip.fromLong = function(ipl) {
      return (ipl >>> 24) + "." + (ipl >> 16 & 255) + "." + (ipl >> 8 & 255) + "." + (ipl & 255);
    };
  }
});

// node_modules/smart-buffer/build/utils.js
var require_utils2 = __commonJS({
  "node_modules/smart-buffer/build/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var ERRORS = {
      INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
      INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
      INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
      INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
      INVALID_OFFSET: "An invalid offset value was provided.",
      INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
      INVALID_LENGTH: "An invalid length value was provided.",
      INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
      INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
      INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
      INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
      INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
    };
    exports2.ERRORS = ERRORS;
    function checkEncoding(encoding) {
      if (!buffer_1.Buffer.isEncoding(encoding)) {
        throw new Error(ERRORS.INVALID_ENCODING);
      }
    }
    exports2.checkEncoding = checkEncoding;
    function isFiniteInteger(value) {
      return typeof value === "number" && isFinite(value) && isInteger(value);
    }
    exports2.isFiniteInteger = isFiniteInteger;
    function checkOffsetOrLengthValue(value, offset) {
      if (typeof value === "number") {
        if (!isFiniteInteger(value) || value < 0) {
          throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
        }
      } else {
        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
      }
    }
    function checkLengthValue(length) {
      checkOffsetOrLengthValue(length, false);
    }
    exports2.checkLengthValue = checkLengthValue;
    function checkOffsetValue(offset) {
      checkOffsetOrLengthValue(offset, true);
    }
    exports2.checkOffsetValue = checkOffsetValue;
    function checkTargetOffset(offset, buff) {
      if (offset < 0 || offset > buff.length) {
        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
      }
    }
    exports2.checkTargetOffset = checkTargetOffset;
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }
    function bigIntAndBufferInt64Check(bufferMethod) {
      if (typeof BigInt === "undefined") {
        throw new Error("Platform does not support JS BigInt type.");
      }
      if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
      }
    }
    exports2.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
  }
});

// node_modules/smart-buffer/build/smartbuffer.js
var require_smartbuffer = __commonJS({
  "node_modules/smart-buffer/build/smartbuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var DEFAULT_SMARTBUFFER_SIZE = 4096;
    var DEFAULT_SMARTBUFFER_ENCODING = "utf8";
    var SmartBuffer = class {
      constructor(options) {
        this.length = 0;
        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
        this._writeOffset = 0;
        this._readOffset = 0;
        if (SmartBuffer.isSmartBufferOptions(options)) {
          if (options.encoding) {
            utils_1.checkEncoding(options.encoding);
            this._encoding = options.encoding;
          }
          if (options.size) {
            if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
              this._buff = Buffer.allocUnsafe(options.size);
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
            }
          } else if (options.buff) {
            if (Buffer.isBuffer(options.buff)) {
              this._buff = options.buff;
              this.length = options.buff.length;
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
            }
          } else {
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
          }
        } else {
          if (typeof options !== "undefined") {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
          }
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      }
      static fromSize(size, encoding) {
        return new this({
          size,
          encoding
        });
      }
      static fromBuffer(buff, encoding) {
        return new this({
          buff,
          encoding
        });
      }
      static fromOptions(options) {
        return new this(options);
      }
      static isSmartBufferOptions(options) {
        const castOptions = options;
        return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
      }
      readInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
      }
      readInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
      }
      readInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
      }
      readInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
      }
      readInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
      }
      readBigInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
      }
      readBigInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
      }
      writeInt8(value, offset) {
        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
        return this;
      }
      insertInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
      }
      writeInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      insertInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      writeInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      insertInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      writeInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      insertInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      writeInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      insertInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      writeBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      insertBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      writeBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      insertBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      readUInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
      }
      readUInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
      }
      readUInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
      }
      readUInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
      }
      readUInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
      }
      readBigUInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
      }
      readBigUInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
      }
      writeUInt8(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      insertUInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      writeUInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      insertUInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      writeUInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      insertUInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      writeUInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      insertUInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      writeUInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      insertUInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      writeBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      insertBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      writeBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      insertBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      readFloatBE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
      }
      readFloatLE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
      }
      writeFloatBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      insertFloatBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      writeFloatLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      insertFloatLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      readDoubleBE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
      }
      readDoubleLE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
      }
      writeDoubleBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      insertDoubleBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      writeDoubleLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      insertDoubleLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      readString(arg1, encoding) {
        let lengthVal;
        if (typeof arg1 === "number") {
          utils_1.checkLengthValue(arg1);
          lengthVal = Math.min(arg1, this.length - this._readOffset);
        } else {
          encoding = arg1;
          lengthVal = this.length - this._readOffset;
        }
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
        this._readOffset += lengthVal;
        return value;
      }
      insertString(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        return this._handleString(value, true, offset, encoding);
      }
      writeString(value, arg2, encoding) {
        return this._handleString(value, false, arg2, encoding);
      }
      readStringNT(encoding) {
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value.toString(encoding || this._encoding);
      }
      insertStringNT(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        this.insertString(value, offset, encoding);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      writeStringNT(value, arg2, encoding) {
        this.writeString(value, arg2, encoding);
        this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
        return this;
      }
      readBuffer(length) {
        if (typeof length !== "undefined") {
          utils_1.checkLengthValue(length);
        }
        const lengthVal = typeof length === "number" ? length : this.length;
        const endPoint = Math.min(this.length, this._readOffset + lengthVal);
        const value = this._buff.slice(this._readOffset, endPoint);
        this._readOffset = endPoint;
        return value;
      }
      insertBuffer(value, offset) {
        utils_1.checkOffsetValue(offset);
        return this._handleBuffer(value, true, offset);
      }
      writeBuffer(value, offset) {
        return this._handleBuffer(value, false, offset);
      }
      readBufferNT() {
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value;
      }
      insertBufferNT(value, offset) {
        utils_1.checkOffsetValue(offset);
        this.insertBuffer(value, offset);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      writeBufferNT(value, offset) {
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
        }
        this.writeBuffer(value, offset);
        this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
        return this;
      }
      clear() {
        this._writeOffset = 0;
        this._readOffset = 0;
        this.length = 0;
        return this;
      }
      remaining() {
        return this.length - this._readOffset;
      }
      get readOffset() {
        return this._readOffset;
      }
      set readOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._readOffset = offset;
      }
      get writeOffset() {
        return this._writeOffset;
      }
      set writeOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._writeOffset = offset;
      }
      get encoding() {
        return this._encoding;
      }
      set encoding(encoding) {
        utils_1.checkEncoding(encoding);
        this._encoding = encoding;
      }
      get internalBuffer() {
        return this._buff;
      }
      toBuffer() {
        return this._buff.slice(0, this.length);
      }
      toString(encoding) {
        const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
        utils_1.checkEncoding(encodingVal);
        return this._buff.toString(encodingVal, 0, this.length);
      }
      destroy() {
        this.clear();
        return this;
      }
      _handleString(value, isInsert, arg3, encoding) {
        let offsetVal = this._writeOffset;
        let encodingVal = this._encoding;
        if (typeof arg3 === "number") {
          offsetVal = arg3;
        } else if (typeof arg3 === "string") {
          utils_1.checkEncoding(arg3);
          encodingVal = arg3;
        }
        if (typeof encoding === "string") {
          utils_1.checkEncoding(encoding);
          encodingVal = encoding;
        }
        const byteLength = Buffer.byteLength(value, encodingVal);
        if (isInsert) {
          this.ensureInsertable(byteLength, offsetVal);
        } else {
          this._ensureWriteable(byteLength, offsetVal);
        }
        this._buff.write(value, offsetVal, byteLength, encodingVal);
        if (isInsert) {
          this._writeOffset += byteLength;
        } else {
          if (typeof arg3 === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
          } else {
            this._writeOffset += byteLength;
          }
        }
        return this;
      }
      _handleBuffer(value, isInsert, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        if (isInsert) {
          this.ensureInsertable(value.length, offsetVal);
        } else {
          this._ensureWriteable(value.length, offsetVal);
        }
        value.copy(this._buff, offsetVal);
        if (isInsert) {
          this._writeOffset += value.length;
        } else {
          if (typeof offset === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
          } else {
            this._writeOffset += value.length;
          }
        }
        return this;
      }
      ensureReadable(length, offset) {
        let offsetVal = this._readOffset;
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
          offsetVal = offset;
        }
        if (offsetVal < 0 || offsetVal + length > this.length) {
          throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
        }
      }
      ensureInsertable(dataLength, offset) {
        utils_1.checkOffsetValue(offset);
        this._ensureCapacity(this.length + dataLength);
        if (offset < this.length) {
          this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
        }
        if (offset + dataLength > this.length) {
          this.length = offset + dataLength;
        } else {
          this.length += dataLength;
        }
      }
      _ensureWriteable(dataLength, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureCapacity(offsetVal + dataLength);
        if (offsetVal + dataLength > this.length) {
          this.length = offsetVal + dataLength;
        }
      }
      _ensureCapacity(minLength) {
        const oldLength = this._buff.length;
        if (minLength > oldLength) {
          let data = this._buff;
          let newLength = oldLength * 3 / 2 + 1;
          if (newLength < minLength) {
            newLength = minLength;
          }
          this._buff = Buffer.allocUnsafe(newLength);
          data.copy(this._buff, 0, 0, oldLength);
        }
      }
      _readNumberValue(func, byteSize, offset) {
        this.ensureReadable(byteSize, offset);
        const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
        if (typeof offset === "undefined") {
          this._readOffset += byteSize;
        }
        return value;
      }
      _insertNumberValue(func, byteSize, value, offset) {
        utils_1.checkOffsetValue(offset);
        this.ensureInsertable(byteSize, offset);
        func.call(this._buff, value, offset);
        this._writeOffset += byteSize;
        return this;
      }
      _writeNumberValue(func, byteSize, value, offset) {
        if (typeof offset === "number") {
          if (offset < 0) {
            throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
          }
          utils_1.checkOffsetValue(offset);
        }
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureWriteable(byteSize, offsetVal);
        func.call(this._buff, value, offsetVal);
        if (typeof offset === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
        } else {
          this._writeOffset += byteSize;
        }
        return this;
      }
    };
    exports2.SmartBuffer = SmartBuffer;
  }
});

// node_modules/socks/build/common/constants.js
var require_constants = __commonJS({
  "node_modules/socks/build/common/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SOCKS5_NO_ACCEPTABLE_AUTH = exports2.SOCKS5_CUSTOM_AUTH_END = exports2.SOCKS5_CUSTOM_AUTH_START = exports2.SOCKS_INCOMING_PACKET_SIZES = exports2.SocksClientState = exports2.Socks5Response = exports2.Socks5HostType = exports2.Socks5Auth = exports2.Socks4Response = exports2.SocksCommand = exports2.ERRORS = exports2.DEFAULT_TIMEOUT = void 0;
    var DEFAULT_TIMEOUT = 3e4;
    exports2.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var ERRORS = {
      InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
      InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
      InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
      InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
      InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
      InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
      InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
      InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
      InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
      InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
      NegotiationError: "Negotiation error",
      SocketClosed: "Socket closed",
      ProxyConnectionTimedOut: "Proxy connection timed out",
      InternalError: "SocksClient internal error (this should not happen)",
      InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
      Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
      InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
      Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
      InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
      InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
      InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
      InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
      Socks5AuthenticationFailed: "Socks5 Authentication failed",
      InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
      InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
      InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
      Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
    };
    exports2.ERRORS = ERRORS;
    var SOCKS_INCOMING_PACKET_SIZES = {
      Socks5InitialHandshakeResponse: 2,
      Socks5UserPassAuthenticationResponse: 2,
      Socks5ResponseHeader: 5,
      Socks5ResponseIPv4: 10,
      Socks5ResponseIPv6: 22,
      Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
      Socks4Response: 8
    };
    exports2.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
      SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
      SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
    })(SocksCommand || (SocksCommand = {}));
    exports2.SocksCommand = SocksCommand;
    var Socks4Response;
    (function(Socks4Response2) {
      Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
      Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
      Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
      Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
    })(Socks4Response || (Socks4Response = {}));
    exports2.Socks4Response = Socks4Response;
    var Socks5Auth;
    (function(Socks5Auth2) {
      Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
      Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
      Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
    })(Socks5Auth || (Socks5Auth = {}));
    exports2.Socks5Auth = Socks5Auth;
    var SOCKS5_CUSTOM_AUTH_START = 128;
    exports2.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
    var SOCKS5_CUSTOM_AUTH_END = 254;
    exports2.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
    var SOCKS5_NO_ACCEPTABLE_AUTH = 255;
    exports2.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
    var Socks5Response;
    (function(Socks5Response2) {
      Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
      Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
      Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
      Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
      Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
      Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
      Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
      Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
    })(Socks5Response || (Socks5Response = {}));
    exports2.Socks5Response = Socks5Response;
    var Socks5HostType;
    (function(Socks5HostType2) {
      Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
      Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
      Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
    })(Socks5HostType || (Socks5HostType = {}));
    exports2.Socks5HostType = Socks5HostType;
    var SocksClientState;
    (function(SocksClientState2) {
      SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
      SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
      SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
      SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
      SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
      SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
      SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
      SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
      SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
      SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
      SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
      SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
      SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
    })(SocksClientState || (SocksClientState = {}));
    exports2.SocksClientState = SocksClientState;
  }
});

// node_modules/socks/build/common/util.js
var require_util = __commonJS({
  "node_modules/socks/build/common/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shuffleArray = exports2.SocksClientError = void 0;
    var SocksClientError = class extends Error {
      constructor(message, options) {
        super(message);
        this.options = options;
      }
    };
    exports2.SocksClientError = SocksClientError;
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    exports2.shuffleArray = shuffleArray;
  }
});

// node_modules/socks/build/common/helpers.js
var require_helpers = __commonJS({
  "node_modules/socks/build/common/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSocksClientChainOptions = exports2.validateSocksClientOptions = void 0;
    var util_1 = require_util();
    var constants_1 = require_constants();
    var stream = require("stream");
    function validateSocksClientOptions(options, acceptedCommands = ["connect", "bind", "associate"]) {
      if (!constants_1.SocksCommand[options.command]) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
      }
      if (acceptedCommands.indexOf(options.command) === -1) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!isValidSocksProxy(options.proxy)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
      }
      validateCustomProxyAuth(options.proxy, options);
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
      if (options.existing_socket && !(options.existing_socket instanceof stream.Duplex)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
      }
    }
    exports2.validateSocksClientOptions = validateSocksClientOptions;
    function validateSocksClientChainOptions(options) {
      if (options.command !== "connect") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
      }
      options.proxies.forEach((proxy) => {
        if (!isValidSocksProxy(proxy)) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
        }
        validateCustomProxyAuth(proxy, options);
      });
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
    }
    exports2.validateSocksClientChainOptions = validateSocksClientChainOptions;
    function validateCustomProxyAuth(proxy, options) {
      if (proxy.custom_auth_method !== void 0) {
        if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
        }
        if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_size === void 0) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
      }
    }
    function isValidSocksRemoteHost(remoteHost) {
      return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
    }
    function isValidSocksProxy(proxy) {
      return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
    }
    function isValidTimeoutValue(value) {
      return typeof value === "number" && value > 0;
    }
  }
});

// node_modules/socks/build/common/receivebuffer.js
var require_receivebuffer = __commonJS({
  "node_modules/socks/build/common/receivebuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReceiveBuffer = void 0;
    var ReceiveBuffer = class {
      constructor(size = 4096) {
        this.buffer = Buffer.allocUnsafe(size);
        this.offset = 0;
        this.originalSize = size;
      }
      get length() {
        return this.offset;
      }
      append(data) {
        if (!Buffer.isBuffer(data)) {
          throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
        }
        if (this.offset + data.length >= this.buffer.length) {
          const tmp = this.buffer;
          this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
          tmp.copy(this.buffer);
        }
        data.copy(this.buffer, this.offset);
        return this.offset += data.length;
      }
      peek(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        return this.buffer.slice(0, length);
      }
      get(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        const value = Buffer.allocUnsafe(length);
        this.buffer.slice(0, length).copy(value);
        this.buffer.copyWithin(0, length, length + this.offset - length);
        this.offset -= length;
        return value;
      }
    };
    exports2.ReceiveBuffer = ReceiveBuffer;
  }
});

// node_modules/socks/build/client/socksclient.js
var require_socksclient = __commonJS({
  "node_modules/socks/build/client/socksclient.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SocksClientError = exports2.SocksClient = void 0;
    var events_1 = require("events");
    var net = require("net");
    var ip = require_ip();
    var smart_buffer_1 = require_smartbuffer();
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var receivebuffer_1 = require_receivebuffer();
    var util_1 = require_util();
    Object.defineProperty(exports2, "SocksClientError", { enumerable: true, get: function() {
      return util_1.SocksClientError;
    } });
    var SocksClient = class extends events_1.EventEmitter {
      constructor(options) {
        super();
        this.options = Object.assign({}, options);
        helpers_1.validateSocksClientOptions(options);
        this.setState(constants_1.SocksClientState.Created);
      }
      static createConnection(options, callback) {
        return new Promise((resolve, reject) => {
          try {
            helpers_1.validateSocksClientOptions(options, ["connect"]);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          const client = new SocksClient(options);
          client.connect(options.existing_socket);
          client.once("established", (info) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(null, info);
              resolve(info);
            } else {
              resolve(info);
            }
          });
          client.once("error", (err) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          });
        });
      }
      static createConnectionChain(options, callback) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          try {
            helpers_1.validateSocksClientChainOptions(options);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          let sock;
          if (options.randomizeChain) {
            util_1.shuffleArray(options.proxies);
          }
          try {
            for (let i = 0; i < options.proxies.length; i++) {
              const nextProxy = options.proxies[i];
              const nextDestination = i === options.proxies.length - 1 ? options.destination : {
                host: options.proxies[i + 1].ipaddress,
                port: options.proxies[i + 1].port
              };
              const result = yield SocksClient.createConnection({
                command: "connect",
                proxy: nextProxy,
                destination: nextDestination
              });
              if (!sock) {
                sock = result.socket;
              }
            }
            if (typeof callback === "function") {
              callback(null, { socket: sock });
              resolve({ socket: sock });
            } else {
              resolve({ socket: sock });
            }
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          }
        }));
      }
      static createUDPFrame(options) {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt16BE(0);
        buff.writeUInt8(options.frameNumber || 0);
        if (net.isIPv4(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeUInt32BE(ip.toLong(options.remoteHost.host));
        } else if (net.isIPv6(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer(ip.toBuffer(options.remoteHost.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
          buff.writeString(options.remoteHost.host);
        }
        buff.writeUInt16BE(options.remoteHost.port);
        buff.writeBuffer(options.data);
        return buff.toBuffer();
      }
      static parseUDPFrame(data) {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        const frameNumber = buff.readUInt8();
        const hostType = buff.readUInt8();
        let remoteHost;
        if (hostType === constants_1.Socks5HostType.IPv4) {
          remoteHost = ip.fromLong(buff.readUInt32BE());
        } else if (hostType === constants_1.Socks5HostType.IPv6) {
          remoteHost = ip.toString(buff.readBuffer(16));
        } else {
          remoteHost = buff.readString(buff.readUInt8());
        }
        const remotePort = buff.readUInt16BE();
        return {
          frameNumber,
          remoteHost: {
            host: remoteHost,
            port: remotePort
          },
          data: buff.readBuffer()
        };
      }
      setState(newState) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.state = newState;
        }
      }
      connect(existingSocket) {
        this.onDataReceived = (data) => this.onDataReceivedHandler(data);
        this.onClose = () => this.onCloseHandler();
        this.onError = (err) => this.onErrorHandler(err);
        this.onConnect = () => this.onConnectHandler();
        const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
        if (timer.unref && typeof timer.unref === "function") {
          timer.unref();
        }
        if (existingSocket) {
          this.socket = existingSocket;
        } else {
          this.socket = new net.Socket();
        }
        this.socket.once("close", this.onClose);
        this.socket.once("error", this.onError);
        this.socket.once("connect", this.onConnect);
        this.socket.on("data", this.onDataReceived);
        this.setState(constants_1.SocksClientState.Connecting);
        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
        if (existingSocket) {
          this.socket.emit("connect");
        } else {
          this.socket.connect(this.getSocketOptions());
          if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
            this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
          }
        }
        this.prependOnceListener("established", (info) => {
          setImmediate(() => {
            if (this.receiveBuffer.length > 0) {
              const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
              info.socket.emit("data", excessData);
            }
            info.socket.resume();
          });
        });
      }
      getSocketOptions() {
        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
      }
      onEstablishedTimeout() {
        if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
          this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
        }
      }
      onConnectHandler() {
        this.setState(constants_1.SocksClientState.Connected);
        if (this.options.proxy.type === 4) {
          this.sendSocks4InitialHandshake();
        } else {
          this.sendSocks5InitialHandshake();
        }
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      onDataReceivedHandler(data) {
        this.receiveBuffer.append(data);
        this.processData();
      }
      processData() {
        while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
          if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4FinalHandshakeResponse();
            } else {
              this.handleInitialSocks5HandshakeResponse();
            }
          } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
            this.handleInitialSocks5AuthenticationHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
            this.handleSocks5FinalHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4IncomingConnectionResponse();
            } else {
              this.handleSocks5IncomingConnectionResponse();
            }
          } else {
            this.closeSocket(constants_1.ERRORS.InternalError);
            break;
          }
        }
      }
      onCloseHandler() {
        this.closeSocket(constants_1.ERRORS.SocketClosed);
      }
      onErrorHandler(err) {
        this.closeSocket(err.message);
      }
      removeInternalSocketHandlers() {
        this.socket.pause();
        this.socket.removeListener("data", this.onDataReceived);
        this.socket.removeListener("close", this.onClose);
        this.socket.removeListener("error", this.onError);
        this.socket.removeListener("connect", this.onConnect);
      }
      closeSocket(err) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.setState(constants_1.SocksClientState.Error);
          this.socket.destroy();
          this.removeInternalSocketHandlers();
          this.emit("error", new util_1.SocksClientError(err, this.options));
        }
      }
      sendSocks4InitialHandshake() {
        const userId = this.options.proxy.userId || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(4);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt16BE(this.options.destination.port);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeBuffer(ip.toBuffer(this.options.destination.host));
          buff.writeStringNT(userId);
        } else {
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(1);
          buff.writeStringNT(userId);
          buff.writeStringNT(this.options.destination.host);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
        this.socket.write(buff.toBuffer());
      }
      handleSocks4FinalHandshakeResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
            buff.readOffset = 2;
            const remoteHost = {
              port: buff.readUInt16BE(),
              host: ip.fromLong(buff.readUInt32BE())
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.emit("bound", { remoteHost, socket: this.socket });
          } else {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { socket: this.socket });
          }
        }
      }
      handleSocks4IncomingConnectionResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: ip.fromLong(buff.readUInt32BE())
          };
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      sendSocks5InitialHandshake() {
        const buff = new smart_buffer_1.SmartBuffer();
        const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
        if (this.options.proxy.userId || this.options.proxy.password) {
          supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
        }
        if (this.options.proxy.custom_auth_method !== void 0) {
          supportedAuthMethods.push(this.options.proxy.custom_auth_method);
        }
        buff.writeUInt8(5);
        buff.writeUInt8(supportedAuthMethods.length);
        for (const authMethod of supportedAuthMethods) {
          buff.writeUInt8(authMethod);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      handleInitialSocks5HandshakeResponse() {
        const data = this.receiveBuffer.get(2);
        if (data[0] !== 5) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
        } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
        } else {
          if (data[1] === constants_1.Socks5Auth.NoAuth) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
            this.sendSocks5CommandRequest();
          } else if (data[1] === constants_1.Socks5Auth.UserPass) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
            this.sendSocks5UserPassAuthentication();
          } else if (data[1] === this.options.proxy.custom_auth_method) {
            this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
            this.sendSocks5CustomAuthentication();
          } else {
            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
          }
        }
      }
      sendSocks5UserPassAuthentication() {
        const userId = this.options.proxy.userId || "";
        const password = this.options.proxy.password || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(1);
        buff.writeUInt8(Buffer.byteLength(userId));
        buff.writeString(userId);
        buff.writeUInt8(Buffer.byteLength(password));
        buff.writeString(password);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentAuthentication);
      }
      sendSocks5CustomAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
          this.socket.write(yield this.options.proxy.custom_auth_request_handler());
          this.setState(constants_1.SocksClientState.SentAuthentication);
        });
      }
      handleSocks5CustomAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.options.proxy.custom_auth_response_handler(data);
        });
      }
      handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleSocks5AuthenticationUserPassHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleInitialSocks5AuthenticationHandshakeResponse() {
        return __awaiter(this, void 0, void 0, function* () {
          this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
          let authResult = false;
          if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
            authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
            authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
            authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
          }
          if (!authResult) {
            this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
          } else {
            this.sendSocks5CommandRequest();
          }
        });
      }
      sendSocks5CommandRequest() {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(5);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt8(0);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeBuffer(ip.toBuffer(this.options.destination.host));
        } else if (net.isIPv6(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer(ip.toBuffer(this.options.destination.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(this.options.destination.host.length);
          buff.writeString(this.options.destination.host);
        }
        buff.writeUInt16BE(this.options.destination.port);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentFinalHandshake);
      }
      handleSocks5FinalHandshakeResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.fromLong(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.toString(buff.readBuffer(16)),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
            this.emit("bound", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", {
              remoteHost,
              socket: this.socket
            });
          }
        }
      }
      handleSocks5IncomingConnectionResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.fromLong(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip.toString(buff.readBuffer(16)),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      get socksClientOptions() {
        return Object.assign({}, this.options);
      }
    };
    exports2.SocksClient = SocksClient;
  }
});

// node_modules/socks/build/index.js
var require_build = __commonJS({
  "node_modules/socks/build/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_socksclient(), exports2);
  }
});

// node_modules/socks-proxy-agent/dist/agent.js
var require_agent2 = __commonJS({
  "node_modules/socks-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dns_1 = __importDefault(require("dns"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var socks_1 = require_build();
    var debug = debug_1.default("socks-proxy-agent");
    function dnsLookup(host) {
      return new Promise((resolve, reject) => {
        dns_1.default.lookup(host, (err, res) => {
          if (err) {
            reject(err);
          } else {
            resolve(res);
          }
        });
      });
    }
    function parseSocksProxy(opts) {
      let port = 0;
      let lookup = false;
      let type = 5;
      const host = opts.hostname || opts.host;
      if (!host) {
        throw new TypeError('No "host"');
      }
      if (typeof opts.port === "number") {
        port = opts.port;
      } else if (typeof opts.port === "string") {
        port = parseInt(opts.port, 10);
      }
      if (!port) {
        port = 1080;
      }
      if (opts.protocol) {
        switch (opts.protocol.replace(":", "")) {
          case "socks4":
            lookup = true;
          case "socks4a":
            type = 4;
            break;
          case "socks5":
            lookup = true;
          case "socks":
          case "socks5h":
            type = 5;
            break;
          default:
            throw new TypeError(`A "socks" protocol must be specified! Got: ${opts.protocol}`);
        }
      }
      if (typeof opts.type !== "undefined") {
        if (opts.type === 4 || opts.type === 5) {
          type = opts.type;
        } else {
          throw new TypeError(`"type" must be 4 or 5, got: ${opts.type}`);
        }
      }
      const proxy = {
        host,
        port,
        type
      };
      let userId = opts.userId || opts.username;
      let password = opts.password;
      if (opts.auth) {
        const auth = opts.auth.split(":");
        userId = auth[0];
        password = auth[1];
      }
      if (userId) {
        Object.defineProperty(proxy, "userId", {
          value: userId,
          enumerable: false
        });
      }
      if (password) {
        Object.defineProperty(proxy, "password", {
          value: password,
          enumerable: false
        });
      }
      return { lookup, proxy };
    }
    var SocksProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new TypeError("a SOCKS proxy server `host` and `port` must be specified!");
        }
        super(opts);
        const parsedProxy = parseSocksProxy(opts);
        this.lookup = parsedProxy.lookup;
        this.proxy = parsedProxy.proxy;
        this.tlsConnectionOptions = opts.tls || {};
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { lookup, proxy } = this;
          let { host, port, timeout } = opts;
          if (!host) {
            throw new Error("No `host` defined!");
          }
          if (lookup) {
            host = yield dnsLookup(host);
          }
          const socksOpts = {
            proxy,
            destination: { host, port },
            command: "connect",
            timeout
          };
          debug("Creating socks proxy connection: %o", socksOpts);
          const { socket } = yield socks_1.SocksClient.createConnection(socksOpts);
          debug("Successfully created socks proxy connection");
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            const servername = opts.servername || opts.host;
            return tls_1.default.connect(Object.assign(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
              socket,
              servername
            }), this.tlsConnectionOptions));
          }
          return socket;
        });
      }
    };
    exports2.default = SocksProxyAgent;
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/socks-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/socks-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent2());
    function createSocksProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createSocksProxyAgent2) {
      createSocksProxyAgent2.SocksProxyAgent = agent_1.default;
      createSocksProxyAgent2.prototype = agent_1.default.prototype;
    })(createSocksProxyAgent || (createSocksProxyAgent = {}));
    module2.exports = createSocksProxyAgent;
  }
});

// node_modules/playwright-core/lib/server/cookieStore.js
var require_cookieStore = __commonJS({
  "node_modules/playwright-core/lib/server/cookieStore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.domainMatches = domainMatches;
    exports2.CookieStore = void 0;
    var Cookie = class {
      constructor(data) {
        this._raw = void 0;
        this._raw = data;
      }
      name() {
        return this._raw.name;
      }
      matches(url) {
        if (this._raw.secure && url.protocol !== "https:")
          return false;
        if (!domainMatches(url.hostname, this._raw.domain))
          return false;
        if (!pathMatches(url.pathname, this._raw.path))
          return false;
        return true;
      }
      equals(other) {
        return this._raw.name === other._raw.name && this._raw.domain === other._raw.domain && this._raw.path === other._raw.path;
      }
      networkCookie() {
        return this._raw;
      }
      updateExpiresFrom(other) {
        this._raw.expires = other._raw.expires;
      }
      expired() {
        if (this._raw.expires === -1)
          return false;
        return this._raw.expires * 1e3 < Date.now();
      }
    };
    var CookieStore = class {
      constructor() {
        this._nameToCookies = /* @__PURE__ */ new Map();
      }
      addCookies(cookies) {
        for (const cookie of cookies)
          this._addCookie(new Cookie(cookie));
      }
      cookies(url) {
        const result = [];
        for (const cookie of this._cookiesIterator()) {
          if (cookie.matches(url))
            result.push(cookie.networkCookie());
        }
        return result;
      }
      allCookies() {
        const result = [];
        for (const cookie of this._cookiesIterator())
          result.push(cookie.networkCookie());
        return result;
      }
      _addCookie(cookie) {
        if (cookie.expired())
          return;
        let set = this._nameToCookies.get(cookie.name());
        if (!set) {
          set = /* @__PURE__ */ new Set();
          this._nameToCookies.set(cookie.name(), set);
        }
        CookieStore.pruneExpired(set);
        for (const other of set) {
          if (other.equals(cookie)) {
            cookie.updateExpiresFrom(other);
            set.delete(other);
          }
        }
        set.add(cookie);
      }
      *_cookiesIterator() {
        for (const [name, cookies] of this._nameToCookies) {
          CookieStore.pruneExpired(cookies);
          for (const cookie of cookies)
            yield cookie;
          if (cookies.size === 0)
            this._nameToCookies.delete(name);
        }
      }
      static pruneExpired(cookies) {
        for (const cookie of cookies) {
          if (cookie.expired())
            cookies.delete(cookie);
        }
      }
    };
    exports2.CookieStore = CookieStore;
    function domainMatches(value, domain) {
      if (value === domain)
        return true;
      if (!domain.startsWith("."))
        return false;
      value = "." + value;
      return value.endsWith(domain);
    }
    function pathMatches(value, path) {
      if (value === path)
        return true;
      if (!value.endsWith("/"))
        value = value + "/";
      if (!path.endsWith("/"))
        path = path + "/";
      return value.startsWith(path);
    }
  }
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/mime/Mime.js"(exports2, module2) {
    "use strict";
    function Mime() {
      this._types = Object.create(null);
      this._extensions = Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      let last = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module2.exports = Mime;
  }
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/mime/types/standard.js"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/mime/types/other.js
var require_other = __commonJS({
  "node_modules/mime/types/other.js"(exports2, module2) {
    module2.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/mime/index.js
var require_mime = __commonJS({
  "node_modules/mime/index.js"(exports2, module2) {
    "use strict";
    var Mime = require_Mime();
    module2.exports = new Mime(require_standard(), require_other());
  }
});

// node_modules/playwright-core/lib/server/formData.js
var require_formData = __commonJS({
  "node_modules/playwright-core/lib/server/formData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.MultipartFormData = void 0;
    var _mime = _interopRequireDefault2(require_mime());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MultipartFormData = class {
      constructor() {
        this._boundary = void 0;
        this._chunks = [];
        this._boundary = generateUniqueBoundaryString();
      }
      contentTypeHeader() {
        return `multipart/form-data; boundary=${this._boundary}`;
      }
      addField(name, value) {
        this._beginMultiPartHeader(name);
        this._finishMultiPartHeader();
        this._chunks.push(Buffer.from(value));
        this._finishMultiPartField();
      }
      addFileField(name, value) {
        this._beginMultiPartHeader(name);
        this._chunks.push(Buffer.from(`; filename="${value.name}"`));
        this._chunks.push(Buffer.from(`\r
content-type: ${value.mimeType || _mime.default.getType(value.name) || "application/octet-stream"}`));
        this._finishMultiPartHeader();
        this._chunks.push(Buffer.from(value.buffer, "base64"));
        this._finishMultiPartField();
      }
      finish() {
        this._addBoundary(true);
        return Buffer.concat(this._chunks);
      }
      _beginMultiPartHeader(name) {
        this._addBoundary();
        this._chunks.push(Buffer.from(`content-disposition: form-data; name="${name}"`));
      }
      _finishMultiPartHeader() {
        this._chunks.push(Buffer.from(`\r
\r
`));
      }
      _finishMultiPartField() {
        this._chunks.push(Buffer.from(`\r
`));
      }
      _addBoundary(isLastBoundary) {
        this._chunks.push(Buffer.from("--" + this._boundary));
        if (isLastBoundary)
          this._chunks.push(Buffer.from("--"));
        this._chunks.push(Buffer.from("\r\n"));
      }
    };
    exports2.MultipartFormData = MultipartFormData;
    var alphaNumericEncodingMap = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66];
    function generateUniqueBoundaryString() {
      const charCodes = [];
      for (let i = 0; i < 16; i++)
        charCodes.push(alphaNumericEncodingMap[Math.floor(Math.random() * alphaNumericEncodingMap.length)]);
      return "----WebKitFormBoundary" + String.fromCharCode(...charCodes);
    }
  }
});

// node_modules/playwright-core/lib/server/fetch.js
var require_fetch = __commonJS({
  "node_modules/playwright-core/lib/server/fetch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GlobalAPIRequestContext = exports2.BrowserContextAPIRequestContext = exports2.APIRequestContext = void 0;
    var http = _interopRequireWildcard2(require("http"));
    var https = _interopRequireWildcard2(require("https"));
    var _httpsProxyAgent = require_dist();
    var _progress = require_progress2();
    var _socksProxyAgent = require_dist2();
    var _stream = require("stream");
    var _url = _interopRequireDefault2(require("url"));
    var _zlib = _interopRequireDefault2(require("zlib"));
    var _timeoutSettings = require_timeoutSettings();
    var _utils2 = require_utils();
    var _browserContext = require_browserContext();
    var _cookieStore = require_cookieStore();
    var _formData = require_formData();
    var _instrumentation = require_instrumentation();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var APIRequestContext = class extends _instrumentation.SdkObject {
      static findResponseBody(guid) {
        for (const request of APIRequestContext.allInstances) {
          const body = request.fetchResponses.get(guid);
          if (body)
            return body;
        }
        return void 0;
      }
      constructor(parent) {
        super(parent, "fetchRequest");
        this.fetchResponses = /* @__PURE__ */ new Map();
        this.fetchLog = /* @__PURE__ */ new Map();
        APIRequestContext.allInstances.add(this);
      }
      _disposeImpl() {
        APIRequestContext.allInstances.delete(this);
        this.fetchResponses.clear();
        this.fetchLog.clear();
        this.emit(APIRequestContext.Events.Dispose);
      }
      disposeResponse(fetchUid) {
        this.fetchResponses.delete(fetchUid);
        this.fetchLog.delete(fetchUid);
      }
      _storeResponseBody(body) {
        const uid = (0, _utils2.createGuid)();
        this.fetchResponses.set(uid, body);
        return uid;
      }
      fetch(params, metadata) {
        return __async(this, null, function* () {
          var _params$method;
          const headers = {};
          const defaults = this._defaultOptions();
          headers["user-agent"] = defaults.userAgent;
          headers["accept"] = "*/*";
          headers["accept-encoding"] = "gzip,deflate,br";
          if (defaults.extraHTTPHeaders) {
            for (const {
              name,
              value
            } of defaults.extraHTTPHeaders)
              headers[name.toLowerCase()] = value;
          }
          if (params.headers) {
            for (const {
              name,
              value
            } of params.headers)
              headers[name.toLowerCase()] = value;
          }
          const method = ((_params$method = params.method) === null || _params$method === void 0 ? void 0 : _params$method.toUpperCase()) || "GET";
          const proxy = defaults.proxy;
          let agent;
          if (proxy) {
            var _proxyOpts$protocol;
            const proxyOpts = _url.default.parse(proxy.server);
            if ((_proxyOpts$protocol = proxyOpts.protocol) !== null && _proxyOpts$protocol !== void 0 && _proxyOpts$protocol.startsWith("socks")) {
              agent = new _socksProxyAgent.SocksProxyAgent({
                host: proxyOpts.hostname,
                port: proxyOpts.port || void 0
              });
            } else {
              if (proxy.username)
                proxyOpts.auth = `${proxy.username}:${proxy.password || ""}`;
              agent = new _httpsProxyAgent.HttpsProxyAgent(proxyOpts);
            }
          }
          const timeout = defaults.timeoutSettings.timeout(params);
          const deadline = timeout && (0, _utils2.monotonicTime)() + timeout;
          const options = {
            method,
            headers,
            agent,
            maxRedirects: 20,
            timeout,
            deadline
          };
          if (params.ignoreHTTPSErrors || defaults.ignoreHTTPSErrors)
            options.rejectUnauthorized = false;
          const requestUrl = new URL(params.url, defaults.baseURL);
          if (params.params) {
            for (const {
              name,
              value
            } of params.params)
              requestUrl.searchParams.set(name, value);
          }
          let postData;
          if (["POST", "PUT", "PATCH", "DELETE"].includes(method))
            postData = serializePostData(params, headers);
          else if (params.postData || params.jsonData || params.formData || params.multipartData)
            throw new Error(`Method ${method} does not accept post data`);
          if (postData)
            headers["content-length"] = String(postData.byteLength);
          const controller = new _progress.ProgressController(metadata, this);
          const fetchResponse = yield controller.run((progress) => {
            return this._sendRequest(progress, requestUrl, options, postData);
          });
          const fetchUid = this._storeResponseBody(fetchResponse.body);
          this.fetchLog.set(fetchUid, controller.metadata.log);
          if (params.failOnStatusCode && (fetchResponse.status < 200 || fetchResponse.status >= 400))
            throw new Error(`${fetchResponse.status} ${fetchResponse.statusText}`);
          return __spreadProps(__spreadValues({}, fetchResponse), {
            fetchUid
          });
        });
      }
      _parseSetCookieHeader(responseUrl, setCookie) {
        if (!setCookie)
          return [];
        const url = new URL(responseUrl);
        const defaultPath = "/" + url.pathname.substr(1).split("/").slice(0, -1).join("/");
        const cookies = [];
        for (const header of setCookie) {
          const cookie = parseCookie(header);
          if (!cookie)
            continue;
          if (!cookie.domain)
            cookie.domain = url.hostname;
          else
            (0, _utils2.assert)(cookie.domain.startsWith("."));
          if (!(0, _cookieStore.domainMatches)(url.hostname, cookie.domain))
            continue;
          if (!cookie.path || !cookie.path.startsWith("/"))
            cookie.path = defaultPath;
          cookies.push(cookie);
        }
        return cookies;
      }
      _updateRequestCookieHeader(url, options) {
        return __async(this, null, function* () {
          if (options.headers["cookie"] !== void 0)
            return;
          const cookies = yield this._cookies(url);
          if (cookies.length) {
            const valueArray = cookies.map((c) => `${c.name}=${c.value}`);
            options.headers["cookie"] = valueArray.join("; ");
          }
        });
      }
      _sendRequest(progress, url, options, postData) {
        return __async(this, null, function* () {
          var _cookie;
          yield this._updateRequestCookieHeader(url, options);
          const requestCookies = ((_cookie = options.headers["cookie"]) === null || _cookie === void 0 ? void 0 : _cookie.split(";").map((p) => {
            const [name, value] = p.split("=").map((v) => v.trim());
            return {
              name,
              value
            };
          })) || [];
          const requestEvent = {
            url,
            method: options.method,
            headers: options.headers,
            cookies: requestCookies,
            postData
          };
          this.emit(APIRequestContext.Events.Request, requestEvent);
          return new Promise((fulfill, reject) => {
            const requestConstructor = (url.protocol === "https:" ? https : http).request;
            const request = requestConstructor(url, options, (response) => __async(this, null, function* () {
              const notifyRequestFinished = (body2) => {
                const requestFinishedEvent = {
                  requestEvent,
                  httpVersion: response.httpVersion,
                  statusCode: response.statusCode || 0,
                  statusMessage: response.statusMessage || "",
                  headers: response.headers,
                  rawHeaders: response.rawHeaders,
                  cookies,
                  body: body2
                };
                this.emit(APIRequestContext.Events.RequestFinished, requestFinishedEvent);
              };
              progress.log(`\u2190 ${response.statusCode} ${response.statusMessage}`);
              for (const [name, value] of Object.entries(response.headers))
                progress.log(`  ${name}: ${value}`);
              const cookies = this._parseSetCookieHeader(response.url || url.toString(), response.headers["set-cookie"]);
              if (cookies.length)
                yield this._addCookies(cookies);
              if (redirectStatus.includes(response.statusCode)) {
                if (!options.maxRedirects) {
                  reject(new Error("Max redirect count exceeded"));
                  request.destroy();
                  return;
                }
                const headers = __spreadValues({}, options.headers);
                delete headers[`cookie`];
                const status = response.statusCode;
                let method = options.method;
                if ((status === 301 || status === 302) && method === "POST" || status === 303 && !["GET", "HEAD"].includes(method)) {
                  method = "GET";
                  postData = void 0;
                  delete headers[`content-encoding`];
                  delete headers[`content-language`];
                  delete headers[`content-length`];
                  delete headers[`content-location`];
                  delete headers[`content-type`];
                }
                const redirectOptions = {
                  method,
                  headers,
                  agent: options.agent,
                  maxRedirects: options.maxRedirects - 1,
                  timeout: options.timeout,
                  deadline: options.deadline
                };
                if (options.rejectUnauthorized === false)
                  redirectOptions.rejectUnauthorized = false;
                if (response.headers.location) {
                  const locationURL = new URL(response.headers.location, url);
                  notifyRequestFinished();
                  fulfill(this._sendRequest(progress, locationURL, redirectOptions, postData));
                  request.destroy();
                  return;
                }
              }
              if (response.statusCode === 401 && !options.headers["authorization"]) {
                const auth = response.headers["www-authenticate"];
                const credentials = this._defaultOptions().httpCredentials;
                if (auth !== null && auth !== void 0 && auth.trim().startsWith("Basic") && credentials) {
                  const {
                    username,
                    password
                  } = credentials;
                  const encoded = Buffer.from(`${username || ""}:${password || ""}`).toString("base64");
                  options.headers["authorization"] = `Basic ${encoded}`;
                  notifyRequestFinished();
                  fulfill(this._sendRequest(progress, url, options, postData));
                  request.destroy();
                  return;
                }
              }
              response.on("aborted", () => reject(new Error("aborted")));
              let body = response;
              let transform;
              const encoding = response.headers["content-encoding"];
              if (encoding === "gzip" || encoding === "x-gzip") {
                transform = _zlib.default.createGunzip({
                  flush: _zlib.default.constants.Z_SYNC_FLUSH,
                  finishFlush: _zlib.default.constants.Z_SYNC_FLUSH
                });
              } else if (encoding === "br") {
                transform = _zlib.default.createBrotliDecompress();
              } else if (encoding === "deflate") {
                transform = _zlib.default.createInflate();
              }
              if (transform) {
                body = (0, _stream.pipeline)(response, transform, (e) => {
                  if (e)
                    reject(new Error(`failed to decompress '${encoding}' encoding: ${e}`));
                });
              }
              const chunks = [];
              body.on("data", (chunk) => chunks.push(chunk));
              body.on("end", () => {
                const body2 = Buffer.concat(chunks);
                notifyRequestFinished(body2);
                fulfill({
                  url: response.url || url.toString(),
                  status: response.statusCode || 0,
                  statusText: response.statusMessage || "",
                  headers: toHeadersArray(response.rawHeaders),
                  body: body2
                });
              });
              body.on("error", reject);
            }));
            request.on("error", reject);
            const disposeListener = () => {
              reject(new Error("Request context disposed."));
              request.destroy();
            };
            this.on(APIRequestContext.Events.Dispose, disposeListener);
            request.on("close", () => this.off(APIRequestContext.Events.Dispose, disposeListener));
            progress.log(`\u2192 ${options.method} ${url.toString()}`);
            if (options.headers) {
              for (const [name, value] of Object.entries(options.headers))
                progress.log(`  ${name}: ${value}`);
            }
            if (options.deadline) {
              const rejectOnTimeout = () => {
                reject(new Error(`Request timed out after ${options.timeout}ms`));
                request.destroy();
              };
              const remaining = options.deadline - (0, _utils2.monotonicTime)();
              if (remaining <= 0) {
                rejectOnTimeout();
                return;
              }
              request.setTimeout(remaining, rejectOnTimeout);
            }
            if (postData)
              request.write(postData);
            request.end();
          });
        });
      }
    };
    exports2.APIRequestContext = APIRequestContext;
    APIRequestContext.Events = {
      Dispose: "dispose",
      Request: "request",
      RequestFinished: "requestfinished"
    };
    APIRequestContext.allInstances = /* @__PURE__ */ new Set();
    var BrowserContextAPIRequestContext = class extends APIRequestContext {
      constructor(context) {
        super(context);
        this._context = void 0;
        this._context = context;
        context.once(_browserContext.BrowserContext.Events.Close, () => this._disposeImpl());
      }
      dispose() {
        this.fetchResponses.clear();
      }
      _defaultOptions() {
        return {
          userAgent: this._context._options.userAgent || this._context._browser.userAgent(),
          extraHTTPHeaders: this._context._options.extraHTTPHeaders,
          httpCredentials: this._context._options.httpCredentials,
          proxy: this._context._options.proxy || this._context._browser.options.proxy,
          timeoutSettings: this._context._timeoutSettings,
          ignoreHTTPSErrors: this._context._options.ignoreHTTPSErrors,
          baseURL: this._context._options.baseURL
        };
      }
      _addCookies(cookies) {
        return __async(this, null, function* () {
          yield this._context.addCookies(cookies);
        });
      }
      _cookies(url) {
        return __async(this, null, function* () {
          return yield this._context.cookies(url.toString());
        });
      }
      storageState() {
        return __async(this, null, function* () {
          return this._context.storageState();
        });
      }
    };
    exports2.BrowserContextAPIRequestContext = BrowserContextAPIRequestContext;
    var GlobalAPIRequestContext = class extends APIRequestContext {
      constructor(playwright2, options) {
        super(playwright2);
        this._cookieStore = new _cookieStore.CookieStore();
        this._options = void 0;
        this._origins = void 0;
        const timeoutSettings = new _timeoutSettings.TimeoutSettings();
        if (options.timeout !== void 0)
          timeoutSettings.setDefaultTimeout(options.timeout);
        const proxy = options.proxy;
        if (proxy !== null && proxy !== void 0 && proxy.server) {
          let url = proxy === null || proxy === void 0 ? void 0 : proxy.server.trim();
          if (!/^\w+:\/\//.test(url))
            url = "http://" + url;
          proxy.server = url;
        }
        if (options.storageState) {
          this._origins = options.storageState.origins;
          this._cookieStore.addCookies(options.storageState.cookies);
        }
        this._options = {
          baseURL: options.baseURL,
          userAgent: options.userAgent || (0, _utils2.getUserAgent)(),
          extraHTTPHeaders: options.extraHTTPHeaders,
          ignoreHTTPSErrors: !!options.ignoreHTTPSErrors,
          httpCredentials: options.httpCredentials,
          proxy,
          timeoutSettings
        };
      }
      dispose() {
        this._disposeImpl();
      }
      _defaultOptions() {
        return this._options;
      }
      _addCookies(cookies) {
        return __async(this, null, function* () {
          this._cookieStore.addCookies(cookies);
        });
      }
      _cookies(url) {
        return __async(this, null, function* () {
          return this._cookieStore.cookies(url);
        });
      }
      storageState() {
        return __async(this, null, function* () {
          return {
            cookies: this._cookieStore.allCookies(),
            origins: this._origins || []
          };
        });
      }
    };
    exports2.GlobalAPIRequestContext = GlobalAPIRequestContext;
    function toHeadersArray(rawHeaders) {
      const result = [];
      for (let i = 0; i < rawHeaders.length; i += 2)
        result.push({
          name: rawHeaders[i],
          value: rawHeaders[i + 1]
        });
      return result;
    }
    var redirectStatus = [301, 302, 303, 307, 308];
    function parseCookie(header) {
      const pairs = header.split(";").filter((s) => s.trim().length > 0).map((p) => p.split("=").map((s) => s.trim()));
      if (!pairs.length)
        return null;
      const [name, value] = pairs[0];
      const cookie = {
        name,
        value,
        domain: "",
        path: "",
        expires: -1,
        httpOnly: false,
        secure: false,
        sameSite: "Lax"
      };
      for (let i = 1; i < pairs.length; i++) {
        const [name2, value2] = pairs[i];
        switch (name2.toLowerCase()) {
          case "expires":
            const expiresMs = +new Date(value2);
            if (isFinite(expiresMs))
              cookie.expires = expiresMs / 1e3;
            break;
          case "max-age":
            const maxAgeSec = parseInt(value2, 10);
            if (isFinite(maxAgeSec))
              cookie.expires = Date.now() / 1e3 + maxAgeSec;
            break;
          case "domain":
            cookie.domain = value2.toLocaleLowerCase() || "";
            if (cookie.domain && !cookie.domain.startsWith("."))
              cookie.domain = "." + cookie.domain;
            break;
          case "path":
            cookie.path = value2 || "";
            break;
          case "secure":
            cookie.secure = true;
            break;
          case "httponly":
            cookie.httpOnly = true;
            break;
        }
      }
      return cookie;
    }
    function isJsonParsable(value) {
      if (typeof value !== "string")
        return false;
      try {
        JSON.parse(value);
        return true;
      } catch (e) {
        if (e instanceof SyntaxError)
          return false;
        else
          throw e;
      }
    }
    function serializePostData(params, headers) {
      (0, _utils2.assert)((params.postData ? 1 : 0) + (params.jsonData ? 1 : 0) + (params.formData ? 1 : 0) + (params.multipartData ? 1 : 0) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
      if (params.jsonData) {
        var _contentType, _headers$_contentType;
        const json = isJsonParsable(params.jsonData) ? params.jsonData : JSON.stringify(params.jsonData);
        (_headers$_contentType = headers[_contentType = "content-type"]) !== null && _headers$_contentType !== void 0 ? _headers$_contentType : headers[_contentType] = "application/json";
        return Buffer.from(json, "utf8");
      } else if (params.formData) {
        var _contentType2, _headers$_contentType2;
        const searchParams = new URLSearchParams();
        for (const {
          name,
          value
        } of params.formData)
          searchParams.append(name, value);
        (_headers$_contentType2 = headers[_contentType2 = "content-type"]) !== null && _headers$_contentType2 !== void 0 ? _headers$_contentType2 : headers[_contentType2] = "application/x-www-form-urlencoded";
        return Buffer.from(searchParams.toString(), "utf8");
      } else if (params.multipartData) {
        var _contentType3, _headers$_contentType3;
        const formData = new _formData.MultipartFormData();
        for (const field of params.multipartData) {
          if (field.file)
            formData.addFileField(field.name, field.file);
          else if (field.value)
            formData.addField(field.name, field.value);
        }
        (_headers$_contentType3 = headers[_contentType3 = "content-type"]) !== null && _headers$_contentType3 !== void 0 ? _headers$_contentType3 : headers[_contentType3] = formData.contentTypeHeader();
        return formData.finish();
      } else if (params.postData) {
        var _contentType4, _headers$_contentType4;
        (_headers$_contentType4 = headers[_contentType4 = "content-type"]) !== null && _headers$_contentType4 !== void 0 ? _headers$_contentType4 : headers[_contentType4] = "application/octet-stream";
        return Buffer.from(params.postData, "base64");
      }
      return void 0;
    }
  }
});

// node_modules/playwright-core/lib/server/network.js
var require_network = __commonJS({
  "node_modules/playwright-core/lib/server/network.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.filterCookies = filterCookies;
    exports2.rewriteCookies = rewriteCookies;
    exports2.parsedURL = parsedURL;
    exports2.stripFragmentFromUrl = stripFragmentFromUrl;
    exports2.singleHeader = singleHeader;
    exports2.mergeHeaders = mergeHeaders;
    exports2.STATUS_TEXTS = exports2.WebSocket = exports2.Response = exports2.Route = exports2.Request = void 0;
    var _utils2 = require_utils();
    var _async = require_async();
    var _instrumentation = require_instrumentation();
    var _fetch = require_fetch();
    function filterCookies(cookies, urls) {
      const parsedURLs = urls.map((s) => new URL(s));
      return cookies.filter((c) => {
        if (!parsedURLs.length)
          return true;
        for (const parsedURL2 of parsedURLs) {
          let domain = c.domain;
          if (!domain.startsWith("."))
            domain = "." + domain;
          if (!("." + parsedURL2.hostname).endsWith(domain))
            continue;
          if (!parsedURL2.pathname.startsWith(c.path))
            continue;
          if (parsedURL2.protocol !== "https:" && c.secure)
            continue;
          return true;
        }
        return false;
      });
    }
    function rewriteCookies(cookies) {
      return cookies.map((c) => {
        (0, _utils2.assert)(c.name, "Cookie should have a name");
        (0, _utils2.assert)(c.url || c.domain && c.path, "Cookie should have a url or a domain/path pair");
        (0, _utils2.assert)(!(c.url && c.domain), "Cookie should have either url or domain");
        (0, _utils2.assert)(!(c.url && c.path), "Cookie should have either url or path");
        const copy = __spreadValues({}, c);
        if (copy.url) {
          (0, _utils2.assert)(copy.url !== "about:blank", `Blank page can not have cookie "${c.name}"`);
          (0, _utils2.assert)(!copy.url.startsWith("data:"), `Data URL page can not have cookie "${c.name}"`);
          const url = new URL(copy.url);
          copy.domain = url.hostname;
          copy.path = url.pathname.substring(0, url.pathname.lastIndexOf("/") + 1);
          copy.secure = url.protocol === "https:";
        }
        return copy;
      });
    }
    function parsedURL(url) {
      try {
        return new URL(url);
      } catch (e) {
        return null;
      }
    }
    function stripFragmentFromUrl(url) {
      if (!url.includes("#"))
        return url;
      return url.substring(0, url.indexOf("#"));
    }
    var Request = class extends _instrumentation.SdkObject {
      constructor(frame, redirectedFrom, documentId, url, resourceType, method, postData, headers) {
        super(frame, "request");
        this._response = null;
        this._redirectedFrom = void 0;
        this._redirectedTo = null;
        this._documentId = void 0;
        this._isFavicon = void 0;
        this._failureText = null;
        this._url = void 0;
        this._resourceType = void 0;
        this._method = void 0;
        this._postData = void 0;
        this._headers = void 0;
        this._headersMap = /* @__PURE__ */ new Map();
        this._rawRequestHeadersPromise = void 0;
        this._frame = void 0;
        this._waitForResponsePromise = new _async.ManualPromise();
        this._responseEndTiming = -1;
        this.responseSize = {
          encodedBodySize: 0,
          transferSize: 0,
          responseHeadersSize: 0
        };
        (0, _utils2.assert)(!url.startsWith("data:"), "Data urls should not fire requests");
        this._frame = frame;
        this._redirectedFrom = redirectedFrom;
        if (redirectedFrom)
          redirectedFrom._redirectedTo = this;
        this._documentId = documentId;
        this._url = stripFragmentFromUrl(url);
        this._resourceType = resourceType;
        this._method = method;
        this._postData = postData;
        this._headers = headers;
        for (const {
          name,
          value
        } of this._headers)
          this._headersMap.set(name.toLowerCase(), value);
        this._isFavicon = url.endsWith("/favicon.ico") || !!(redirectedFrom !== null && redirectedFrom !== void 0 && redirectedFrom._isFavicon);
      }
      _setFailureText(failureText) {
        this._failureText = failureText;
        this._waitForResponsePromise.resolve(null);
      }
      url() {
        return this._url;
      }
      resourceType() {
        return this._resourceType;
      }
      method() {
        return this._method;
      }
      postDataBuffer() {
        return this._postData;
      }
      headers() {
        return this._headers;
      }
      headerValue(name) {
        return this._headersMap.get(name);
      }
      setWillReceiveExtraHeaders() {
        if (!this._rawRequestHeadersPromise)
          this._rawRequestHeadersPromise = new _async.ManualPromise();
      }
      setRawRequestHeaders(headers) {
        if (!this._rawRequestHeadersPromise)
          this._rawRequestHeadersPromise = new _async.ManualPromise();
        this._rawRequestHeadersPromise.resolve(headers);
      }
      rawRequestHeaders() {
        return __async(this, null, function* () {
          return this._rawRequestHeadersPromise || Promise.resolve(this._headers);
        });
      }
      rawRequestHeadersPromise() {
        return this._rawRequestHeadersPromise;
      }
      response() {
        return this._waitForResponsePromise;
      }
      _existingResponse() {
        return this._response;
      }
      _setResponse(response) {
        this._response = response;
        this._waitForResponsePromise.resolve(response);
      }
      _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
      }
      frame() {
        return this._frame;
      }
      isNavigationRequest() {
        return !!this._documentId;
      }
      redirectedFrom() {
        return this._redirectedFrom;
      }
      failure() {
        if (this._failureText === null)
          return null;
        return {
          errorText: this._failureText
        };
      }
      bodySize() {
        var _this$postDataBuffer;
        return ((_this$postDataBuffer = this.postDataBuffer()) === null || _this$postDataBuffer === void 0 ? void 0 : _this$postDataBuffer.length) || 0;
      }
      requestHeadersSize() {
        return __async(this, null, function* () {
          let headersSize = 4;
          headersSize += this.method().length;
          headersSize += new URL(this.url()).pathname.length;
          headersSize += 8;
          const headers = this.rawRequestHeadersPromise() ? yield this.rawRequestHeadersPromise() : this._headers;
          for (const header of headers)
            headersSize += header.name.length + header.value.length + 4;
          return headersSize;
        });
      }
    };
    exports2.Request = Request;
    var Route = class extends _instrumentation.SdkObject {
      constructor(request, delegate) {
        super(request.frame(), "route");
        this._request = void 0;
        this._delegate = void 0;
        this._handled = false;
        this._request = request;
        this._delegate = delegate;
      }
      request() {
        return this._request;
      }
      abort(errorCode = "failed") {
        return __async(this, null, function* () {
          (0, _utils2.assert)(!this._handled, "Route is already handled!");
          this._handled = true;
          yield this._delegate.abort(errorCode);
        });
      }
      fulfill(overrides) {
        return __async(this, null, function* () {
          (0, _utils2.assert)(!this._handled, "Route is already handled!");
          this._handled = true;
          let body = overrides.body;
          let isBase64 = overrides.isBase64 || false;
          if (body === void 0) {
            if (overrides.fetchResponseUid) {
              const context = this._request.frame()._page._browserContext;
              const buffer = context.fetchRequest.fetchResponses.get(overrides.fetchResponseUid) || _fetch.APIRequestContext.findResponseBody(overrides.fetchResponseUid);
              (0, _utils2.assert)(buffer, "Fetch response has been disposed");
              body = buffer.toString("base64");
              isBase64 = true;
            } else {
              body = "";
              isBase64 = false;
            }
          }
          yield this._delegate.fulfill({
            status: overrides.status || 200,
            headers: overrides.headers || [],
            body,
            isBase64
          });
        });
      }
      continue() {
        return __async(this, arguments, function* (overrides = {}) {
          (0, _utils2.assert)(!this._handled, "Route is already handled!");
          if (overrides.url) {
            const newUrl = new URL(overrides.url);
            const oldUrl = new URL(this._request.url());
            if (oldUrl.protocol !== newUrl.protocol)
              throw new Error("New URL must have same protocol as overridden URL");
          }
          yield this._delegate.continue(this._request, overrides);
        });
      }
    };
    exports2.Route = Route;
    var Response = class extends _instrumentation.SdkObject {
      constructor(request, status, statusText, headers, timing, getResponseBodyCallback, httpVersion) {
        super(request.frame(), "response");
        this._request = void 0;
        this._contentPromise = null;
        this._finishedPromise = new _async.ManualPromise();
        this._status = void 0;
        this._statusText = void 0;
        this._url = void 0;
        this._headers = void 0;
        this._headersMap = /* @__PURE__ */ new Map();
        this._getResponseBodyCallback = void 0;
        this._timing = void 0;
        this._serverAddrPromise = new _async.ManualPromise();
        this._securityDetailsPromise = new _async.ManualPromise();
        this._rawResponseHeadersPromise = void 0;
        this._httpVersion = void 0;
        this._request = request;
        this._timing = timing;
        this._status = status;
        this._statusText = statusText;
        this._url = request.url();
        this._headers = headers;
        for (const {
          name,
          value
        } of this._headers)
          this._headersMap.set(name.toLowerCase(), value);
        this._getResponseBodyCallback = getResponseBodyCallback;
        this._request._setResponse(this);
        this._httpVersion = httpVersion;
      }
      _serverAddrFinished(addr) {
        this._serverAddrPromise.resolve(addr);
      }
      _securityDetailsFinished(securityDetails) {
        this._securityDetailsPromise.resolve(securityDetails);
      }
      _requestFinished(responseEndTiming) {
        this._request._responseEndTiming = Math.max(responseEndTiming, this._timing.responseStart);
        this._finishedPromise.resolve();
      }
      _setHttpVersion(httpVersion) {
        this._httpVersion = httpVersion;
      }
      url() {
        return this._url;
      }
      status() {
        return this._status;
      }
      statusText() {
        return this._statusText;
      }
      headers() {
        return this._headers;
      }
      headerValue(name) {
        return this._headersMap.get(name);
      }
      rawResponseHeaders() {
        return __async(this, null, function* () {
          return this._rawResponseHeadersPromise || Promise.resolve(this._headers);
        });
      }
      setWillReceiveExtraHeaders() {
        this._request.setWillReceiveExtraHeaders();
        this._rawResponseHeadersPromise = new _async.ManualPromise();
      }
      setRawResponseHeaders(headers) {
        if (!this._rawResponseHeadersPromise)
          this._rawResponseHeadersPromise = new _async.ManualPromise();
        this._rawResponseHeadersPromise.resolve(headers);
      }
      timing() {
        return this._timing;
      }
      serverAddr() {
        return __async(this, null, function* () {
          return (yield this._serverAddrPromise) || null;
        });
      }
      securityDetails() {
        return __async(this, null, function* () {
          return (yield this._securityDetailsPromise) || null;
        });
      }
      body() {
        if (!this._contentPromise) {
          this._contentPromise = this._finishedPromise.then(() => __async(this, null, function* () {
            if (this._status >= 300 && this._status <= 399)
              throw new Error("Response body is unavailable for redirect responses");
            return this._getResponseBodyCallback();
          }));
        }
        return this._contentPromise;
      }
      request() {
        return this._request;
      }
      frame() {
        return this._request.frame();
      }
      httpVersion() {
        if (!this._httpVersion)
          return "HTTP/1.1";
        if (this._httpVersion === "http/1.1")
          return "HTTP/1.1";
        if (this._httpVersion === "h2")
          return "HTTP/2.0";
        return this._httpVersion;
      }
      _responseHeadersSize() {
        return __async(this, null, function* () {
          if (this._request.responseSize.responseHeadersSize)
            return this._request.responseSize.responseHeadersSize;
          let headersSize = 4;
          headersSize += 8;
          headersSize += 3;
          headersSize += this.statusText().length;
          const headers = yield this._bestEffortResponseHeaders();
          for (const header of headers)
            headersSize += header.name.length + header.value.length + 4;
          headersSize += 2;
          return headersSize;
        });
      }
      _bestEffortResponseHeaders() {
        return __async(this, null, function* () {
          return this._rawResponseHeadersPromise ? yield this._rawResponseHeadersPromise : this._headers;
        });
      }
      sizes() {
        return __async(this, null, function* () {
          yield this._finishedPromise;
          const requestHeadersSize = yield this._request.requestHeadersSize();
          const responseHeadersSize = yield this._responseHeadersSize();
          let {
            encodedBodySize
          } = this._request.responseSize;
          if (!encodedBodySize) {
            var _headers$find;
            const headers = yield this._bestEffortResponseHeaders();
            const contentLength = (_headers$find = headers.find((h) => h.name.toLowerCase() === "content-length")) === null || _headers$find === void 0 ? void 0 : _headers$find.value;
            encodedBodySize = contentLength ? +contentLength : 0;
          }
          return {
            requestBodySize: this._request.bodySize(),
            requestHeadersSize,
            responseBodySize: encodedBodySize,
            responseHeadersSize
          };
        });
      }
    };
    exports2.Response = Response;
    var WebSocket = class extends _instrumentation.SdkObject {
      constructor(parent, url) {
        super(parent, "ws");
        this._url = void 0;
        this._notified = false;
        this._url = url;
      }
      markAsNotified() {
        if (this._notified)
          return false;
        this._notified = true;
        return true;
      }
      url() {
        return this._url;
      }
      frameSent(opcode, data) {
        this.emit(WebSocket.Events.FrameSent, {
          opcode,
          data
        });
      }
      frameReceived(opcode, data) {
        this.emit(WebSocket.Events.FrameReceived, {
          opcode,
          data
        });
      }
      error(errorMessage) {
        this.emit(WebSocket.Events.SocketError, errorMessage);
      }
      closed() {
        this.emit(WebSocket.Events.Close);
      }
    };
    exports2.WebSocket = WebSocket;
    WebSocket.Events = {
      Close: "close",
      SocketError: "socketerror",
      FrameReceived: "framereceived",
      FrameSent: "framesent"
    };
    var STATUS_TEXTS = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "Switch Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    exports2.STATUS_TEXTS = STATUS_TEXTS;
    function singleHeader(name, value) {
      return [{
        name,
        value
      }];
    }
    function mergeHeaders(headers) {
      const lowerCaseToValue = /* @__PURE__ */ new Map();
      const lowerCaseToOriginalCase = /* @__PURE__ */ new Map();
      for (const h of headers) {
        if (!h)
          continue;
        for (const {
          name,
          value
        } of h) {
          const lower = name.toLowerCase();
          lowerCaseToOriginalCase.set(lower, name);
          lowerCaseToValue.set(lower, value);
        }
      }
      const result = [];
      for (const [lower, value] of lowerCaseToValue)
        result.push({
          name: lowerCaseToOriginalCase.get(lower),
          value
        });
      return result;
    }
  }
});

// node_modules/playwright-core/lib/generated/injectedScriptSource.js
var require_injectedScriptSource = __commonJS({
  "node_modules/playwright-core/lib/generated/injectedScriptSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = 'var pwExport;(()=>{"use strict";var e={204:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.checkComponentAttribute=function(e,t){for(const n of t.jsonPath)null!=e&&(e=e[n]);const n="string"!=typeof e||t.caseSensetive?e:e.toUpperCase(),r="string"!=typeof t.value||t.caseSensetive?t.value:t.value.toUpperCase();return"<truthy>"===t.op?!!n:"="===t.op?n===r:"string"==typeof n&&"string"==typeof r&&("*="===t.op?n.includes(r):"^="===t.op?n.startsWith(r):"$="===t.op?n.endsWith(r):"|="===t.op?n===r||n.startsWith(r+"-"):"~="===t.op&&n.split(" ").includes(r))},t.parseComponentSelector=function(e){let t=0,n=0===e.length;const r=()=>e[t]||"",o=()=>{const o=r();return++t,n=t>=e.length,o},i=o=>{if(n)throw new Error(`Unexpected end of selector while parsing selector \\`${e}\\``);throw new Error(`Error while parsing selector \\`${e}\\` - unexpected symbol "${r()}" at position ${t}`+(o?" during "+o:""))};function s(){for(;!n&&/\\s/.test(r());)o()}function c(){let e="";for(s();!n&&/[-$0-9A-Z_]/i.test(r());)e+=o();return e}function a(e){let t=o();for(t!==e&&i("parsing quoted string");!n&&r()!==e;)"\\\\"===r()&&o(),t+=o();return r()!==e&&i("parsing quoted string"),t+=o(),t}function l(){let e="";return s(),e="\'"===r()||\'"\'===r()?a(r()).slice(1,-1):c(),e||i("parsing property path"),e}function u(){o();const t=[];for(t.push(l()),s();"."===r();)o(),t.push(l()),s();if("]"===r())return o(),{jsonPath:t,op:"<truthy>",value:null,caseSensetive:!1};const c=function(){s();let e="";return n||(e+=o()),n||"="===e||(e+=o()),["=","*=","^=","$=","|=","~="].includes(e)||i("parsing operator"),e}();let u,h=!0;if(s(),"\'"===r()||\'"\'===r())u=a(r()).slice(1,-1),s(),"i"===r()||"I"===r()?(h=!1,o()):"s"!==r()&&"S"!==r()||(h=!0,o());else{for(u="";!n&&!/\\s/.test(r())&&"]"!==r();)u+=o();"true"===u?u=!0:"false"===u?u=!1:(u=+u,isNaN(u)&&i("parsing attribute value"))}if(s(),"]"!==r()&&i("parsing attribute value"),o(),"="!==c&&"string"!=typeof u)throw new Error(`Error while parsing selector \\`${e}\\` - cannot use ${c} in attribute with non-string matching value - ${u}`);return{jsonPath:t,op:c,value:u,caseSensetive:h}}const h={name:"",attributes:[]};for(h.name=c(),s();"["===r();)h.attributes.push(u()),s();if(n||i(void 0),!h.name&&!h.attributes.length)throw new Error(`Error while parsing selector \\`${e}\\` - selector cannot be empty`);return h}},317:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseCSS=function(e,t){let n;try{n=o.tokenize(e),n[n.length-1]instanceof o.EOFToken||n.push(new o.EOFToken)}catch(t){const n=t.message+` while parsing selector "${e}"`,r=(t.stack||"").indexOf(t.message);throw-1!==r&&(t.stack=t.stack.substring(0,r)+n+t.stack.substring(r+t.message.length)),t.message=n,t}const i=n.find((e=>e instanceof o.AtKeywordToken||e instanceof o.BadStringToken||e instanceof o.BadURLToken||e instanceof o.ColumnToken||e instanceof o.CDOToken||e instanceof o.CDCToken||e instanceof o.SemicolonToken||e instanceof o.OpenCurlyToken||e instanceof o.CloseCurlyToken||e instanceof o.URLToken||e instanceof o.PercentageToken));if(i)throw new r.InvalidSelectorError(`Unsupported token "${i.toSource()}" while parsing selector "${e}"`);let s=0;const c=new Set;function a(){return new r.InvalidSelectorError(`Unexpected token "${n[s].toSource()}" while parsing selector "${e}"`)}function l(){for(;n[s]instanceof o.WhitespaceToken;)s++}function u(e=s){return n[e]instanceof o.IdentToken}function h(e=s){return n[e]instanceof o.CommaToken}function p(e=s){return n[e]instanceof o.CloseParenToken}function f(e=s){return n[e]instanceof o.DelimToken&&"*"===n[e].value}function d(e=s){return n[e]instanceof o.EOFToken}function m(e=s){return n[e]instanceof o.DelimToken&&[">","+","~"].includes(n[e].value)}function g(e=s){return h(e)||p(e)||d(e)||m(e)||n[e]instanceof o.WhitespaceToken}function y(){const e=[w()];for(;l(),h();)s++,e.push(w());return e}function w(){return l(),function(e=s){return n[e]instanceof o.NumberToken}()||function(e=s){return n[e]instanceof o.StringToken}()?n[s++].value:function(){const e={simples:[]};for(l(),m()?e.simples.push({selector:{functions:[{name:"scope",args:[]}]},combinator:""}):e.simples.push({selector:v(),combinator:""});;){if(l(),m())e.simples[e.simples.length-1].combinator=n[s++].value,l();else if(g())break;e.simples.push({combinator:"",selector:v()})}return e}()}function v(){let e="";const r=[];for(;!g();)if(u()||f())e+=n[s++].toSource();else if(n[s]instanceof o.HashToken)e+=n[s++].toSource();else if(n[s]instanceof o.DelimToken&&"."===n[s].value){if(s++,!u())throw a();e+="."+n[s++].toSource()}else if(n[s]instanceof o.ColonToken)if(s++,u())if(t.has(n[s].value.toLowerCase())){const e=n[s++].value.toLowerCase();r.push({name:e,args:[]}),c.add(e)}else e+=":"+n[s++].toSource();else{if(!(n[s]instanceof o.FunctionToken))throw a();{const o=n[s++].value.toLowerCase();if(t.has(o)?(r.push({name:o,args:y()}),c.add(o)):e+=`:${o}(${E()})`,l(),!p())throw a();s++}}else{if(!(n[s]instanceof o.OpenSquareToken))throw a();for(e+="[",s++;!(n[s]instanceof o.CloseSquareToken||d());)e+=n[s++].toSource();if(!(n[s]instanceof o.CloseSquareToken))throw a();e+="]",s++}if(!e&&!r.length)throw a();return{css:e||void 0,functions:r}}function E(){let e="";for(;!p()&&!d();)e+=n[s++].toSource();return e}const b=y();if(!d())throw new r.InvalidSelectorError(`Error while parsing selector "${e}"`);if(b.some((e=>"object"!=typeof e||!("simples"in e))))throw new r.InvalidSelectorError(`Error while parsing selector "${e}"`);return{selector:b,names:Array.from(c)}},t.serializeSelector=function e(t){return t.map((t=>"string"==typeof t?`"${t}"`:"number"==typeof t?String(t):t.simples.map((({selector:t,combinator:n})=>{let r=t.css||"";return r+=t.functions.map((t=>`:${t.name}(${e(t.args)})`)).join(""),n&&(r+=" "+n),r})).join(" "))).join(", ")};var r=n(672),o=function(e,t){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var n=i(t);if(n&&n.has(e))return n.get(e);var r={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var c=o?Object.getOwnPropertyDescriptor(e,s):null;c&&(c.get||c.set)?Object.defineProperty(r,s,c):r[s]=e[s]}return r.default=e,n&&n.set(e,r),r}(n(503));function i(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,n=new WeakMap;return(i=function(e){return e?n:t})(e)}},503:(e,t)=>{var n,r;n=function(e){var t=function(e,t,n){return e>=t&&e<=n};function n(e){return t(e,48,57)}function r(e){return n(e)||t(e,65,70)||t(e,97,102)}function o(e){return function(e){return t(e,65,90)}(e)||function(e){return t(e,97,122)}(e)}function i(e){return o(e)||function(e){return e>=128}(e)||95==e}function s(e){return i(e)||n(e)||45==e}function c(e){return t(e,0,8)||11==e||t(e,14,31)||127==e}function a(e){return 10==e}function l(e){return a(e)||9==e||32==e}var u=function(e){this.message=e};function h(e){if(e<=65535)return String.fromCharCode(e);e-=Math.pow(2,16);var t=Math.floor(e/Math.pow(2,10))+55296,n=e%Math.pow(2,10)+56320;return String.fromCharCode(t)+String.fromCharCode(n)}function p(){throw"Abstract Base Class"}function f(){return this}function d(){return this}function m(){return this}function g(){return this}function y(){return this}function w(){return this}function v(){return this}function E(){return this}function b(){throw"Abstract Base Class"}function _(){return this.value="{",this.mirror="}",this}function S(){return this.value="}",this.mirror="{",this}function T(){return this.value="[",this.mirror="]",this}function x(){return this.value="]",this.mirror="[",this}function k(){return this.value="(",this.mirror=")",this}function N(){return this.value=")",this.mirror="(",this}function C(){return this}function A(){return this}function O(){return this}function M(){return this}function P(){return this}function R(){return this}function $(){return this}function I(e){return this.value=h(e),this}function j(){throw"Abstract Base Class"}function L(e){this.value=e}function D(e){this.value=e,this.mirror=")"}function q(e){this.value=e}function U(e){this.value=e,this.type="unrestricted"}function W(e){this.value=e}function G(e){this.value=e}function F(){this.value=null,this.type="integer",this.repr=""}function H(){this.value=null,this.repr=""}function B(){this.value=null,this.type="integer",this.repr="",this.unit=""}function z(e){for(var n="",r=(e=""+e).charCodeAt(0),o=0;o<e.length;o++){var i=e.charCodeAt(o);if(0==i)throw new u("Invalid character: the input contains U+0000.");t(i,1,31)||127==i||0==o&&t(i,48,57)||1==o&&t(i,48,57)&&45==r?n+="\\\\"+i.toString(16)+" ":i>=128||45==i||95==i||t(i,48,57)||t(i,65,90)||t(i,97,122)?n+=e[o]:n+="\\\\"+e[o]}return n}function V(e){e=""+e;for(var n="",r=0;r<e.length;r++){var o=e.charCodeAt(r);if(0==o)throw new u("Invalid character: the input contains U+0000.");t(o,1,31)||127==o?n+="\\\\"+o.toString(16)+" ":n+=34==o||92==o?"\\\\"+e[r]:e[r]}return n}(u.prototype=new Error).name="InvalidCharacterError",p.prototype.toJSON=function(){return{token:this.tokenType}},p.prototype.toString=function(){return this.tokenType},p.prototype.toSource=function(){return""+this},f.prototype=Object.create(p.prototype),f.prototype.tokenType="BADSTRING",d.prototype=Object.create(p.prototype),d.prototype.tokenType="BADURL",m.prototype=Object.create(p.prototype),m.prototype.tokenType="WHITESPACE",m.prototype.toString=function(){return"WS"},m.prototype.toSource=function(){return" "},g.prototype=Object.create(p.prototype),g.prototype.tokenType="CDO",g.prototype.toSource=function(){return"\\x3c!--"},y.prototype=Object.create(p.prototype),y.prototype.tokenType="CDC",y.prototype.toSource=function(){return"--\\x3e"},w.prototype=Object.create(p.prototype),w.prototype.tokenType=":",v.prototype=Object.create(p.prototype),v.prototype.tokenType=";",E.prototype=Object.create(p.prototype),E.prototype.tokenType=",",b.prototype=Object.create(p.prototype),_.prototype=Object.create(b.prototype),_.prototype.tokenType="{",S.prototype=Object.create(b.prototype),S.prototype.tokenType="}",T.prototype=Object.create(b.prototype),T.prototype.tokenType="[",x.prototype=Object.create(b.prototype),x.prototype.tokenType="]",k.prototype=Object.create(b.prototype),k.prototype.tokenType="(",N.prototype=Object.create(b.prototype),N.prototype.tokenType=")",C.prototype=Object.create(p.prototype),C.prototype.tokenType="~=",A.prototype=Object.create(p.prototype),A.prototype.tokenType="|=",O.prototype=Object.create(p.prototype),O.prototype.tokenType="^=",M.prototype=Object.create(p.prototype),M.prototype.tokenType="$=",P.prototype=Object.create(p.prototype),P.prototype.tokenType="*=",R.prototype=Object.create(p.prototype),R.prototype.tokenType="||",$.prototype=Object.create(p.prototype),$.prototype.tokenType="EOF",$.prototype.toSource=function(){return""},I.prototype=Object.create(p.prototype),I.prototype.tokenType="DELIM",I.prototype.toString=function(){return"DELIM("+this.value+")"},I.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},I.prototype.toSource=function(){return"\\\\"==this.value?"\\\\\\n":this.value},j.prototype=Object.create(p.prototype),j.prototype.ASCIIMatch=function(e){return this.value.toLowerCase()==e.toLowerCase()},j.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},L.prototype=Object.create(j.prototype),L.prototype.tokenType="IDENT",L.prototype.toString=function(){return"IDENT("+this.value+")"},L.prototype.toSource=function(){return z(this.value)},D.prototype=Object.create(j.prototype),D.prototype.tokenType="FUNCTION",D.prototype.toString=function(){return"FUNCTION("+this.value+")"},D.prototype.toSource=function(){return z(this.value)+"("},q.prototype=Object.create(j.prototype),q.prototype.tokenType="AT-KEYWORD",q.prototype.toString=function(){return"AT("+this.value+")"},q.prototype.toSource=function(){return"@"+z(this.value)},U.prototype=Object.create(j.prototype),U.prototype.tokenType="HASH",U.prototype.toString=function(){return"HASH("+this.value+")"},U.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e},U.prototype.toSource=function(){return"id"==this.type?"#"+z(this.value):"#"+function(e){for(var n="",r=((e=""+e).charCodeAt(0),0);r<e.length;r++){var o=e.charCodeAt(r);if(0==o)throw new u("Invalid character: the input contains U+0000.");o>=128||45==o||95==o||t(o,48,57)||t(o,65,90)||t(o,97,122)?n+=e[r]:n+="\\\\"+o.toString(16)+" "}return n}(this.value)},W.prototype=Object.create(j.prototype),W.prototype.tokenType="STRING",W.prototype.toString=function(){return\'"\'+V(this.value)+\'"\'},G.prototype=Object.create(j.prototype),G.prototype.tokenType="URL",G.prototype.toString=function(){return"URL("+this.value+")"},G.prototype.toSource=function(){return\'url("\'+V(this.value)+\'")\'},F.prototype=Object.create(p.prototype),F.prototype.tokenType="NUMBER",F.prototype.toString=function(){return"integer"==this.type?"INT("+this.value+")":"NUMBER("+this.value+")"},F.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e},F.prototype.toSource=function(){return this.repr},H.prototype=Object.create(p.prototype),H.prototype.tokenType="PERCENTAGE",H.prototype.toString=function(){return"PERCENTAGE("+this.value+")"},H.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.repr=this.repr,e},H.prototype.toSource=function(){return this.repr+"%"},B.prototype=Object.create(p.prototype),B.prototype.tokenType="DIMENSION",B.prototype.toString=function(){return"DIM("+this.value+","+this.unit+")"},B.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e.unit=this.unit,e},B.prototype.toSource=function(){var e=this.repr,n=z(this.unit);return"e"!=n[0].toLowerCase()||"-"!=n[1]&&!t(n.charCodeAt(1),48,57)||(n="\\\\65 "+n.slice(1,n.length)),e+n},e.tokenize=function(e){e=function(e){for(var n=[],r=0;r<e.length;r++){var o=e.charCodeAt(r);if(13==o&&10==e.charCodeAt(r+1)&&(o=10,r++),13!=o&&12!=o||(o=10),0==o&&(o=65533),t(o,55296,56319)&&t(e.charCodeAt(r+1),56320,57343)){var i=o-55296,s=e.charCodeAt(r+1)-56320;o=Math.pow(2,16)+i*Math.pow(2,10)+s,r++}n.push(o)}return n}(e);for(var o,u=-1,p=[],b=0,j=0,z=0,V={line:b,column:j},X=function(t){return t>=e.length?-1:e[t]},J=function(e){if(void 0===e&&(e=1),e>3)throw"Spec Error: no more than three codepoints of lookahead.";return X(u+e)},Q=function(e){return void 0===e&&(e=1),a(o=X(u+=e))?(b+=1,z=j,j=0):j+=e,!0},K=function(){return u-=1,a(o)?(b-=1,j=z):j-=1,V.line=b,V.column=j,!0},Y=function(e){return void 0===e&&(e=o),-1==e},Z=function(){return console.log("Parse error at index "+u+", processing codepoint 0x"+o.toString(16)+"."),!0},ee=function(){if(te(),Q(),l(o)){for(;l(J());)Q();return new m}if(34==o)return oe();if(35==o){if(s(J())||ce(J(1),J(2))){var e=new U;return le(J(1),J(2),J(3))&&(e.type="id"),e.value=pe(),e}return new I(o)}return 36==o?61==J()?(Q(),new M):new I(o):39==o?oe():40==o?new k:41==o?new N:42==o?61==J()?(Q(),new P):new I(o):43==o?he()?(K(),ne()):new I(o):44==o?new E:45==o?he()?(K(),ne()):45==J(1)&&62==J(2)?(Q(2),new y):ue()?(K(),re()):new I(o):46==o?he()?(K(),ne()):new I(o):58==o?new w:59==o?new v:60==o?33==J(1)&&45==J(2)&&45==J(3)?(Q(3),new g):new I(o):64==o?le(J(1),J(2),J(3))?new q(pe()):new I(o):91==o?new T:92==o?ae()?(K(),re()):(Z(),new I(o)):93==o?new x:94==o?61==J()?(Q(),new O):new I(o):123==o?new _:124==o?61==J()?(Q(),new A):124==J()?(Q(),new R):new I(o):125==o?new S:126==o?61==J()?(Q(),new C):new I(o):n(o)?(K(),ne()):i(o)?(K(),re()):Y()?new $:new I(o)},te=function(){for(;47==J(1)&&42==J(2);)for(Q(2);;){if(Q(),42==o&&47==J()){Q();break}if(Y())return void Z()}},ne=function(){var e,t=fe();return le(J(1),J(2),J(3))?((e=new B).value=t.value,e.repr=t.repr,e.type=t.type,e.unit=pe(),e):37==J()?(Q(),(e=new H).value=t.value,e.repr=t.repr,e):((e=new F).value=t.value,e.repr=t.repr,e.type=t.type,e)},re=function(){var e=pe();if("url"==e.toLowerCase()&&40==J()){for(Q();l(J(1))&&l(J(2));)Q();return 34==J()||39==J()?new D(e):!l(J())||34!=J(2)&&39!=J(2)?ie():new D(e)}return 40==J()?(Q(),new D(e)):new L(e)},oe=function(e){void 0===e&&(e=o);for(var t="";Q();){if(o==e||Y())return new W(t);if(a(o))return Z(),K(),new f;92==o?Y(J())||(a(J())?Q():t+=h(se())):t+=h(o)}},ie=function(){for(var e=new G("");l(J());)Q();if(Y(J()))return e;for(;Q();){if(41==o||Y())return e;if(l(o)){for(;l(J());)Q();return 41==J()||Y(J())?(Q(),e):(me(),new d)}if(34==o||39==o||40==o||c(o))return Z(),me(),new d;if(92==o){if(!ae())return Z(),me(),new d;e.value+=h(se())}else e.value+=h(o)}},se=function(){if(Q(),r(o)){for(var e=[o],t=0;t<5&&r(J());t++)Q(),e.push(o);l(J())&&Q();var n=parseInt(e.map((function(e){return String.fromCharCode(e)})).join(""),16);return n>1114111&&(n=65533),n}return Y()?65533:o},ce=function(e,t){return 92==e&&!a(t)},ae=function(){return ce(o,J())},le=function(e,t,n){return 45==e?i(t)||45==t||ce(t,n):!!i(e)||92==e&&ce(e,t)},ue=function(){return le(o,J(1),J(2))},he=function(){return e=o,t=J(1),r=J(2),43==e||45==e?!!n(t)||!(46!=t||!n(r)):46==e?!!n(t):!!n(e);var e,t,r},pe=function(){for(var e="";Q();)if(s(o))e+=h(o);else{if(!ae())return K(),e;e+=h(se())}},fe=function(){var e=[],t="integer";for(43!=J()&&45!=J()||(Q(),e+=h(o));n(J());)Q(),e+=h(o);if(46==J(1)&&n(J(2)))for(Q(),e+=h(o),Q(),e+=h(o),t="number";n(J());)Q(),e+=h(o);var r=J(1),i=J(2),s=J(3);if(69!=r&&101!=r||!n(i)){if((69==r||101==r)&&(43==i||45==i)&&n(s))for(Q(),e+=h(o),Q(),e+=h(o),Q(),e+=h(o),t="number";n(J());)Q(),e+=h(o)}else for(Q(),e+=h(o),Q(),e+=h(o),t="number";n(J());)Q(),e+=h(o);return{type:t,value:de(e),repr:e}},de=function(e){return+e},me=function(){for(;Q();){if(41==o||Y())return;ae()&&se()}},ge=0;!Y(J());)if(p.push(ee()),++ge>2*e.length)return"I\'m infinite-looping!";return p},e.IdentToken=L,e.FunctionToken=D,e.AtKeywordToken=q,e.HashToken=U,e.StringToken=W,e.BadStringToken=f,e.URLToken=G,e.BadURLToken=d,e.DelimToken=I,e.NumberToken=F,e.PercentageToken=H,e.DimensionToken=B,e.IncludeMatchToken=C,e.DashMatchToken=A,e.PrefixMatchToken=O,e.SuffixMatchToken=M,e.SubstringMatchToken=P,e.ColumnToken=R,e.WhitespaceToken=m,e.CDOToken=g,e.CDCToken=y,e.ColonToken=w,e.SemicolonToken=v,e.CommaToken=E,e.OpenParenToken=k,e.CloseParenToken=N,e.OpenSquareToken=T,e.CloseSquareToken=x,e.OpenCurlyToken=_,e.CloseCurlyToken=S,e.EOFToken=$,e.CSSParserToken=p,e.GroupingToken=b},void 0===(r=n.apply(t,[t]))||(e.exports=r)},672:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isInvalidSelectorError=function(e){return e instanceof n},t.InvalidSelectorError=void 0;class n extends Error{}t.InvalidSelectorError=n},461:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSelector=s,t.splitSelectorByFrame=function(e){const t=s(e),n=[];let o={parts:[]},i=0;for(let e=0;e<t.parts.length;++e){const s=t.parts[e];if("control"!==s.name||"enter-frame"!==s.body)t.capture===e&&(o.capture=e-i),o.parts.push(s);else{if(!o.parts.length)throw new r.InvalidSelectorError("Selector cannot start with entering frame, select the iframe first");n.push(o),o={parts:[]},i=e+1}}if(!o.parts.length)throw new r.InvalidSelectorError(`Selector cannot end with entering frame, while parsing selector ${e}`);if(n.push(o),"number"==typeof t.capture&&"number"!=typeof n[n.length-1].capture)throw new r.InvalidSelectorError("Can not capture the selector before diving into the frame. Only use * after the last frame has been selected");return n},t.stringifySelector=function(e){return"string"==typeof e?e:e.parts.map(((t,n)=>{const r="css"===t.name?"":t.name+"=";return`${n===e.capture?"*":""}${r}${t.source}`})).join(" >> ")},t.customCSSNames=void 0;var r=n(672),o=n(317);const i=new Set(["not","is","where","has","scope","light","visible","text","text-matches","text-is","has-text","above","below","right-of","left-of","near","nth-match"]);function s(e){const t=function(e){let t,n=0,o=0;const i={parts:[]},s=()=>{const t=e.substring(o,n).trim(),s=t.indexOf("=");let c,a;-1!==s&&t.substring(0,s).trim().match(/^[a-zA-Z_0-9-+:*]+$/)?(c=t.substring(0,s).trim(),a=t.substring(s+1)):t.length>1&&\'"\'===t[0]&&\'"\'===t[t.length-1]||t.length>1&&"\'"===t[0]&&"\'"===t[t.length-1]?(c="text",a=t):/^\\(*\\/\\//.test(t)||t.startsWith("..")?(c="xpath",a=t):(c="css",a=t);let l=!1;if("*"===c[0]&&(l=!0,c=c.substring(1)),i.parts.push({name:c,body:a}),l){if(void 0!==i.capture)throw new r.InvalidSelectorError("Only one of the selectors can capture using * modifier");i.capture=i.parts.length-1}};if(!e.includes(">>"))return n=e.length,s(),i;for(;n<e.length;){const r=e[n];"\\\\"===r&&n+1<e.length?n+=2:r===t?(t=void 0,n++):t||\'"\'!==r&&"\'"!==r&&"`"!==r?t||">"!==r||">"!==e[n+1]?n++:(s(),n+=2,o=n):(t=r,n++)}return s(),i}(e),n=t.parts.map((e=>"css"===e.name||"css:light"===e.name?("css:light"===e.name&&(e.body=":light("+e.body+")"),{name:"css",body:(0,o.parseCSS)(e.body,i).selector,source:e.body}):{...e,source:e.body}));return{capture:t.capture,parts:n}}t.customCSSNames=i},141:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Highlight=void 0,t.Highlight=class{constructor(e){this._outerGlassPaneElement=void 0,this._glassPaneShadow=void 0,this._innerGlassPaneElement=void 0,this._highlightElements=[],this._tooltipElement=void 0,this._actionPointElement=void 0,this._isUnderTest=void 0,this._isUnderTest=e,this._outerGlassPaneElement=document.createElement("x-pw-glass"),this._outerGlassPaneElement.style.position="fixed",this._outerGlassPaneElement.style.top="0",this._outerGlassPaneElement.style.right="0",this._outerGlassPaneElement.style.bottom="0",this._outerGlassPaneElement.style.left="0",this._outerGlassPaneElement.style.zIndex="2147483647",this._outerGlassPaneElement.style.pointerEvents="none",this._outerGlassPaneElement.style.display="flex",this._tooltipElement=document.createElement("x-pw-tooltip"),this._actionPointElement=document.createElement("x-pw-action-point"),this._actionPointElement.setAttribute("hidden","true"),this._innerGlassPaneElement=document.createElement("x-pw-glass-inner"),this._innerGlassPaneElement.style.flex="auto",this._innerGlassPaneElement.appendChild(this._tooltipElement),this._glassPaneShadow=this._outerGlassPaneElement.attachShadow({mode:this._isUnderTest?"open":"closed"}),this._glassPaneShadow.appendChild(this._innerGlassPaneElement),this._glassPaneShadow.appendChild(this._actionPointElement);const t=document.createElement("style");t.textContent="\\n        x-pw-tooltip {\\n          align-items: center;\\n          backdrop-filter: blur(5px);\\n          background-color: rgba(0, 0, 0, 0.7);\\n          border-radius: 2px;\\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\\n          color: rgb(204, 204, 204);\\n          display: none;\\n          font-family: \'Dank Mono\', \'Operator Mono\', Inconsolata, \'Fira Mono\',\\n                      \'SF Mono\', Monaco, \'Droid Sans Mono\', \'Source Code Pro\', monospace;\\n          font-size: 12.8px;\\n          font-weight: normal;\\n          left: 0;\\n          line-height: 1.5;\\n          max-width: 600px;\\n          padding: 3.2px 5.12px 3.2px;\\n          position: absolute;\\n          top: 0;\\n        }\\n        x-pw-action-point {\\n          position: absolute;\\n          width: 20px;\\n          height: 20px;\\n          background: red;\\n          border-radius: 10px;\\n          pointer-events: none;\\n          margin: -10px 0 0 -10px;\\n          z-index: 2;\\n        }\\n        *[hidden] {\\n          display: none !important;\\n        }\\n    ",this._glassPaneShadow.appendChild(t)}install(){document.documentElement.appendChild(this._outerGlassPaneElement)}uninstall(){this._outerGlassPaneElement.remove()}isInstalled(){return this._outerGlassPaneElement.parentElement===document.documentElement&&!this._outerGlassPaneElement.nextElementSibling}showActionPoint(e,t){this._actionPointElement.style.top=t+"px",this._actionPointElement.style.left=e+"px",this._actionPointElement.hidden=!1}hideActionPoint(){this._actionPointElement.hidden=!0}updateHighlight(e,t,n){this._tooltipElement.textContent=t,this._tooltipElement.style.top="0",this._tooltipElement.style.left="0",this._tooltipElement.style.display="flex";const r=e.map((e=>e.getBoundingClientRect())),o=this._tooltipElement.offsetWidth,i=this._tooltipElement.offsetHeight,s=this._innerGlassPaneElement.offsetWidth,c=this._innerGlassPaneElement.offsetHeight;if(r.length){const e=r[0];let t=e.left;t+o>s-5&&(t=s-o-5);let n=e.bottom+5;n+i>c-5&&(n=e.top>i+5?e.top-i-5:c-5-i),this._tooltipElement.style.top=n+"px",this._tooltipElement.style.left=t+"px"}else this._tooltipElement.style.display="none";const a=this._highlightElements;this._highlightElements=[];for(const e of r){const t=a.length?a.shift():this._createHighlightElement(),r=n?"#dc6f6f7f":"#6fa8dc7f";t.style.backgroundColor=this._highlightElements.length?"#f6b26b7f":r,t.style.left=e.x+"px",t.style.top=e.y+"px",t.style.width=e.width+"px",t.style.height=e.height+"px",t.style.display="block",this._highlightElements.push(t)}for(const e of a)e.style.display="none",this._highlightElements.push(e)}_createHighlightElement(){const e=document.createElement("x-pw-highlight");return e.style.position="absolute",e.style.top="0",e.style.left="0",e.style.width="0",e.style.height="0",e.style.boxSizing="border-box",this._glassPaneShadow.appendChild(e),e}}},836:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ReactEngine=void 0;var r=n(848),o=n(204);function i(e){if("function"==typeof e.type)return e.type.displayName||e.type.name||"Anonymous";if("string"==typeof e.type)return e.type;if(e._currentElement){const t=e._currentElement.type;if("string"==typeof t)return t;if("function"==typeof t)return t.displayName||t.name||"Anonymous"}return""}function s(e){if(e.child){const t=[];for(let n=e.child;n;n=n.sibling)t.push(n);return t}if(!e._currentElement)return[];const t=e=>{var t;const n=null===(t=e._currentElement)||void 0===t?void 0:t.type;return"function"==typeof n||"string"==typeof n};if(e._renderedComponent){const n=e._renderedComponent;return t(n)?[n]:[]}return e._renderedChildren?[...Object.values(e._renderedChildren)].filter(t):[]}function c(e){var t;const n=e.memoizedProps||(null===(t=e._currentElement)||void 0===t?void 0:t.props);if(!n||"string"==typeof n)return n;const r={...n};return delete r.children,r}function a(e){var t;const n={name:i(e),children:s(e).map(a),rootElements:[],props:c(e)},r=e.stateNode||e._hostNode||(null===(t=e._renderedComponent)||void 0===t?void 0:t._hostNode);if(r instanceof Element)n.rootElements.push(r);else for(const e of n.children)n.rootElements.push(...e.rootElements);return n}function l(e,t,n=[]){t(e)&&n.push(e);for(const r of e.children)l(r,t,n);return n}function u(e,t=[]){const n=document.createTreeWalker(e,NodeFilter.SHOW_ELEMENT);do{const e=n.currentNode;if(e.hasOwnProperty("_reactRootContainer")&&t.push(e._reactRootContainer._internalRoot.current),e instanceof Element&&e.hasAttribute("data-reactroot"))for(const n of Object.keys(e))(n.startsWith("__reactInternalInstance")||n.startsWith("__reactFiber"))&&t.push(e[n]);const r=e instanceof Element?e.shadowRoot:null;r&&u(r,t)}while(n.nextNode());return t}const h={queryAll(e,t){const{name:n,attributes:i}=(0,o.parseComponentSelector)(t),s=u(document).map((e=>a(e))).map((t=>l(t,(t=>{if(n&&t.name!==n)return!1;if(t.rootElements.some((t=>!(0,r.isInsideScope)(e,t))))return!1;for(const e of i)if(!(0,o.checkComponentAttribute)(t.props,e))return!1;return!0})))).flat(),c=new Set;for(const e of s)for(const t of e.rootElements)c.add(t);return[...c]}};t.ReactEngine=h},848:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createLaxTextMatcher=d,t.createStrictTextMatcher=m,t.createRegexTextMatcher=g,t.elementText=w,t.elementMatchesText=v,t.isInsideScope=function(e,t){for(;t;){if(e.contains(t))return!0;for(;t.parentElement;)t=t.parentElement;t=N(t)}return!1},t.parentElementOrShadowHost=N,t.isVisible=O,t.SelectorEvaluatorImpl=void 0;var r=n(461);t.SelectorEvaluatorImpl=class{constructor(e){this._engines=new Map,this._cacheQueryCSS=new Map,this._cacheMatches=new Map,this._cacheQuery=new Map,this._cacheMatchesSimple=new Map,this._cacheMatchesParents=new Map,this._cacheCallMatches=new Map,this._cacheCallQuery=new Map,this._cacheQuerySimple=new Map,this._cacheText=new Map,this._scoreMap=void 0,this._retainCacheCounter=0;for(const[t,n]of e)this._engines.set(t,n);this._engines.set("not",c),this._engines.set("is",o),this._engines.set("where",o),this._engines.set("has",i),this._engines.set("scope",s),this._engines.set("light",a),this._engines.set("visible",l),this._engines.set("text",u),this._engines.set("text-is",h),this._engines.set("text-matches",p),this._engines.set("has-text",f),this._engines.set("right-of",x("right-of",E)),this._engines.set("left-of",x("left-of",b)),this._engines.set("above",x("above",_)),this._engines.set("below",x("below",S)),this._engines.set("near",x("near",T)),this._engines.set("nth-match",k);const t=[...this._engines.keys()];t.sort();const n=[...r.customCSSNames];if(n.sort(),t.join("|")!==n.join("|"))throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${t.join("|")} vs ${n.join("|")}`)}begin(){++this._retainCacheCounter}end(){--this._retainCacheCounter,this._retainCacheCounter||(this._cacheQueryCSS.clear(),this._cacheMatches.clear(),this._cacheQuery.clear(),this._cacheMatchesSimple.clear(),this._cacheMatchesParents.clear(),this._cacheCallMatches.clear(),this._cacheCallQuery.clear(),this._cacheQuerySimple.clear(),this._cacheText.clear())}_cached(e,t,n,r){e.has(t)||e.set(t,[]);const o=e.get(t),i=o.find((e=>n.every(((t,n)=>e.rest[n]===t))));if(i)return i.result;const s=r();return o.push({rest:n,result:s}),s}_checkSelector(e){if("object"!=typeof e||!e||!(Array.isArray(e)||"simples"in e&&e.simples.length))throw new Error(`Malformed selector "${e}"`);return e}matches(e,t,n){const r=this._checkSelector(t);this.begin();try{return this._cached(this._cacheMatches,e,[r,n.scope,n.pierceShadow],(()=>Array.isArray(r)?this._matchesEngine(o,e,r,n):!!this._matchesSimple(e,r.simples[r.simples.length-1].selector,n)&&this._matchesParents(e,r,r.simples.length-2,n)))}finally{this.end()}}query(e,t){const n=this._checkSelector(t);this.begin();try{return this._cached(this._cacheQuery,n,[e.scope,e.pierceShadow],(()=>{if(Array.isArray(n))return this._queryEngine(o,e,n);const t=this._scoreMap;this._scoreMap=new Map;let r=this._querySimple(e,n.simples[n.simples.length-1].selector);return r=r.filter((t=>this._matchesParents(t,n,n.simples.length-2,e))),this._scoreMap.size&&r.sort(((e,t)=>{const n=this._scoreMap.get(e),r=this._scoreMap.get(t);return n===r?0:void 0===n?1:void 0===r?-1:n-r})),this._scoreMap=t,r}))}finally{this.end()}}_markScore(e,t){this._scoreMap&&this._scoreMap.set(e,t)}_matchesSimple(e,t,n){return this._cached(this._cacheMatchesSimple,e,[t,n.scope,n.pierceShadow],(()=>{if(!t.functions.some((e=>"scope"===e.name||"is"===e.name))&&e===n.scope)return!1;if(t.css&&!this._matchesCSS(e,t.css))return!1;for(const r of t.functions)if(!this._matchesEngine(this._getEngine(r.name),e,r.args,n))return!1;return!0}))}_querySimple(e,t){return t.functions.length?this._cached(this._cacheQuerySimple,t,[e.scope,e.pierceShadow],(()=>{let n=t.css;const r=t.functions;let o;"*"===n&&r.length&&(n=void 0);let i=-1;void 0!==n?(o=this._queryCSS(e,n),r.some((e=>"scope"===e.name))&&1===e.scope.nodeType&&o.unshift(e.scope)):(i=r.findIndex((e=>void 0!==this._getEngine(e.name).query)),-1===i&&(i=0),o=this._queryEngine(this._getEngine(r[i].name),e,r[i].args));for(let t=0;t<r.length;t++){if(t===i)continue;const n=this._getEngine(r[t].name);void 0!==n.matches&&(o=o.filter((o=>this._matchesEngine(n,o,r[t].args,e))))}for(let t=0;t<r.length;t++){if(t===i)continue;const n=this._getEngine(r[t].name);void 0===n.matches&&(o=o.filter((o=>this._matchesEngine(n,o,r[t].args,e))))}return o})):this._queryCSS(e,t.css||"*")}_matchesParents(e,t,n,r){return n<0||this._cached(this._cacheMatchesParents,e,[t,n,r.scope,r.pierceShadow],(()=>{const{selector:o,combinator:i}=t.simples[n];if(">"===i){const i=C(e,r);return!(!i||!this._matchesSimple(i,o,r))&&this._matchesParents(i,t,n-1,r)}if("+"===i){const i=A(e,r);return!(!i||!this._matchesSimple(i,o,r))&&this._matchesParents(i,t,n-1,r)}if(""===i){let i=C(e,r);for(;i;){if(this._matchesSimple(i,o,r)){if(this._matchesParents(i,t,n-1,r))return!0;if(""===t.simples[n-1].combinator)break}i=C(i,r)}return!1}if("~"===i){let i=A(e,r);for(;i;){if(this._matchesSimple(i,o,r)){if(this._matchesParents(i,t,n-1,r))return!0;if("~"===t.simples[n-1].combinator)break}i=A(i,r)}return!1}if(">="===i){let i=e;for(;i;){if(this._matchesSimple(i,o,r)){if(this._matchesParents(i,t,n-1,r))return!0;if(""===t.simples[n-1].combinator)break}i=C(i,r)}return!1}throw new Error(`Unsupported combinator "${i}"`)}))}_matchesEngine(e,t,n,r){if(e.matches)return this._callMatches(e,t,n,r);if(e.query)return this._callQuery(e,n,r).includes(t);throw new Error(\'Selector engine should implement "matches" or "query"\')}_queryEngine(e,t,n){if(e.query)return this._callQuery(e,n,t);if(e.matches)return this._queryCSS(t,"*").filter((r=>this._callMatches(e,r,n,t)));throw new Error(\'Selector engine should implement "matches" or "query"\')}_callMatches(e,t,n,r){return this._cached(this._cacheCallMatches,t,[e,r.scope,r.pierceShadow,...n],(()=>e.matches(t,n,r,this)))}_callQuery(e,t,n){return this._cached(this._cacheCallQuery,e,[n.scope,n.pierceShadow,...t],(()=>e.query(n,t,this)))}_matchesCSS(e,t){return e.matches(t)}_queryCSS(e,t){return this._cached(this._cacheQueryCSS,t,[e.scope,e.pierceShadow],(()=>{let n=[];return function r(o){if(n=n.concat([...o.querySelectorAll(t)]),e.pierceShadow){o.shadowRoot&&r(o.shadowRoot);for(const e of o.querySelectorAll("*"))e.shadowRoot&&r(e.shadowRoot)}}(e.scope),n}))}_getEngine(e){const t=this._engines.get(e);if(!t)throw new Error(`Unknown selector engine "${e}"`);return t}};const o={matches(e,t,n,r){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');return t.some((t=>r.matches(e,t,n)))},query(e,t,n){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');let r=[];for(const o of t)r=r.concat(n.query(e,o));return 1===t.length?r:function(e){const t=new Map,n=[],r=[];function o(e){let r=t.get(e);if(r)return r;const i=N(e);return i?o(i).children.push(e):n.push(e),r={children:[],taken:!1},t.set(e,r),r}return e.forEach((e=>o(e).taken=!0)),n.forEach((function e(n){const o=t.get(n);if(o.taken&&r.push(n),o.children.length>1){const e=new Set(o.children);o.children=[];let t=n.firstElementChild;for(;t&&o.children.length<e.size;)e.has(t)&&o.children.push(t),t=t.nextElementSibling;for(t=n.shadowRoot?n.shadowRoot.firstElementChild:null;t&&o.children.length<e.size;)e.has(t)&&o.children.push(t),t=t.nextElementSibling}o.children.forEach(e)})),r}(r)}},i={matches(e,t,n,r){if(0===t.length)throw new Error(\'"has" engine expects non-empty selector list\');return r.query({...n,scope:e},t).length>0}},s={matches(e,t,n,r){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');return 9===n.scope.nodeType?e===n.scope.documentElement:e===n.scope},query(e,t,n){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');if(9===e.scope.nodeType){const t=e.scope.documentElement;return t?[t]:[]}return 1===e.scope.nodeType?[e.scope]:[]}},c={matches(e,t,n,r){if(0===t.length)throw new Error(\'"not" engine expects non-empty selector list\');return!r.matches(e,t,n)}},a={query:(e,t,n)=>n.query({...e,pierceShadow:!1},t),matches:(e,t,n,r)=>r.matches(e,t,{...n,pierceShadow:!1})},l={matches(e,t,n,r){if(t.length)throw new Error(\'"visible" engine expects no arguments\');return O(e)}},u={matches(e,t,n,r){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text" engine expects a single string\');return"self"===v(r,e,d(t[0]))}},h={matches(e,t,n,r){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text-is" engine expects a single string\');return"none"!==v(r,e,m(t[0]))}},p={matches(e,t,n,r){if(0===t.length||"string"!=typeof t[0]||t.length>2||2===t.length&&"string"!=typeof t[1])throw new Error(\'"text-matches" engine expects a regexp body and optional regexp flags\');return"self"===v(r,e,g(t[0],2===t.length?t[1]:void 0))}},f={matches(e,t,n,r){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"has-text" engine expects a single string\');return!y(e)&&d(t[0])(w(r,e))}};function d(e){return e=e.trim().replace(/\\s+/g," ").toLowerCase(),t=>t.full.trim().replace(/\\s+/g," ").toLowerCase().includes(e)}function m(e){return e=e.trim().replace(/\\s+/g," "),t=>!e&&!t.immediate.length||t.immediate.some((t=>t.trim().replace(/\\s+/g," ")===e))}function g(e,t){const n=new RegExp(e,t);return e=>n.test(e.full)}function y(e){return"SCRIPT"===e.nodeName||"STYLE"===e.nodeName||document.head&&document.head.contains(e)}function w(e,t){let n=e._cacheText.get(t);if(void 0===n){if(n={full:"",immediate:[]},!y(t)){let r="";if(t instanceof HTMLInputElement&&("submit"===t.type||"button"===t.type))n={full:t.value,immediate:[t.value]};else{for(let o=t.firstChild;o;o=o.nextSibling)o.nodeType===Node.TEXT_NODE?(n.full+=o.nodeValue||"",r+=o.nodeValue||""):(r&&n.immediate.push(r),r="",o.nodeType===Node.ELEMENT_NODE&&(n.full+=w(e,o).full));r&&n.immediate.push(r),t.shadowRoot&&(n.full+=w(e,t.shadowRoot).full)}}e._cacheText.set(t,n)}return n}function v(e,t,n){if(y(t))return"none";if(!n(w(e,t)))return"none";for(let r=t.firstChild;r;r=r.nextSibling)if(r.nodeType===Node.ELEMENT_NODE&&n(w(e,r)))return"selfAndChildren";return t.shadowRoot&&n(w(e,t.shadowRoot))?"selfAndChildren":"self"}function E(e,t,n){const r=e.left-t.right;if(!(r<0||void 0!==n&&r>n))return r+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function b(e,t,n){const r=t.left-e.right;if(!(r<0||void 0!==n&&r>n))return r+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function _(e,t,n){const r=t.top-e.bottom;if(!(r<0||void 0!==n&&r>n))return r+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function S(e,t,n){const r=e.top-t.bottom;if(!(r<0||void 0!==n&&r>n))return r+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function T(e,t,n){const r=void 0===n?50:n;let o=0;return e.left-t.right>=0&&(o+=e.left-t.right),t.left-e.right>=0&&(o+=t.left-e.right),t.top-e.bottom>=0&&(o+=t.top-e.bottom),e.top-t.bottom>=0&&(o+=e.top-t.bottom),o>r?void 0:o}function x(e,t){return{matches(n,r,o,i){const s=r.length&&"number"==typeof r[r.length-1]?r[r.length-1]:void 0,c=void 0===s?r:r.slice(0,r.length-1);if(r.length<1+(void 0===s?0:1))throw new Error(`"${e}" engine expects a selector list and optional maximum distance in pixels`);const a=n.getBoundingClientRect();let l;for(const e of i.query(o,c)){if(e===n)continue;const r=t(a,e.getBoundingClientRect(),s);void 0!==r&&(void 0===l||r<l)&&(l=r)}return void 0!==l&&(i._markScore(n,l),!0)}}}const k={query(e,t,n){let r=t[t.length-1];if(t.length<2)throw new Error(\'"nth-match" engine expects non-empty selector list and an index argument\');if("number"!=typeof r||r<1)throw new Error(\'"nth-match" engine expects a one-based index as the last argument\');const i=o.query(e,t.slice(0,t.length-1),n);return r--,r<i.length?[i[r]]:[]}};function N(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:void 0}function C(e,t){if(e!==t.scope)return t.pierceShadow?N(e):e.parentElement||void 0}function A(e,t){if(e!==t.scope)return e.previousElementSibling||void 0}function O(e){if(!e.ownerDocument||!e.ownerDocument.defaultView)return!0;const t=e.ownerDocument.defaultView.getComputedStyle(e);if(!t||"hidden"===t.visibility)return!1;if("contents"===t.display){for(let t=e.firstChild;t;t=t.nextSibling){if(1===t.nodeType&&O(t))return!0;if(3===t.nodeType&&M(t))return!0}return!1}const n=e.getBoundingClientRect();return n.width>0&&n.height>0}function M(e){const t=document.createRange();t.selectNode(e);const n=t.getBoundingClientRect();return n.width>0&&n.height>0}},854:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.querySelector=function(e,t,n){try{const r=e.parseSelector(t);return{selector:t,elements:e.querySelectorAll(r,n)}}catch(e){return{selector:t,elements:[]}}},t.generateSelector=function(e,t){e._evaluator.begin();try{const n=function(e,t){if(t.ownerDocument.documentElement===t)return[{engine:"css",selector:"html",score:1}];const n=(l,h)=>{const m=h?o:i;let g=m.get(l);return void 0===g&&(g=((o,i)=>{const l=o===t;let h=i?function(e,t,n){if("SELECT"===t.nodeName)return[];const o=(0,r.elementText)(e._evaluator,t).full.trim().replace(/\\s+/g," ").substring(0,80);if(!o)return[];const i=[];let s=o;if((o.includes(\'"\')||o.includes(">>")||"/"===o[0])&&(s=`/.*${function(e){return e.replace(/[.*+?^>${}()|[\\]\\\\]/g,"\\\\$&")}(o)}.*/`),i.push({engine:"text",selector:s,score:10}),n&&s===o){let e=t.nodeName.toLowerCase();t.hasAttribute("role")&&(e+=`[role=${u(t.getAttribute("role"))}]`),i.push({engine:"css",selector:`${e}:has-text("${o}")`,score:30})}return i}(e,o,o===t).map((e=>[e])):[];o!==t&&(h=s(h));const m=function(e,t){const n=[];for(const e of["data-testid","data-test-id","data-test"])t.hasAttribute(e)&&n.push({engine:"css",selector:`[${e}=${u(t.getAttribute(e))}]`,score:1});if("INPUT"===t.nodeName){const e=t;e.placeholder&&n.push({engine:"css",selector:`[placeholder=${u(e.placeholder)}]`,score:10})}t.hasAttribute("aria-label")&&n.push({engine:"css",selector:`[aria-label=${u(t.getAttribute("aria-label"))}]`,score:10}),t.getAttribute("alt")&&["APPLET","AREA","IMG","INPUT"].includes(t.nodeName)&&n.push({engine:"css",selector:`${d(t.nodeName.toLowerCase())}[alt=${u(t.getAttribute("alt"))}]`,score:10}),t.hasAttribute("role")&&n.push({engine:"css",selector:`${d(t.nodeName.toLowerCase())}[role=${u(t.getAttribute("role"))}]`,score:50}),t.getAttribute("name")&&["BUTTON","FORM","FIELDSET","IFRAME","INPUT","KEYGEN","OBJECT","OUTPUT","SELECT","TEXTAREA","MAP","META","PARAM"].includes(t.nodeName)&&n.push({engine:"css",selector:`${d(t.nodeName.toLowerCase())}[name=${u(t.getAttribute("name"))}]`,score:50}),["INPUT","TEXTAREA"].includes(t.nodeName)&&"hidden"!==t.getAttribute("type")&&t.getAttribute("type")&&n.push({engine:"css",selector:`${d(t.nodeName.toLowerCase())}[type=${u(t.getAttribute("type"))}]`,score:50}),["INPUT","TEXTAREA","SELECT"].includes(t.nodeName)&&n.push({engine:"css",selector:d(t.nodeName.toLowerCase()),score:50});const r=t.getAttribute("id");return r&&!function(e){let t,n=0;for(let r=0;r<e.length;++r){const o=e[r];let i;"-"!==o&&"_"!==o&&(i=o>="a"&&o<="z"?"lower":o>="A"&&o<="Z"?"upper":o>="0"&&o<="9"?"digit":"other","lower"!==i||"upper"!==t?(t&&t!==i&&++n,t=i):t=i)}return n>=e.length/4}(r)&&n.push({engine:"css",selector:a(r),score:100}),n.push({engine:"css",selector:d(t.nodeName.toLowerCase()),score:200}),n}(0,o).map((e=>[e]));let g=f(e,t.ownerDocument,o,[...h,...m],l);h=s(h);const y=t=>{const r=i&&!t.length,s=[...t,...m].filter((e=>!g||p(e)<p(g)));let a=s[0];if(a)for(let t=c(o);t;t=c(t)){const i=n(t,r);if(!i)continue;if(g&&p([...i,...a])>=p(g))continue;if(a=f(e,t,o,s,l),!a)return;const c=[...i,...a];(!g||p(c)<p(g))&&(g=c)}};return y(h),o===t&&h.length&&y([]),g})(l,h),m.set(l,g)),g};return n(t,!0)}(e,t=t.closest("button,select,input,[role=button],[role=checkbox],[role=radio]")||t),m=h(n||[l(e,t)]),g=e.parseSelector(m);return{selector:m,elements:e.querySelectorAll(g,t.ownerDocument)}}finally{o.clear(),i.clear(),e._evaluator.end()}};var r=n(848);const o=new Map,i=new Map;function s(e){return e.filter((e=>"/"!==e[0].selector[0]))}function c(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:null}function a(e){return/^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(e)?"#"+e:`[id="${d(e)}"]`}function l(e,t){const n=1e7,r=t.ownerDocument,o=[];function i(n){const r=o.slice();n&&r.unshift(n);const i=r.join(" "),s=e.parseSelector(i);return e.querySelector(s,t.ownerDocument,!1)===t?i:void 0}for(let e=t;e&&e!==r;e=c(e)){const t=e.nodeName.toLowerCase();let r="";if(e.id){const t=a(e.id),o=i(t);if(o)return{engine:"css",selector:o,score:n};r=t}const s=e.parentNode,c=[...e.classList];for(let e=0;e<c.length;++e){const t="."+c.slice(0,e+1).join("."),o=i(t);if(o)return{engine:"css",selector:o,score:n};!r&&s&&1===s.querySelectorAll(t).length&&(r=t)}if(s){const o=[...s.children],c=0===o.filter((e=>e.nodeName.toLowerCase()===t)).indexOf(e)?d(t):`${d(t)}:nth-child(${1+o.indexOf(e)})`,a=i(c);if(a)return{engine:"css",selector:a,score:n};r||(r=c)}else r||(r=t);o.unshift(r)}return{engine:"css",selector:i(),score:n}}function u(e){return`"${d(e)}"`}function h(e){const t=[];let n="";for(const{engine:r,selector:o}of e)t.length&&("css"!==n||"css"!==r||o.startsWith(":nth-match("))&&t.push(">>"),n=r,"css"===r?t.push(o):t.push(`${r}=${o}`);return t.join(" ")}function p(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n].score*(e.length-n);return t}function f(e,t,n,r,o){const i=r.map((e=>({tokens:e,score:p(e)})));i.sort(((e,t)=>e.score-t.score));let s=null;for(const{tokens:r}of i){const i=e.parseSelector(h(r)),c=e.querySelectorAll(i,t),a=c.indexOf(n);if(0===a)return r;if(!o||s||-1===a||c.length>5)continue;const l=r.map((e=>"text"!==e.engine?e:e.selector.startsWith("/")&&e.selector.endsWith("/")?{engine:"css",selector:`:text-matches("${e.selector.substring(1,e.selector.length-1)}")`,score:e.score}:{engine:"css",selector:`:text("${e.selector}")`,score:e.score}));s=[{engine:"css",selector:`:nth-match(${h(l)}, ${a+1})`,score:p(l)+1e3}]}return s}function d(e){let t="";for(let n=0;n<e.length;n++)t+=m(e,n);return t}function m(e,t){const n=e.charCodeAt(t);return 0===n?"\uFFFD":n>=1&&n<=31||n>=48&&n<=57&&(0===t||1===t&&45===e.charCodeAt(0))?"\\\\"+n.toString(16)+" ":0===t&&45===n&&1===e.length?"\\\\"+e.charAt(t):n>=128||45===n||95===n||n>=48&&n<=57||n>=65&&n<=90||n>=97&&n<=122?e.charAt(t):"\\\\"+e.charAt(t)}},12:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.VueEngine=void 0;var r=n(848),o=n(204);function i(e,t){const n=e.replace(/^[a-zA-Z]:/,"").replace(/\\\\/g,"/");let r=n.substring(n.lastIndexOf("/")+1);return t&&r.endsWith(t)&&(r=r.substring(0,r.length-t.length)),r}function s(e,t){return t?t.toUpperCase():""}const c=/(?:^|[-_/])(\\w)/g,a=e=>e&&e.replace(c,s);function l(e,t,n=[]){t(e)&&n.push(e);for(const r of e.children)l(r,t,n);return n}function u(e,t=[]){const n=document.createTreeWalker(e,NodeFilter.SHOW_ELEMENT),r=new Set;do{const e=n.currentNode;e.__vue__&&r.add(e.__vue__.$root),e.__vue_app__&&e._vnode&&e._vnode.component&&t.push({root:e._vnode.component,version:3});const o=e instanceof Element?e.shadowRoot:null;o&&u(o,t)}while(n.nextNode());for(const e of r)t.push({version:2,root:e});return t}const h={queryAll(e,t){const{name:n,attributes:s}=(0,o.parseComponentSelector)(t),c=u(document).map((e=>3===e.version?function(e){function t(e,t){return e.type.__playwright_guessedName=t,t}function n(e){const n=function(e){const t=e.name||e._componentTag||e.__playwright_guessedName;if(t)return t;const n=e.__file;return n?a(i(n,".vue")):void 0}(e.type||{});if(n)return n;if(e.root===e)return"Root";for(const n in null===(r=e.parent)||void 0===r||null===(o=r.type)||void 0===o?void 0:o.components){var r,o,s;if((null===(s=e.parent)||void 0===s?void 0:s.type.components[n])===e.type)return t(e,n)}for(const n in null===(c=e.appContext)||void 0===c?void 0:c.components){var c;if(e.appContext.components[n]===e.type)return t(e,n)}return"Anonymous Component"}function r(e){const t=[];return e.component&&t.push(e.component),e.suspense&&t.push(...r(e.suspense.activeBranch)),Array.isArray(e.children)&&e.children.forEach((e=>{e.component?t.push(e.component):t.push(...r(e))})),t.filter((e=>{var t;return!(function(e){return e._isBeingDestroyed||e.isUnmounted}(e)||null!==(t=e.type.devtools)&&void 0!==t&&t.hide)}))}function o(e){return function(e){return"Symbol(Fragment)"===e.subTree.type.toString()}(e)?function(e){if(!e.children)return[];const t=[];for(let n=0,r=e.children.length;n<r;n++){const r=e.children[n];r.component?t.push(...o(r.component)):r.el&&t.push(r.el)}return t}(e.subTree):[e.subTree.el]}return function e(t){return{name:n(t),children:r(t.subTree).map(e),rootElements:o(t),props:t.props}}(e)}(e.root):function(e){function t(e){return function(e){const t=e.displayName||e.name||e._componentTag;if(t)return t;const n=e.__file;return n?a(i(n,".vue")):void 0}(e.$options||e.fnOptions||{})||(e.$root===e?"Root":"Anonymous Component")}function n(e){return e.$children?e.$children:Array.isArray(e.subTree.children)?e.subTree.children.filter((e=>!!e.component)).map((e=>e.component)):[]}return function e(r){return{name:t(r),children:n(r).map(e),rootElements:[r.$el],props:r._props}}(e)}(e.root))).map((t=>l(t,(t=>{if(n&&t.name!==n)return!1;if(t.rootElements.some((t=>!(0,r.isInsideScope)(e,t))))return!1;for(const e of s)if(!(0,o.checkComponentAttribute)(t.props,e))return!1;return!0})))).flat(),h=new Set;for(const e of c)for(const t of e.rootElements)h.add(t);return[...h]}};t.VueEngine=h},530:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.XPathEngine=void 0;const n={queryAll(e,t){t.startsWith("/")&&(t="."+t);const n=[],r=e instanceof Document?e:e.ownerDocument;if(!r)return n;const o=r.evaluate(t,e,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE);for(let e=o.iterateNext();e;e=o.iterateNext())e.nodeType===Node.ELEMENT_NODE&&n.push(e);return n}};t.XPathEngine=n}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var i=t[r]={exports:{}};return e[r](i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}();var r={};(()=>{var e=r;e.default=void 0;var t=n(530),o=n(836),i=n(12),s=n(461),c=n(848),a=n(854),l=n(141);const u=new Set(["AREA","BASE","BR","COL","COMMAND","EMBED","HR","IMG","INPUT","KEYGEN","LINK","MENUITEM","META","PARAM","SOURCE","TRACK","WBR"]),h=new Set(["checked","selected","disabled","readonly","multiple"]);function p(e){return e.replace(/\\n/g,"\u21B5").replace(/\\t/g,"\u21C6")}const f=new Map([["auxclick","mouse"],["click","mouse"],["dblclick","mouse"],["mousedown","mouse"],["mouseeenter","mouse"],["mouseleave","mouse"],["mousemove","mouse"],["mouseout","mouse"],["mouseover","mouse"],["mouseup","mouse"],["mouseleave","mouse"],["mousewheel","mouse"],["keydown","keyboard"],["keyup","keyboard"],["keypress","keyboard"],["textInput","keyboard"],["touchstart","touch"],["touchmove","touch"],["touchend","touch"],["touchcancel","touch"],["pointerover","pointer"],["pointerout","pointer"],["pointerenter","pointer"],["pointerleave","pointer"],["pointerdown","pointer"],["pointerup","pointer"],["pointermove","pointer"],["pointercancel","pointer"],["gotpointercapture","pointer"],["lostpointercapture","pointer"],["focus","focus"],["blur","focus"],["drag","drag"],["dragstart","drag"],["dragend","drag"],["dragover","drag"],["dragenter","drag"],["dragleave","drag"],["dragexit","drag"],["drop","drag"]]),d=new Set(["mousemove"]),m=new Set(["pointerdown","pointerup","touchstart","touchend","touchcancel"]),g=new Set(["mousedown","mouseup","pointerdown","pointerup","click","auxclick","dblclick","contextmenu"]),y=new Set([...d,...m,...g]);function w(e){if(!e.includes("\\\\"))return e;const t=[];let n=0;for(;n<e.length;)"\\\\"===e[n]&&n+1<e.length&&n++,t.push(e[n++]);return t.join("")}class v{constructor(e){this._string=void 0,this._substring=void 0,this._regex=void 0,this._normalizeWhiteSpace=void 0,this._normalizeWhiteSpace=e.normalizeWhiteSpace,this._string=e.matchSubstring?void 0:this.normalizeWhiteSpace(e.string),this._substring=e.matchSubstring?this.normalizeWhiteSpace(e.string):void 0,this._regex=e.regexSource?new RegExp(e.regexSource,e.regexFlags):void 0}matches(e){return this._normalizeWhiteSpace&&!this._regex&&(e=this.normalizeWhiteSpace(e)),void 0!==this._string?e===this._string:void 0!==this._substring?e.includes(this._substring):!!this._regex&&!!this._regex.test(e)}normalizeWhiteSpace(e){return e&&this._normalizeWhiteSpace?e.trim().replace(/\\u200b/g,"").replace(/\\s+/g," "):e}}function E(e,t){if(e===t)return!0;if(e&&t&&"object"==typeof e&&"object"==typeof t){if(e.constructor!==t.constructor)return!1;if(Array.isArray(e)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!E(e[n],t[n]))return!1;return!0}if(e instanceof RegExp)return e.source===t.source&&e.flags===t.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===t.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===t.toString();const n=Object.keys(e);if(n.length!==Object.keys(t).length)return!1;for(let e=0;e<n.length;++e)if(!t.hasOwnProperty(n[e]))return!1;for(const r of n)if(!E(e[r],t[r]))return!1;return!0}return"number"==typeof e&&"number"==typeof t&&isNaN(e)&&isNaN(t)}function b(e){return!!e&&(!("FIELDSET"!==e.tagName||!e.hasAttribute("disabled"))||b(e.parentElement))}function _(e){if(!e)return!1;const t=(e.getAttribute("aria-disabled")||"").toLowerCase();return"true"===t||"false"!==t&&_((0,c.parentElementOrShadowHost)(e))}var S=class{constructor(e,n,r){this._engines=void 0,this._evaluator=void 0,this._stableRafCount=void 0,this._browserName=void 0,this.onGlobalListenersRemoved=new Set,this._hitTargetInterceptor=void 0,this._highlight=void 0,this._evaluator=new c.SelectorEvaluatorImpl(new Map),this._engines=new Map,this._engines.set("xpath",t.XPathEngine),this._engines.set("xpath:light",t.XPathEngine),this._engines.set("_react",o.ReactEngine),this._engines.set("_vue",i.VueEngine),this._engines.set("text",this._createTextEngine(!0)),this._engines.set("text:light",this._createTextEngine(!1)),this._engines.set("id",this._createAttributeEngine("id",!0)),this._engines.set("id:light",this._createAttributeEngine("id",!1)),this._engines.set("data-testid",this._createAttributeEngine("data-testid",!0)),this._engines.set("data-testid:light",this._createAttributeEngine("data-testid",!1)),this._engines.set("data-test-id",this._createAttributeEngine("data-test-id",!0)),this._engines.set("data-test-id:light",this._createAttributeEngine("data-test-id",!1)),this._engines.set("data-test",this._createAttributeEngine("data-test",!0)),this._engines.set("data-test:light",this._createAttributeEngine("data-test",!1)),this._engines.set("css",this._createCSSEngine()),this._engines.set("nth",{queryAll:()=>[]}),this._engines.set("visible",{queryAll:()=>[]}),this._engines.set("control",this._createControlEngine());for(const{name:e,engine:t}of r)this._engines.set(e,t);this._stableRafCount=e,this._browserName=n,this._setupGlobalListenersRemovalDetection(),this._setupHitTargetInterceptors()}eval(e){return n.g.eval(e)}parseSelector(e){const t=(0,s.parseSelector)(e);for(const n of t.parts)if(!this._engines.has(n.name))throw this.createStacklessError(`Unknown engine "${n.name}" while parsing selector ${e}`);return t}querySelector(e,t,n){if(!t.querySelector)throw this.createStacklessError("Node is not queryable.");this._evaluator.begin();try{var r,o;const i=this._querySelectorRecursively([{element:t,capture:void 0}],e,0,new Map);if(n&&i.length>1)throw this.strictModeViolationError(e,i.map((e=>e.element)));return(null===(r=i[0])||void 0===r?void 0:r.capture)||(null===(o=i[0])||void 0===o?void 0:o.element)}finally{this._evaluator.end()}}_querySelectorRecursively(e,t,n,r){if(n===t.parts.length)return e;const o=t.parts[n];if("nth"===o.name){let i=[];if("0"===o.body)i=e.slice(0,1);else if("-1"===o.body)e.length&&(i=e.slice(e.length-1));else{if("number"==typeof t.capture)throw this.createStacklessError("Can\'t query n-th element in a request with the capture.");const n=+o.body,r=new Set;for(const t of e)r.add(t.element),n+1===r.size&&(i=[t])}return this._querySelectorRecursively(i,t,n+1,r)}if("visible"===o.name){const i=Boolean(o.body),s=e.filter((e=>i===(0,c.isVisible)(e.element)));return this._querySelectorRecursively(s,t,n+1,r)}const i=[];for(const o of e){const e=n-1===t.capture?o.element:o.capture;let s=r.get(o.element);s||(s=[],r.set(o.element,s));let c=s[n];c||(c=this._queryEngineAll(t.parts[n],o.element),s[n]=c);for(const t of c){if(!("nodeName"in t))throw this.createStacklessError(`Expected a Node but got ${Object.prototype.toString.call(t)}`);i.push({element:t,capture:e})}}return this._querySelectorRecursively(i,t,n+1,r)}querySelectorAll(e,t){if(!t.querySelectorAll)throw this.createStacklessError("Node is not queryable.");this._evaluator.begin();try{const n=this._querySelectorRecursively([{element:t,capture:void 0}],e,0,new Map),r=new Set;for(const e of n)r.add(e.capture||e.element);return[...r]}finally{this._evaluator.end()}}_queryEngineAll(e,t){return this._engines.get(e.name).queryAll(t,e.body)}_createAttributeEngine(e,t){return{queryAll:(n,r)=>this._evaluator.query({scope:n,pierceShadow:t},(t=>[{simples:[{selector:{css:`[${e}=${JSON.stringify(t)}]`,functions:[]},combinator:""}]}])(r))}}_createCSSEngine(){const e=this._evaluator;return{queryAll:(t,n)=>e.query({scope:t,pierceShadow:!0},n)}}_createTextEngine(e){const t=(t,n)=>{const{matcher:r,kind:o}=function(e){if("/"===e[0]&&e.lastIndexOf("/")>0){const t=e.lastIndexOf("/");return{matcher:(0,c.createRegexTextMatcher)(e.substring(1,t),e.substring(t+1)),kind:"regex"}}let t=!1;return e.length>1&&\'"\'===e[0]&&\'"\'===e[e.length-1]&&(e=w(e.substring(1,e.length-1)),t=!0),e.length>1&&"\'"===e[0]&&"\'"===e[e.length-1]&&(e=w(e.substring(1,e.length-1)),t=!0),{matcher:t?(0,c.createStrictTextMatcher)(e):(0,c.createLaxTextMatcher)(e),kind:t?"strict":"lax"}}(n),i=[];let s=null;const a=e=>{if("lax"===o&&s&&s.contains(e))return!1;const t=(0,c.elementMatchesText)(this._evaluator,e,r);"none"===t&&(s=e),("self"===t||"selfAndChildren"===t&&"strict"===o)&&i.push(e)};t.nodeType===Node.ELEMENT_NODE&&a(t);const l=this._evaluator._queryCSS({scope:t,pierceShadow:e},"*");for(const e of l)a(e);return i};return{queryAll:(e,n)=>t(e,n)}}_createControlEngine(){return{queryAll(e,t){if("enter-frame"===t)return[];if("return-empty"===t)return[];throw new Error(`Internal error, unknown control selector ${t}`)}}}extend(e,t){return new(n.g.eval(`\\n    (() => {\\n      ${e}\\n      return pwExport;\\n    })()`))(this,t)}isVisible(e){return(0,c.isVisible)(e)}pollRaf(e){return this.poll(e,(e=>requestAnimationFrame(e)))}pollInterval(e,t){return this.poll(t,(t=>setTimeout(t,e)))}pollLogScale(e){const t=[100,250,500];let n=0;return this.poll(e,(e=>setTimeout(e,t[n++]||1e3)))}poll(e,t){return this._runAbortableTask((n=>{let r,o;const i=new Promise(((e,t)=>{r=e,o=t})),s=()=>{if(!n.aborted)try{const o=e(n);o!==n.continuePolling?r(o):t(s)}catch(e){n.log("  "+e.message),o(e)}};return s(),i}))}_runAbortableTask(e){let t,n=[],r=!1;const o=()=>{t&&(t(n),n=[],t=void 0)};let i,s="";const c={injectedScript:this,aborted:!1,continuePolling:Symbol("continuePolling"),log:e=>{s=e,n.push({message:e}),o()},logRepeating:e=>{e!==s&&c.log(e)},setIntermediateResult:e=>{i!==e&&(i=e,n.push({intermediateResult:e}),o())}};return{takeNextLogs:()=>new Promise((e=>{t=e,(n.length||r)&&o()})),run:()=>{const t=e(c);return t.finally((()=>{r=!0,o()})),t},cancel:()=>{c.aborted=!0},takeLastLogs:()=>n}}getElementBorderWidth(e){if(e.nodeType!==Node.ELEMENT_NODE||!e.ownerDocument||!e.ownerDocument.defaultView)return{left:0,top:0};const t=e.ownerDocument.defaultView.getComputedStyle(e);return{left:parseInt(t.borderLeftWidth||"",10),top:parseInt(t.borderTopWidth||"",10)}}retarget(e,t){let n=e.nodeType===Node.ELEMENT_NODE?e:e.parentElement;return n?(n.matches("input, textarea, select")||(n=n.closest("button, [role=button], [role=checkbox], [role=radio]")||n),"follow-label"===t&&(n.matches("input, textarea, button, select, [role=button], [role=checkbox], [role=radio]")||n.isContentEditable||(n=n.closest("label")||n),"LABEL"===n.nodeName&&(n=n.control||n)),n):null}waitForElementStatesAndPerformAction(e,t,n,r){let o,i=0,s=0,c=0;return this.pollRaf((a=>{if(n)return a.log("    forcing action"),r(e,a);for(const n of t){if("stable"!==n){const t=this.elementState(e,n);if("boolean"!=typeof t)return t;if(!t)return a.logRepeating(`    element is not ${n} - waiting...`),a.continuePolling;continue}const t=this.retarget(e,"no-follow-label");if(!t)return"error:notconnected";if(1==++i)return a.continuePolling;const r=performance.now();if(this._stableRafCount>1&&r-c<15)return a.continuePolling;c=r;const l=t.getBoundingClientRect(),u={x:l.top,y:l.left,width:l.width,height:l.height};o&&u.x===o.x&&u.y===o.y&&u.width===o.width&&u.height===o.height?++s:s=0;const h=s>=this._stableRafCount,p=h||!o;if(o=u,p||a.logRepeating("    element is not stable - waiting..."),!h)return a.continuePolling}return r(e,a)}))}elementState(e,t){const n=this.retarget(e,["stable","visible","hidden"].includes(t)?"no-follow-label":"follow-label");if(!n||!n.isConnected)return"hidden"===t||"error:notconnected";if("visible"===t)return this.isVisible(n);if("hidden"===t)return!this.isVisible(n);const r=function(e){const t=["BUTTON","INPUT","SELECT","TEXTAREA"].includes(e.nodeName);return!(!t||!e.hasAttribute("disabled"))||!(!t||!b(e))||!!_(e)}(n);if("disabled"===t)return r;if("enabled"===t)return!r;const o=!(["INPUT","TEXTAREA","SELECT"].includes(n.nodeName)&&n.hasAttribute("readonly"));if("editable"===t)return!r&&o;if("checked"===t||"unchecked"===t){if(["checkbox","radio"].includes(n.getAttribute("role")||"")){const e="true"===n.getAttribute("aria-checked");return"checked"===t?e:!e}if("INPUT"!==n.nodeName)throw this.createStacklessError("Not a checkbox or radio button");if(!["radio","checkbox"].includes(n.type.toLowerCase()))throw this.createStacklessError("Not a checkbox or radio button");const e=n.checked;return"checked"===t?e:!e}throw this.createStacklessError(`Unexpected element state "${t}"`)}selectOptions(e,t,n){const r=this.retarget(t,"follow-label");if(!r)return"error:notconnected";if("select"!==r.nodeName.toLowerCase())throw this.createStacklessError("Element is not a <select> element");const o=r,i=[...o.options],s=[];let c=e.slice();for(let e=0;e<i.length;e++){const t=i[e],n=n=>{if(n instanceof Node)return t===n;let r=!0;return void 0!==n.value&&(r=r&&n.value===t.value),void 0!==n.label&&(r=r&&n.label===t.label),void 0!==n.index&&(r=r&&n.index===e),r};if(c.some(n)){if(s.push(t),!o.multiple){c=[];break}c=c.filter((e=>!n(e)))}}return c.length?(n.logRepeating("    did not find some options - waiting... "),n.continuePolling):(o.value=void 0,s.forEach((e=>e.selected=!0)),n.log("    selected specified option(s)"),o.dispatchEvent(new Event("input",{bubbles:!0})),o.dispatchEvent(new Event("change",{bubbles:!0})),s.map((e=>e.value)))}fill(e,t,n){const r=this.retarget(t,"follow-label");if(!r)return"error:notconnected";if("input"===r.nodeName.toLowerCase()){const t=r,o=t.type.toLowerCase(),i=new Set(["color","date","time","datetime","datetime-local","month","range","week"]);if(!new Set(["","email","number","password","search","tel","text","url"]).has(o)&&!i.has(o))throw n.log(`    input of type "${o}" cannot be filled`),this.createStacklessError(`Input of type "${o}" cannot be filled`);if("number"===o&&(e=e.trim(),isNaN(Number(e))))throw this.createStacklessError("Cannot type text into input[type=number]");if(i.has(o)){if(e=e.trim(),t.focus(),t.value=e,t.value!==e)throw this.createStacklessError("Malformed value");return r.dispatchEvent(new Event("input",{bubbles:!0})),r.dispatchEvent(new Event("change",{bubbles:!0})),"done"}}else if("textarea"===r.nodeName.toLowerCase());else if(!r.isContentEditable)throw this.createStacklessError("Element is not an <input>, <textarea> or [contenteditable] element");return this.selectText(r),"needsinput"}selectText(e){const t=this.retarget(e,"follow-label");if(!t)return"error:notconnected";if("input"===t.nodeName.toLowerCase()){const e=t;return e.select(),e.focus(),"done"}if("textarea"===t.nodeName.toLowerCase()){const e=t;return e.selectionStart=0,e.selectionEnd=e.value.length,e.focus(),"done"}const n=t.ownerDocument.createRange();n.selectNodeContents(t);const r=t.ownerDocument.defaultView.getSelection();return r&&(r.removeAllRanges(),r.addRange(n)),t.focus(),"done"}focusNode(e,t){if(!e.isConnected)return"error:notconnected";if(e.nodeType!==Node.ELEMENT_NODE)throw this.createStacklessError("Node is not an element");const n=e.getRootNode().activeElement===e&&e.ownerDocument&&e.ownerDocument.hasFocus();if(e.focus(),t&&!n&&"input"===e.nodeName.toLowerCase())try{e.setSelectionRange(0,0)}catch(e){}return"done"}setInputFiles(e,t){if(e.nodeType!==Node.ELEMENT_NODE)return"Node is not of type HTMLElement";const n=e;if("INPUT"!==n.nodeName)return"Not an <input> element";const r=n;if("file"!==(r.getAttribute("type")||"").toLowerCase())return"Not an input[type=file] element";const o=t.map((e=>{const t=Uint8Array.from(atob(e.buffer),(e=>e.charCodeAt(0)));return new File([t],e.name,{type:e.mimeType})})),i=new DataTransfer;for(const e of o)i.items.add(e);r.files=i.files,r.dispatchEvent(new Event("input",{bubbles:!0})),r.dispatchEvent(new Event("change",{bubbles:!0}))}checkHitTargetAt(e,t){let n=e.nodeType===Node.ELEMENT_NODE?e:e.parentElement;if(!n||!n.isConnected)return"error:notconnected";n=n.closest("button, [role=button]")||n;const r=this.deepElementFromPoint(document,t.x,t.y);return this._expectHitTargetParent(r,n)}_expectHitTargetParent(e,t){const n=[];for(;e&&e!==t;)n.push(e),e=(0,c.parentElementOrShadowHost)(e);if(e===t)return"done";const r=this.previewNode(n[0]||document.documentElement);let o,i=t;for(;i;){const e=n.indexOf(i);if(-1!==e){e>1&&(o=this.previewNode(n[e-1]));break}i=(0,c.parentElementOrShadowHost)(i)}return o?{hitTargetDescription:`${r} from ${o} subtree`}:{hitTargetDescription:r}}setupHitTargetInterceptor(e,t,n){const r=e.nodeType===Node.ELEMENT_NODE?e:e.parentElement;if(!r||!r.isConnected)return"error:notconnected";const o=r.closest("button, [role=button]")||r,i={hover:d,tap:m,mouse:g}[t];let s;const c=e=>{if(!i.has(e.type))return;if(!e.isTrusted)return;const t=window.TouchEvent&&e instanceof window.TouchEvent?e.touches[0]:e;if(void 0===s&&t){const e=this.deepElementFromPoint(document,t.clientX,t.clientY);s=this._expectHitTargetParent(e,o)}(n||"done"!==s&&void 0!==s)&&(e.preventDefault(),e.stopPropagation(),e.stopImmediatePropagation())};return this._hitTargetInterceptor=c,{stop:()=>(this._hitTargetInterceptor===c&&(this._hitTargetInterceptor=void 0),s||"done")}}dispatchEvent(e,t,n){let r;switch(n={bubbles:!0,cancelable:!0,composed:!0,...n},f.get(t)){case"mouse":r=new MouseEvent(t,n);break;case"keyboard":r=new KeyboardEvent(t,n);break;case"touch":r=new TouchEvent(t,n);break;case"pointer":r=new PointerEvent(t,n);break;case"focus":r=new FocusEvent(t,n);break;case"drag":r=new DragEvent(t,n);break;default:r=new Event(t,n)}e.dispatchEvent(r)}deepElementFromPoint(e,t,n){let r,o=e;for(;o;){const e=o.elementsFromPoint(t,n)[0];if(!e||r===e)break;r=e,o=r.shadowRoot}return r}previewNode(e){if(e.nodeType===Node.TEXT_NODE)return p(`#text=${e.nodeValue||""}`);if(e.nodeType!==Node.ELEMENT_NODE)return p(`<${e.nodeName.toLowerCase()} />`);const t=e,n=[];for(let e=0;e<t.attributes.length;e++){const{name:r,value:o}=t.attributes[e];"style"===r||r.startsWith("__playwright")||(!o&&h.has(r)?n.push(` ${r}`):n.push(` ${r}="${o}"`))}n.sort(((e,t)=>e.length-t.length));let r=n.join("");if(r.length>50&&(r=r.substring(0,49)+"\u2026"),u.has(t.nodeName))return p(`<${t.nodeName.toLowerCase()}${r}/>`);const o=t.childNodes;let i=!1;if(o.length<=5){i=!0;for(let e=0;e<o.length;e++)i=i&&o[e].nodeType===Node.TEXT_NODE}let s=i?t.textContent||"":o.length?"\u2026":"";return s.length>50&&(s=s.substring(0,49)+"\u2026"),p(`<${t.nodeName.toLowerCase()}${r}>${s}</${t.nodeName.toLowerCase()}>`)}strictModeViolationError(e,t){const n=t.slice(0,10).map((e=>({preview:this.previewNode(e),selector:(0,a.generateSelector)(this,e).selector}))),r=n.map(((e,t)=>`\\n    ${t+1}) ${e.preview} aka playwright.$("${e.selector}")`));return n.length<t.length&&r.push("\\n    ..."),this.createStacklessError(`strict mode violation: "${(0,s.stringifySelector)(e)}" resolved to ${t.length} elements:${r.join("")}\\n`)}createStacklessError(e){if("firefox"===this._browserName){const t=new Error("Error: "+e);return t.stack="",t}const t=new Error(e);return delete t.stack,t}highlight(e){this._highlight||(this._highlight=new l.Highlight(!1),this._highlight.install()),this._highlight.updateHighlight(this.querySelectorAll(e,document.documentElement),(0,s.stringifySelector)(e),!1)}hideHighlight(){this._highlight&&(this._highlight.uninstall(),delete this._highlight)}_setupGlobalListenersRemovalDetection(){const e="__playwright_global_listeners_check__";let t=!1;const n=()=>t=!0;window.addEventListener(e,n),new MutationObserver((r=>{if(r.some((e=>Array.from(e.addedNodes).includes(document.documentElement)))&&(t=!1,window.dispatchEvent(new CustomEvent(e)),!t)){window.addEventListener(e,n);for(const e of this.onGlobalListenersRemoved)e()}})).observe(document,{childList:!0})}_setupHitTargetInterceptors(){const e=e=>{var t;return null===(t=this._hitTargetInterceptor)||void 0===t?void 0:t.call(this,e)},t=()=>{for(const t of y)window.addEventListener(t,e,{capture:!0,passive:!1})};t(),this.onGlobalListenersRemoved.add(t)}expectSingleElement(e,t,n){const r=e.injectedScript,o=n.expression;{let n;if("to.be.checked"===o)n=e.injectedScript.elementState(t,"checked");else if("to.be.unchecked"===o)n=e.injectedScript.elementState(t,"unchecked");else if("to.be.disabled"===o)n=e.injectedScript.elementState(t,"disabled");else if("to.be.editable"===o)n=e.injectedScript.elementState(t,"editable");else if("to.be.empty"===o){var i;n="INPUT"===t.nodeName||"TEXTAREA"===t.nodeName?!t.value:!(null!==(i=t.textContent)&&void 0!==i&&i.trim())}else"to.be.enabled"===o?n=e.injectedScript.elementState(t,"enabled"):"to.be.focused"===o?n=document.activeElement===t:"to.be.hidden"===o?n=e.injectedScript.elementState(t,"hidden"):"to.be.visible"===o&&(n=e.injectedScript.elementState(t,"visible"));if(void 0!==n){if("error:notcheckbox"===n)throw r.createStacklessError("Element is not a checkbox");if("error:notconnected"===n)throw r.createStacklessError("Element is not connected");return{received:n,matches:n}}}if("to.have.property"===o){const e=t[n.expressionArg];return{received:e,matches:E(e,n.expectedValue)}}{let e;if("to.have.attribute"===o)e=t.getAttribute(n.expressionArg)||"";else if("to.have.class"===o)e=t.className;else if("to.have.css"===o)e=window.getComputedStyle(t)[n.expressionArg];else if("to.have.id"===o)e=t.id;else if("to.have.text"===o)e=n.useInnerText?t.innerText:t.textContent||"";else if("to.have.title"===o)e=document.title;else if("to.have.url"===o)e=document.location.href;else if("to.have.value"===o){if("INPUT"!==(t=this.retarget(t,"follow-label")).nodeName&&"TEXTAREA"!==t.nodeName&&"SELECT"!==t.nodeName)throw this.createStacklessError("Not an input element");e=t.value}if(void 0!==e&&n.expectedText)return{received:e,matches:new v(n.expectedText[0]).matches(e)}}throw this.createStacklessError("Unknown expect matcher: "+o)}expectArray(e,t){const n=t.expression;if("to.have.count"===n){const n=e.length;return{received:n,matches:n===t.expectedNumber}}let r;if("to.have.text.array"===n||"to.contain.text.array"===n?r=e.map((e=>t.useInnerText?e.innerText:e.textContent||"")):"to.have.class.array"===n&&(r=e.map((e=>e.className))),r&&t.expectedText){const e="to.contain.text.array"!==n;if(r.length!==t.expectedText.length&&e)return{received:r,matches:!1};let o=0;const i=t.expectedText.map((e=>new v(e)));let s=!0;for(const e of i){for(;o<r.length&&!e.matches(r[o]);)o++;if(o>=r.length){s=!1;break}}return{received:r,matches:s}}throw this.createStacklessError("Unknown expect matcher: "+n)}};e.default=S})(),pwExport=r.default})();';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/server/common/protocolError.js
var require_protocolError = __commonJS({
  "node_modules/playwright-core/lib/server/common/protocolError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isSessionClosedError = isSessionClosedError;
    exports2.ProtocolError = void 0;
    var ProtocolError = class extends Error {
      constructor(sessionClosed, message) {
        super(message);
        this.sessionClosed = void 0;
        this.sessionClosed = sessionClosed || false;
      }
    };
    exports2.ProtocolError = ProtocolError;
    function isSessionClosedError(e) {
      return e instanceof ProtocolError && e.sessionClosed;
    }
  }
});

// node_modules/playwright-core/lib/generated/utilityScriptSource.js
var require_utilityScriptSource = __commonJS({
  "node_modules/playwright-core/lib/generated/utilityScriptSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = 'var pwExport;(()=>{"use strict";var t={645:(t,e,r)=>{function n(t,e,o){const i=e(t);if(!("fallThrough"in i))return i;if(t=i.fallThrough,o.has(t))throw new Error("Argument is a circular structure");if("symbol"==typeof t)return{v:"undefined"};if(Object.is(t,void 0))return{v:"undefined"};if(Object.is(t,null))return{v:"null"};if(Object.is(t,NaN))return{v:"NaN"};if(Object.is(t,1/0))return{v:"Infinity"};if(Object.is(t,-1/0))return{v:"-Infinity"};if(Object.is(t,-0))return{v:"-0"};if("boolean"==typeof t)return t;if("number"==typeof t)return t;if("string"==typeof t)return t;if((u=t)instanceof Error||u&&u.__proto__&&"Error"===u.__proto__.name){const e=t;return"captureStackTrace"in r.g.Error?e.stack||"":`${e.name}: ${e.message}\\n${e.stack}`}var u;if(function(t){return t instanceof Date||"[object Date]"===Object.prototype.toString.call(t)}(t))return{d:t.toJSON()};if(function(t){return t instanceof RegExp||"[object RegExp]"===Object.prototype.toString.call(t)}(t))return{r:{p:t.source,f:t.flags}};if(Array.isArray(t)){const r=[];o.add(t);for(let i=0;i<t.length;++i)r.push(n(t[i],e,o));return o.delete(t),{a:r}}if("object"==typeof t){const r=[];o.add(t);for(const i of Object.keys(t)){let u;try{u=t[i]}catch(t){continue}"toJSON"===i&&"function"==typeof u?r.push({k:i,v:{o:[]}}):r.push({k:i,v:n(u,e,o)})}return o.delete(t),{o:r}}}Object.defineProperty(e,"__esModule",{value:!0}),e.parseEvaluationResultValue=function t(e,r=[]){if(!Object.is(e,void 0)){if("object"==typeof e&&e){if("v"in e){if("undefined"===e.v)return;return"null"===e.v?null:"NaN"===e.v?NaN:"Infinity"===e.v?1/0:"-Infinity"===e.v?-1/0:"-0"===e.v?-0:void 0}if("d"in e)return new Date(e.d);if("r"in e)return new RegExp(e.r.p,e.r.f);if("a"in e)return e.a.map((e=>t(e,r)));if("o"in e){const n={};for(const{k:o,v:i}of e.o)n[o]=t(i,r);return n}if("h"in e)return r[e.h]}return e}},e.serializeAsCallArgument=function(t,e){return n(t,e,new Set)}}},e={};function r(n){var o=e[n];if(void 0!==o)return o.exports;var i=e[n]={exports:{}};return t[n](i,i.exports,r),i.exports}r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}();var n={};(()=>{var t=n;t.default=void 0;var e=r(645);t.default=class{evaluate(t,n,o,i,...u){const a=u.slice(0,i),f=u.slice(i),s=a.map((t=>(0,e.parseEvaluationResultValue)(t,f)));let c=r.g.eval(o);return!0===t?c=c(...s):!1===t?c=c:"function"==typeof c&&(c=c(...s)),n?this._promiseAwareJsonValueNoThrow(c):c}jsonValue(t,r){if(!Object.is(r,void 0))return(0,e.serializeAsCallArgument)(r,(t=>({fallThrough:t})))}_promiseAwareJsonValueNoThrow(t){const e=t=>{try{return this.jsonValue(!0,t)}catch(t){return}};return t&&"object"==typeof t&&"function"==typeof t.then?(async()=>{const r=await t;return e(r)})():e(t)}}})(),pwExport=n.default})();';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/server/common/utilityScriptSerializers.js
var require_utilityScriptSerializers = __commonJS({
  "node_modules/playwright-core/lib/server/common/utilityScriptSerializers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parseEvaluationResultValue = parseEvaluationResultValue;
    exports2.serializeAsCallArgument = serializeAsCallArgument;
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isDate(obj) {
      return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
    }
    function isError(obj) {
      return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === "Error";
    }
    function parseEvaluationResultValue(value, handles = []) {
      if (Object.is(value, void 0))
        return void 0;
      if (typeof value === "object" && value) {
        if ("v" in value) {
          if (value.v === "undefined")
            return void 0;
          if (value.v === "null")
            return null;
          if (value.v === "NaN")
            return NaN;
          if (value.v === "Infinity")
            return Infinity;
          if (value.v === "-Infinity")
            return -Infinity;
          if (value.v === "-0")
            return -0;
          return void 0;
        }
        if ("d" in value)
          return new Date(value.d);
        if ("r" in value)
          return new RegExp(value.r.p, value.r.f);
        if ("a" in value)
          return value.a.map((a) => parseEvaluationResultValue(a, handles));
        if ("o" in value) {
          const result = {};
          for (const {
            k,
            v
          } of value.o)
            result[k] = parseEvaluationResultValue(v, handles);
          return result;
        }
        if ("h" in value)
          return handles[value.h];
      }
      return value;
    }
    function serializeAsCallArgument(value, handleSerializer) {
      return serialize(value, handleSerializer, /* @__PURE__ */ new Set());
    }
    function serialize(value, handleSerializer, visited) {
      const result = handleSerializer(value);
      if ("fallThrough" in result)
        value = result.fallThrough;
      else
        return result;
      if (visited.has(value))
        throw new Error("Argument is a circular structure");
      if (typeof value === "symbol")
        return {
          v: "undefined"
        };
      if (Object.is(value, void 0))
        return {
          v: "undefined"
        };
      if (Object.is(value, null))
        return {
          v: "null"
        };
      if (Object.is(value, NaN))
        return {
          v: "NaN"
        };
      if (Object.is(value, Infinity))
        return {
          v: "Infinity"
        };
      if (Object.is(value, -Infinity))
        return {
          v: "-Infinity"
        };
      if (Object.is(value, -0))
        return {
          v: "-0"
        };
      if (typeof value === "boolean")
        return value;
      if (typeof value === "number")
        return value;
      if (typeof value === "string")
        return value;
      if (isError(value)) {
        const error = value;
        if ("captureStackTrace" in global.Error) {
          return error.stack || "";
        }
        return `${error.name}: ${error.message}
${error.stack}`;
      }
      if (isDate(value))
        return {
          d: value.toJSON()
        };
      if (isRegExp(value))
        return {
          r: {
            p: value.source,
            f: value.flags
          }
        };
      if (Array.isArray(value)) {
        const a = [];
        visited.add(value);
        for (let i = 0; i < value.length; ++i)
          a.push(serialize(value[i], handleSerializer, visited));
        visited.delete(value);
        return {
          a
        };
      }
      if (typeof value === "object") {
        const o = [];
        visited.add(value);
        for (const name of Object.keys(value)) {
          let item;
          try {
            item = value[name];
          } catch (e) {
            continue;
          }
          if (name === "toJSON" && typeof item === "function")
            o.push({
              k: name,
              v: {
                o: []
              }
            });
          else
            o.push({
              k: name,
              v: serialize(item, handleSerializer, visited)
            });
        }
        visited.delete(value);
        return {
          o
        };
      }
    }
  }
});

// node_modules/playwright-core/lib/server/javascript.js
var require_javascript = __commonJS({
  "node_modules/playwright-core/lib/server/javascript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.evaluate = evaluate;
    exports2.evaluateExpression = evaluateExpression;
    exports2.evaluateExpressionAndWaitForSignals = evaluateExpressionAndWaitForSignals;
    exports2.parseUnserializableValue = parseUnserializableValue;
    exports2.normalizeEvaluationExpression = normalizeEvaluationExpression;
    exports2.isJavaScriptErrorInEvaluate = isJavaScriptErrorInEvaluate;
    exports2.JavaScriptErrorInEvaluate = exports2.JSHandle = exports2.ExecutionContext = void 0;
    var utilityScriptSource = _interopRequireWildcard2(require_utilityScriptSource());
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _instrumentation = require_instrumentation();
    var _async = require_async();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var ExecutionContext = class extends _instrumentation.SdkObject {
      constructor(parent, delegate) {
        super(parent, "execution-context");
        this._delegate = void 0;
        this._utilityScriptPromise = void 0;
        this._destroyedPromise = new _async.ManualPromise();
        this._delegate = delegate;
      }
      contextDestroyed(error) {
        this._destroyedPromise.resolve(error);
      }
      _raceAgainstContextDestroyed(promise) {
        return Promise.race([this._destroyedPromise.then((e) => {
          throw e;
        }), promise]);
      }
      rawEvaluateJSON(expression) {
        return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateJSON(expression));
      }
      rawEvaluateHandle(expression) {
        return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(expression));
      }
      rawCallFunctionNoReply(func, ...args) {
        this._delegate.rawCallFunctionNoReply(func, ...args);
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return this._raceAgainstContextDestroyed(this._delegate.evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds));
      }
      getProperties(context, objectId) {
        return this._raceAgainstContextDestroyed(this._delegate.getProperties(context, objectId));
      }
      createHandle(remoteObject) {
        return this._delegate.createHandle(this, remoteObject);
      }
      releaseHandle(objectId) {
        return this._delegate.releaseHandle(objectId);
      }
      waitForSignalsCreatedBy(action) {
        return __async(this, null, function* () {
          return action();
        });
      }
      adoptIfNeeded(handle) {
        return null;
      }
      utilityScript() {
        if (!this._utilityScriptPromise) {
          const source = `
      (() => {
        ${utilityScriptSource.source}
        return new pwExport();
      })();`;
          this._utilityScriptPromise = this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(source).then((objectId) => new JSHandle(this, "object", void 0, objectId)));
        }
        return this._utilityScriptPromise;
      }
      doSlowMo() {
        return __async(this, null, function* () {
        });
      }
    };
    exports2.ExecutionContext = ExecutionContext;
    var JSHandle = class extends _instrumentation.SdkObject {
      constructor(context, type, preview, objectId, value) {
        super(context, "handle");
        this._context = void 0;
        this._disposed = false;
        this._objectId = void 0;
        this._value = void 0;
        this._objectType = void 0;
        this._preview = void 0;
        this._previewCallback = void 0;
        this._context = context;
        this._objectId = objectId;
        this._value = value;
        this._objectType = type;
        this._preview = this._objectId ? preview || `JSHandle@${this._objectType}` : String(value);
      }
      callFunctionNoReply(func, arg) {
        this._context.rawCallFunctionNoReply(func, this, arg);
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          return evaluate(this._context, true, pageFunction, this, arg);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          return evaluate(this._context, false, pageFunction, this, arg);
        });
      }
      evaluateExpressionAndWaitForSignals(expression, isFunction, returnByValue, arg) {
        return __async(this, null, function* () {
          const value = yield evaluateExpressionAndWaitForSignals(this._context, returnByValue, expression, isFunction, this, arg);
          yield this._context.doSlowMo();
          return value;
        });
      }
      getProperty(propertyName) {
        return __async(this, null, function* () {
          const objectHandle = yield this.evaluateHandle((object, propertyName2) => {
            const result2 = {
              __proto__: null
            };
            result2[propertyName2] = object[propertyName2];
            return result2;
          }, propertyName);
          const properties = yield objectHandle.getProperties();
          const result = properties.get(propertyName);
          objectHandle.dispose();
          return result;
        });
      }
      getProperties() {
        return __async(this, null, function* () {
          if (!this._objectId)
            return /* @__PURE__ */ new Map();
          return this._context.getProperties(this._context, this._objectId);
        });
      }
      rawValue() {
        return this._value;
      }
      jsonValue() {
        return __async(this, null, function* () {
          if (!this._objectId)
            return this._value;
          const utilityScript = yield this._context.utilityScript();
          const script = `(utilityScript, ...args) => utilityScript.jsonValue(...args)`;
          return this._context.evaluateWithArguments(script, true, utilityScript, [true], [this._objectId]);
        });
      }
      asElement() {
        return null;
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        if (this._objectId)
          this._context.releaseHandle(this._objectId).catch((e) => {
          });
      }
      toString() {
        return this._preview;
      }
      _setPreviewCallback(callback) {
        this._previewCallback = callback;
      }
      preview() {
        return this._preview;
      }
      _setPreview(preview) {
        this._preview = preview;
        if (this._previewCallback)
          this._previewCallback(preview);
      }
    };
    exports2.JSHandle = JSHandle;
    function evaluate(context, returnByValue, pageFunction, ...args) {
      return __async(this, null, function* () {
        return evaluateExpression(context, returnByValue, String(pageFunction), typeof pageFunction === "function", ...args);
      });
    }
    function evaluateExpression(context, returnByValue, expression, isFunction, ...args) {
      return __async(this, null, function* () {
        const utilityScript = yield context.utilityScript();
        expression = normalizeEvaluationExpression(expression, isFunction);
        const handles = [];
        const toDispose = [];
        const pushHandle = (handle) => {
          handles.push(handle);
          return handles.length - 1;
        };
        args = args.map((arg) => (0, _utilityScriptSerializers.serializeAsCallArgument)(arg, (handle) => {
          if (handle instanceof JSHandle) {
            if (!handle._objectId)
              return {
                fallThrough: handle._value
              };
            if (handle._disposed)
              throw new Error("JSHandle is disposed!");
            const adopted = context.adoptIfNeeded(handle);
            if (adopted === null)
              return {
                h: pushHandle(Promise.resolve(handle))
              };
            toDispose.push(adopted);
            return {
              h: pushHandle(adopted)
            };
          }
          return {
            fallThrough: handle
          };
        }));
        const utilityScriptObjectIds = [];
        for (const handle of yield Promise.all(handles)) {
          if (handle._context !== context)
            throw new Error("JSHandles can be evaluated only in the context they were created!");
          utilityScriptObjectIds.push(handle._objectId);
        }
        const utilityScriptValues = [isFunction, returnByValue, expression, args.length, ...args];
        const script = `(utilityScript, ...args) => utilityScript.evaluate(...args)`;
        try {
          return yield context.evaluateWithArguments(script, returnByValue, utilityScript, utilityScriptValues, utilityScriptObjectIds);
        } finally {
          toDispose.map((handlePromise) => handlePromise.then((handle) => handle.dispose()));
        }
      });
    }
    function evaluateExpressionAndWaitForSignals(context, returnByValue, expression, isFunction, ...args) {
      return __async(this, null, function* () {
        return yield context.waitForSignalsCreatedBy(() => evaluateExpression(context, returnByValue, expression, isFunction, ...args));
      });
    }
    function parseUnserializableValue(unserializableValue) {
      if (unserializableValue === "NaN")
        return NaN;
      if (unserializableValue === "Infinity")
        return Infinity;
      if (unserializableValue === "-Infinity")
        return -Infinity;
      if (unserializableValue === "-0")
        return -0;
    }
    function normalizeEvaluationExpression(expression, isFunction) {
      expression = expression.trim();
      if (isFunction) {
        try {
          new Function("(" + expression + ")");
        } catch (e1) {
          if (expression.startsWith("async "))
            expression = "async function " + expression.substring("async ".length);
          else
            expression = "function " + expression;
          try {
            new Function("(" + expression + ")");
          } catch (e2) {
            throw new Error("Passed function is not well-serializable!");
          }
        }
      }
      if (/^(async)?\s*function(\s|\()/.test(expression))
        expression = "(" + expression + ")";
      return expression;
    }
    var JavaScriptErrorInEvaluate = class extends Error {
    };
    exports2.JavaScriptErrorInEvaluate = JavaScriptErrorInEvaluate;
    function isJavaScriptErrorInEvaluate(error) {
      return error instanceof JavaScriptErrorInEvaluate;
    }
  }
});

// node_modules/playwright-core/lib/server/dom.js
var require_dom = __commonJS({
  "node_modules/playwright-core/lib/server/dom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isNonRecoverableDOMError = isNonRecoverableDOMError;
    exports2.throwRetargetableDOMError = throwRetargetableDOMError;
    exports2.assertDone = assertDone;
    exports2.waitForSelectorTask = waitForSelectorTask;
    exports2.kUnableToAdoptErrorMessage = exports2.InjectedScriptPollHandler = exports2.ElementHandle = exports2.FrameExecutionContext = exports2.NonRecoverableDOMError = void 0;
    var mime = _interopRequireWildcard2(require_mime());
    var injectedScriptSource = _interopRequireWildcard2(require_injectedScriptSource());
    var _protocolError = require_protocolError();
    var js = _interopRequireWildcard2(require_javascript());
    var _progress = require_progress2();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var NonRecoverableDOMError = class extends Error {
    };
    exports2.NonRecoverableDOMError = NonRecoverableDOMError;
    function isNonRecoverableDOMError(error) {
      return error instanceof NonRecoverableDOMError;
    }
    var FrameExecutionContext = class extends js.ExecutionContext {
      constructor(delegate, frame, world) {
        super(frame, delegate);
        this.frame = void 0;
        this._injectedScriptPromise = void 0;
        this.world = void 0;
        this.frame = frame;
        this.world = world;
      }
      waitForSignalsCreatedBy(action) {
        return __async(this, null, function* () {
          return this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, action);
        });
      }
      adoptIfNeeded(handle) {
        if (handle instanceof ElementHandle && handle._context !== this)
          return this.frame._page._delegate.adoptElementHandle(handle, this);
        return null;
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluate(this, true, pageFunction, arg);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluate(this, false, pageFunction, arg);
        });
      }
      evaluateExpression(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluateExpression(this, true, expression, isFunction, arg);
        });
      }
      evaluateExpressionAndWaitForSignals(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return yield this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, () => __async(this, null, function* () {
            return this.evaluateExpression(expression, isFunction, arg);
          }));
        });
      }
      evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return yield this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, () => __async(this, null, function* () {
            return js.evaluateExpression(this, false, expression, isFunction, arg);
          }));
        });
      }
      createHandle(remoteObject) {
        if (this.frame._page._delegate.isElementHandle(remoteObject))
          return new ElementHandle(this, remoteObject.objectId);
        return super.createHandle(remoteObject);
      }
      injectedScript() {
        if (!this._injectedScriptPromise) {
          const custom = [];
          for (const [name, {
            source: source2
          }] of this.frame._page.selectors._engines)
            custom.push(`{ name: '${name}', engine: (${source2}) }`);
          const source = `
        (() => {
        ${injectedScriptSource.source}
        return new pwExport(
          ${this.frame._page._delegate.rafCountForStablePosition()},
          "${this.frame._page._browserContext._browser.options.name}",
          [${custom.join(",\n")}]
        );
        })();
      `;
          this._injectedScriptPromise = this.rawEvaluateHandle(source).then((objectId) => new js.JSHandle(this, "object", void 0, objectId));
        }
        return this._injectedScriptPromise;
      }
      doSlowMo() {
        return __async(this, null, function* () {
          return this.frame._page._doSlowMo();
        });
      }
    };
    exports2.FrameExecutionContext = FrameExecutionContext;
    var ElementHandle = class extends js.JSHandle {
      constructor(context, objectId) {
        super(context, "node", void 0, objectId);
        this._page = void 0;
        this._frame = void 0;
        this._page = context.frame._page;
        this._frame = context.frame;
        this._initializePreview().catch((e) => {
        });
      }
      _initializePreview() {
        return __async(this, null, function* () {
          const utility = yield this._context.injectedScript();
          this._setPreview(yield utility.evaluate((injected, e) => "JSHandle@" + injected.previewNode(e), this));
        });
      }
      asElement() {
        return this;
      }
      evaluateInUtility(pageFunction, arg) {
        return __async(this, null, function* () {
          try {
            const utility = yield this._frame._utilityContext();
            return yield utility.evaluate(pageFunction, [yield utility.injectedScript(), this, arg]);
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            return "error:notconnected";
          }
        });
      }
      evaluateHandleInUtility(pageFunction, arg) {
        return __async(this, null, function* () {
          try {
            const utility = yield this._frame._utilityContext();
            return yield utility.evaluateHandle(pageFunction, [yield utility.injectedScript(), this, arg]);
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            return "error:notconnected";
          }
        });
      }
      evaluatePoll(progress, pageFunction, arg) {
        return __async(this, null, function* () {
          try {
            const utility = yield this._frame._utilityContext();
            const poll = yield utility.evaluateHandle(pageFunction, [yield utility.injectedScript(), this, arg]);
            const pollHandler = new InjectedScriptPollHandler(progress, poll);
            return yield pollHandler.finish();
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            return "error:notconnected";
          }
        });
      }
      ownerFrame() {
        return __async(this, null, function* () {
          const frameId = yield this._page._delegate.getOwnerFrame(this);
          if (!frameId)
            return null;
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            return frame;
          for (const page of this._page._browserContext.pages()) {
            const frame2 = page._frameManager.frame(frameId);
            if (frame2)
              return frame2;
          }
          return null;
        });
      }
      isIframeElement() {
        return __async(this, null, function* () {
          return this.evaluateInUtility(([injected, node]) => node && (node.nodeName === "IFRAME" || node.nodeName === "FRAME"), {});
        });
      }
      contentFrame() {
        return __async(this, null, function* () {
          const isFrameElement = throwRetargetableDOMError(yield this.isIframeElement());
          if (!isFrameElement)
            return null;
          return this._page._delegate.getContentFrame(this);
        });
      }
      getAttribute(name) {
        return __async(this, null, function* () {
          return throwRetargetableDOMError(yield this.evaluateInUtility(([injected, node, name2]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
              throw injected.createStacklessError("Node is not an element");
            const element = node;
            return {
              value: element.getAttribute(name2)
            };
          }, name)).value;
        });
      }
      inputValue() {
        return __async(this, null, function* () {
          return throwRetargetableDOMError(yield this.evaluateInUtility(([injected, node]) => {
            const element = injected.retarget(node, "follow-label");
            if (!element || element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")
              throw injected.createStacklessError("Node is not an <input>, <textarea> or <select> element");
            return {
              value: element.value
            };
          }, void 0)).value;
        });
      }
      textContent() {
        return __async(this, null, function* () {
          return throwRetargetableDOMError(yield this.evaluateInUtility(([injected, node]) => {
            return {
              value: node.textContent
            };
          }, void 0)).value;
        });
      }
      innerText() {
        return __async(this, null, function* () {
          return throwRetargetableDOMError(yield this.evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
              throw injected.createStacklessError("Node is not an element");
            if (node.namespaceURI !== "http://www.w3.org/1999/xhtml")
              throw injected.createStacklessError("Node is not an HTMLElement");
            const element = node;
            return {
              value: element.innerText
            };
          }, void 0)).value;
        });
      }
      innerHTML() {
        return __async(this, null, function* () {
          return throwRetargetableDOMError(yield this.evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
              throw injected.createStacklessError("Node is not an element");
            const element = node;
            return {
              value: element.innerHTML
            };
          }, void 0)).value;
        });
      }
      dispatchEvent(_0) {
        return __async(this, arguments, function* (type, eventInit = {}) {
          const main = yield this._frame._mainContext();
          yield this._page._frameManager.waitForSignalsCreatedBy(null, false, () => __async(this, null, function* () {
            return main.evaluate(([injected, node, {
              type: type2,
              eventInit: eventInit2
            }]) => injected.dispatchEvent(node, type2, eventInit2), [yield main.injectedScript(), this, {
              type,
              eventInit
            }]);
          }));
          yield this._page._doSlowMo();
        });
      }
      _scrollRectIntoViewIfNeeded(rect) {
        return __async(this, null, function* () {
          return yield this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
        });
      }
      _waitAndScrollIntoViewIfNeeded(progress) {
        return __async(this, null, function* () {
          while (progress.isRunning()) {
            assertDone(throwRetargetableDOMError(yield this._waitForDisplayedAtStablePosition(progress, false, false)));
            progress.throwIfAborted();
            const result = throwRetargetableDOMError(yield this._scrollRectIntoViewIfNeeded());
            if (result === "error:notvisible")
              continue;
            assertDone(result);
            return;
          }
        });
      }
      scrollIntoViewIfNeeded(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this._waitAndScrollIntoViewIfNeeded(progress), this._page._timeoutSettings.timeout(options));
        });
      }
      _clickablePoint() {
        return __async(this, null, function* () {
          const intersectQuadWithViewport = (quad) => {
            return quad.map((point) => ({
              x: Math.min(Math.max(point.x, 0), metrics.width),
              y: Math.min(Math.max(point.y, 0), metrics.height)
            }));
          };
          const computeQuadArea = (quad) => {
            let area = 0;
            for (let i = 0; i < quad.length; ++i) {
              const p1 = quad[i];
              const p2 = quad[(i + 1) % quad.length];
              area += (p1.x * p2.y - p2.x * p1.y) / 2;
            }
            return Math.abs(area);
          };
          const [quads, metrics] = yield Promise.all([this._page._delegate.getContentQuads(this), this._page.mainFrame()._utilityContext().then((utility) => utility.evaluate(() => ({
            width: innerWidth,
            height: innerHeight
          })))]);
          if (!quads || !quads.length)
            return "error:notvisible";
          const filtered = quads.map((quad) => intersectQuadWithViewport(quad)).filter((quad) => computeQuadArea(quad) > 0.99);
          if (!filtered.length)
            return "error:notinviewport";
          const result = {
            x: 0,
            y: 0
          };
          for (const point of filtered[0]) {
            result.x += point.x / 4;
            result.y += point.y / 4;
          }
          compensateHalfIntegerRoundingError(result);
          return result;
        });
      }
      _offsetPoint(offset) {
        return __async(this, null, function* () {
          const [box, border] = yield Promise.all([this.boundingBox(), this.evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch((e) => {
          })]);
          if (!box || !border)
            return "error:notvisible";
          if (border === "error:notconnected")
            return border;
          return {
            x: box.x + border.left + offset.x,
            y: box.y + border.top + offset.y
          };
        });
      }
      _retryPointerAction(progress, actionName, waitForEnabled, action, options) {
        return __async(this, null, function* () {
          let retry = 0;
          const waitTime = [0, 20, 100, 100, 500];
          const scrollOptions = [void 0, {
            block: "end",
            inline: "end"
          }, {
            block: "center",
            inline: "center"
          }, {
            block: "start",
            inline: "start"
          }];
          while (progress.isRunning()) {
            if (retry) {
              progress.log(`retrying ${actionName} action${options.trial ? " (trial run)" : ""}, attempt #${retry}`);
              const timeout = waitTime[Math.min(retry - 1, waitTime.length - 1)];
              if (timeout) {
                progress.log(`  waiting ${timeout}ms`);
                const result2 = yield this.evaluateInUtility(([injected, node, timeout2]) => new Promise((f) => setTimeout(f, timeout2)), timeout);
                if (result2 === "error:notconnected")
                  return result2;
              }
            } else {
              progress.log(`attempting ${actionName} action${options.trial ? " (trial run)" : ""}`);
            }
            const forceScrollOptions = scrollOptions[retry % scrollOptions.length];
            const result = yield this._performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options);
            ++retry;
            if (result === "error:notvisible") {
              if (options.force)
                throw new NonRecoverableDOMError("Element is not visible");
              progress.log("  element is not visible");
              continue;
            }
            if (result === "error:notinviewport") {
              if (options.force)
                throw new NonRecoverableDOMError("Element is outside of the viewport");
              progress.log("  element is outside of the viewport");
              continue;
            }
            if (typeof result === "object" && "hitTargetDescription" in result) {
              progress.log(`  ${result.hitTargetDescription} intercepts pointer events`);
              continue;
            }
            return result;
          }
          return "done";
        });
      }
      _performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options) {
        return __async(this, null, function* () {
          const {
            force = false,
            position
          } = options;
          if (options.__testHookBeforeStable)
            yield options.__testHookBeforeStable();
          const result = yield this._waitForDisplayedAtStablePosition(progress, force, waitForEnabled);
          if (result !== "done")
            return result;
          if (options.__testHookAfterStable)
            yield options.__testHookAfterStable();
          progress.log("  scrolling into view if needed");
          progress.throwIfAborted();
          if (forceScrollOptions) {
            const scrolled = yield this.evaluateInUtility(([injected, node, options2]) => {
              if (node.nodeType === 1)
                node.scrollIntoView(options2);
            }, forceScrollOptions);
            if (scrolled === "error:notconnected")
              return scrolled;
          } else {
            const scrolled = yield this._scrollRectIntoViewIfNeeded(position ? {
              x: position.x,
              y: position.y,
              width: 0,
              height: 0
            } : void 0);
            if (scrolled !== "done")
              return scrolled;
          }
          progress.log("  done scrolling");
          const maybePoint = position ? yield this._offsetPoint(position) : yield this._clickablePoint();
          if (typeof maybePoint === "string")
            return maybePoint;
          const point = roundPoint(maybePoint);
          progress.metadata.point = point;
          if (process.env.PLAYWRIGHT_NO_LAYOUT_SHIFT_CHECK)
            return this._finishPointerAction(progress, actionName, point, options, action);
          else
            return this._finishPointerActionDetectLayoutShift(progress, actionName, point, options, action);
        });
      }
      _finishPointerAction(progress, actionName, point, options, action) {
        return __async(this, null, function* () {
          if (!options.force) {
            if (options.__testHookBeforeHitTarget)
              yield options.__testHookBeforeHitTarget();
            progress.log(`  checking that element receives pointer events at (${point.x},${point.y})`);
            const hitTargetResult = yield this._checkHitTargetAt(point);
            if (hitTargetResult !== "done")
              return hitTargetResult;
            progress.log(`  element does receive pointer events`);
          }
          if (options.trial) {
            progress.log(`  trial ${actionName} has finished`);
            return "done";
          }
          yield progress.beforeInputAction(this);
          yield this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            if (options.__testHookBeforePointerAction)
              yield options.__testHookBeforePointerAction();
            progress.throwIfAborted();
            let restoreModifiers;
            if (options && options.modifiers)
              restoreModifiers = yield this._page.keyboard._ensureModifiers(options.modifiers);
            progress.log(`  performing ${actionName} action`);
            yield action(point);
            progress.log(`  ${actionName} action done`);
            progress.log("  waiting for scheduled navigations to finish");
            if (options.__testHookAfterPointerAction)
              yield options.__testHookAfterPointerAction();
            if (restoreModifiers)
              yield this._page.keyboard._ensureModifiers(restoreModifiers);
          }), "input");
          progress.log("  navigations have finished");
          return "done";
        });
      }
      _finishPointerActionDetectLayoutShift(progress, actionName, point, options, action) {
        return __async(this, null, function* () {
          yield progress.beforeInputAction(this);
          let hitTargetInterceptionHandle;
          if (!options.force) {
            if (options.__testHookBeforeHitTarget)
              yield options.__testHookBeforeHitTarget();
            const actionType = actionName === "hover" || actionName === "tap" ? actionName : "mouse";
            const handle = yield this.evaluateHandleInUtility(([injected, node, {
              actionType: actionType2,
              trial
            }]) => injected.setupHitTargetInterceptor(node, actionType2, trial), {
              actionType,
              trial: !!options.trial
            });
            if (handle === "error:notconnected")
              return handle;
            if (!handle._objectId)
              return handle.rawValue();
            hitTargetInterceptionHandle = handle;
            progress.cleanupWhenAborted(() => {
              hitTargetInterceptionHandle.evaluate((h) => h.stop()).catch((e) => {
              });
            });
          }
          const actionResult = yield this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            if (options.__testHookBeforePointerAction)
              yield options.__testHookBeforePointerAction();
            progress.throwIfAborted();
            let restoreModifiers;
            if (options && options.modifiers)
              restoreModifiers = yield this._page.keyboard._ensureModifiers(options.modifiers);
            progress.log(`  performing ${actionName} action`);
            yield action(point);
            if (restoreModifiers)
              yield this._page.keyboard._ensureModifiers(restoreModifiers);
            if (hitTargetInterceptionHandle) {
              const stopHitTargetInterception = hitTargetInterceptionHandle.evaluate((h) => h.stop()).catch((e) => "done");
              if (!options.noWaitAfter) {
                const hitTargetResult = yield stopHitTargetInterception;
                if (hitTargetResult !== "done")
                  return hitTargetResult;
              }
            }
            progress.log(`  ${options.trial ? "trial " : ""}${actionName} action done`);
            progress.log("  waiting for scheduled navigations to finish");
            if (options.__testHookAfterPointerAction)
              yield options.__testHookAfterPointerAction();
            return "done";
          }), "input");
          if (actionResult !== "done")
            return actionResult;
          progress.log("  navigations have finished");
          return "done";
        });
      }
      hover(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._hover(progress, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _hover(progress, options) {
        return this._retryPointerAction(progress, "hover", false, (point) => this._page.mouse.move(point.x, point.y), options);
      }
      click(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._click(progress, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _click(progress, options) {
        return this._retryPointerAction(progress, "click", true, (point) => this._page.mouse.click(point.x, point.y, options), options);
      }
      dblclick(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._dblclick(progress, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _dblclick(progress, options) {
        return this._retryPointerAction(progress, "dblclick", true, (point) => this._page.mouse.dblclick(point.x, point.y, options), options);
      }
      tap(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._tap(progress, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _tap(progress, options) {
        return this._retryPointerAction(progress, "tap", true, (point) => this._page.touchscreen.tap(point.x, point.y), options);
      }
      selectOption(metadata, elements, values, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._selectOption(progress, elements, values, options);
            return throwRetargetableDOMError(result);
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _selectOption(progress, elements, values, options) {
        return __async(this, null, function* () {
          const optionsToSelect = [...elements, ...values];
          yield progress.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            progress.throwIfAborted();
            progress.log("  selecting specified option(s)");
            const result = yield this.evaluatePoll(progress, ([injected, node, {
              optionsToSelect: optionsToSelect2,
              force
            }]) => {
              return injected.waitForElementStatesAndPerformAction(node, ["visible", "enabled"], force, injected.selectOptions.bind(injected, optionsToSelect2));
            }, {
              optionsToSelect,
              force: options.force
            });
            yield this._page._doSlowMo();
            return result;
          }));
        });
      }
      fill(_0, _1) {
        return __async(this, arguments, function* (metadata, value, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._fill(progress, value, options);
            assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _fill(progress, value, options) {
        return __async(this, null, function* () {
          progress.log(`elementHandle.fill("${value}")`);
          yield progress.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            progress.log("  waiting for element to be visible, enabled and editable");
            const filled = yield this.evaluatePoll(progress, ([injected, node, {
              value: value2,
              force
            }]) => {
              return injected.waitForElementStatesAndPerformAction(node, ["visible", "enabled", "editable"], force, injected.fill.bind(injected, value2));
            }, {
              value,
              force: options.force
            });
            progress.throwIfAborted();
            if (filled === "error:notconnected")
              return filled;
            progress.log("  element is visible, enabled and editable");
            if (filled === "needsinput") {
              progress.throwIfAborted();
              if (value)
                yield this._page.keyboard.insertText(value);
              else
                yield this._page.keyboard.press("Delete");
            } else {
              assertDone(filled);
            }
            return "done";
          }), "input");
        });
      }
      selectText(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            progress.throwIfAborted();
            const result = yield this.evaluatePoll(progress, ([injected, node, force]) => {
              return injected.waitForElementStatesAndPerformAction(node, ["visible"], force, injected.selectText.bind(injected));
            }, options.force);
            assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      setInputFiles(metadata, files, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._setInputFiles(progress, files, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _setInputFiles(progress, files, options) {
        return __async(this, null, function* () {
          for (const payload of files) {
            if (!payload.mimeType)
              payload.mimeType = mime.getType(payload.name) || "application/octet-stream";
          }
          const result = yield this.evaluateHandleInUtility(([injected, node, multiple]) => {
            const element = injected.retarget(node, "follow-label");
            if (!element)
              return;
            if (element.tagName !== "INPUT")
              throw injected.createStacklessError("Node is not an HTMLInputElement");
            if (multiple && !element.multiple)
              throw injected.createStacklessError("Non-multiple file input can only accept single file");
            return element;
          }, files.length > 1);
          if (result === "error:notconnected" || !result.asElement())
            return "error:notconnected";
          const retargeted = result.asElement();
          yield progress.beforeInputAction(this);
          yield this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            progress.throwIfAborted();
            yield this._page._delegate.setInputFiles(retargeted, files);
          }));
          yield this._page._doSlowMo();
          return "done";
        });
      }
      focus(metadata) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          yield controller.run((progress) => __async(this, null, function* () {
            const result = yield this._focus(progress);
            yield this._page._doSlowMo();
            return assertDone(throwRetargetableDOMError(result));
          }), 0);
        });
      }
      _focus(progress, resetSelectionIfNotFocused) {
        return __async(this, null, function* () {
          progress.throwIfAborted();
          return yield this.evaluateInUtility(([injected, node, resetSelectionIfNotFocused2]) => injected.focusNode(node, resetSelectionIfNotFocused2), resetSelectionIfNotFocused);
        });
      }
      type(metadata, text, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._type(progress, text, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _type(progress, text, options) {
        return __async(this, null, function* () {
          progress.log(`elementHandle.type("${text}")`);
          yield progress.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            const result = yield this._focus(progress, true);
            if (result !== "done")
              return result;
            progress.throwIfAborted();
            yield this._page.keyboard.type(text, options);
            return "done";
          }), "input");
        });
      }
      press(metadata, key, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._press(progress, key, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _press(progress, key, options) {
        return __async(this, null, function* () {
          progress.log(`elementHandle.press("${key}")`);
          yield progress.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            const result = yield this._focus(progress, true);
            if (result !== "done")
              return result;
            progress.throwIfAborted();
            yield this._page.keyboard.press(key, options);
            return "done";
          }), "input");
        });
      }
      check(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._setChecked(progress, true, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      uncheck(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._setChecked(progress, false, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _setChecked(progress, state, options) {
        return __async(this, null, function* () {
          const isChecked = () => __async(this, null, function* () {
            const result2 = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "checked"), {});
            return throwRetargetableDOMError(result2);
          });
          if ((yield isChecked()) === state)
            return "done";
          const result = yield this._click(progress, options);
          if (result !== "done")
            return result;
          if (options.trial)
            return "done";
          if ((yield isChecked()) !== state)
            throw new NonRecoverableDOMError("Clicking the checkbox did not change its state");
          return "done";
        });
      }
      boundingBox() {
        return __async(this, null, function* () {
          return this._page._delegate.getBoundingBox(this);
        });
      }
      screenshot(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this._page._screenshotter.screenshotElement(progress, this, options), this._page._timeoutSettings.timeout(options));
        });
      }
      querySelector(selector, options) {
        return __async(this, null, function* () {
          const pair = yield this._frame.resolveFrameForSelectorNoWait(selector, options, this);
          if (!pair)
            return null;
          const {
            frame,
            info
          } = pair;
          return this._page.selectors.query(frame, info, this._frame === frame ? this : void 0);
        });
      }
      querySelectorAll(selector) {
        return __async(this, null, function* () {
          const pair = yield this._frame.resolveFrameForSelectorNoWait(selector, {}, this);
          if (!pair)
            return [];
          const {
            frame,
            info
          } = pair;
          return this._page.selectors._queryAll(frame, info, this._frame === frame ? this : void 0, true);
        });
      }
      evalOnSelectorAndWaitForSignals(selector, strict, expression, isFunction, arg) {
        return __async(this, null, function* () {
          const pair = yield this._frame.resolveFrameForSelectorNoWait(selector, {
            strict
          }, this);
          const handle = pair ? yield this._page.selectors.query(pair.frame, pair.info, this._frame === pair.frame ? this : void 0) : null;
          if (!handle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
          const result = yield handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
          handle.dispose();
          return result;
        });
      }
      evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
        return __async(this, null, function* () {
          const pair = yield this._frame.resolveFrameForSelectorNoWait(selector, {}, this);
          if (!pair)
            throw new Error(`Error: failed to find frame for selector "${selector}"`);
          const {
            frame,
            info
          } = pair;
          const arrayHandle = yield this._page.selectors._queryArrayInMainWorld(frame, info, this._frame === frame ? this : void 0);
          const result = yield arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
          arrayHandle.dispose();
          return result;
        });
      }
      isVisible() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "visible"), {});
          if (result === "error:notconnected")
            return false;
          return result;
        });
      }
      isHidden() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "hidden"), {});
          return throwRetargetableDOMError(result);
        });
      }
      isEnabled() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "enabled"), {});
          return throwRetargetableDOMError(result);
        });
      }
      isDisabled() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "disabled"), {});
          return throwRetargetableDOMError(result);
        });
      }
      isEditable() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "editable"), {});
          return throwRetargetableDOMError(result);
        });
      }
      isChecked() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "checked"), {});
          return throwRetargetableDOMError(result);
        });
      }
      waitForElementState(_0, _1) {
        return __async(this, arguments, function* (metadata, state, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            progress.log(`  waiting for element to be ${state}`);
            const result = yield this.evaluatePoll(progress, ([injected, node, state2]) => {
              return injected.waitForElementStatesAndPerformAction(node, [state2], false, () => "done");
            }, state);
            assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      waitForSelector(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._frame.waitForSelector(metadata, selector, options, this);
        });
      }
      _adoptTo(context) {
        return __async(this, null, function* () {
          if (this._context !== context) {
            const adopted = yield this._page._delegate.adoptElementHandle(this, context);
            this.dispose();
            return adopted;
          }
          return this;
        });
      }
      _waitForDisplayedAtStablePosition(progress, force, waitForEnabled) {
        return __async(this, null, function* () {
          if (waitForEnabled)
            progress.log(`  waiting for element to be visible, enabled and stable`);
          else
            progress.log(`  waiting for element to be visible and stable`);
          const result = yield this.evaluatePoll(progress, ([injected, node, {
            waitForEnabled: waitForEnabled2,
            force: force2
          }]) => {
            return injected.waitForElementStatesAndPerformAction(node, waitForEnabled2 ? ["visible", "stable", "enabled"] : ["visible", "stable"], force2, () => "done");
          }, {
            waitForEnabled,
            force
          });
          if (result === "error:notconnected")
            return result;
          if (waitForEnabled)
            progress.log("  element is visible, enabled and stable");
          else
            progress.log("  element is visible and stable");
          return result;
        });
      }
      _checkHitTargetAt(point) {
        return __async(this, null, function* () {
          const frame = yield this.ownerFrame();
          if (frame && frame.parentFrame()) {
            const element = yield frame.frameElement();
            const box = yield element.boundingBox();
            if (!box)
              return "error:notconnected";
            point = {
              x: point.x - box.x,
              y: point.y - box.y
            };
          }
          return this.evaluateInUtility(([injected, node, point2]) => injected.checkHitTargetAt(node, point2), point);
        });
      }
    };
    exports2.ElementHandle = ElementHandle;
    var InjectedScriptPollHandler = class {
      constructor(progress, poll) {
        this._progress = void 0;
        this._poll = void 0;
        this._progress = progress;
        this._poll = poll;
        this._progress.cleanupWhenAborted(() => this.cancel());
        this._streamLogs();
      }
      _streamLogs() {
        return __async(this, null, function* () {
          while (this._poll && this._progress.isRunning()) {
            const log = yield this._poll.evaluate((poll) => poll.takeNextLogs()).catch((e) => []);
            if (!this._poll || !this._progress.isRunning())
              return;
            for (const entry of log)
              this._progress.logEntry(entry);
          }
        });
      }
      finishHandle() {
        return __async(this, null, function* () {
          try {
            const result = yield this._poll.evaluateHandle((poll) => poll.run());
            yield this._finishInternal();
            return result;
          } finally {
            yield this.cancel();
          }
        });
      }
      finish() {
        return __async(this, null, function* () {
          try {
            const result = yield this._poll.evaluate((poll) => poll.run());
            yield this._finishInternal();
            return result;
          } finally {
            yield this.cancel();
          }
        });
      }
      _finishInternal() {
        return __async(this, null, function* () {
          if (!this._poll)
            return;
          const log = yield this._poll.evaluate((poll) => poll.takeLastLogs()).catch((e) => []);
          for (const entry of log)
            this._progress.logEntry(entry);
        });
      }
      cancel() {
        return __async(this, null, function* () {
          if (!this._poll)
            return;
          const copy = this._poll;
          this._poll = null;
          yield copy.evaluate((p) => p.cancel()).catch((e) => {
          });
          copy.dispose();
        });
      }
    };
    exports2.InjectedScriptPollHandler = InjectedScriptPollHandler;
    function throwRetargetableDOMError(result) {
      if (result === "error:notconnected")
        throw new Error("Element is not attached to the DOM");
      return result;
    }
    function assertDone(result) {
    }
    function roundPoint(point) {
      return {
        x: (point.x * 100 | 0) / 100,
        y: (point.y * 100 | 0) / 100
      };
    }
    function compensateHalfIntegerRoundingError(point) {
      const remainderX = point.x - Math.floor(point.x);
      if (remainderX > 0.49 && remainderX < 0.51)
        point.x -= 0.02;
      const remainderY = point.y - Math.floor(point.y);
      if (remainderY > 0.49 && remainderY < 0.51)
        point.y -= 0.02;
    }
    function waitForSelectorTask(selector, state, omitReturnValue, root) {
      return (injectedScript) => injectedScript.evaluateHandle((injected, {
        parsed,
        strict,
        state: state2,
        omitReturnValue: omitReturnValue2,
        root: root2
      }) => {
        let lastElement;
        return injected.pollRaf((progress) => {
          const elements = injected.querySelectorAll(parsed, root2 || document);
          let element = elements[0];
          const visible = element ? injected.isVisible(element) : false;
          if (lastElement !== element) {
            lastElement = element;
            if (!element) {
              progress.log(`  selector did not resolve to any element`);
            } else {
              if (elements.length > 1) {
                if (strict)
                  throw injected.strictModeViolationError(parsed, elements);
                progress.log(`  selector resolved to ${elements.length} elements. Proceeding with the first one.`);
              }
              progress.log(`  selector resolved to ${visible ? "visible" : "hidden"} ${injected.previewNode(element)}`);
            }
          }
          const hasElement = !!element;
          if (omitReturnValue2)
            element = void 0;
          switch (state2) {
            case "attached":
              return hasElement ? element : progress.continuePolling;
            case "detached":
              return !hasElement ? void 0 : progress.continuePolling;
            case "visible":
              return visible ? element : progress.continuePolling;
            case "hidden":
              return !visible ? void 0 : progress.continuePolling;
          }
        });
      }, {
        parsed: selector.parsed,
        strict: selector.strict,
        state,
        omitReturnValue,
        root
      });
    }
    var kUnableToAdoptErrorMessage = "Unable to adopt element handle from a different document";
    exports2.kUnableToAdoptErrorMessage = kUnableToAdoptErrorMessage;
  }
});

// node_modules/playwright-core/lib/common/types.js
var require_types = __commonJS({
  "node_modules/playwright-core/lib/common/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
  }
});

// node_modules/playwright-core/lib/server/types.js
var require_types2 = __commonJS({
  "node_modules/playwright-core/lib/server/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "Size", {
      enumerable: true,
      get: function() {
        return _types.Size;
      }
    });
    Object.defineProperty(exports2, "Point", {
      enumerable: true,
      get: function() {
        return _types.Point;
      }
    });
    Object.defineProperty(exports2, "Rect", {
      enumerable: true,
      get: function() {
        return _types.Rect;
      }
    });
    Object.defineProperty(exports2, "Quad", {
      enumerable: true,
      get: function() {
        return _types.Quad;
      }
    });
    Object.defineProperty(exports2, "URLMatch", {
      enumerable: true,
      get: function() {
        return _types.URLMatch;
      }
    });
    Object.defineProperty(exports2, "TimeoutOptions", {
      enumerable: true,
      get: function() {
        return _types.TimeoutOptions;
      }
    });
    exports2.forcedColors = exports2.reducedMotions = exports2.colorSchemes = exports2.mediaTypes = exports2.kLifecycleEvents = void 0;
    var _types = require_types();
    var kLifecycleEvents = /* @__PURE__ */ new Set(["load", "domcontentloaded", "networkidle", "commit"]);
    exports2.kLifecycleEvents = kLifecycleEvents;
    var mediaTypes = /* @__PURE__ */ new Set(["screen", "print"]);
    exports2.mediaTypes = mediaTypes;
    var colorSchemes = /* @__PURE__ */ new Set(["dark", "light", "no-preference"]);
    exports2.colorSchemes = colorSchemes;
    var reducedMotions = /* @__PURE__ */ new Set(["no-preference", "reduce"]);
    exports2.reducedMotions = reducedMotions;
    var forcedColors = /* @__PURE__ */ new Set(["active", "none"]);
    exports2.forcedColors = forcedColors;
  }
});

// node_modules/playwright-core/lib/server/common/selectorErrors.js
var require_selectorErrors = __commonJS({
  "node_modules/playwright-core/lib/server/common/selectorErrors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isInvalidSelectorError = isInvalidSelectorError;
    exports2.InvalidSelectorError = void 0;
    var InvalidSelectorError = class extends Error {
    };
    exports2.InvalidSelectorError = InvalidSelectorError;
    function isInvalidSelectorError(error) {
      return error instanceof InvalidSelectorError;
    }
  }
});

// node_modules/playwright-core/lib/server/common/cssTokenizer.js
var require_cssTokenizer = __commonJS({
  "node_modules/playwright-core/lib/server/common/cssTokenizer.js"(exports2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(["exports"], factory);
      } else if (typeof exports2 !== "undefined") {
        factory(exports2);
      } else {
        factory(root);
      }
    })(exports2, function(exports3) {
      var between = function(num, first, last) {
        return num >= first && num <= last;
      };
      function digit(code) {
        return between(code, 48, 57);
      }
      function hexdigit(code) {
        return digit(code) || between(code, 65, 70) || between(code, 97, 102);
      }
      function uppercaseletter(code) {
        return between(code, 65, 90);
      }
      function lowercaseletter(code) {
        return between(code, 97, 122);
      }
      function letter(code) {
        return uppercaseletter(code) || lowercaseletter(code);
      }
      function nonascii(code) {
        return code >= 128;
      }
      function namestartchar(code) {
        return letter(code) || nonascii(code) || code == 95;
      }
      function namechar(code) {
        return namestartchar(code) || digit(code) || code == 45;
      }
      function nonprintable(code) {
        return between(code, 0, 8) || code == 11 || between(code, 14, 31) || code == 127;
      }
      function newline(code) {
        return code == 10;
      }
      function whitespace(code) {
        return newline(code) || code == 9 || code == 32;
      }
      function badescape(code) {
        return newline(code) || isNaN(code);
      }
      var maximumallowedcodepoint = 1114111;
      var InvalidCharacterError = function(message) {
        this.message = message;
      };
      InvalidCharacterError.prototype = new Error();
      InvalidCharacterError.prototype.name = "InvalidCharacterError";
      function preprocess(str) {
        var codepoints = [];
        for (var i = 0; i < str.length; i++) {
          var code = str.charCodeAt(i);
          if (code == 13 && str.charCodeAt(i + 1) == 10) {
            code = 10;
            i++;
          }
          if (code == 13 || code == 12)
            code = 10;
          if (code == 0)
            code = 65533;
          if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {
            var lead = code - 55296;
            var trail = str.charCodeAt(i + 1) - 56320;
            code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
            i++;
          }
          codepoints.push(code);
        }
        return codepoints;
      }
      function stringFromCode(code) {
        if (code <= 65535)
          return String.fromCharCode(code);
        code -= Math.pow(2, 16);
        var lead = Math.floor(code / Math.pow(2, 10)) + 55296;
        var trail = code % Math.pow(2, 10) + 56320;
        return String.fromCharCode(lead) + String.fromCharCode(trail);
      }
      function tokenize(str) {
        str = preprocess(str);
        var i = -1;
        var tokens = [];
        var code;
        var line = 0;
        var column = 0;
        var lastLineLength = 0;
        var incrLineno = function() {
          line += 1;
          lastLineLength = column;
          column = 0;
        };
        var locStart = { line, column };
        var codepoint = function(i2) {
          if (i2 >= str.length) {
            return -1;
          }
          return str[i2];
        };
        var next = function(num) {
          if (num === void 0)
            num = 1;
          if (num > 3)
            throw "Spec Error: no more than three codepoints of lookahead.";
          return codepoint(i + num);
        };
        var consume = function(num) {
          if (num === void 0)
            num = 1;
          i += num;
          code = codepoint(i);
          if (newline(code))
            incrLineno();
          else
            column += num;
          return true;
        };
        var reconsume = function() {
          i -= 1;
          if (newline(code)) {
            line -= 1;
            column = lastLineLength;
          } else {
            column -= 1;
          }
          locStart.line = line;
          locStart.column = column;
          return true;
        };
        var eof = function(codepoint2) {
          if (codepoint2 === void 0)
            codepoint2 = code;
          return codepoint2 == -1;
        };
        var donothing = function() {
        };
        var parseerror = function() {
          console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");
          return true;
        };
        var consumeAToken = function() {
          consumeComments();
          consume();
          if (whitespace(code)) {
            while (whitespace(next()))
              consume();
            return new WhitespaceToken();
          } else if (code == 34)
            return consumeAStringToken();
          else if (code == 35) {
            if (namechar(next()) || areAValidEscape(next(1), next(2))) {
              var token = new HashToken();
              if (wouldStartAnIdentifier(next(1), next(2), next(3)))
                token.type = "id";
              token.value = consumeAName();
              return token;
            } else {
              return new DelimToken(code);
            }
          } else if (code == 36) {
            if (next() == 61) {
              consume();
              return new SuffixMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 39)
            return consumeAStringToken();
          else if (code == 40)
            return new OpenParenToken();
          else if (code == 41)
            return new CloseParenToken();
          else if (code == 42) {
            if (next() == 61) {
              consume();
              return new SubstringMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 43) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 44)
            return new CommaToken();
          else if (code == 45) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else if (next(1) == 45 && next(2) == 62) {
              consume(2);
              return new CDCToken();
            } else if (startsWithAnIdentifier()) {
              reconsume();
              return consumeAnIdentlikeToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 46) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 58)
            return new ColonToken();
          else if (code == 59)
            return new SemicolonToken();
          else if (code == 60) {
            if (next(1) == 33 && next(2) == 45 && next(3) == 45) {
              consume(3);
              return new CDOToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 64) {
            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
              return new AtKeywordToken(consumeAName());
            } else {
              return new DelimToken(code);
            }
          } else if (code == 91)
            return new OpenSquareToken();
          else if (code == 92) {
            if (startsWithAValidEscape()) {
              reconsume();
              return consumeAnIdentlikeToken();
            } else {
              parseerror();
              return new DelimToken(code);
            }
          } else if (code == 93)
            return new CloseSquareToken();
          else if (code == 94) {
            if (next() == 61) {
              consume();
              return new PrefixMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 123)
            return new OpenCurlyToken();
          else if (code == 124) {
            if (next() == 61) {
              consume();
              return new DashMatchToken();
            } else if (next() == 124) {
              consume();
              return new ColumnToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 125)
            return new CloseCurlyToken();
          else if (code == 126) {
            if (next() == 61) {
              consume();
              return new IncludeMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (digit(code)) {
            reconsume();
            return consumeANumericToken();
          } else if (namestartchar(code)) {
            reconsume();
            return consumeAnIdentlikeToken();
          } else if (eof())
            return new EOFToken();
          else
            return new DelimToken(code);
        };
        var consumeComments = function() {
          while (next(1) == 47 && next(2) == 42) {
            consume(2);
            while (true) {
              consume();
              if (code == 42 && next() == 47) {
                consume();
                break;
              } else if (eof()) {
                parseerror();
                return;
              }
            }
          }
        };
        var consumeANumericToken = function() {
          var num = consumeANumber();
          if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
            var token = new DimensionToken();
            token.value = num.value;
            token.repr = num.repr;
            token.type = num.type;
            token.unit = consumeAName();
            return token;
          } else if (next() == 37) {
            consume();
            var token = new PercentageToken();
            token.value = num.value;
            token.repr = num.repr;
            return token;
          } else {
            var token = new NumberToken();
            token.value = num.value;
            token.repr = num.repr;
            token.type = num.type;
            return token;
          }
        };
        var consumeAnIdentlikeToken = function() {
          var str2 = consumeAName();
          if (str2.toLowerCase() == "url" && next() == 40) {
            consume();
            while (whitespace(next(1)) && whitespace(next(2)))
              consume();
            if (next() == 34 || next() == 39) {
              return new FunctionToken(str2);
            } else if (whitespace(next()) && (next(2) == 34 || next(2) == 39)) {
              return new FunctionToken(str2);
            } else {
              return consumeAURLToken();
            }
          } else if (next() == 40) {
            consume();
            return new FunctionToken(str2);
          } else {
            return new IdentToken(str2);
          }
        };
        var consumeAStringToken = function(endingCodePoint) {
          if (endingCodePoint === void 0)
            endingCodePoint = code;
          var string = "";
          while (consume()) {
            if (code == endingCodePoint || eof()) {
              return new StringToken(string);
            } else if (newline(code)) {
              parseerror();
              reconsume();
              return new BadStringToken();
            } else if (code == 92) {
              if (eof(next())) {
                donothing();
              } else if (newline(next())) {
                consume();
              } else {
                string += stringFromCode(consumeEscape());
              }
            } else {
              string += stringFromCode(code);
            }
          }
        };
        var consumeAURLToken = function() {
          var token = new URLToken("");
          while (whitespace(next()))
            consume();
          if (eof(next()))
            return token;
          while (consume()) {
            if (code == 41 || eof()) {
              return token;
            } else if (whitespace(code)) {
              while (whitespace(next()))
                consume();
              if (next() == 41 || eof(next())) {
                consume();
                return token;
              } else {
                consumeTheRemnantsOfABadURL();
                return new BadURLToken();
              }
            } else if (code == 34 || code == 39 || code == 40 || nonprintable(code)) {
              parseerror();
              consumeTheRemnantsOfABadURL();
              return new BadURLToken();
            } else if (code == 92) {
              if (startsWithAValidEscape()) {
                token.value += stringFromCode(consumeEscape());
              } else {
                parseerror();
                consumeTheRemnantsOfABadURL();
                return new BadURLToken();
              }
            } else {
              token.value += stringFromCode(code);
            }
          }
        };
        var consumeEscape = function() {
          consume();
          if (hexdigit(code)) {
            var digits = [code];
            for (var total = 0; total < 5; total++) {
              if (hexdigit(next())) {
                consume();
                digits.push(code);
              } else {
                break;
              }
            }
            if (whitespace(next()))
              consume();
            var value = parseInt(digits.map(function(x) {
              return String.fromCharCode(x);
            }).join(""), 16);
            if (value > maximumallowedcodepoint)
              value = 65533;
            return value;
          } else if (eof()) {
            return 65533;
          } else {
            return code;
          }
        };
        var areAValidEscape = function(c1, c2) {
          if (c1 != 92)
            return false;
          if (newline(c2))
            return false;
          return true;
        };
        var startsWithAValidEscape = function() {
          return areAValidEscape(code, next());
        };
        var wouldStartAnIdentifier = function(c1, c2, c3) {
          if (c1 == 45) {
            return namestartchar(c2) || c2 == 45 || areAValidEscape(c2, c3);
          } else if (namestartchar(c1)) {
            return true;
          } else if (c1 == 92) {
            return areAValidEscape(c1, c2);
          } else {
            return false;
          }
        };
        var startsWithAnIdentifier = function() {
          return wouldStartAnIdentifier(code, next(1), next(2));
        };
        var wouldStartANumber = function(c1, c2, c3) {
          if (c1 == 43 || c1 == 45) {
            if (digit(c2))
              return true;
            if (c2 == 46 && digit(c3))
              return true;
            return false;
          } else if (c1 == 46) {
            if (digit(c2))
              return true;
            return false;
          } else if (digit(c1)) {
            return true;
          } else {
            return false;
          }
        };
        var startsWithANumber = function() {
          return wouldStartANumber(code, next(1), next(2));
        };
        var consumeAName = function() {
          var result = "";
          while (consume()) {
            if (namechar(code)) {
              result += stringFromCode(code);
            } else if (startsWithAValidEscape()) {
              result += stringFromCode(consumeEscape());
            } else {
              reconsume();
              return result;
            }
          }
        };
        var consumeANumber = function() {
          var repr = [];
          var type = "integer";
          if (next() == 43 || next() == 45) {
            consume();
            repr += stringFromCode(code);
          }
          while (digit(next())) {
            consume();
            repr += stringFromCode(code);
          }
          if (next(1) == 46 && digit(next(2))) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          }
          var c1 = next(1), c2 = next(2), c3 = next(3);
          if ((c1 == 69 || c1 == 101) && digit(c2)) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          } else if ((c1 == 69 || c1 == 101) && (c2 == 43 || c2 == 45) && digit(c3)) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          }
          var value = convertAStringToANumber(repr);
          return { type, value, repr };
        };
        var convertAStringToANumber = function(string) {
          return +string;
        };
        var consumeTheRemnantsOfABadURL = function() {
          while (consume()) {
            if (code == 41 || eof()) {
              return;
            } else if (startsWithAValidEscape()) {
              consumeEscape();
              donothing();
            } else {
              donothing();
            }
          }
        };
        var iterationCount = 0;
        while (!eof(next())) {
          tokens.push(consumeAToken());
          iterationCount++;
          if (iterationCount > str.length * 2)
            return "I'm infinite-looping!";
        }
        return tokens;
      }
      function CSSParserToken() {
        throw "Abstract Base Class";
      }
      CSSParserToken.prototype.toJSON = function() {
        return { token: this.tokenType };
      };
      CSSParserToken.prototype.toString = function() {
        return this.tokenType;
      };
      CSSParserToken.prototype.toSource = function() {
        return "" + this;
      };
      function BadStringToken() {
        return this;
      }
      BadStringToken.prototype = Object.create(CSSParserToken.prototype);
      BadStringToken.prototype.tokenType = "BADSTRING";
      function BadURLToken() {
        return this;
      }
      BadURLToken.prototype = Object.create(CSSParserToken.prototype);
      BadURLToken.prototype.tokenType = "BADURL";
      function WhitespaceToken() {
        return this;
      }
      WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
      WhitespaceToken.prototype.tokenType = "WHITESPACE";
      WhitespaceToken.prototype.toString = function() {
        return "WS";
      };
      WhitespaceToken.prototype.toSource = function() {
        return " ";
      };
      function CDOToken() {
        return this;
      }
      CDOToken.prototype = Object.create(CSSParserToken.prototype);
      CDOToken.prototype.tokenType = "CDO";
      CDOToken.prototype.toSource = function() {
        return "<!--";
      };
      function CDCToken() {
        return this;
      }
      CDCToken.prototype = Object.create(CSSParserToken.prototype);
      CDCToken.prototype.tokenType = "CDC";
      CDCToken.prototype.toSource = function() {
        return "-->";
      };
      function ColonToken() {
        return this;
      }
      ColonToken.prototype = Object.create(CSSParserToken.prototype);
      ColonToken.prototype.tokenType = ":";
      function SemicolonToken() {
        return this;
      }
      SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
      SemicolonToken.prototype.tokenType = ";";
      function CommaToken() {
        return this;
      }
      CommaToken.prototype = Object.create(CSSParserToken.prototype);
      CommaToken.prototype.tokenType = ",";
      function GroupingToken() {
        throw "Abstract Base Class";
      }
      GroupingToken.prototype = Object.create(CSSParserToken.prototype);
      function OpenCurlyToken() {
        this.value = "{";
        this.mirror = "}";
        return this;
      }
      OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
      OpenCurlyToken.prototype.tokenType = "{";
      function CloseCurlyToken() {
        this.value = "}";
        this.mirror = "{";
        return this;
      }
      CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
      CloseCurlyToken.prototype.tokenType = "}";
      function OpenSquareToken() {
        this.value = "[";
        this.mirror = "]";
        return this;
      }
      OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
      OpenSquareToken.prototype.tokenType = "[";
      function CloseSquareToken() {
        this.value = "]";
        this.mirror = "[";
        return this;
      }
      CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
      CloseSquareToken.prototype.tokenType = "]";
      function OpenParenToken() {
        this.value = "(";
        this.mirror = ")";
        return this;
      }
      OpenParenToken.prototype = Object.create(GroupingToken.prototype);
      OpenParenToken.prototype.tokenType = "(";
      function CloseParenToken() {
        this.value = ")";
        this.mirror = "(";
        return this;
      }
      CloseParenToken.prototype = Object.create(GroupingToken.prototype);
      CloseParenToken.prototype.tokenType = ")";
      function IncludeMatchToken() {
        return this;
      }
      IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
      IncludeMatchToken.prototype.tokenType = "~=";
      function DashMatchToken() {
        return this;
      }
      DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
      DashMatchToken.prototype.tokenType = "|=";
      function PrefixMatchToken() {
        return this;
      }
      PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
      PrefixMatchToken.prototype.tokenType = "^=";
      function SuffixMatchToken() {
        return this;
      }
      SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
      SuffixMatchToken.prototype.tokenType = "$=";
      function SubstringMatchToken() {
        return this;
      }
      SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
      SubstringMatchToken.prototype.tokenType = "*=";
      function ColumnToken() {
        return this;
      }
      ColumnToken.prototype = Object.create(CSSParserToken.prototype);
      ColumnToken.prototype.tokenType = "||";
      function EOFToken() {
        return this;
      }
      EOFToken.prototype = Object.create(CSSParserToken.prototype);
      EOFToken.prototype.tokenType = "EOF";
      EOFToken.prototype.toSource = function() {
        return "";
      };
      function DelimToken(code) {
        this.value = stringFromCode(code);
        return this;
      }
      DelimToken.prototype = Object.create(CSSParserToken.prototype);
      DelimToken.prototype.tokenType = "DELIM";
      DelimToken.prototype.toString = function() {
        return "DELIM(" + this.value + ")";
      };
      DelimToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
      };
      DelimToken.prototype.toSource = function() {
        if (this.value == "\\")
          return "\\\n";
        else
          return this.value;
      };
      function StringValuedToken() {
        throw "Abstract Base Class";
      }
      StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
      StringValuedToken.prototype.ASCIIMatch = function(str) {
        return this.value.toLowerCase() == str.toLowerCase();
      };
      StringValuedToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
      };
      function IdentToken(val) {
        this.value = val;
      }
      IdentToken.prototype = Object.create(StringValuedToken.prototype);
      IdentToken.prototype.tokenType = "IDENT";
      IdentToken.prototype.toString = function() {
        return "IDENT(" + this.value + ")";
      };
      IdentToken.prototype.toSource = function() {
        return escapeIdent(this.value);
      };
      function FunctionToken(val) {
        this.value = val;
        this.mirror = ")";
      }
      FunctionToken.prototype = Object.create(StringValuedToken.prototype);
      FunctionToken.prototype.tokenType = "FUNCTION";
      FunctionToken.prototype.toString = function() {
        return "FUNCTION(" + this.value + ")";
      };
      FunctionToken.prototype.toSource = function() {
        return escapeIdent(this.value) + "(";
      };
      function AtKeywordToken(val) {
        this.value = val;
      }
      AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
      AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
      AtKeywordToken.prototype.toString = function() {
        return "AT(" + this.value + ")";
      };
      AtKeywordToken.prototype.toSource = function() {
        return "@" + escapeIdent(this.value);
      };
      function HashToken(val) {
        this.value = val;
        this.type = "unrestricted";
      }
      HashToken.prototype = Object.create(StringValuedToken.prototype);
      HashToken.prototype.tokenType = "HASH";
      HashToken.prototype.toString = function() {
        return "HASH(" + this.value + ")";
      };
      HashToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        return json;
      };
      HashToken.prototype.toSource = function() {
        if (this.type == "id") {
          return "#" + escapeIdent(this.value);
        } else {
          return "#" + escapeHash(this.value);
        }
      };
      function StringToken(val) {
        this.value = val;
      }
      StringToken.prototype = Object.create(StringValuedToken.prototype);
      StringToken.prototype.tokenType = "STRING";
      StringToken.prototype.toString = function() {
        return '"' + escapeString(this.value) + '"';
      };
      function URLToken(val) {
        this.value = val;
      }
      URLToken.prototype = Object.create(StringValuedToken.prototype);
      URLToken.prototype.tokenType = "URL";
      URLToken.prototype.toString = function() {
        return "URL(" + this.value + ")";
      };
      URLToken.prototype.toSource = function() {
        return 'url("' + escapeString(this.value) + '")';
      };
      function NumberToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
      }
      NumberToken.prototype = Object.create(CSSParserToken.prototype);
      NumberToken.prototype.tokenType = "NUMBER";
      NumberToken.prototype.toString = function() {
        if (this.type == "integer")
          return "INT(" + this.value + ")";
        return "NUMBER(" + this.value + ")";
      };
      NumberToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        return json;
      };
      NumberToken.prototype.toSource = function() {
        return this.repr;
      };
      function PercentageToken() {
        this.value = null;
        this.repr = "";
      }
      PercentageToken.prototype = Object.create(CSSParserToken.prototype);
      PercentageToken.prototype.tokenType = "PERCENTAGE";
      PercentageToken.prototype.toString = function() {
        return "PERCENTAGE(" + this.value + ")";
      };
      PercentageToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.repr = this.repr;
        return json;
      };
      PercentageToken.prototype.toSource = function() {
        return this.repr + "%";
      };
      function DimensionToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
        this.unit = "";
      }
      DimensionToken.prototype = Object.create(CSSParserToken.prototype);
      DimensionToken.prototype.tokenType = "DIMENSION";
      DimensionToken.prototype.toString = function() {
        return "DIM(" + this.value + "," + this.unit + ")";
      };
      DimensionToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        json.unit = this.unit;
        return json;
      };
      DimensionToken.prototype.toSource = function() {
        var source = this.repr;
        var unit = escapeIdent(this.unit);
        if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 48, 57))) {
          unit = "\\65 " + unit.slice(1, unit.length);
        }
        return source + unit;
      };
      function escapeIdent(string) {
        string = "" + string;
        var result = "";
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (between(code, 1, 31) || code == 127 || i == 0 && between(code, 48, 57) || i == 1 && between(code, 48, 57) && firstcode == 45) {
            result += "\\" + code.toString(16) + " ";
          } else if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {
            result += string[i];
          } else {
            result += "\\" + string[i];
          }
        }
        return result;
      }
      function escapeHash(string) {
        string = "" + string;
        var result = "";
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {
            result += string[i];
          } else {
            result += "\\" + code.toString(16) + " ";
          }
        }
        return result;
      }
      function escapeString(string) {
        string = "" + string;
        var result = "";
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (between(code, 1, 31) || code == 127) {
            result += "\\" + code.toString(16) + " ";
          } else if (code == 34 || code == 92) {
            result += "\\" + string[i];
          } else {
            result += string[i];
          }
        }
        return result;
      }
      exports3.tokenize = tokenize;
      exports3.IdentToken = IdentToken;
      exports3.FunctionToken = FunctionToken;
      exports3.AtKeywordToken = AtKeywordToken;
      exports3.HashToken = HashToken;
      exports3.StringToken = StringToken;
      exports3.BadStringToken = BadStringToken;
      exports3.URLToken = URLToken;
      exports3.BadURLToken = BadURLToken;
      exports3.DelimToken = DelimToken;
      exports3.NumberToken = NumberToken;
      exports3.PercentageToken = PercentageToken;
      exports3.DimensionToken = DimensionToken;
      exports3.IncludeMatchToken = IncludeMatchToken;
      exports3.DashMatchToken = DashMatchToken;
      exports3.PrefixMatchToken = PrefixMatchToken;
      exports3.SuffixMatchToken = SuffixMatchToken;
      exports3.SubstringMatchToken = SubstringMatchToken;
      exports3.ColumnToken = ColumnToken;
      exports3.WhitespaceToken = WhitespaceToken;
      exports3.CDOToken = CDOToken;
      exports3.CDCToken = CDCToken;
      exports3.ColonToken = ColonToken;
      exports3.SemicolonToken = SemicolonToken;
      exports3.CommaToken = CommaToken;
      exports3.OpenParenToken = OpenParenToken;
      exports3.CloseParenToken = CloseParenToken;
      exports3.OpenSquareToken = OpenSquareToken;
      exports3.CloseSquareToken = CloseSquareToken;
      exports3.OpenCurlyToken = OpenCurlyToken;
      exports3.CloseCurlyToken = CloseCurlyToken;
      exports3.EOFToken = EOFToken;
      exports3.CSSParserToken = CSSParserToken;
      exports3.GroupingToken = GroupingToken;
    });
  }
});

// node_modules/playwright-core/lib/server/common/cssParser.js
var require_cssParser = __commonJS({
  "node_modules/playwright-core/lib/server/common/cssParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parseCSS = parseCSS;
    exports2.serializeSelector = serializeSelector;
    var _selectorErrors = require_selectorErrors();
    var css = _interopRequireWildcard2(require_cssTokenizer());
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function parseCSS(selector, customNames) {
      let tokens;
      try {
        tokens = css.tokenize(selector);
        if (!(tokens[tokens.length - 1] instanceof css.EOFToken))
          tokens.push(new css.EOFToken());
      } catch (e) {
        const newMessage = e.message + ` while parsing selector "${selector}"`;
        const index = (e.stack || "").indexOf(e.message);
        if (index !== -1)
          e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);
        e.message = newMessage;
        throw e;
      }
      const unsupportedToken = tokens.find((token) => {
        return token instanceof css.AtKeywordToken || token instanceof css.BadStringToken || token instanceof css.BadURLToken || token instanceof css.ColumnToken || token instanceof css.CDOToken || token instanceof css.CDCToken || token instanceof css.SemicolonToken || token instanceof css.OpenCurlyToken || token instanceof css.CloseCurlyToken || token instanceof css.URLToken || token instanceof css.PercentageToken;
      });
      if (unsupportedToken)
        throw new _selectorErrors.InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing selector "${selector}"`);
      let pos = 0;
      const names = /* @__PURE__ */ new Set();
      function unexpected() {
        return new _selectorErrors.InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing selector "${selector}"`);
      }
      function skipWhitespace() {
        while (tokens[pos] instanceof css.WhitespaceToken)
          pos++;
      }
      function isIdent(p = pos) {
        return tokens[p] instanceof css.IdentToken;
      }
      function isString(p = pos) {
        return tokens[p] instanceof css.StringToken;
      }
      function isNumber(p = pos) {
        return tokens[p] instanceof css.NumberToken;
      }
      function isComma(p = pos) {
        return tokens[p] instanceof css.CommaToken;
      }
      function isCloseParen(p = pos) {
        return tokens[p] instanceof css.CloseParenToken;
      }
      function isStar(p = pos) {
        return tokens[p] instanceof css.DelimToken && tokens[p].value === "*";
      }
      function isEOF(p = pos) {
        return tokens[p] instanceof css.EOFToken;
      }
      function isClauseCombinator(p = pos) {
        return tokens[p] instanceof css.DelimToken && [">", "+", "~"].includes(tokens[p].value);
      }
      function isSelectorClauseEnd(p = pos) {
        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof css.WhitespaceToken;
      }
      function consumeFunctionArguments() {
        const result2 = [consumeArgument()];
        while (true) {
          skipWhitespace();
          if (!isComma())
            break;
          pos++;
          result2.push(consumeArgument());
        }
        return result2;
      }
      function consumeArgument() {
        skipWhitespace();
        if (isNumber())
          return tokens[pos++].value;
        if (isString())
          return tokens[pos++].value;
        return consumeComplexSelector();
      }
      function consumeComplexSelector() {
        const result2 = {
          simples: []
        };
        skipWhitespace();
        if (isClauseCombinator()) {
          result2.simples.push({
            selector: {
              functions: [{
                name: "scope",
                args: []
              }]
            },
            combinator: ""
          });
        } else {
          result2.simples.push({
            selector: consumeSimpleSelector(),
            combinator: ""
          });
        }
        while (true) {
          skipWhitespace();
          if (isClauseCombinator()) {
            result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;
            skipWhitespace();
          } else if (isSelectorClauseEnd()) {
            break;
          }
          result2.simples.push({
            combinator: "",
            selector: consumeSimpleSelector()
          });
        }
        return result2;
      }
      function consumeSimpleSelector() {
        let rawCSSString = "";
        const functions = [];
        while (!isSelectorClauseEnd()) {
          if (isIdent() || isStar()) {
            rawCSSString += tokens[pos++].toSource();
          } else if (tokens[pos] instanceof css.HashToken) {
            rawCSSString += tokens[pos++].toSource();
          } else if (tokens[pos] instanceof css.DelimToken && tokens[pos].value === ".") {
            pos++;
            if (isIdent())
              rawCSSString += "." + tokens[pos++].toSource();
            else
              throw unexpected();
          } else if (tokens[pos] instanceof css.ColonToken) {
            pos++;
            if (isIdent()) {
              if (!customNames.has(tokens[pos].value.toLowerCase())) {
                rawCSSString += ":" + tokens[pos++].toSource();
              } else {
                const name = tokens[pos++].value.toLowerCase();
                functions.push({
                  name,
                  args: []
                });
                names.add(name);
              }
            } else if (tokens[pos] instanceof css.FunctionToken) {
              const name = tokens[pos++].value.toLowerCase();
              if (!customNames.has(name)) {
                rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;
              } else {
                functions.push({
                  name,
                  args: consumeFunctionArguments()
                });
                names.add(name);
              }
              skipWhitespace();
              if (!isCloseParen())
                throw unexpected();
              pos++;
            } else {
              throw unexpected();
            }
          } else if (tokens[pos] instanceof css.OpenSquareToken) {
            rawCSSString += "[";
            pos++;
            while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())
              rawCSSString += tokens[pos++].toSource();
            if (!(tokens[pos] instanceof css.CloseSquareToken))
              throw unexpected();
            rawCSSString += "]";
            pos++;
          } else {
            throw unexpected();
          }
        }
        if (!rawCSSString && !functions.length)
          throw unexpected();
        return {
          css: rawCSSString || void 0,
          functions
        };
      }
      function consumeBuiltinFunctionArguments() {
        let s = "";
        while (!isCloseParen() && !isEOF())
          s += tokens[pos++].toSource();
        return s;
      }
      const result = consumeFunctionArguments();
      if (!isEOF())
        throw new _selectorErrors.InvalidSelectorError(`Error while parsing selector "${selector}"`);
      if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))
        throw new _selectorErrors.InvalidSelectorError(`Error while parsing selector "${selector}"`);
      return {
        selector: result,
        names: Array.from(names)
      };
    }
    function serializeSelector(args) {
      return args.map((arg) => {
        if (typeof arg === "string")
          return `"${arg}"`;
        if (typeof arg === "number")
          return String(arg);
        return arg.simples.map(({
          selector,
          combinator
        }) => {
          let s = selector.css || "";
          s = s + selector.functions.map((func) => `:${func.name}(${serializeSelector(func.args)})`).join("");
          if (combinator)
            s += " " + combinator;
          return s;
        }).join(" ");
      }).join(", ");
    }
  }
});

// node_modules/playwright-core/lib/server/common/selectorParser.js
var require_selectorParser = __commonJS({
  "node_modules/playwright-core/lib/server/common/selectorParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parseSelector = parseSelector;
    exports2.splitSelectorByFrame = splitSelectorByFrame;
    exports2.stringifySelector = stringifySelector;
    exports2.customCSSNames = void 0;
    var _selectorErrors = require_selectorErrors();
    var _cssParser = require_cssParser();
    var customCSSNames = /* @__PURE__ */ new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);
    exports2.customCSSNames = customCSSNames;
    function parseSelector(selector) {
      const result = parseSelectorString(selector);
      const parts = result.parts.map((part) => {
        if (part.name === "css" || part.name === "css:light") {
          if (part.name === "css:light")
            part.body = ":light(" + part.body + ")";
          const parsedCSS = (0, _cssParser.parseCSS)(part.body, customCSSNames);
          return {
            name: "css",
            body: parsedCSS.selector,
            source: part.body
          };
        }
        return __spreadProps(__spreadValues({}, part), {
          source: part.body
        });
      });
      return {
        capture: result.capture,
        parts
      };
    }
    function splitSelectorByFrame(selectorText) {
      const selector = parseSelector(selectorText);
      const result = [];
      let chunk = {
        parts: []
      };
      let chunkStartIndex = 0;
      for (let i = 0; i < selector.parts.length; ++i) {
        const part = selector.parts[i];
        if (part.name === "control" && part.body === "enter-frame") {
          if (!chunk.parts.length)
            throw new _selectorErrors.InvalidSelectorError("Selector cannot start with entering frame, select the iframe first");
          result.push(chunk);
          chunk = {
            parts: []
          };
          chunkStartIndex = i + 1;
          continue;
        }
        if (selector.capture === i)
          chunk.capture = i - chunkStartIndex;
        chunk.parts.push(part);
      }
      if (!chunk.parts.length)
        throw new _selectorErrors.InvalidSelectorError(`Selector cannot end with entering frame, while parsing selector ${selectorText}`);
      result.push(chunk);
      if (typeof selector.capture === "number" && typeof result[result.length - 1].capture !== "number")
        throw new _selectorErrors.InvalidSelectorError(`Can not capture the selector before diving into the frame. Only use * after the last frame has been selected`);
      return result;
    }
    function stringifySelector(selector) {
      if (typeof selector === "string")
        return selector;
      return selector.parts.map((p, i) => {
        const prefix = p.name === "css" ? "" : p.name + "=";
        return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;
      }).join(" >> ");
    }
    function parseSelectorString(selector) {
      let index = 0;
      let quote;
      let start = 0;
      const result = {
        parts: []
      };
      const append = () => {
        const part = selector.substring(start, index).trim();
        const eqIndex = part.indexOf("=");
        let name;
        let body;
        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
          name = part.substring(0, eqIndex).trim();
          body = part.substring(eqIndex + 1);
        } else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
          name = "text";
          body = part;
        } else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
          name = "text";
          body = part;
        } else if (/^\(*\/\//.test(part) || part.startsWith("..")) {
          name = "xpath";
          body = part;
        } else {
          name = "css";
          body = part;
        }
        let capture = false;
        if (name[0] === "*") {
          capture = true;
          name = name.substring(1);
        }
        result.parts.push({
          name,
          body
        });
        if (capture) {
          if (result.capture !== void 0)
            throw new _selectorErrors.InvalidSelectorError(`Only one of the selectors can capture using * modifier`);
          result.capture = result.parts.length - 1;
        }
      };
      if (!selector.includes(">>")) {
        index = selector.length;
        append();
        return result;
      }
      while (index < selector.length) {
        const c = selector[index];
        if (c === "\\" && index + 1 < selector.length) {
          index += 2;
        } else if (c === quote) {
          quote = void 0;
          index++;
        } else if (!quote && (c === '"' || c === "'" || c === "`")) {
          quote = c;
          index++;
        } else if (!quote && c === ">" && selector[index + 1] === ">") {
          append();
          index += 2;
          start = index;
        } else {
          index++;
        }
      }
      append();
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/frames.js
var require_frames = __commonJS({
  "node_modules/playwright-core/lib/server/frames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Frame = exports2.FrameManager = void 0;
    var dom = _interopRequireWildcard2(require_dom());
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var js = _interopRequireWildcard2(require_javascript());
    var network = _interopRequireWildcard2(require_network());
    var _page = require_page();
    var types = _interopRequireWildcard2(require_types2());
    var _browserContext = require_browserContext();
    var _progress = require_progress2();
    var _utils2 = require_utils();
    var _async = require_async();
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    var _protocolError = require_protocolError();
    var _selectorParser = require_selectorParser();
    var _selectorErrors = require_selectorErrors();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FrameManager = class {
      constructor(page) {
        this._page = void 0;
        this._frames = /* @__PURE__ */ new Map();
        this._mainFrame = void 0;
        this._consoleMessageTags = /* @__PURE__ */ new Map();
        this._signalBarriers = /* @__PURE__ */ new Set();
        this._webSockets = /* @__PURE__ */ new Map();
        this._dialogCounter = 0;
        this._page = page;
        this._mainFrame = void 0;
      }
      dispose() {
        for (const frame of this._frames.values())
          frame._stopNetworkIdleTimer();
      }
      mainFrame() {
        return this._mainFrame;
      }
      frames() {
        const frames = [];
        collect(this._mainFrame);
        return frames;
        function collect(frame) {
          frames.push(frame);
          for (const subframe of frame.childFrames())
            collect(subframe);
        }
      }
      frame(frameId) {
        return this._frames.get(frameId) || null;
      }
      frameAttached(frameId, parentFrameId) {
        const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
        if (!parentFrame) {
          if (this._mainFrame) {
            this._frames.delete(this._mainFrame._id);
            this._mainFrame._id = frameId;
          } else {
            (0, _utils2.assert)(!this._frames.has(frameId));
            this._mainFrame = new Frame(this._page, frameId, parentFrame);
          }
          this._frames.set(frameId, this._mainFrame);
          return this._mainFrame;
        } else {
          (0, _utils2.assert)(!this._frames.has(frameId));
          const frame = new Frame(this._page, frameId, parentFrame);
          this._frames.set(frameId, frame);
          this._page.emit(_page.Page.Events.FrameAttached, frame);
          return frame;
        }
      }
      waitForSignalsCreatedBy(progress, noWaitAfter, action, source) {
        return __async(this, null, function* () {
          if (noWaitAfter)
            return action();
          const barrier = new SignalBarrier(progress);
          this._signalBarriers.add(barrier);
          if (progress)
            progress.cleanupWhenAborted(() => this._signalBarriers.delete(barrier));
          const result = yield action();
          if (source === "input")
            yield this._page._delegate.inputActionEpilogue();
          yield barrier.waitFor();
          this._signalBarriers.delete(barrier);
          yield new Promise((0, _utils2.makeWaitForNextTask)());
          return result;
        });
      }
      frameWillPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
          barrier.retain();
      }
      frameDidPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
          barrier.release();
      }
      frameRequestedNavigation(frameId, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        for (const barrier of this._signalBarriers)
          barrier.addFrameNavigation(frame);
        if (frame.pendingDocument() && frame.pendingDocument().documentId === documentId) {
          return;
        }
        frame.setPendingDocument({
          documentId,
          request: void 0
        });
      }
      frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {
        const frame = this._frames.get(frameId);
        this.removeChildFramesRecursively(frame);
        this.clearWebSockets(frame);
        frame._url = url;
        frame._name = name;
        let keepPending;
        const pendingDocument = frame.pendingDocument();
        if (pendingDocument) {
          if (pendingDocument.documentId === void 0) {
            pendingDocument.documentId = documentId;
          }
          if (pendingDocument.documentId === documentId) {
            frame._currentDocument = pendingDocument;
          } else {
            keepPending = pendingDocument;
            frame._currentDocument = {
              documentId,
              request: void 0
            };
          }
          frame.setPendingDocument(void 0);
        } else {
          frame._currentDocument = {
            documentId,
            request: void 0
          };
        }
        frame._onClearLifecycle();
        const navigationEvent = {
          url,
          name,
          newDocument: frame._currentDocument
        };
        frame.emit(Frame.Events.Navigation, navigationEvent);
        if (!initial) {
          _debugLogger.debugLogger.log("api", `  navigated to "${url}"`);
          this._page.frameNavigatedToNewDocument(frame);
        }
        frame.setPendingDocument(keepPending);
      }
      frameCommittedSameDocumentNavigation(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        frame._url = url;
        const navigationEvent = {
          url,
          name: frame._name
        };
        frame.emit(Frame.Events.Navigation, navigationEvent);
        _debugLogger.debugLogger.log("api", `  navigated to "${url}"`);
      }
      frameAbortedNavigation(frameId, errorText, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame || !frame.pendingDocument())
          return;
        if (documentId !== void 0 && frame.pendingDocument().documentId !== documentId)
          return;
        const navigationEvent = {
          url: frame._url,
          name: frame._name,
          newDocument: frame.pendingDocument(),
          error: new Error(errorText)
        };
        frame.setPendingDocument(void 0);
        frame.emit(Frame.Events.Navigation, navigationEvent);
      }
      frameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
          this._removeFramesRecursively(frame);
      }
      frameStoppedLoading(frameId) {
        this.frameLifecycleEvent(frameId, "domcontentloaded");
        this.frameLifecycleEvent(frameId, "load");
      }
      frameLifecycleEvent(frameId, event) {
        const frame = this._frames.get(frameId);
        if (frame)
          frame._onLifecycleEvent(event);
      }
      requestStarted(request, route) {
        const frame = request.frame();
        this._inflightRequestStarted(request);
        if (request._documentId)
          frame.setPendingDocument({
            documentId: request._documentId,
            request
          });
        if (request._isFavicon) {
          if (route)
            route.continue(request, {});
          return;
        }
        this._page._browserContext.emit(_browserContext.BrowserContext.Events.Request, request);
        if (route)
          this._page._requestStarted(request, route);
      }
      requestReceivedResponse(response) {
        if (response.request()._isFavicon)
          return;
        this._page._browserContext.emit(_browserContext.BrowserContext.Events.Response, response);
      }
      reportRequestFinished(request, response) {
        this._inflightRequestFinished(request);
        if (request._isFavicon)
          return;
        this._page._browserContext.emit(_browserContext.BrowserContext.Events.RequestFinished, {
          request,
          response
        });
      }
      requestFailed(request, canceled) {
        const frame = request.frame();
        this._inflightRequestFinished(request);
        if (frame.pendingDocument() && frame.pendingDocument().request === request) {
          let errorText = request.failure().errorText;
          if (canceled)
            errorText += "; maybe frame was detached?";
          this.frameAbortedNavigation(frame._id, errorText, frame.pendingDocument().documentId);
        }
        if (request._isFavicon)
          return;
        this._page._browserContext.emit(_browserContext.BrowserContext.Events.RequestFailed, request);
      }
      dialogDidOpen() {
        for (const frame of this._frames.values())
          frame._invalidateNonStallingEvaluations("JavaScript dialog interrupted evaluation");
        this._dialogCounter++;
      }
      dialogWillClose() {
        this._dialogCounter--;
      }
      removeChildFramesRecursively(frame) {
        for (const child of frame.childFrames())
          this._removeFramesRecursively(child);
      }
      _removeFramesRecursively(frame) {
        this.removeChildFramesRecursively(frame);
        frame._onDetached();
        this._frames.delete(frame._id);
        if (!this._page.isClosed())
          this._page.emit(_page.Page.Events.FrameDetached, frame);
      }
      _inflightRequestFinished(request) {
        const frame = request.frame();
        if (request._isFavicon)
          return;
        if (!frame._inflightRequests.has(request))
          return;
        frame._inflightRequests.delete(request);
        if (frame._inflightRequests.size === 0)
          frame._startNetworkIdleTimer();
      }
      _inflightRequestStarted(request) {
        const frame = request.frame();
        if (request._isFavicon)
          return;
        frame._inflightRequests.add(request);
        if (frame._inflightRequests.size === 1)
          frame._stopNetworkIdleTimer();
      }
      interceptConsoleMessage(message) {
        if (message.type() !== "debug")
          return false;
        const tag = message.text();
        const handler = this._consoleMessageTags.get(tag);
        if (!handler)
          return false;
        this._consoleMessageTags.delete(tag);
        handler();
        return true;
      }
      clearWebSockets(frame) {
        if (frame.parentFrame())
          return;
        this._webSockets.clear();
      }
      onWebSocketCreated(requestId, url) {
        const ws = new network.WebSocket(this._page, url);
        this._webSockets.set(requestId, ws);
      }
      onWebSocketRequest(requestId) {
        const ws = this._webSockets.get(requestId);
        if (ws && ws.markAsNotified())
          this._page.emit(_page.Page.Events.WebSocket, ws);
      }
      onWebSocketResponse(requestId, status, statusText) {
        const ws = this._webSockets.get(requestId);
        if (status < 400)
          return;
        if (ws)
          ws.error(`${statusText}: ${status}`);
      }
      onWebSocketFrameSent(requestId, opcode, data) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.frameSent(opcode, data);
      }
      webSocketFrameReceived(requestId, opcode, data) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.frameReceived(opcode, data);
      }
      webSocketClosed(requestId) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.closed();
        this._webSockets.delete(requestId);
      }
      webSocketError(requestId, errorMessage) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.error(errorMessage);
      }
    };
    exports2.FrameManager = FrameManager;
    var Frame = class extends _instrumentation.SdkObject {
      constructor(page, id, parentFrame) {
        super(page, "frame");
        this._id = void 0;
        this._firedLifecycleEvents = /* @__PURE__ */ new Set();
        this._subtreeLifecycleEvents = /* @__PURE__ */ new Set();
        this._currentDocument = void 0;
        this._pendingDocument = void 0;
        this._page = void 0;
        this._parentFrame = void 0;
        this._url = "";
        this._detached = false;
        this._contextData = /* @__PURE__ */ new Map();
        this._childFrames = /* @__PURE__ */ new Set();
        this._name = "";
        this._inflightRequests = /* @__PURE__ */ new Set();
        this._networkIdleTimer = void 0;
        this._setContentCounter = 0;
        this._detachedPromise = void 0;
        this._detachedCallback = () => {
        };
        this._nonStallingEvaluations = /* @__PURE__ */ new Set();
        this.attribution.frame = this;
        this._id = id;
        this._page = page;
        this._parentFrame = parentFrame;
        this._currentDocument = {
          documentId: void 0,
          request: void 0
        };
        this._detachedPromise = new Promise((x) => this._detachedCallback = x);
        this._contextData.set("main", {
          contextPromise: new _async.ManualPromise(),
          context: null,
          rerunnableTasks: /* @__PURE__ */ new Set()
        });
        this._contextData.set("utility", {
          contextPromise: new _async.ManualPromise(),
          context: null,
          rerunnableTasks: /* @__PURE__ */ new Set()
        });
        this._setContext("main", null);
        this._setContext("utility", null);
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
        this._firedLifecycleEvents.add("commit");
        this._subtreeLifecycleEvents.add("commit");
      }
      isDetached() {
        return this._detached;
      }
      _onLifecycleEvent(event) {
        if (this._firedLifecycleEvents.has(event))
          return;
        this._firedLifecycleEvents.add(event);
        this._page.mainFrame()._recalculateLifecycle();
      }
      _onClearLifecycle() {
        this._firedLifecycleEvents.clear();
        this._page.mainFrame()._recalculateLifecycle();
        this._inflightRequests = new Set(Array.from(this._inflightRequests).filter((request) => request === this._currentDocument.request));
        this._stopNetworkIdleTimer();
        if (this._inflightRequests.size === 0)
          this._startNetworkIdleTimer();
        this._onLifecycleEvent("commit");
      }
      setPendingDocument(documentInfo) {
        this._pendingDocument = documentInfo;
        if (documentInfo)
          this._invalidateNonStallingEvaluations("Navigation interrupted the evaluation");
      }
      pendingDocument() {
        return this._pendingDocument;
      }
      _invalidateNonStallingEvaluations(message) {
        if (!this._nonStallingEvaluations)
          return;
        const error = new Error(message);
        for (const callback of this._nonStallingEvaluations)
          callback(error);
      }
      nonStallingRawEvaluateInExistingMainContext(expression) {
        return __async(this, null, function* () {
          if (this._pendingDocument)
            throw new Error("Frame is currently attempting a navigation");
          if (this._page._frameManager._dialogCounter)
            throw new Error("Open JavaScript dialog prevents evaluation");
          const context = this._existingMainContext();
          if (!context)
            throw new Error("Frame does not yet have a main execution context");
          let callback = () => {
          };
          const frameInvalidated = new Promise((f, r) => callback = r);
          this._nonStallingEvaluations.add(callback);
          try {
            return yield Promise.race([context.rawEvaluateJSON(expression), frameInvalidated]);
          } finally {
            this._nonStallingEvaluations.delete(callback);
          }
        });
      }
      nonStallingEvaluateInExistingContext(expression, isFunction, world) {
        return __async(this, null, function* () {
          var _this$_contextData$ge;
          if (this._pendingDocument)
            throw new Error("Frame is currently attempting a navigation");
          const context = (_this$_contextData$ge = this._contextData.get(world)) === null || _this$_contextData$ge === void 0 ? void 0 : _this$_contextData$ge.context;
          if (!context)
            throw new Error("Frame does not yet have the execution context");
          let callback = () => {
          };
          const frameInvalidated = new Promise((f, r) => callback = r);
          this._nonStallingEvaluations.add(callback);
          try {
            return yield Promise.race([context.evaluateExpression(expression, isFunction), frameInvalidated]);
          } finally {
            this._nonStallingEvaluations.delete(callback);
          }
        });
      }
      _recalculateLifecycle() {
        const events = new Set(this._firedLifecycleEvents);
        for (const child of this._childFrames) {
          child._recalculateLifecycle();
          for (const event of events) {
            if (!child._subtreeLifecycleEvents.has(event))
              events.delete(event);
          }
        }
        const mainFrame = this._page.mainFrame();
        for (const event of events) {
          if (!this._subtreeLifecycleEvents.has(event)) {
            this.emit(Frame.Events.AddLifecycle, event);
            if (this === mainFrame && this._url !== "about:blank")
              _debugLogger.debugLogger.log("api", `  "${event}" event fired`);
            if (this === mainFrame && event === "load")
              this._page.emit(_page.Page.Events.Load);
            if (this === mainFrame && event === "domcontentloaded")
              this._page.emit(_page.Page.Events.DOMContentLoaded);
          }
        }
        for (const event of this._subtreeLifecycleEvents) {
          if (!events.has(event))
            this.emit(Frame.Events.RemoveLifecycle, event);
        }
        this._subtreeLifecycleEvents = events;
      }
      raceNavigationAction(action) {
        return __async(this, null, function* () {
          return Promise.race([this._page._disconnectedPromise.then(() => {
            throw new Error("Navigation failed because page was closed!");
          }), this._page._crashedPromise.then(() => {
            throw new Error("Navigation failed because page crashed!");
          }), this._detachedPromise.then(() => {
            throw new Error("Navigating frame was detached!");
          }), action()]);
        });
      }
      goto(_0, _1) {
        return __async(this, arguments, function* (metadata, url, options = {}) {
          const constructedNavigationURL = (0, _utils2.constructURLBasedOnBaseURL)(this._page._browserContext._options.baseURL, url);
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this._goto(progress, constructedNavigationURL, options), this._page._timeoutSettings.navigationTimeout(options));
        });
      }
      _goto(progress, url, options) {
        return __async(this, null, function* () {
          return this.raceNavigationAction(() => __async(this, null, function* () {
            const waitUntil = verifyLifecycle("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
            progress.log(`navigating to "${url}", waiting until "${waitUntil}"`);
            const headers = this._page._state.extraHTTPHeaders || [];
            const refererHeader = headers.find((h) => h.name.toLowerCase() === "referer");
            let referer = refererHeader ? refererHeader.value : void 0;
            if (options.referer !== void 0) {
              if (referer !== void 0 && referer !== options.referer)
                throw new Error('"referer" is already specified as extra HTTP header');
              referer = options.referer;
            }
            url = _helper.helper.completeUserURL(url);
            const sameDocument = _helper.helper.waitForEvent(progress, this, Frame.Events.Navigation, (e) => !e.newDocument);
            const navigateResult = yield this._page._delegate.navigateFrame(this, url, referer);
            let event;
            if (navigateResult.newDocumentId) {
              sameDocument.dispose();
              event = yield _helper.helper.waitForEvent(progress, this, Frame.Events.Navigation, (event2) => {
                return event2.newDocument && (event2.newDocument.documentId === navigateResult.newDocumentId || !event2.error);
              }).promise;
              if (event.newDocument.documentId !== navigateResult.newDocumentId) {
                throw new Error("Navigation interrupted by another one");
              }
              if (event.error)
                throw event.error;
            } else {
              event = yield sameDocument.promise;
            }
            if (!this._subtreeLifecycleEvents.has(waitUntil))
              yield _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
            const request = event.newDocument ? event.newDocument.request : void 0;
            const response = request ? request._finalRequest().response() : null;
            yield this._page._doSlowMo();
            return response;
          }));
        });
      }
      _waitForNavigation(progress, options) {
        return __async(this, null, function* () {
          const waitUntil = verifyLifecycle("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          progress.log(`waiting for navigation until "${waitUntil}"`);
          const navigationEvent = yield _helper.helper.waitForEvent(progress, this, Frame.Events.Navigation, (event) => {
            if (event.error)
              return true;
            progress.log(`  navigated to "${this._url}"`);
            return true;
          }).promise;
          if (navigationEvent.error)
            throw navigationEvent.error;
          if (!this._subtreeLifecycleEvents.has(waitUntil))
            yield _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
          const request = navigationEvent.newDocument ? navigationEvent.newDocument.request : void 0;
          return request ? request._finalRequest().response() : null;
        });
      }
      _waitForLoadState(progress, state) {
        return __async(this, null, function* () {
          const waitUntil = verifyLifecycle("state", state);
          if (!this._subtreeLifecycleEvents.has(waitUntil))
            yield _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
        });
      }
      frameElement() {
        return __async(this, null, function* () {
          return this._page._delegate.getFrameElement(this);
        });
      }
      _context(world) {
        return this._contextData.get(world).contextPromise.then((contextOrError) => {
          if (contextOrError instanceof js.ExecutionContext)
            return contextOrError;
          throw contextOrError;
        });
      }
      _mainContext() {
        return this._context("main");
      }
      _existingMainContext() {
        var _this$_contextData$ge2;
        return ((_this$_contextData$ge2 = this._contextData.get("main")) === null || _this$_contextData$ge2 === void 0 ? void 0 : _this$_contextData$ge2.context) || null;
      }
      _utilityContext() {
        return this._context("utility");
      }
      evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg, world = "main") {
        return __async(this, null, function* () {
          const context = yield this._context(world);
          const handle = yield context.evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg);
          if (world === "main")
            yield this._page._doSlowMo();
          return handle;
        });
      }
      evaluateExpression(expression, isFunction, arg, world = "main") {
        return __async(this, null, function* () {
          const context = yield this._context(world);
          const value = yield context.evaluateExpression(expression, isFunction, arg);
          if (world === "main")
            yield this._page._doSlowMo();
          return value;
        });
      }
      evaluateExpressionAndWaitForSignals(expression, isFunction, arg, world = "main") {
        return __async(this, null, function* () {
          const context = yield this._context(world);
          const value = yield context.evaluateExpressionAndWaitForSignals(expression, isFunction, arg);
          if (world === "main")
            yield this._page._doSlowMo();
          return value;
        });
      }
      querySelector(selector, options) {
        return __async(this, null, function* () {
          _debugLogger.debugLogger.log("api", `    finding element using the selector "${selector}"`);
          const result = yield this.resolveFrameForSelectorNoWait(selector, options);
          if (!result)
            return null;
          return this._page.selectors.query(result.frame, result.info);
        });
      }
      waitForSelector(metadata, selector, options, scope) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          if (options.visibility)
            throw new Error("options.visibility is not supported, did you mean options.state?");
          if (options.waitFor && options.waitFor !== "visible")
            throw new Error("options.waitFor is not supported, did you mean options.state?");
          const {
            state = "visible"
          } = options;
          if (!["attached", "detached", "visible", "hidden"].includes(state))
            throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
          return controller.run((progress) => __async(this, null, function* () {
            progress.log(`waiting for selector "${selector}"${state === "attached" ? "" : " to be " + state}`);
            return this.retryWithProgress(progress, selector, options, (selectorInFrame, continuePolling) => __async(this, null, function* () {
              const {
                frame,
                info
              } = selectorInFrame;
              const actualScope = this === frame ? scope : void 0;
              const task = dom.waitForSelectorTask(info, state, options.omitReturnValue, actualScope);
              const result = actualScope ? yield frame._runWaitForSelectorTaskOnce(progress, (0, _selectorParser.stringifySelector)(info.parsed), info.world, task) : yield frame._scheduleRerunnableHandleTask(progress, info.world, task);
              if (!result.asElement()) {
                result.dispose();
                return null;
              }
              if (options.__testHookBeforeAdoptNode)
                yield options.__testHookBeforeAdoptNode();
              const handle = result.asElement();
              try {
                return yield handle._adoptTo(yield frame._mainContext());
              } catch (e) {
                return continuePolling;
              }
            }), scope);
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      dispatchEvent(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, type, eventInit = {}, options = {}) {
          yield this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => {
            progress.injectedScript.dispatchEvent(element, data.type, data.eventInit);
          }, {
            type,
            eventInit
          }, __spreadValues({
            mainWorld: true
          }, options));
          yield this._page._doSlowMo();
        });
      }
      evalOnSelectorAndWaitForSignals(selector, strict, expression, isFunction, arg) {
        return __async(this, null, function* () {
          const pair = yield this.resolveFrameForSelectorNoWait(selector, {
            strict
          });
          const handle = pair ? yield this._page.selectors.query(pair.frame, pair.info) : null;
          if (!handle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
          const result = yield handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
          handle.dispose();
          return result;
        });
      }
      evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
        return __async(this, null, function* () {
          const pair = yield this.resolveFrameForSelectorNoWait(selector, {});
          if (!pair)
            throw new Error(`Error: failed to find frame for selector "${selector}"`);
          const arrayHandle = yield this._page.selectors._queryArrayInMainWorld(pair.frame, pair.info);
          const result = yield arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
          arrayHandle.dispose();
          return result;
        });
      }
      querySelectorAll(selector) {
        return __async(this, null, function* () {
          const pair = yield this.resolveFrameForSelectorNoWait(selector, {});
          if (!pair)
            return [];
          return this._page.selectors._queryAll(pair.frame, pair.info, void 0, true);
        });
      }
      queryCount(selector) {
        return __async(this, null, function* () {
          const pair = yield this.resolveFrameForSelectorNoWait(selector);
          if (!pair)
            throw new Error(`Error: failed to find frame for selector "${selector}"`);
          return yield this._page.selectors._queryCount(pair.frame, pair.info);
        });
      }
      content() {
        return __async(this, null, function* () {
          try {
            const context = yield this._utilityContext();
            return yield context.evaluate(() => {
              let retVal = "";
              if (document.doctype)
                retVal = new XMLSerializer().serializeToString(document.doctype);
              if (document.documentElement)
                retVal += document.documentElement.outerHTML;
              return retVal;
            });
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            throw new Error(`Unable to retrieve content because the page is navigating and changing the content.`);
          }
        });
      }
      setContent(_0, _1) {
        return __async(this, arguments, function* (metadata, html, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this.raceNavigationAction(() => __async(this, null, function* () {
            const waitUntil = options.waitUntil === void 0 ? "load" : options.waitUntil;
            progress.log(`setting frame content, waiting until "${waitUntil}"`);
            const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
            const context = yield this._utilityContext();
            const lifecyclePromise = new Promise((resolve, reject) => {
              this._page._frameManager._consoleMessageTags.set(tag, () => {
                this._onClearLifecycle();
                this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
              });
            });
            const contentPromise = context.evaluate(({
              html: html2,
              tag: tag2
            }) => {
              window.stop();
              document.open();
              console.debug(tag2);
              document.write(html2);
              document.close();
            }, {
              html,
              tag
            });
            yield Promise.all([contentPromise, lifecyclePromise]);
            yield this._page._doSlowMo();
          })), this._page._timeoutSettings.navigationTimeout(options));
        });
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      addScriptTag(params) {
        return __async(this, null, function* () {
          const {
            url = null,
            content = null,
            type = ""
          } = params;
          if (!url && !content)
            throw new Error("Provide an object with a `url`, `path` or `content` property");
          const context = yield this._mainContext();
          return this._raceWithCSPError(() => __async(this, null, function* () {
            if (url !== null)
              return (yield context.evaluateHandle(addScriptUrl, {
                url,
                type
              })).asElement();
            const result = (yield context.evaluateHandle(addScriptContent, {
              content,
              type
            })).asElement();
            if (this._page._delegate.cspErrorsAsynchronousForInlineScipts)
              yield context.evaluate(() => true);
            return result;
          }));
          function addScriptUrl(params2) {
            return __async(this, null, function* () {
              const script = document.createElement("script");
              script.src = params2.url;
              if (params2.type)
                script.type = params2.type;
              const promise = new Promise((res, rej) => {
                script.onload = res;
                script.onerror = (e) => rej(typeof e === "string" ? new Error(e) : new Error(`Failed to load script at ${script.src}`));
              });
              document.head.appendChild(script);
              yield promise;
              return script;
            });
          }
          function addScriptContent(params2) {
            const script = document.createElement("script");
            script.type = params2.type || "text/javascript";
            script.text = params2.content;
            let error = null;
            script.onerror = (e) => error = e;
            document.head.appendChild(script);
            if (error)
              throw error;
            return script;
          }
        });
      }
      addStyleTag(params) {
        return __async(this, null, function* () {
          const {
            url = null,
            content = null
          } = params;
          if (!url && !content)
            throw new Error("Provide an object with a `url`, `path` or `content` property");
          const context = yield this._mainContext();
          return this._raceWithCSPError(() => __async(this, null, function* () {
            if (url !== null)
              return (yield context.evaluateHandle(addStyleUrl, url)).asElement();
            return (yield context.evaluateHandle(addStyleContent, content)).asElement();
          }));
          function addStyleUrl(url2) {
            return __async(this, null, function* () {
              const link = document.createElement("link");
              link.rel = "stylesheet";
              link.href = url2;
              const promise = new Promise((res, rej) => {
                link.onload = res;
                link.onerror = rej;
              });
              document.head.appendChild(link);
              yield promise;
              return link;
            });
          }
          function addStyleContent(content2) {
            return __async(this, null, function* () {
              const style = document.createElement("style");
              style.type = "text/css";
              style.appendChild(document.createTextNode(content2));
              const promise = new Promise((res, rej) => {
                style.onload = res;
                style.onerror = rej;
              });
              document.head.appendChild(style);
              yield promise;
              return style;
            });
          }
        });
      }
      _raceWithCSPError(func) {
        return __async(this, null, function* () {
          const listeners = [];
          let result;
          let error;
          let cspMessage;
          const actionPromise = func().then((r) => result = r).catch((e) => error = e);
          const errorPromise = new Promise((resolve) => {
            listeners.push(_eventsHelper.eventsHelper.addEventListener(this._page, _page.Page.Events.Console, (message) => {
              if (message.type() === "error" && message.text().includes("Content Security Policy")) {
                cspMessage = message;
                resolve();
              }
            }));
          });
          yield Promise.race([actionPromise, errorPromise]);
          _eventsHelper.eventsHelper.removeEventListeners(listeners);
          if (cspMessage)
            throw new Error(cspMessage.text());
          if (error)
            throw error;
          return result;
        });
      }
      retryWithProgress(progress, selector, options, action, scope) {
        return __async(this, null, function* () {
          const continuePolling = Symbol("continuePolling");
          while (progress.isRunning()) {
            let selectorInFrame;
            if (options.omitAttached) {
              selectorInFrame = yield this.resolveFrameForSelectorNoWait(selector, options, scope);
            } else {
              selectorInFrame = yield this._resolveFrameForSelector(progress, selector, options, scope);
              if (!selectorInFrame) {
                yield new Promise((f) => setTimeout(f, 100));
                continue;
              }
            }
            try {
              const result = yield action(selectorInFrame, continuePolling);
              if (result === continuePolling)
                continue;
              return result;
            } catch (e) {
              var _selectorInFrame;
              if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
                throw e;
              if (dom.isNonRecoverableDOMError(e))
                throw e;
              if (this.isDetached())
                throw e;
              if (scope && scope._context.frame === ((_selectorInFrame = selectorInFrame) === null || _selectorInFrame === void 0 ? void 0 : _selectorInFrame.frame))
                throw e;
              continue;
            }
          }
          progress.throwIfAborted();
          return void 0;
        });
      }
      _retryWithProgressIfNotConnected(progress, selector, strict, action) {
        return __async(this, null, function* () {
          return this.retryWithProgress(progress, selector, {
            strict
          }, (selectorInFrame, continuePolling) => __async(this, null, function* () {
            const {
              frame,
              info
            } = selectorInFrame;
            const task = dom.waitForSelectorTask(info, "attached");
            progress.log(`waiting for selector "${selector}"`);
            const handle = yield frame._scheduleRerunnableHandleTask(progress, info.world, task);
            const element = handle.asElement();
            try {
              const result = yield action(element);
              if (result === "error:notconnected") {
                progress.log("element was detached from the DOM, retrying");
                return continuePolling;
              }
              return result;
            } finally {
              element === null || element === void 0 ? void 0 : element.dispose();
            }
          }));
        });
      }
      click(metadata, selector, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._click(progress, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      dblclick(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._dblclick(progress, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      dragAndDrop(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, source, target, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          yield controller.run((progress) => __async(this, null, function* () {
            dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, source, options.strict, (handle) => __async(this, null, function* () {
              return handle._retryPointerAction(progress, "move and down", false, (point) => __async(this, null, function* () {
                yield this._page.mouse.move(point.x, point.y);
                yield this._page.mouse.down();
              }), __spreadProps(__spreadValues({}, options), {
                position: options.sourcePosition,
                timeout: progress.timeUntilDeadline()
              }));
            })));
            dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, target, options.strict, (handle) => __async(this, null, function* () {
              return handle._retryPointerAction(progress, "move and up", false, (point) => __async(this, null, function* () {
                yield this._page.mouse.move(point.x, point.y);
                yield this._page.mouse.up();
              }), __spreadProps(__spreadValues({}, options), {
                position: options.targetPosition,
                timeout: progress.timeUntilDeadline()
              }));
            })));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      tap(metadata, selector, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._tap(progress, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      fill(metadata, selector, value, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._fill(progress, value, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      focus(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          yield controller.run((progress) => __async(this, null, function* () {
            dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._focus(progress)));
            yield this._page._doSlowMo();
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      textContent(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._scheduleRerunnableTask(metadata, selector, (progress, element) => element.textContent, void 0, options);
        });
      }
      innerText(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._scheduleRerunnableTask(metadata, selector, (progress, element) => {
            if (element.namespaceURI !== "http://www.w3.org/1999/xhtml")
              throw progress.injectedScript.createStacklessError("Node is not an HTMLElement");
            return element.innerText;
          }, void 0, options);
        });
      }
      innerHTML(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._scheduleRerunnableTask(metadata, selector, (progress, element) => element.innerHTML, void 0, options);
        });
      }
      getAttribute(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, name, options = {}) {
          return this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => element.getAttribute(data.name), {
            name
          }, options);
        });
      }
      inputValue(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._scheduleRerunnableTask(metadata, selector, (progress, node) => {
            const element = progress.injectedScript.retarget(node, "follow-label");
            if (!element || element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")
              throw progress.injectedScript.createStacklessError("Node is not an <input>, <textarea> or <select> element");
            return element.value;
          }, void 0, options);
        });
      }
      highlight(selector) {
        return __async(this, null, function* () {
          const pair = yield this.resolveFrameForSelectorNoWait(selector);
          if (!pair)
            return;
          const context = yield this._utilityContext();
          const injectedScript = yield context.injectedScript();
          return yield injectedScript.evaluate((injected, {
            parsed
          }) => {
            return injected.highlight(parsed);
          }, {
            parsed: pair.info.parsed
          });
        });
      }
      hideHighlight() {
        return __async(this, null, function* () {
          const context = yield this._utilityContext();
          const injectedScript = yield context.injectedScript();
          return yield injectedScript.evaluate((injected) => {
            return injected.hideHighlight();
          });
        });
      }
      _elementState(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, state, options = {}) {
          const result = yield this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => {
            const injected = progress.injectedScript;
            return injected.elementState(element, data.state);
          }, {
            state
          }, options);
          return dom.throwRetargetableDOMError(result);
        });
      }
      isVisible(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            progress.log(`  checking visibility of "${selector}"`);
            const pair = yield this.resolveFrameForSelectorNoWait(selector, options);
            if (!pair)
              return false;
            const element = yield this._page.selectors.query(pair.frame, pair.info);
            return element ? yield element.isVisible() : false;
          }), this._page._timeoutSettings.timeout({}));
        });
      }
      isHidden(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return !(yield this.isVisible(metadata, selector, options));
        });
      }
      isDisabled(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._elementState(metadata, selector, "disabled", options);
        });
      }
      isEnabled(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._elementState(metadata, selector, "enabled", options);
        });
      }
      isEditable(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._elementState(metadata, selector, "editable", options);
        });
      }
      isChecked(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._elementState(metadata, selector, "checked", options);
        });
      }
      hover(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._hover(progress, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      selectOption(_0, _1, _2, _3) {
        return __async(this, arguments, function* (metadata, selector, elements, values, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._selectOption(progress, elements, values, options));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      setInputFiles(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, files, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._setInputFiles(progress, files, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      type(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, text, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._type(progress, text, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      press(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, key, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._press(progress, key, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      check(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._setChecked(progress, true, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      uncheck(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._setChecked(progress, false, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      waitForTimeout(metadata, timeout) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run(() => __async(this, null, function* () {
            yield new Promise((resolve) => setTimeout(resolve, timeout));
          }));
        });
      }
      expect(metadata, selector, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          const isArray = options.expression === "to.have.count" || options.expression.endsWith(".array");
          const mainWorld = options.expression === "to.have.property";
          const timeout = this._page._timeoutSettings.timeout(options);
          let omitAttached = false;
          if (!options.isNot && options.expression === "to.be.hidden")
            omitAttached = true;
          else if (options.isNot && options.expression === "to.be.visible")
            omitAttached = true;
          else if (!options.isNot && options.expression === "to.have.count" && options.expectedNumber === 0)
            omitAttached = true;
          else if (options.isNot && options.expression === "to.have.count" && options.expectedNumber !== 0)
            omitAttached = true;
          else if (!options.isNot && options.expression.endsWith(".array") && options.expectedText.length === 0)
            omitAttached = true;
          else if (options.isNot && options.expression.endsWith(".array") && options.expectedText.length > 0)
            omitAttached = true;
          return controller.run((outerProgress) => __async(this, null, function* () {
            outerProgress.log(`${metadata.apiName}${timeout ? ` with timeout ${timeout}ms` : ""}`);
            return yield this._scheduleRerunnableTaskWithProgress(outerProgress, selector, (progress, element, options2, elements) => {
              let result;
              if (options2.isArray) {
                result = progress.injectedScript.expectArray(elements, options2);
              } else {
                if (!element) {
                  if (!options2.isNot && options2.expression === "to.be.hidden")
                    return {
                      matches: true
                    };
                  if (options2.isNot && options2.expression === "to.be.visible")
                    return {
                      matches: false
                    };
                  return progress.continuePolling;
                }
                result = progress.injectedScript.expectSingleElement(progress, element, options2);
              }
              if (result.matches === options2.isNot) {
                progress.setIntermediateResult(result.received);
                if (!Array.isArray(result.received))
                  progress.log(`  unexpected value "${result.received}"`);
                return progress.continuePolling;
              }
              return result;
            }, __spreadProps(__spreadValues({}, options), {
              isArray
            }), __spreadValues({
              strict: true,
              querySelectorAll: isArray,
              mainWorld,
              omitAttached,
              logScale: true
            }, options));
          }), timeout).catch((e) => {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorErrors.isInvalidSelectorError)(e))
              throw e;
            return {
              received: controller.lastIntermediateResult(),
              matches: options.isNot,
              log: metadata.log
            };
          });
        });
      }
      _waitForFunctionExpression(metadata, expression, isFunction, arg, options, world = "main") {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          if (typeof options.pollingInterval === "number")
            (0, _utils2.assert)(options.pollingInterval > 0, "Cannot poll with non-positive interval: " + options.pollingInterval);
          expression = js.normalizeEvaluationExpression(expression, isFunction);
          const task = (injectedScript) => injectedScript.evaluateHandle((injectedScript2, {
            expression: expression2,
            isFunction: isFunction2,
            polling,
            arg: arg2
          }) => {
            const predicate = (arg3) => {
              let result = self.eval(expression2);
              if (isFunction2 === true) {
                result = result(arg3);
              } else if (isFunction2 === false) {
                result = result;
              } else {
                if (typeof result === "function")
                  result = result(arg3);
              }
              return result;
            };
            if (typeof polling !== "number")
              return injectedScript2.pollRaf((progress) => predicate(arg2) || progress.continuePolling);
            return injectedScript2.pollInterval(polling, (progress) => predicate(arg2) || progress.continuePolling);
          }, {
            expression,
            isFunction,
            polling: options.pollingInterval,
            arg
          });
          return controller.run((progress) => this._scheduleRerunnableHandleTask(progress, world, task), this._page._timeoutSettings.timeout(options));
        });
      }
      waitForFunctionValueInUtility(progress, pageFunction) {
        return __async(this, null, function* () {
          const expression = `() => {
      const result = (${pageFunction})();
      if (!result)
        return result;
      return JSON.stringify(result);
    }`;
          const handle = yield this._waitForFunctionExpression((0, _instrumentation.internalCallMetadata)(), expression, true, void 0, {
            timeout: progress.timeUntilDeadline()
          }, "utility");
          return JSON.parse(handle.rawValue());
        });
      }
      title() {
        return __async(this, null, function* () {
          const context = yield this._utilityContext();
          return context.evaluate(() => document.title);
        });
      }
      _onDetached() {
        this._stopNetworkIdleTimer();
        this._detached = true;
        this._detachedCallback();
        const error = new Error("Frame was detached");
        for (const data of this._contextData.values()) {
          if (data.context)
            data.context.contextDestroyed(error);
          data.contextPromise.resolve(error);
          for (const rerunnableTask of data.rerunnableTasks)
            rerunnableTask.terminate(error);
        }
        if (this._parentFrame)
          this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
      }
      _scheduleRerunnableTask(_0, _1, _2, _3) {
        return __async(this, arguments, function* (metadata, selector, body, taskData, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return yield this._scheduleRerunnableTaskWithProgress(progress, selector, body, taskData, options);
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _scheduleRerunnableTaskWithProgress(_0, _1, _2, _3) {
        return __async(this, arguments, function* (progress, selector, body, taskData, options = {}) {
          const callbackText = body.toString();
          return this.retryWithProgress(progress, selector, options, (selectorInFrame) => __async(this, null, function* () {
            progress.log(`waiting for selector "${selector}"`);
            const {
              frame,
              info
            } = selectorInFrame || {
              frame: this,
              info: {
                parsed: {
                  parts: [{
                    name: "control",
                    body: "return-empty",
                    source: "control=return-empty"
                  }]
                },
                world: "utility",
                strict: !!options.strict
              }
            };
            return yield frame._scheduleRerunnableTaskInFrame(progress, info, callbackText, taskData, options);
          }));
        });
      }
      _scheduleRerunnableTaskInFrame(progress, info, callbackText, taskData, options) {
        return __async(this, null, function* () {
          progress.throwIfAborted();
          const data = this._contextData.get(options.mainWorld ? "main" : info.world);
          {
            const rerunnableTask = new RerunnableTask(data, progress, (injectedScript) => {
              return injectedScript.evaluateHandle((injected, {
                info: info2,
                taskData: taskData2,
                callbackText: callbackText2,
                querySelectorAll,
                logScale,
                omitAttached,
                snapshotName
              }) => {
                const callback = injected.eval(callbackText2);
                const poller = logScale ? injected.pollLogScale.bind(injected) : injected.pollRaf.bind(injected);
                let markedElements = /* @__PURE__ */ new Set();
                return poller((progress2) => {
                  let element;
                  let elements = [];
                  if (querySelectorAll) {
                    elements = injected.querySelectorAll(info2.parsed, document);
                    element = elements[0];
                    progress2.logRepeating(`  selector resolved to ${elements.length} element${elements.length === 1 ? "" : "s"}`);
                  } else {
                    element = injected.querySelector(info2.parsed, document, info2.strict);
                    elements = element ? [element] : [];
                    if (element)
                      progress2.logRepeating(`  selector resolved to ${injected.previewNode(element)}`);
                  }
                  if (!element && !omitAttached)
                    return progress2.continuePolling;
                  if (snapshotName) {
                    const previouslyMarkedElements = markedElements;
                    markedElements = new Set(elements);
                    for (const e of previouslyMarkedElements) {
                      if (!markedElements.has(e))
                        e.removeAttribute("__playwright_target__");
                    }
                    for (const e of markedElements) {
                      if (!previouslyMarkedElements.has(e))
                        e.setAttribute("__playwright_target__", snapshotName);
                    }
                  }
                  return callback(progress2, element, taskData2, elements);
                });
              }, {
                info,
                taskData,
                callbackText,
                querySelectorAll: options.querySelectorAll,
                logScale: options.logScale,
                omitAttached: options.omitAttached,
                snapshotName: progress.metadata.afterSnapshot
              });
            }, true);
            if (this._detached)
              rerunnableTask.terminate(new Error("Frame got detached."));
            if (data.context)
              rerunnableTask.rerun(data.context);
            return yield rerunnableTask.promise;
          }
        });
      }
      _scheduleRerunnableHandleTask(progress, world, task) {
        const data = this._contextData.get(world);
        const rerunnableTask = new RerunnableTask(data, progress, task, false);
        if (this._detached)
          rerunnableTask.terminate(new Error("waitForFunction failed: frame got detached."));
        if (data.context)
          rerunnableTask.rerun(data.context);
        return rerunnableTask.handlePromise;
      }
      _setContext(world, context) {
        const data = this._contextData.get(world);
        data.context = context;
        if (context) {
          data.contextPromise.resolve(context);
          for (const rerunnableTask of data.rerunnableTasks)
            rerunnableTask.rerun(context);
        } else {
          data.contextPromise = new _async.ManualPromise();
        }
      }
      _contextCreated(world, context) {
        const data = this._contextData.get(world);
        if (data.context) {
          data.context.contextDestroyed(new Error("Execution context was destroyed, most likely because of a navigation"));
          this._setContext(world, null);
        }
        this._setContext(world, context);
      }
      _contextDestroyed(context) {
        if (this._detached)
          return;
        context.contextDestroyed(new Error("Execution context was destroyed, most likely because of a navigation"));
        for (const [world, data] of this._contextData) {
          if (data.context === context)
            this._setContext(world, null);
        }
      }
      _startNetworkIdleTimer() {
        (0, _utils2.assert)(!this._networkIdleTimer);
        if (this._firedLifecycleEvents.has("networkidle") || this._detached)
          return;
        this._networkIdleTimer = setTimeout(() => this._onLifecycleEvent("networkidle"), 500);
      }
      _stopNetworkIdleTimer() {
        if (this._networkIdleTimer)
          clearTimeout(this._networkIdleTimer);
        this._networkIdleTimer = void 0;
      }
      extendInjectedScript(source, arg) {
        return __async(this, null, function* () {
          const context = yield this._context("main");
          const injectedScriptHandle = yield context.injectedScript();
          return injectedScriptHandle.evaluateHandle((injectedScript, {
            source: source2,
            arg: arg2
          }) => {
            return injectedScript.extend(source2, arg2);
          }, {
            source,
            arg
          });
        });
      }
      _resolveFrameForSelector(progress, selector, options, scope) {
        return __async(this, null, function* () {
          const elementPath = [];
          progress.cleanupWhenAborted(() => {
            for (const element of elementPath)
              element.dispose();
          });
          let frame = this;
          const frameChunks = (0, _selectorParser.splitSelectorByFrame)(selector);
          for (let i = 0; i < frameChunks.length - 1 && progress.isRunning(); ++i) {
            const info = this._page.parseSelector(frameChunks[i], options);
            const task = dom.waitForSelectorTask(info, "attached", false, i === 0 ? scope : void 0);
            progress.log(`  waiting for frame "${(0, _selectorParser.stringifySelector)(frameChunks[i])}"`);
            const handle = i === 0 && scope ? yield frame._runWaitForSelectorTaskOnce(progress, (0, _selectorParser.stringifySelector)(info.parsed), info.world, task) : yield frame._scheduleRerunnableHandleTask(progress, info.world, task);
            const element = handle.asElement();
            const isIframe = yield element.isIframeElement();
            if (isIframe === "error:notconnected")
              return null;
            if (!isIframe)
              throw new Error(`Selector "${(0, _selectorParser.stringifySelector)(info.parsed)}" resolved to ${element.preview()}, <iframe> was expected`);
            frame = yield element.contentFrame();
            element.dispose();
            if (!frame)
              return null;
          }
          return {
            frame,
            info: this._page.parseSelector(frameChunks[frameChunks.length - 1], options)
          };
        });
      }
      resolveFrameForSelectorNoWait(_0) {
        return __async(this, arguments, function* (selector, options = {}, scope) {
          let frame = this;
          const frameChunks = (0, _selectorParser.splitSelectorByFrame)(selector);
          for (let i = 0; i < frameChunks.length - 1; ++i) {
            const info = this._page.parseSelector(frameChunks[i], options);
            const element = yield this._page.selectors.query(frame, info, i === 0 ? scope : void 0);
            if (!element)
              return null;
            frame = yield element.contentFrame();
            element.dispose();
            if (!frame)
              throw new Error(`Selector "${(0, _selectorParser.stringifySelector)(info.parsed)}" resolved to ${element.preview()}, <iframe> was expected`);
          }
          return {
            frame,
            info: this._page.parseSelector(frameChunks[frameChunks.length - 1], options)
          };
        });
      }
      _runWaitForSelectorTaskOnce(progress, selector, world, task) {
        return __async(this, null, function* () {
          const context = yield this._context(world);
          const injected = yield context.injectedScript();
          try {
            const pollHandler = new dom.InjectedScriptPollHandler(progress, yield task(injected));
            const result = yield pollHandler.finishHandle();
            progress.cleanupWhenAborted(() => result.dispose());
            return result;
          } catch (e) {
            throw new Error(`Error: frame navigated while waiting for selector "${selector}"`);
          }
        });
      }
    };
    exports2.Frame = Frame;
    Frame.Events = {
      Navigation: "navigation",
      AddLifecycle: "addlifecycle",
      RemoveLifecycle: "removelifecycle"
    };
    var RerunnableTask = class {
      constructor(data, progress, task, returnByValue) {
        this.promise = void 0;
        this.handlePromise = void 0;
        this._task = void 0;
        this._progress = void 0;
        this._returnByValue = void 0;
        this._contextData = void 0;
        this._task = task;
        this._progress = progress;
        this._returnByValue = returnByValue;
        if (returnByValue)
          this.promise = new _async.ManualPromise();
        else
          this.handlePromise = new _async.ManualPromise();
        this._contextData = data;
        this._contextData.rerunnableTasks.add(this);
      }
      terminate(error) {
        this._reject(error);
      }
      _resolve(value) {
        if (this.promise)
          this.promise.resolve(value);
        if (this.handlePromise)
          this.handlePromise.resolve(value);
      }
      _reject(error) {
        if (this.promise)
          this.promise.reject(error);
        if (this.handlePromise)
          this.handlePromise.reject(error);
      }
      rerun(context) {
        return __async(this, null, function* () {
          try {
            const injectedScript = yield context.injectedScript();
            const pollHandler = new dom.InjectedScriptPollHandler(this._progress, yield this._task(injectedScript));
            const result = this._returnByValue ? yield pollHandler.finish() : yield pollHandler.finishHandle();
            this._contextData.rerunnableTasks.delete(this);
            this._resolve(result);
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) {
              this._contextData.rerunnableTasks.delete(this);
              this._reject(e);
            }
          }
        });
      }
    };
    var SignalBarrier = class {
      constructor(progress) {
        this._progress = void 0;
        this._protectCount = 0;
        this._promise = new _async.ManualPromise();
        this._progress = progress;
        this.retain();
      }
      waitFor() {
        this.release();
        return this._promise;
      }
      addFrameNavigation(frame) {
        return __async(this, null, function* () {
          if (frame.parentFrame())
            return;
          this.retain();
          const waiter = _helper.helper.waitForEvent(null, frame, Frame.Events.Navigation, (e) => {
            if (!e.error && this._progress)
              this._progress.log(`  navigated to "${frame._url}"`);
            return true;
          });
          yield Promise.race([frame._page._disconnectedPromise, frame._page._crashedPromise, frame._detachedPromise, waiter.promise]).catch((e) => {
          });
          waiter.dispose();
          this.release();
        });
      }
      retain() {
        ++this._protectCount;
      }
      release() {
        --this._protectCount;
        if (!this._protectCount)
          this._promise.resolve();
      }
    };
    function verifyLifecycle(name, waitUntil) {
      if (waitUntil === "networkidle0")
        waitUntil = "networkidle";
      if (!types.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
      return waitUntil;
    }
  }
});

// node_modules/playwright-core/lib/server/usKeyboardLayout.js
var require_usKeyboardLayout = __commonJS({
  "node_modules/playwright-core/lib/server/usKeyboardLayout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.USKeyboardLayout = exports2.keypadLocation = void 0;
    var keypadLocation = 3;
    exports2.keypadLocation = keypadLocation;
    var USKeyboardLayout = {
      "Escape": {
        "keyCode": 27,
        "key": "Escape"
      },
      "F1": {
        "keyCode": 112,
        "key": "F1"
      },
      "F2": {
        "keyCode": 113,
        "key": "F2"
      },
      "F3": {
        "keyCode": 114,
        "key": "F3"
      },
      "F4": {
        "keyCode": 115,
        "key": "F4"
      },
      "F5": {
        "keyCode": 116,
        "key": "F5"
      },
      "F6": {
        "keyCode": 117,
        "key": "F6"
      },
      "F7": {
        "keyCode": 118,
        "key": "F7"
      },
      "F8": {
        "keyCode": 119,
        "key": "F8"
      },
      "F9": {
        "keyCode": 120,
        "key": "F9"
      },
      "F10": {
        "keyCode": 121,
        "key": "F10"
      },
      "F11": {
        "keyCode": 122,
        "key": "F11"
      },
      "F12": {
        "keyCode": 123,
        "key": "F12"
      },
      "Backquote": {
        "keyCode": 192,
        "shiftKey": "~",
        "key": "`"
      },
      "Digit1": {
        "keyCode": 49,
        "shiftKey": "!",
        "key": "1"
      },
      "Digit2": {
        "keyCode": 50,
        "shiftKey": "@",
        "key": "2"
      },
      "Digit3": {
        "keyCode": 51,
        "shiftKey": "#",
        "key": "3"
      },
      "Digit4": {
        "keyCode": 52,
        "shiftKey": "$",
        "key": "4"
      },
      "Digit5": {
        "keyCode": 53,
        "shiftKey": "%",
        "key": "5"
      },
      "Digit6": {
        "keyCode": 54,
        "shiftKey": "^",
        "key": "6"
      },
      "Digit7": {
        "keyCode": 55,
        "shiftKey": "&",
        "key": "7"
      },
      "Digit8": {
        "keyCode": 56,
        "shiftKey": "*",
        "key": "8"
      },
      "Digit9": {
        "keyCode": 57,
        "shiftKey": "(",
        "key": "9"
      },
      "Digit0": {
        "keyCode": 48,
        "shiftKey": ")",
        "key": "0"
      },
      "Minus": {
        "keyCode": 189,
        "shiftKey": "_",
        "key": "-"
      },
      "Equal": {
        "keyCode": 187,
        "shiftKey": "+",
        "key": "="
      },
      "Backslash": {
        "keyCode": 220,
        "shiftKey": "|",
        "key": "\\"
      },
      "Backspace": {
        "keyCode": 8,
        "key": "Backspace"
      },
      "Tab": {
        "keyCode": 9,
        "key": "Tab"
      },
      "KeyQ": {
        "keyCode": 81,
        "shiftKey": "Q",
        "key": "q"
      },
      "KeyW": {
        "keyCode": 87,
        "shiftKey": "W",
        "key": "w"
      },
      "KeyE": {
        "keyCode": 69,
        "shiftKey": "E",
        "key": "e"
      },
      "KeyR": {
        "keyCode": 82,
        "shiftKey": "R",
        "key": "r"
      },
      "KeyT": {
        "keyCode": 84,
        "shiftKey": "T",
        "key": "t"
      },
      "KeyY": {
        "keyCode": 89,
        "shiftKey": "Y",
        "key": "y"
      },
      "KeyU": {
        "keyCode": 85,
        "shiftKey": "U",
        "key": "u"
      },
      "KeyI": {
        "keyCode": 73,
        "shiftKey": "I",
        "key": "i"
      },
      "KeyO": {
        "keyCode": 79,
        "shiftKey": "O",
        "key": "o"
      },
      "KeyP": {
        "keyCode": 80,
        "shiftKey": "P",
        "key": "p"
      },
      "BracketLeft": {
        "keyCode": 219,
        "shiftKey": "{",
        "key": "["
      },
      "BracketRight": {
        "keyCode": 221,
        "shiftKey": "}",
        "key": "]"
      },
      "CapsLock": {
        "keyCode": 20,
        "key": "CapsLock"
      },
      "KeyA": {
        "keyCode": 65,
        "shiftKey": "A",
        "key": "a"
      },
      "KeyS": {
        "keyCode": 83,
        "shiftKey": "S",
        "key": "s"
      },
      "KeyD": {
        "keyCode": 68,
        "shiftKey": "D",
        "key": "d"
      },
      "KeyF": {
        "keyCode": 70,
        "shiftKey": "F",
        "key": "f"
      },
      "KeyG": {
        "keyCode": 71,
        "shiftKey": "G",
        "key": "g"
      },
      "KeyH": {
        "keyCode": 72,
        "shiftKey": "H",
        "key": "h"
      },
      "KeyJ": {
        "keyCode": 74,
        "shiftKey": "J",
        "key": "j"
      },
      "KeyK": {
        "keyCode": 75,
        "shiftKey": "K",
        "key": "k"
      },
      "KeyL": {
        "keyCode": 76,
        "shiftKey": "L",
        "key": "l"
      },
      "Semicolon": {
        "keyCode": 186,
        "shiftKey": ":",
        "key": ";"
      },
      "Quote": {
        "keyCode": 222,
        "shiftKey": '"',
        "key": "'"
      },
      "Enter": {
        "keyCode": 13,
        "key": "Enter",
        "text": "\r"
      },
      "ShiftLeft": {
        "keyCode": 160,
        "keyCodeWithoutLocation": 16,
        "key": "Shift",
        "location": 1
      },
      "KeyZ": {
        "keyCode": 90,
        "shiftKey": "Z",
        "key": "z"
      },
      "KeyX": {
        "keyCode": 88,
        "shiftKey": "X",
        "key": "x"
      },
      "KeyC": {
        "keyCode": 67,
        "shiftKey": "C",
        "key": "c"
      },
      "KeyV": {
        "keyCode": 86,
        "shiftKey": "V",
        "key": "v"
      },
      "KeyB": {
        "keyCode": 66,
        "shiftKey": "B",
        "key": "b"
      },
      "KeyN": {
        "keyCode": 78,
        "shiftKey": "N",
        "key": "n"
      },
      "KeyM": {
        "keyCode": 77,
        "shiftKey": "M",
        "key": "m"
      },
      "Comma": {
        "keyCode": 188,
        "shiftKey": "<",
        "key": ","
      },
      "Period": {
        "keyCode": 190,
        "shiftKey": ">",
        "key": "."
      },
      "Slash": {
        "keyCode": 191,
        "shiftKey": "?",
        "key": "/"
      },
      "ShiftRight": {
        "keyCode": 161,
        "keyCodeWithoutLocation": 16,
        "key": "Shift",
        "location": 2
      },
      "ControlLeft": {
        "keyCode": 162,
        "keyCodeWithoutLocation": 17,
        "key": "Control",
        "location": 1
      },
      "MetaLeft": {
        "keyCode": 91,
        "key": "Meta",
        "location": 1
      },
      "AltLeft": {
        "keyCode": 164,
        "keyCodeWithoutLocation": 18,
        "key": "Alt",
        "location": 1
      },
      "Space": {
        "keyCode": 32,
        "key": " "
      },
      "AltRight": {
        "keyCode": 165,
        "keyCodeWithoutLocation": 18,
        "key": "Alt",
        "location": 2
      },
      "AltGraph": {
        "keyCode": 225,
        "key": "AltGraph"
      },
      "MetaRight": {
        "keyCode": 92,
        "key": "Meta",
        "location": 2
      },
      "ContextMenu": {
        "keyCode": 93,
        "key": "ContextMenu"
      },
      "ControlRight": {
        "keyCode": 163,
        "keyCodeWithoutLocation": 17,
        "key": "Control",
        "location": 2
      },
      "PrintScreen": {
        "keyCode": 44,
        "key": "PrintScreen"
      },
      "ScrollLock": {
        "keyCode": 145,
        "key": "ScrollLock"
      },
      "Pause": {
        "keyCode": 19,
        "key": "Pause"
      },
      "PageUp": {
        "keyCode": 33,
        "key": "PageUp"
      },
      "PageDown": {
        "keyCode": 34,
        "key": "PageDown"
      },
      "Insert": {
        "keyCode": 45,
        "key": "Insert"
      },
      "Delete": {
        "keyCode": 46,
        "key": "Delete"
      },
      "Home": {
        "keyCode": 36,
        "key": "Home"
      },
      "End": {
        "keyCode": 35,
        "key": "End"
      },
      "ArrowLeft": {
        "keyCode": 37,
        "key": "ArrowLeft"
      },
      "ArrowUp": {
        "keyCode": 38,
        "key": "ArrowUp"
      },
      "ArrowRight": {
        "keyCode": 39,
        "key": "ArrowRight"
      },
      "ArrowDown": {
        "keyCode": 40,
        "key": "ArrowDown"
      },
      "NumLock": {
        "keyCode": 144,
        "key": "NumLock"
      },
      "NumpadDivide": {
        "keyCode": 111,
        "key": "/",
        "location": 3
      },
      "NumpadMultiply": {
        "keyCode": 106,
        "key": "*",
        "location": 3
      },
      "NumpadSubtract": {
        "keyCode": 109,
        "key": "-",
        "location": 3
      },
      "Numpad7": {
        "keyCode": 36,
        "shiftKeyCode": 103,
        "key": "Home",
        "shiftKey": "7",
        "location": 3
      },
      "Numpad8": {
        "keyCode": 38,
        "shiftKeyCode": 104,
        "key": "ArrowUp",
        "shiftKey": "8",
        "location": 3
      },
      "Numpad9": {
        "keyCode": 33,
        "shiftKeyCode": 105,
        "key": "PageUp",
        "shiftKey": "9",
        "location": 3
      },
      "Numpad4": {
        "keyCode": 37,
        "shiftKeyCode": 100,
        "key": "ArrowLeft",
        "shiftKey": "4",
        "location": 3
      },
      "Numpad5": {
        "keyCode": 12,
        "shiftKeyCode": 101,
        "key": "Clear",
        "shiftKey": "5",
        "location": 3
      },
      "Numpad6": {
        "keyCode": 39,
        "shiftKeyCode": 102,
        "key": "ArrowRight",
        "shiftKey": "6",
        "location": 3
      },
      "NumpadAdd": {
        "keyCode": 107,
        "key": "+",
        "location": 3
      },
      "Numpad1": {
        "keyCode": 35,
        "shiftKeyCode": 97,
        "key": "End",
        "shiftKey": "1",
        "location": 3
      },
      "Numpad2": {
        "keyCode": 40,
        "shiftKeyCode": 98,
        "key": "ArrowDown",
        "shiftKey": "2",
        "location": 3
      },
      "Numpad3": {
        "keyCode": 34,
        "shiftKeyCode": 99,
        "key": "PageDown",
        "shiftKey": "3",
        "location": 3
      },
      "Numpad0": {
        "keyCode": 45,
        "shiftKeyCode": 96,
        "key": "Insert",
        "shiftKey": "0",
        "location": 3
      },
      "NumpadDecimal": {
        "keyCode": 46,
        "shiftKeyCode": 110,
        "key": "\0",
        "shiftKey": ".",
        "location": 3
      },
      "NumpadEnter": {
        "keyCode": 13,
        "key": "Enter",
        "text": "\r",
        "location": 3
      }
    };
    exports2.USKeyboardLayout = USKeyboardLayout;
  }
});

// node_modules/playwright-core/lib/server/input.js
var require_input = __commonJS({
  "node_modules/playwright-core/lib/server/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Touchscreen = exports2.Mouse = exports2.Keyboard = exports2.keypadLocation = void 0;
    var _utils2 = require_utils();
    var keyboardLayout = _interopRequireWildcard2(require_usKeyboardLayout());
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var keypadLocation = keyboardLayout.keypadLocation;
    exports2.keypadLocation = keypadLocation;
    var kModifiers = ["Alt", "Control", "Meta", "Shift"];
    var Keyboard = class {
      constructor(raw, page) {
        this._pressedModifiers = /* @__PURE__ */ new Set();
        this._pressedKeys = /* @__PURE__ */ new Set();
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
      }
      down(key) {
        return __async(this, null, function* () {
          const description = this._keyDescriptionForString(key);
          const autoRepeat = this._pressedKeys.has(description.code);
          this._pressedKeys.add(description.code);
          if (kModifiers.includes(description.key))
            this._pressedModifiers.add(description.key);
          const text = description.text;
          yield this._raw.keydown(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location, autoRepeat, text);
          yield this._page._doSlowMo();
        });
      }
      _keyDescriptionForString(keyString) {
        let description = usKeyboardLayout.get(keyString);
        (0, _utils2.assert)(description, `Unknown key: "${keyString}"`);
        const shift = this._pressedModifiers.has("Shift");
        description = shift && description.shifted ? description.shifted : description;
        if (this._pressedModifiers.size > 1 || !this._pressedModifiers.has("Shift") && this._pressedModifiers.size === 1)
          return __spreadProps(__spreadValues({}, description), {
            text: ""
          });
        return description;
      }
      up(key) {
        return __async(this, null, function* () {
          const description = this._keyDescriptionForString(key);
          if (kModifiers.includes(description.key))
            this._pressedModifiers.delete(description.key);
          this._pressedKeys.delete(description.code);
          yield this._raw.keyup(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location);
          yield this._page._doSlowMo();
        });
      }
      insertText(text) {
        return __async(this, null, function* () {
          yield this._raw.sendText(text);
          yield this._page._doSlowMo();
        });
      }
      type(text, options) {
        return __async(this, null, function* () {
          const delay = options && options.delay || void 0;
          for (const char of text) {
            if (usKeyboardLayout.has(char)) {
              yield this.press(char, {
                delay
              });
            } else {
              if (delay)
                yield new Promise((f) => setTimeout(f, delay));
              yield this.insertText(char);
            }
          }
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          function split(keyString) {
            const keys = [];
            let building = "";
            for (const char of keyString) {
              if (char === "+" && building) {
                keys.push(building);
                building = "";
              } else {
                building += char;
              }
            }
            keys.push(building);
            return keys;
          }
          const tokens = split(key);
          const promises = [];
          key = tokens[tokens.length - 1];
          for (let i = 0; i < tokens.length - 1; ++i)
            promises.push(this.down(tokens[i]));
          promises.push(this.down(key));
          if (options.delay) {
            yield Promise.all(promises);
            yield new Promise((f) => setTimeout(f, options.delay));
          }
          promises.push(this.up(key));
          for (let i = tokens.length - 2; i >= 0; --i)
            promises.push(this.up(tokens[i]));
          yield Promise.all(promises);
        });
      }
      _ensureModifiers(modifiers) {
        return __async(this, null, function* () {
          for (const modifier of modifiers) {
            if (!kModifiers.includes(modifier))
              throw new Error("Unknown modifier " + modifier);
          }
          const restore = Array.from(this._pressedModifiers);
          const promises = [];
          for (const key of kModifiers) {
            const needDown = modifiers.includes(key);
            const isDown = this._pressedModifiers.has(key);
            if (needDown && !isDown)
              promises.push(this.down(key));
            else if (!needDown && isDown)
              promises.push(this.up(key));
          }
          yield Promise.all(promises);
          return restore;
        });
      }
      _modifiers() {
        return this._pressedModifiers;
      }
    };
    exports2.Keyboard = Keyboard;
    var Mouse = class {
      constructor(raw, page) {
        this._keyboard = void 0;
        this._x = 0;
        this._y = 0;
        this._lastButton = "none";
        this._buttons = /* @__PURE__ */ new Set();
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
        this._keyboard = this._page.keyboard;
      }
      move(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          const {
            steps = 1
          } = options;
          const fromX = this._x;
          const fromY = this._y;
          this._x = x;
          this._y = y;
          for (let i = 1; i <= steps; i++) {
            const middleX = fromX + (x - fromX) * (i / steps);
            const middleY = fromY + (y - fromY) * (i / steps);
            yield this._raw.move(middleX, middleY, this._lastButton, this._buttons, this._keyboard._modifiers(), !!options.forClick);
            yield this._page._doSlowMo();
          }
        });
      }
      down() {
        return __async(this, arguments, function* (options = {}) {
          const {
            button = "left",
            clickCount = 1
          } = options;
          this._lastButton = button;
          this._buttons.add(button);
          yield this._raw.down(this._x, this._y, this._lastButton, this._buttons, this._keyboard._modifiers(), clickCount);
          yield this._page._doSlowMo();
        });
      }
      up() {
        return __async(this, arguments, function* (options = {}) {
          const {
            button = "left",
            clickCount = 1
          } = options;
          this._lastButton = "none";
          this._buttons.delete(button);
          yield this._raw.up(this._x, this._y, button, this._buttons, this._keyboard._modifiers(), clickCount);
          yield this._page._doSlowMo();
        });
      }
      click(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          const {
            delay = null,
            clickCount = 1
          } = options;
          if (delay) {
            this.move(x, y, {
              forClick: true
            });
            for (let cc = 1; cc <= clickCount; ++cc) {
              yield this.down(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              }));
              yield new Promise((f) => setTimeout(f, delay));
              yield this.up(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              }));
              if (cc < clickCount)
                yield new Promise((f) => setTimeout(f, delay));
            }
          } else {
            const promises = [];
            promises.push(this.move(x, y, {
              forClick: true
            }));
            for (let cc = 1; cc <= clickCount; ++cc) {
              promises.push(this.down(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              })));
              promises.push(this.up(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              })));
            }
            yield Promise.all(promises);
          }
        });
      }
      dblclick(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this.click(x, y, __spreadProps(__spreadValues({}, options), {
            clickCount: 2
          }));
        });
      }
      wheel(deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._raw.wheel(this._x, this._y, this._buttons, this._keyboard._modifiers(), deltaX, deltaY);
          yield this._page._doSlowMo();
        });
      }
    };
    exports2.Mouse = Mouse;
    var aliases = /* @__PURE__ */ new Map([["ShiftLeft", ["Shift"]], ["ControlLeft", ["Control"]], ["AltLeft", ["Alt"]], ["MetaLeft", ["Meta"]], ["Enter", ["\n", "\r"]]]);
    var usKeyboardLayout = buildLayoutClosure(keyboardLayout.USKeyboardLayout);
    function buildLayoutClosure(layout) {
      const result = /* @__PURE__ */ new Map();
      for (const code in layout) {
        const definition = layout[code];
        const description = {
          key: definition.key || "",
          keyCode: definition.keyCode || 0,
          keyCodeWithoutLocation: definition.keyCodeWithoutLocation || definition.keyCode || 0,
          code,
          text: definition.text || "",
          location: definition.location || 0
        };
        if (definition.key.length === 1)
          description.text = description.key;
        let shiftedDescription;
        if (definition.shiftKey) {
          (0, _utils2.assert)(definition.shiftKey.length === 1);
          shiftedDescription = __spreadValues({}, description);
          shiftedDescription.key = definition.shiftKey;
          shiftedDescription.text = definition.shiftKey;
          if (definition.shiftKeyCode)
            shiftedDescription.keyCode = definition.shiftKeyCode;
        }
        result.set(code, __spreadProps(__spreadValues({}, description), {
          shifted: shiftedDescription
        }));
        if (aliases.has(code)) {
          for (const alias of aliases.get(code))
            result.set(alias, description);
        }
        if (definition.location)
          continue;
        if (description.key.length === 1)
          result.set(description.key, description);
        if (shiftedDescription)
          result.set(shiftedDescription.key, __spreadProps(__spreadValues({}, shiftedDescription), {
            shifted: void 0
          }));
      }
      return result;
    }
    var Touchscreen = class {
      constructor(raw, page) {
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
      }
      tap(x, y) {
        return __async(this, null, function* () {
          if (!this._page._browserContext._options.hasTouch)
            throw new Error("hasTouch must be enabled on the browser context before using the touchscreen.");
          yield this._raw.tap(x, y, this._page.keyboard._modifiers());
          yield this._page._doSlowMo();
        });
      }
    };
    exports2.Touchscreen = Touchscreen;
  }
});

// node_modules/playwright-core/lib/server/screenshotter.js
var require_screenshotter = __commonJS({
  "node_modules/playwright-core/lib/server/screenshotter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Screenshotter = void 0;
    var _helper = require_helper();
    var _utils2 = require_utils();
    var Screenshotter = class {
      constructor(page) {
        this._queue = new TaskQueue();
        this._page = void 0;
        this._page = page;
        this._queue = new TaskQueue();
      }
      _originalViewportSize(progress) {
        return __async(this, null, function* () {
          const originalViewportSize = this._page.viewportSize();
          let viewportSize = originalViewportSize;
          if (!viewportSize)
            viewportSize = yield this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
              width: window.innerWidth,
              height: window.innerHeight
            }));
          return {
            viewportSize,
            originalViewportSize
          };
        });
      }
      _fullPageSize(progress) {
        return __async(this, null, function* () {
          const fullPageSize = yield this._page.mainFrame().waitForFunctionValueInUtility(progress, () => {
            if (!document.body || !document.documentElement)
              return null;
            return {
              width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth),
              height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)
            };
          });
          return fullPageSize;
        });
      }
      screenshotPage(progress, options) {
        return __async(this, null, function* () {
          const format = validateScreenshotOptions(options);
          return this._queue.postTask(() => __async(this, null, function* () {
            const {
              viewportSize
            } = yield this._originalViewportSize(progress);
            if (options.fullPage) {
              const fullPageSize = yield this._fullPageSize(progress);
              let documentRect = {
                x: 0,
                y: 0,
                width: fullPageSize.width,
                height: fullPageSize.height
              };
              const fitsViewport = fullPageSize.width <= viewportSize.width && fullPageSize.height <= viewportSize.height;
              if (options.clip)
                documentRect = trimClipToSize(options.clip, documentRect);
              const buffer = yield this._screenshot(progress, format, documentRect, void 0, fitsViewport, options);
              progress.throwIfAborted();
              return buffer;
            }
            const viewportRect = options.clip ? trimClipToSize(options.clip, viewportSize) : __spreadValues({
              x: 0,
              y: 0
            }, viewportSize);
            return yield this._screenshot(progress, format, void 0, viewportRect, true, options);
          }));
        });
      }
      screenshotElement(_0, _1) {
        return __async(this, arguments, function* (progress, handle, options = {}) {
          const format = validateScreenshotOptions(options);
          return this._queue.postTask(() => __async(this, null, function* () {
            const {
              viewportSize
            } = yield this._originalViewportSize(progress);
            yield handle._waitAndScrollIntoViewIfNeeded(progress);
            progress.throwIfAborted();
            const boundingBox = yield handle.boundingBox();
            (0, _utils2.assert)(boundingBox, "Node is either not visible or not an HTMLElement");
            (0, _utils2.assert)(boundingBox.width !== 0, "Node has 0 width.");
            (0, _utils2.assert)(boundingBox.height !== 0, "Node has 0 height.");
            const fitsViewport = boundingBox.width <= viewportSize.width && boundingBox.height <= viewportSize.height;
            progress.throwIfAborted();
            const scrollOffset = yield this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
              x: window.scrollX,
              y: window.scrollY
            }));
            const documentRect = __spreadValues({}, boundingBox);
            documentRect.x += scrollOffset.x;
            documentRect.y += scrollOffset.y;
            const buffer = yield this._screenshot(progress, format, _helper.helper.enclosingIntRect(documentRect), void 0, fitsViewport, options);
            progress.throwIfAborted();
            return buffer;
          }));
        });
      }
      _screenshot(progress, format, documentRect, viewportRect, fitsViewport, options) {
        return __async(this, null, function* () {
          if (options.__testHookBeforeScreenshot)
            yield options.__testHookBeforeScreenshot();
          progress.throwIfAborted();
          const shouldSetDefaultBackground = options.omitBackground && format === "png";
          if (shouldSetDefaultBackground) {
            yield this._page._delegate.setBackgroundColor({
              r: 0,
              g: 0,
              b: 0,
              a: 0
            });
            progress.cleanupWhenAborted(() => this._page._delegate.setBackgroundColor());
          }
          progress.throwIfAborted();
          const buffer = yield this._page._delegate.takeScreenshot(progress, format, documentRect, viewportRect, options.quality, fitsViewport);
          progress.throwIfAborted();
          if (shouldSetDefaultBackground)
            yield this._page._delegate.setBackgroundColor();
          progress.throwIfAborted();
          if (options.__testHookAfterScreenshot)
            yield options.__testHookAfterScreenshot();
          return buffer;
        });
      }
    };
    exports2.Screenshotter = Screenshotter;
    var TaskQueue = class {
      constructor() {
        this._chain = void 0;
        this._chain = Promise.resolve();
      }
      postTask(task) {
        const result = this._chain.then(task);
        this._chain = result.catch(() => {
        });
        return result;
      }
    };
    function trimClipToSize(clip, size) {
      const p1 = {
        x: Math.max(0, Math.min(clip.x, size.width)),
        y: Math.max(0, Math.min(clip.y, size.height))
      };
      const p2 = {
        x: Math.max(0, Math.min(clip.x + clip.width, size.width)),
        y: Math.max(0, Math.min(clip.y + clip.height, size.height))
      };
      const result = {
        x: p1.x,
        y: p1.y,
        width: p2.x - p1.x,
        height: p2.y - p1.y
      };
      (0, _utils2.assert)(result.width && result.height, "Clipped area is either empty or outside the resulting image");
      return result;
    }
    function validateScreenshotOptions(options) {
      let format = null;
      if (options.type) {
        (0, _utils2.assert)(options.type === "png" || options.type === "jpeg", "Unknown options.type value: " + options.type);
        format = options.type;
      }
      if (!format)
        format = "png";
      if (options.quality !== void 0) {
        (0, _utils2.assert)(format === "jpeg", "options.quality is unsupported for the " + format + " screenshots");
        (0, _utils2.assert)(typeof options.quality === "number", "Expected options.quality to be a number but found " + typeof options.quality);
        (0, _utils2.assert)(Number.isInteger(options.quality), "Expected options.quality to be an integer");
        (0, _utils2.assert)(options.quality >= 0 && options.quality <= 100, "Expected options.quality to be between 0 and 100 (inclusive), got " + options.quality);
      }
      if (options.clip) {
        (0, _utils2.assert)(typeof options.clip.x === "number", "Expected options.clip.x to be a number but found " + typeof options.clip.x);
        (0, _utils2.assert)(typeof options.clip.y === "number", "Expected options.clip.y to be a number but found " + typeof options.clip.y);
        (0, _utils2.assert)(typeof options.clip.width === "number", "Expected options.clip.width to be a number but found " + typeof options.clip.width);
        (0, _utils2.assert)(typeof options.clip.height === "number", "Expected options.clip.height to be a number but found " + typeof options.clip.height);
        (0, _utils2.assert)(options.clip.width !== 0, "Expected options.clip.width not to be 0.");
        (0, _utils2.assert)(options.clip.height !== 0, "Expected options.clip.height not to be 0.");
      }
      return format;
    }
  }
});

// node_modules/playwright-core/lib/server/console.js
var require_console = __commonJS({
  "node_modules/playwright-core/lib/server/console.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConsoleMessage = void 0;
    var _instrumentation = require_instrumentation();
    var ConsoleMessage = class extends _instrumentation.SdkObject {
      constructor(parent, type, text, args, location2) {
        super(parent, "console-message");
        this._type = void 0;
        this._text = void 0;
        this._args = void 0;
        this._location = void 0;
        this._type = type;
        this._text = text;
        this._args = args;
        this._location = location2 || {
          url: "",
          lineNumber: 0,
          columnNumber: 0
        };
      }
      type() {
        return this._type;
      }
      text() {
        if (this._text === void 0)
          this._text = this._args.map((arg) => arg.preview()).join(" ");
        return this._text;
      }
      args() {
        return this._args;
      }
      location() {
        return this._location;
      }
    };
    exports2.ConsoleMessage = ConsoleMessage;
  }
});

// node_modules/playwright-core/lib/server/accessibility.js
var require_accessibility = __commonJS({
  "node_modules/playwright-core/lib/server/accessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Accessibility = void 0;
    var Accessibility = class {
      constructor(getAXTree) {
        this._getAXTree = void 0;
        this._getAXTree = getAXTree;
      }
      snapshot() {
        return __async(this, arguments, function* (options = {}) {
          const {
            interestingOnly = true,
            root = null
          } = options;
          const {
            tree,
            needle
          } = yield this._getAXTree(root || void 0);
          if (!interestingOnly) {
            if (root)
              return needle && serializeTree(needle)[0];
            return serializeTree(tree)[0];
          }
          const interestingNodes = /* @__PURE__ */ new Set();
          collectInterestingNodes(interestingNodes, tree, false);
          if (root && (!needle || !interestingNodes.has(needle)))
            return null;
          return serializeTree(needle || tree, interestingNodes)[0];
        });
      }
    };
    exports2.Accessibility = Accessibility;
    function collectInterestingNodes(collection, node, insideControl) {
      if (node.isInteresting(insideControl))
        collection.add(node);
      if (node.isLeafNode())
        return;
      insideControl = insideControl || node.isControl();
      for (const child of node.children())
        collectInterestingNodes(collection, child, insideControl);
    }
    function serializeTree(node, whitelistedNodes) {
      const children = [];
      for (const child of node.children())
        children.push(...serializeTree(child, whitelistedNodes));
      if (whitelistedNodes && !whitelistedNodes.has(node))
        return children;
      const serializedNode = node.serialize();
      if (children.length)
        serializedNode.children = children;
      return [serializedNode];
    }
  }
});

// node_modules/playwright-core/lib/server/fileChooser.js
var require_fileChooser = __commonJS({
  "node_modules/playwright-core/lib/server/fileChooser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FileChooser = void 0;
    var FileChooser = class {
      constructor(page, elementHandle, isMultiple) {
        this._page = void 0;
        this._elementHandle = void 0;
        this._isMultiple = void 0;
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
      }
      element() {
        return this._elementHandle;
      }
      isMultiple() {
        return this._isMultiple;
      }
      page() {
        return this._page;
      }
    };
    exports2.FileChooser = FileChooser;
  }
});

// node_modules/playwright-core/lib/server/page.js
var require_page = __commonJS({
  "node_modules/playwright-core/lib/server/page.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PageBinding = exports2.Worker = exports2.Page = void 0;
    var frames = _interopRequireWildcard2(require_frames());
    var input = _interopRequireWildcard2(require_input());
    var js = _interopRequireWildcard2(require_javascript());
    var network = _interopRequireWildcard2(require_network());
    var _screenshotter = require_screenshotter();
    var _timeoutSettings = require_timeoutSettings();
    var _browserContext = require_browserContext();
    var _console = require_console();
    var accessibility = _interopRequireWildcard2(require_accessibility());
    var _fileChooser = require_fileChooser();
    var _progress = require_progress2();
    var _utils2 = require_utils();
    var _async = require_async();
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Page = class extends _instrumentation.SdkObject {
      constructor(delegate, browserContext) {
        super(browserContext, "page");
        this._closedState = "open";
        this._closedPromise = new _async.ManualPromise();
        this._disconnected = false;
        this._initialized = false;
        this._disconnectedPromise = new _async.ManualPromise();
        this._crashedPromise = new _async.ManualPromise();
        this._browserContext = void 0;
        this.keyboard = void 0;
        this.mouse = void 0;
        this.touchscreen = void 0;
        this._timeoutSettings = void 0;
        this._delegate = void 0;
        this._state = void 0;
        this._pageBindings = /* @__PURE__ */ new Map();
        this._evaluateOnNewDocumentSources = [];
        this._screenshotter = void 0;
        this._frameManager = void 0;
        this.accessibility = void 0;
        this._workers = /* @__PURE__ */ new Map();
        this.pdf = void 0;
        this.coverage = void 0;
        this._clientRequestInterceptor = void 0;
        this._serverRequestInterceptor = void 0;
        this._ownedContext = void 0;
        this.selectors = void 0;
        this._pageIsError = void 0;
        this._video = null;
        this._opener = void 0;
        this._frameThrottler = new FrameThrottler(10, 200);
        this.attribution.page = this;
        this._delegate = delegate;
        this._browserContext = browserContext;
        this._state = {
          emulatedSize: browserContext._options.viewport ? {
            viewport: browserContext._options.viewport,
            screen: browserContext._options.screen || browserContext._options.viewport
          } : null,
          mediaType: null,
          colorScheme: browserContext._options.colorScheme !== void 0 ? browserContext._options.colorScheme : "light",
          reducedMotion: browserContext._options.reducedMotion !== void 0 ? browserContext._options.reducedMotion : "no-preference",
          forcedColors: browserContext._options.forcedColors !== void 0 ? browserContext._options.forcedColors : "none",
          extraHTTPHeaders: null
        };
        this.accessibility = new accessibility.Accessibility(delegate.getAccessibilityTree.bind(delegate));
        this.keyboard = new input.Keyboard(delegate.rawKeyboard, this);
        this.mouse = new input.Mouse(delegate.rawMouse, this);
        this.touchscreen = new input.Touchscreen(delegate.rawTouchscreen, this);
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(browserContext._timeoutSettings);
        this._screenshotter = new _screenshotter.Screenshotter(this);
        this._frameManager = new frames.FrameManager(this);
        if (delegate.pdf)
          this.pdf = delegate.pdf.bind(delegate);
        this.coverage = delegate.coverage ? delegate.coverage() : null;
        this.selectors = browserContext.selectors();
        this.instrumentation.onPageOpen(this);
      }
      initOpener(opener) {
        return __async(this, null, function* () {
          if (!opener)
            return;
          const openerPage = yield opener.pageOrError();
          if (openerPage instanceof Page && !openerPage.isClosed())
            this._opener = openerPage;
        });
      }
      reportAsNew(error) {
        if (error) {
          if (this._browserContext.isClosingOrClosed())
            return;
          this._setIsError(error);
        }
        this._initialized = true;
        this._browserContext.emit(_browserContext.BrowserContext.Events.Page, this);
        if (this.isClosed())
          this.emit(Page.Events.Close);
      }
      initializedOrUndefined() {
        return this._initialized ? this : void 0;
      }
      _doSlowMo() {
        return __async(this, null, function* () {
          const slowMo = this._browserContext._browser.options.slowMo;
          if (!slowMo)
            return;
          yield new Promise((x) => setTimeout(x, slowMo));
        });
      }
      _didClose() {
        this.instrumentation.onPageClose(this);
        this._frameManager.dispose();
        this._frameThrottler.setEnabled(false);
        (0, _utils2.assert)(this._closedState !== "closed", "Page closed twice");
        this._closedState = "closed";
        this.emit(Page.Events.Close);
        this._closedPromise.resolve();
      }
      _didCrash() {
        this.instrumentation.onPageClose(this);
        this._frameManager.dispose();
        this._frameThrottler.setEnabled(false);
        this.emit(Page.Events.Crash);
        this._crashedPromise.resolve(new Error("Page crashed"));
      }
      _didDisconnect() {
        this.instrumentation.onPageClose(this);
        this._frameManager.dispose();
        this._frameThrottler.setEnabled(false);
        (0, _utils2.assert)(!this._disconnected, "Page disconnected twice");
        this._disconnected = true;
        this._disconnectedPromise.resolve(new Error("Page closed"));
      }
      _onFileChooserOpened(handle) {
        return __async(this, null, function* () {
          let multiple;
          try {
            multiple = yield handle.evaluate((element) => !!element.multiple);
          } catch (e) {
            return;
          }
          if (!this.listenerCount(Page.Events.FileChooser)) {
            handle.dispose();
            return;
          }
          const fileChooser = new _fileChooser.FileChooser(this, handle, multiple);
          this.emit(Page.Events.FileChooser, fileChooser);
        });
      }
      context() {
        return this._browserContext;
      }
      opener() {
        return this._opener;
      }
      mainFrame() {
        return this._frameManager.mainFrame();
      }
      frames() {
        return this._frameManager.frames();
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      exposeBinding(name, needsHandle, playwrightBinding) {
        return __async(this, null, function* () {
          if (this._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
          if (this._browserContext._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered in the browser context`);
          const binding = new PageBinding(name, playwrightBinding, needsHandle);
          this._pageBindings.set(name, binding);
          yield this._delegate.exposeBinding(binding);
        });
      }
      setExtraHTTPHeaders(headers) {
        this._state.extraHTTPHeaders = headers;
        return this._delegate.updateExtraHTTPHeaders();
      }
      _onBindingCalled(payload, context) {
        return __async(this, null, function* () {
          if (this._disconnected || this._closedState === "closed")
            return;
          yield PageBinding.dispatch(this, payload, context);
        });
      }
      _addConsoleMessage(type, args, location2, text) {
        const message = new _console.ConsoleMessage(this, type, text, args, location2);
        const intercepted = this._frameManager.interceptConsoleMessage(message);
        if (intercepted || !this.listenerCount(Page.Events.Console))
          args.forEach((arg) => arg.dispose());
        else
          this.emit(Page.Events.Console, message);
      }
      reload(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this.mainFrame().raceNavigationAction(() => __async(this, null, function* () {
            const [response] = yield Promise.all([this.mainFrame()._waitForNavigation(progress, options), this._delegate.reload()]);
            yield this._doSlowMo();
            return response;
          })), this._timeoutSettings.navigationTimeout(options));
        });
      }
      goBack(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this.mainFrame().raceNavigationAction(() => __async(this, null, function* () {
            let error;
            const waitPromise = this.mainFrame()._waitForNavigation(progress, options).catch((e) => {
              error = e;
              return null;
            });
            const result = yield this._delegate.goBack();
            if (!result)
              return null;
            const response = yield waitPromise;
            if (error)
              throw error;
            yield this._doSlowMo();
            return response;
          })), this._timeoutSettings.navigationTimeout(options));
        });
      }
      goForward(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this.mainFrame().raceNavigationAction(() => __async(this, null, function* () {
            let error;
            const waitPromise = this.mainFrame()._waitForNavigation(progress, options).catch((e) => {
              error = e;
              return null;
            });
            const result = yield this._delegate.goForward();
            if (!result)
              return null;
            const response = yield waitPromise;
            if (error)
              throw error;
            yield this._doSlowMo();
            return response;
          })), this._timeoutSettings.navigationTimeout(options));
        });
      }
      emulateMedia(options) {
        return __async(this, null, function* () {
          if (options.media !== void 0)
            this._state.mediaType = options.media;
          if (options.colorScheme !== void 0)
            this._state.colorScheme = options.colorScheme;
          if (options.reducedMotion !== void 0)
            this._state.reducedMotion = options.reducedMotion;
          if (options.forcedColors !== void 0)
            this._state.forcedColors = options.forcedColors;
          yield this._delegate.updateEmulateMedia();
          yield this._doSlowMo();
        });
      }
      setViewportSize(viewportSize) {
        return __async(this, null, function* () {
          this._state.emulatedSize = {
            viewport: __spreadValues({}, viewportSize),
            screen: __spreadValues({}, viewportSize)
          };
          yield this._delegate.setEmulatedSize(this._state.emulatedSize);
          yield this._doSlowMo();
        });
      }
      viewportSize() {
        var _this$_state$emulated;
        return ((_this$_state$emulated = this._state.emulatedSize) === null || _this$_state$emulated === void 0 ? void 0 : _this$_state$emulated.viewport) || null;
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._delegate.bringToFront();
        });
      }
      _addInitScriptExpression(source) {
        return __async(this, null, function* () {
          this._evaluateOnNewDocumentSources.push(source);
          yield this._delegate.evaluateOnNewDocument(source);
        });
      }
      _needsRequestInterception() {
        return !!this._clientRequestInterceptor || !!this._serverRequestInterceptor || !!this._browserContext._requestInterceptor;
      }
      _setClientRequestInterceptor(handler) {
        return __async(this, null, function* () {
          this._clientRequestInterceptor = handler;
          yield this._delegate.updateRequestInterception();
        });
      }
      _setServerRequestInterceptor(handler) {
        return __async(this, null, function* () {
          this._serverRequestInterceptor = handler;
          yield this._delegate.updateRequestInterception();
        });
      }
      _requestStarted(request, routeDelegate) {
        const route = new network.Route(request, routeDelegate);
        if (this._serverRequestInterceptor) {
          this._serverRequestInterceptor(route, request);
          return;
        }
        if (this._clientRequestInterceptor) {
          this._clientRequestInterceptor(route, request);
          return;
        }
        if (this._browserContext._requestInterceptor) {
          this._browserContext._requestInterceptor(route, request);
          return;
        }
        route.continue();
      }
      screenshot(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this._screenshotter.screenshotPage(progress, options), this._timeoutSettings.timeout(options));
        });
      }
      close(metadata, options) {
        return __async(this, null, function* () {
          if (this._closedState === "closed")
            return;
          const runBeforeUnload = !!options && !!options.runBeforeUnload;
          if (this._closedState !== "closing") {
            this._closedState = "closing";
            (0, _utils2.assert)(!this._disconnected, "Target closed");
            yield this._delegate.closePage(runBeforeUnload).catch((e) => _debugLogger.debugLogger.log("error", e));
          }
          if (!runBeforeUnload)
            yield this._closedPromise;
          if (this._ownedContext)
            yield this._ownedContext.close(metadata);
        });
      }
      _setIsError(error) {
        this._pageIsError = error;
        if (!this._frameManager.mainFrame())
          this._frameManager.frameAttached("<dummy>", null);
      }
      isClosed() {
        return this._closedState === "closed";
      }
      _addWorker(workerId, worker) {
        this._workers.set(workerId, worker);
        this.emit(Page.Events.Worker, worker);
      }
      _removeWorker(workerId) {
        const worker = this._workers.get(workerId);
        if (!worker)
          return;
        worker.didClose();
        this._workers.delete(workerId);
      }
      _clearWorkers() {
        for (const [workerId, worker] of this._workers) {
          worker.didClose();
          this._workers.delete(workerId);
        }
      }
      _setFileChooserIntercepted(enabled) {
        return __async(this, null, function* () {
          yield this._delegate.setFileChooserIntercepted(enabled);
        });
      }
      frameNavigatedToNewDocument(frame) {
        this.emit(Page.Events.InternalFrameNavigatedToNewDocument, frame);
        const url = frame.url();
        if (!url.startsWith("http"))
          return;
        const purl = network.parsedURL(url);
        if (purl)
          this._browserContext.addVisitedOrigin(purl.origin);
      }
      allBindings() {
        return [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
      }
      getBinding(name) {
        return this._pageBindings.get(name) || this._browserContext._pageBindings.get(name);
      }
      setScreencastOptions(options) {
        this._delegate.setScreencastOptions(options).catch((e) => _debugLogger.debugLogger.log("error", e));
        this._frameThrottler.setEnabled(!!options);
      }
      throttleScreencastFrameAck(ack) {
        this._frameThrottler.ack(ack);
      }
      temporarlyDisableTracingScreencastThrottling() {
        this._frameThrottler.recharge();
      }
      firePageError(error) {
        this.emit(Page.Events.PageError, error);
      }
      parseSelector(selector, options) {
        const strict = typeof (options === null || options === void 0 ? void 0 : options.strict) === "boolean" ? options.strict : !!this.context()._options.strictSelectors;
        return this.selectors.parseSelector(selector, strict);
      }
      hideHighlight() {
        return __async(this, null, function* () {
          yield Promise.all(this.frames().map((frame) => frame.hideHighlight().catch(() => {
          })));
        });
      }
    };
    exports2.Page = Page;
    Page.Events = {
      Close: "close",
      Crash: "crash",
      Console: "console",
      Dialog: "dialog",
      Download: "download",
      FileChooser: "filechooser",
      DOMContentLoaded: "domcontentloaded",
      PageError: "pageerror",
      FrameAttached: "frameattached",
      FrameDetached: "framedetached",
      InternalFrameNavigatedToNewDocument: "internalframenavigatedtonewdocument",
      Load: "load",
      ScreencastFrame: "screencastframe",
      Video: "video",
      WebSocket: "websocket",
      Worker: "worker"
    };
    var Worker = class extends _instrumentation.SdkObject {
      constructor(parent, url) {
        super(parent, "worker");
        this._url = void 0;
        this._executionContextPromise = void 0;
        this._executionContextCallback = void 0;
        this._existingExecutionContext = null;
        this._url = url;
        this._executionContextCallback = () => {
        };
        this._executionContextPromise = new Promise((x) => this._executionContextCallback = x);
      }
      _createExecutionContext(delegate) {
        this._existingExecutionContext = new js.ExecutionContext(this, delegate);
        this._executionContextCallback(this._existingExecutionContext);
      }
      url() {
        return this._url;
      }
      didClose() {
        if (this._existingExecutionContext)
          this._existingExecutionContext.contextDestroyed(new Error("Worker was closed"));
        this.emit(Worker.Events.Close, this);
      }
      evaluateExpression(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluateExpression(yield this._executionContextPromise, true, expression, isFunction, arg);
        });
      }
      evaluateExpressionHandle(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluateExpression(yield this._executionContextPromise, false, expression, isFunction, arg);
        });
      }
    };
    exports2.Worker = Worker;
    Worker.Events = {
      Close: "close"
    };
    var PageBinding = class {
      constructor(name, playwrightFunction, needsHandle) {
        this.name = void 0;
        this.playwrightFunction = void 0;
        this.source = void 0;
        this.needsHandle = void 0;
        this.name = name;
        this.playwrightFunction = playwrightFunction;
        this.source = `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle})`;
        this.needsHandle = needsHandle;
      }
      static dispatch(page, payload, context) {
        return __async(this, null, function* () {
          const {
            name,
            seq,
            args
          } = JSON.parse(payload);
          try {
            (0, _utils2.assert)(context.world);
            const binding = page.getBinding(name);
            let result;
            if (binding.needsHandle) {
              const handle = yield context.evaluateHandle(takeHandle, {
                name,
                seq
              }).catch((e) => null);
              result = yield binding.playwrightFunction({
                frame: context.frame,
                page,
                context: page._browserContext
              }, handle);
            } else {
              result = yield binding.playwrightFunction({
                frame: context.frame,
                page,
                context: page._browserContext
              }, ...args);
            }
            context.evaluate(deliverResult, {
              name,
              seq,
              result
            }).catch((e) => _debugLogger.debugLogger.log("error", e));
          } catch (error) {
            if ((0, _utils2.isError)(error))
              context.evaluate(deliverError, {
                name,
                seq,
                message: error.message,
                stack: error.stack
              }).catch((e) => _debugLogger.debugLogger.log("error", e));
            else
              context.evaluate(deliverErrorValue, {
                name,
                seq,
                error
              }).catch((e) => _debugLogger.debugLogger.log("error", e));
          }
          function takeHandle(arg) {
            const handle = globalThis[arg.name]["handles"].get(arg.seq);
            globalThis[arg.name]["handles"].delete(arg.seq);
            return handle;
          }
          function deliverResult(arg) {
            globalThis[arg.name]["callbacks"].get(arg.seq).resolve(arg.result);
            globalThis[arg.name]["callbacks"].delete(arg.seq);
          }
          function deliverError(arg) {
            const error = new Error(arg.message);
            error.stack = arg.stack;
            globalThis[arg.name]["callbacks"].get(arg.seq).reject(error);
            globalThis[arg.name]["callbacks"].delete(arg.seq);
          }
          function deliverErrorValue(arg) {
            globalThis[arg.name]["callbacks"].get(arg.seq).reject(arg.error);
            globalThis[arg.name]["callbacks"].delete(arg.seq);
          }
        });
      }
    };
    exports2.PageBinding = PageBinding;
    function addPageBinding(bindingName, needsHandle) {
      const binding = globalThis[bindingName];
      if (binding.__installed)
        return;
      globalThis[bindingName] = (...args) => {
        const me = globalThis[bindingName];
        if (needsHandle && args.slice(1).some((arg) => arg !== void 0))
          throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
        let callbacks = me["callbacks"];
        if (!callbacks) {
          callbacks = /* @__PURE__ */ new Map();
          me["callbacks"] = callbacks;
        }
        const seq = (me["lastSeq"] || 0) + 1;
        me["lastSeq"] = seq;
        let handles = me["handles"];
        if (!handles) {
          handles = /* @__PURE__ */ new Map();
          me["handles"] = handles;
        }
        const promise = new Promise((resolve, reject) => callbacks.set(seq, {
          resolve,
          reject
        }));
        if (needsHandle) {
          handles.set(seq, args[0]);
          binding(JSON.stringify({
            name: bindingName,
            seq
          }));
        } else {
          binding(JSON.stringify({
            name: bindingName,
            seq,
            args
          }));
        }
        return promise;
      };
      globalThis[bindingName].__installed = true;
    }
    var FrameThrottler = class {
      constructor(nonThrottledFrames, interval) {
        this._acks = [];
        this._interval = void 0;
        this._nonThrottledFrames = void 0;
        this._budget = void 0;
        this._intervalId = void 0;
        this._nonThrottledFrames = nonThrottledFrames;
        this._budget = nonThrottledFrames;
        this._interval = interval;
      }
      setEnabled(enabled) {
        if (enabled) {
          if (this._intervalId)
            clearInterval(this._intervalId);
          this._intervalId = setInterval(() => this._tick(), this._interval);
        } else if (this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
      }
      recharge() {
        for (const ack of this._acks)
          ack();
        this._acks = [];
        this._budget = this._nonThrottledFrames;
      }
      ack(ack) {
        if (!this._intervalId) {
          ack();
          return;
        }
        if (--this._budget > 0) {
          ack();
          return;
        }
        this._acks.push(ack);
      }
      _tick() {
        var _this$_acks$shift;
        (_this$_acks$shift = this._acks.shift()) === null || _this$_acks$shift === void 0 ? void 0 : _this$_acks$shift();
      }
    };
  }
});

// node_modules/playwright-core/lib/protocol/channels.js
var require_channels = __commonJS({
  "node_modules/playwright-core/lib/protocol/channels.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.pausesBeforeInputActions = exports2.commandsWithTracingSnapshots = void 0;
    var commandsWithTracingSnapshots = /* @__PURE__ */ new Set(["EventTarget.waitForEventInfo", "BrowserContext.waitForEventInfo", "Page.waitForEventInfo", "WebSocket.waitForEventInfo", "ElectronApplication.waitForEventInfo", "AndroidDevice.waitForEventInfo", "Page.goBack", "Page.goForward", "Page.reload", "Page.setViewportSize", "Page.keyboardDown", "Page.keyboardUp", "Page.keyboardInsertText", "Page.keyboardType", "Page.keyboardPress", "Page.mouseMove", "Page.mouseDown", "Page.mouseUp", "Page.mouseClick", "Page.mouseWheel", "Page.touchscreenTap", "Frame.evalOnSelector", "Frame.evalOnSelectorAll", "Frame.addScriptTag", "Frame.addStyleTag", "Frame.check", "Frame.click", "Frame.dragAndDrop", "Frame.dblclick", "Frame.dispatchEvent", "Frame.evaluateExpression", "Frame.evaluateExpressionHandle", "Frame.fill", "Frame.focus", "Frame.getAttribute", "Frame.goto", "Frame.hover", "Frame.innerHTML", "Frame.innerText", "Frame.inputValue", "Frame.isChecked", "Frame.isDisabled", "Frame.isEnabled", "Frame.isHidden", "Frame.isVisible", "Frame.isEditable", "Frame.press", "Frame.selectOption", "Frame.setContent", "Frame.setInputFiles", "Frame.tap", "Frame.textContent", "Frame.type", "Frame.uncheck", "Frame.waitForTimeout", "Frame.waitForFunction", "Frame.waitForSelector", "Frame.expect", "JSHandle.evaluateExpression", "ElementHandle.evaluateExpression", "JSHandle.evaluateExpressionHandle", "ElementHandle.evaluateExpressionHandle", "ElementHandle.evalOnSelector", "ElementHandle.evalOnSelectorAll", "ElementHandle.check", "ElementHandle.click", "ElementHandle.dblclick", "ElementHandle.dispatchEvent", "ElementHandle.fill", "ElementHandle.hover", "ElementHandle.innerHTML", "ElementHandle.innerText", "ElementHandle.inputValue", "ElementHandle.isChecked", "ElementHandle.isDisabled", "ElementHandle.isEditable", "ElementHandle.isEnabled", "ElementHandle.isHidden", "ElementHandle.isVisible", "ElementHandle.press", "ElementHandle.scrollIntoViewIfNeeded", "ElementHandle.selectOption", "ElementHandle.selectText", "ElementHandle.setInputFiles", "ElementHandle.tap", "ElementHandle.textContent", "ElementHandle.type", "ElementHandle.uncheck", "ElementHandle.waitForElementState", "ElementHandle.waitForSelector"]);
    exports2.commandsWithTracingSnapshots = commandsWithTracingSnapshots;
    var pausesBeforeInputActions = /* @__PURE__ */ new Set(["Frame.check", "Frame.click", "Frame.dragAndDrop", "Frame.dblclick", "Frame.fill", "Frame.hover", "Frame.press", "Frame.selectOption", "Frame.setInputFiles", "Frame.tap", "Frame.type", "Frame.uncheck", "ElementHandle.check", "ElementHandle.click", "ElementHandle.dblclick", "ElementHandle.fill", "ElementHandle.hover", "ElementHandle.press", "ElementHandle.selectOption", "ElementHandle.setInputFiles", "ElementHandle.tap", "ElementHandle.type", "ElementHandle.uncheck"]);
    exports2.pausesBeforeInputActions = pausesBeforeInputActions;
  }
});

// node_modules/playwright-core/lib/server/supplements/debugger.js
var require_debugger = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/debugger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Debugger = void 0;
    var _events = require("events");
    var _utils2 = require_utils();
    var _channels = require_channels();
    var symbol = Symbol("Debugger");
    var Debugger = class extends _events.EventEmitter {
      constructor(context) {
        super();
        this._pauseOnNextStatement = false;
        this._pausedCallsMetadata = /* @__PURE__ */ new Map();
        this._enabled = void 0;
        this._context = void 0;
        this._muted = false;
        this._context = context;
        this._context[symbol] = this;
        this._enabled = (0, _utils2.debugMode)() === "inspector";
        if (this._enabled)
          this.pauseOnNextStatement();
      }
      static lookup(context) {
        if (!context)
          return;
        return context[symbol];
      }
      setMuted(muted) {
        return __async(this, null, function* () {
          this._muted = muted;
        });
      }
      onBeforeCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._muted)
            return;
          if (shouldPauseOnCall(sdkObject, metadata) || this._pauseOnNextStatement && shouldPauseBeforeStep(metadata))
            yield this.pause(sdkObject, metadata);
        });
      }
      onBeforeInputAction(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._muted)
            return;
          if (this._enabled && this._pauseOnNextStatement)
            yield this.pause(sdkObject, metadata);
        });
      }
      pause(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._muted)
            return;
          this._enabled = true;
          metadata.pauseStartTime = (0, _utils2.monotonicTime)();
          const result = new Promise((resolve) => {
            this._pausedCallsMetadata.set(metadata, {
              resolve,
              sdkObject
            });
          });
          this.emit(Debugger.Events.PausedStateChanged);
          return result;
        });
      }
      resume(step) {
        this._pauseOnNextStatement = step;
        const endTime = (0, _utils2.monotonicTime)();
        for (const [metadata, {
          resolve
        }] of this._pausedCallsMetadata) {
          metadata.pauseEndTime = endTime;
          resolve();
        }
        this._pausedCallsMetadata.clear();
        this.emit(Debugger.Events.PausedStateChanged);
      }
      pauseOnNextStatement() {
        this._pauseOnNextStatement = true;
      }
      isPaused(metadata) {
        if (metadata)
          return this._pausedCallsMetadata.has(metadata);
        return !!this._pausedCallsMetadata.size;
      }
      pausedDetails() {
        const result = [];
        for (const [metadata, {
          sdkObject
        }] of this._pausedCallsMetadata)
          result.push({
            metadata,
            sdkObject
          });
        return result;
      }
    };
    exports2.Debugger = Debugger;
    Debugger.Events = {
      PausedStateChanged: "pausedstatechanged"
    };
    function shouldPauseOnCall(sdkObject, metadata) {
      var _sdkObject$attributio;
      if (!((_sdkObject$attributio = sdkObject.attribution.browser) !== null && _sdkObject$attributio !== void 0 && _sdkObject$attributio.options.headful) && !(0, _utils2.isUnderTest)())
        return false;
      return metadata.method === "pause";
    }
    function shouldPauseBeforeStep(metadata) {
      if (metadata.method === "close")
        return true;
      if (metadata.method === "waitForSelector" || metadata.method === "waitForEventInfo")
        return false;
      const step = metadata.type + "." + metadata.method;
      return _channels.commandsWithTracingSnapshots.has(step) && !_channels.pausesBeforeInputActions.has(metadata.type + "." + metadata.method);
    }
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/buffer-crc32/index.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/yazl/index.js
var require_yazl = __commonJS({
  "node_modules/yazl/index.js"(exports2) {
    var fs = require("fs");
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var zlib = require("zlib");
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var crc32 = require_buffer_crc32();
    exports2.ZipFile = ZipFile;
    exports2.dateToDosDateTime = dateToDosDateTime;
    util.inherits(ZipFile, EventEmitter);
    function ZipFile() {
      this.outputStream = new PassThrough();
      this.entries = [];
      this.outputStreamCursor = 0;
      this.ended = false;
      this.allDone = false;
      this.forceZip64Eocd = false;
    }
    ZipFile.prototype.addFile = function(realPath, metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (options == null)
        options = {};
      var entry = new Entry(metadataPath, false, options);
      self2.entries.push(entry);
      fs.stat(realPath, function(err, stats) {
        if (err)
          return self2.emit("error", err);
        if (!stats.isFile())
          return self2.emit("error", new Error("not a file: " + realPath));
        entry.uncompressedSize = stats.size;
        if (options.mtime == null)
          entry.setLastModDate(stats.mtime);
        if (options.mode == null)
          entry.setFileAttributesMode(stats.mode);
        entry.setFileDataPumpFunction(function() {
          var readStream = fs.createReadStream(realPath);
          entry.state = Entry.FILE_DATA_IN_PROGRESS;
          readStream.on("error", function(err2) {
            self2.emit("error", err2);
          });
          pumpFileDataReadStream(self2, entry, readStream);
        });
        pumpEntries(self2);
      });
    };
    ZipFile.prototype.addReadStream = function(readStream, metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (options == null)
        options = {};
      var entry = new Entry(metadataPath, false, options);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        entry.state = Entry.FILE_DATA_IN_PROGRESS;
        pumpFileDataReadStream(self2, entry, readStream);
      });
      pumpEntries(self2);
    };
    ZipFile.prototype.addBuffer = function(buffer, metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (buffer.length > 1073741823)
        throw new Error("buffer too large: " + buffer.length + " > " + 1073741823);
      if (options == null)
        options = {};
      if (options.size != null)
        throw new Error("options.size not allowed");
      var entry = new Entry(metadataPath, false, options);
      entry.uncompressedSize = buffer.length;
      entry.crc32 = crc32.unsigned(buffer);
      entry.crcAndFileSizeKnown = true;
      self2.entries.push(entry);
      if (!entry.compress) {
        setCompressedBuffer(buffer);
      } else {
        zlib.deflateRaw(buffer, function(err, compressedBuffer) {
          setCompressedBuffer(compressedBuffer);
        });
      }
      function setCompressedBuffer(compressedBuffer) {
        entry.compressedSize = compressedBuffer.length;
        entry.setFileDataPumpFunction(function() {
          writeToOutputStream(self2, compressedBuffer);
          writeToOutputStream(self2, entry.getDataDescriptor());
          entry.state = Entry.FILE_DATA_DONE;
          setImmediate(function() {
            pumpEntries(self2);
          });
        });
        pumpEntries(self2);
      }
    };
    ZipFile.prototype.addEmptyDirectory = function(metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, true);
      if (options == null)
        options = {};
      if (options.size != null)
        throw new Error("options.size not allowed");
      if (options.compress != null)
        throw new Error("options.compress not allowed");
      var entry = new Entry(metadataPath, true, options);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
      pumpEntries(self2);
    };
    var eocdrSignatureBuffer = bufferFrom([80, 75, 5, 6]);
    ZipFile.prototype.end = function(options, finalSizeCallback) {
      if (typeof options === "function") {
        finalSizeCallback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (this.ended)
        return;
      this.ended = true;
      this.finalSizeCallback = finalSizeCallback;
      this.forceZip64Eocd = !!options.forceZip64Format;
      if (options.comment) {
        if (typeof options.comment === "string") {
          this.comment = encodeCp437(options.comment);
        } else {
          this.comment = options.comment;
        }
        if (this.comment.length > 65535)
          throw new Error("comment is too large");
        if (bufferIncludes(this.comment, eocdrSignatureBuffer))
          throw new Error("comment contains end of central directory record signature");
      } else {
        this.comment = EMPTY_BUFFER;
      }
      pumpEntries(this);
    };
    function writeToOutputStream(self2, buffer) {
      self2.outputStream.write(buffer);
      self2.outputStreamCursor += buffer.length;
    }
    function pumpFileDataReadStream(self2, entry, readStream) {
      var crc32Watcher = new Crc32Watcher();
      var uncompressedSizeCounter = new ByteCounter();
      var compressor = entry.compress ? new zlib.DeflateRaw() : new PassThrough();
      var compressedSizeCounter = new ByteCounter();
      readStream.pipe(crc32Watcher).pipe(uncompressedSizeCounter).pipe(compressor).pipe(compressedSizeCounter).pipe(self2.outputStream, { end: false });
      compressedSizeCounter.on("end", function() {
        entry.crc32 = crc32Watcher.crc32;
        if (entry.uncompressedSize == null) {
          entry.uncompressedSize = uncompressedSizeCounter.byteCount;
        } else {
          if (entry.uncompressedSize !== uncompressedSizeCounter.byteCount)
            return self2.emit("error", new Error("file data stream has unexpected number of bytes"));
        }
        entry.compressedSize = compressedSizeCounter.byteCount;
        self2.outputStreamCursor += entry.compressedSize;
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
    }
    function pumpEntries(self2) {
      if (self2.allDone)
        return;
      if (self2.ended && self2.finalSizeCallback != null) {
        var finalSize = calculateFinalSize(self2);
        if (finalSize != null) {
          self2.finalSizeCallback(finalSize);
          self2.finalSizeCallback = null;
        }
      }
      var entry = getFirstNotDoneEntry();
      function getFirstNotDoneEntry() {
        for (var i = 0; i < self2.entries.length; i++) {
          var entry2 = self2.entries[i];
          if (entry2.state < Entry.FILE_DATA_DONE)
            return entry2;
        }
        return null;
      }
      if (entry != null) {
        if (entry.state < Entry.READY_TO_PUMP_FILE_DATA)
          return;
        if (entry.state === Entry.FILE_DATA_IN_PROGRESS)
          return;
        entry.relativeOffsetOfLocalHeader = self2.outputStreamCursor;
        var localFileHeader = entry.getLocalFileHeader();
        writeToOutputStream(self2, localFileHeader);
        entry.doFileDataPump();
      } else {
        if (self2.ended) {
          self2.offsetOfStartOfCentralDirectory = self2.outputStreamCursor;
          self2.entries.forEach(function(entry2) {
            var centralDirectoryRecord = entry2.getCentralDirectoryRecord();
            writeToOutputStream(self2, centralDirectoryRecord);
          });
          writeToOutputStream(self2, getEndOfCentralDirectoryRecord(self2));
          self2.outputStream.end();
          self2.allDone = true;
        }
      }
    }
    function calculateFinalSize(self2) {
      var pretendOutputCursor = 0;
      var centralDirectorySize = 0;
      for (var i = 0; i < self2.entries.length; i++) {
        var entry = self2.entries[i];
        if (entry.compress)
          return -1;
        if (entry.state >= Entry.READY_TO_PUMP_FILE_DATA) {
          if (entry.uncompressedSize == null)
            return -1;
        } else {
          if (entry.uncompressedSize == null)
            return null;
        }
        entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
        var useZip64Format = entry.useZip64Format();
        pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
        pretendOutputCursor += entry.uncompressedSize;
        if (!entry.crcAndFileSizeKnown) {
          if (useZip64Format) {
            pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
          } else {
            pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
          }
        }
        centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
        if (useZip64Format) {
          centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
        }
      }
      var endOfCentralDirectorySize = 0;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535 || centralDirectorySize >= 65535 || pretendOutputCursor >= 4294967295) {
        endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
      }
      endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length;
      return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
    }
    var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
    var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
    var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
    function getEndOfCentralDirectoryRecord(self2, actuallyJustTellMeHowLongItWouldBe) {
      var needZip64Format = false;
      var normalEntriesLength = self2.entries.length;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535) {
        normalEntriesLength = 65535;
        needZip64Format = true;
      }
      var sizeOfCentralDirectory = self2.outputStreamCursor - self2.offsetOfStartOfCentralDirectory;
      var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
      if (self2.forceZip64Eocd || sizeOfCentralDirectory >= 4294967295) {
        normalSizeOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      var normalOffsetOfStartOfCentralDirectory = self2.offsetOfStartOfCentralDirectory;
      if (self2.forceZip64Eocd || self2.offsetOfStartOfCentralDirectory >= 4294967295) {
        normalOffsetOfStartOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      if (actuallyJustTellMeHowLongItWouldBe) {
        if (needZip64Format) {
          return ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE + END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        } else {
          return END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        }
      }
      var eocdrBuffer = bufferAlloc(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length);
      eocdrBuffer.writeUInt32LE(101010256, 0);
      eocdrBuffer.writeUInt16LE(0, 4);
      eocdrBuffer.writeUInt16LE(0, 6);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
      eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
      eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
      eocdrBuffer.writeUInt16LE(self2.comment.length, 20);
      self2.comment.copy(eocdrBuffer, 22);
      if (!needZip64Format)
        return eocdrBuffer;
      var zip64EocdrBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
      zip64EocdrBuffer.writeUInt32LE(101075792, 0);
      writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
      zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
      zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
      zip64EocdrBuffer.writeUInt32LE(0, 16);
      zip64EocdrBuffer.writeUInt32LE(0, 20);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 24);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 32);
      writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
      writeUInt64LE(zip64EocdrBuffer, self2.offsetOfStartOfCentralDirectory, 48);
      var zip64EocdlBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
      zip64EocdlBuffer.writeUInt32LE(117853008, 0);
      zip64EocdlBuffer.writeUInt32LE(0, 4);
      writeUInt64LE(zip64EocdlBuffer, self2.outputStreamCursor, 8);
      zip64EocdlBuffer.writeUInt32LE(1, 16);
      return Buffer.concat([
        zip64EocdrBuffer,
        zip64EocdlBuffer,
        eocdrBuffer
      ]);
    }
    function validateMetadataPath(metadataPath, isDirectory) {
      if (metadataPath === "")
        throw new Error("empty metadataPath");
      metadataPath = metadataPath.replace(/\\/g, "/");
      if (/^[a-zA-Z]:/.test(metadataPath) || /^\//.test(metadataPath))
        throw new Error("absolute path: " + metadataPath);
      if (metadataPath.split("/").indexOf("..") !== -1)
        throw new Error("invalid relative path: " + metadataPath);
      var looksLikeDirectory = /\/$/.test(metadataPath);
      if (isDirectory) {
        if (!looksLikeDirectory)
          metadataPath += "/";
      } else {
        if (looksLikeDirectory)
          throw new Error("file path cannot end with '/': " + metadataPath);
      }
      return metadataPath;
    }
    var EMPTY_BUFFER = bufferAlloc(0);
    function Entry(metadataPath, isDirectory, options) {
      this.utf8FileName = bufferFrom(metadataPath);
      if (this.utf8FileName.length > 65535)
        throw new Error("utf8 file name too long. " + utf8FileName.length + " > " + 65535);
      this.isDirectory = isDirectory;
      this.state = Entry.WAITING_FOR_METADATA;
      this.setLastModDate(options.mtime != null ? options.mtime : new Date());
      if (options.mode != null) {
        this.setFileAttributesMode(options.mode);
      } else {
        this.setFileAttributesMode(isDirectory ? 16893 : 33204);
      }
      if (isDirectory) {
        this.crcAndFileSizeKnown = true;
        this.crc32 = 0;
        this.uncompressedSize = 0;
        this.compressedSize = 0;
      } else {
        this.crcAndFileSizeKnown = false;
        this.crc32 = null;
        this.uncompressedSize = null;
        this.compressedSize = null;
        if (options.size != null)
          this.uncompressedSize = options.size;
      }
      if (isDirectory) {
        this.compress = false;
      } else {
        this.compress = true;
        if (options.compress != null)
          this.compress = !!options.compress;
      }
      this.forceZip64Format = !!options.forceZip64Format;
      if (options.fileComment) {
        if (typeof options.fileComment === "string") {
          this.fileComment = bufferFrom(options.fileComment, "utf-8");
        } else {
          this.fileComment = options.fileComment;
        }
        if (this.fileComment.length > 65535)
          throw new Error("fileComment is too large");
      } else {
        this.fileComment = EMPTY_BUFFER;
      }
    }
    Entry.WAITING_FOR_METADATA = 0;
    Entry.READY_TO_PUMP_FILE_DATA = 1;
    Entry.FILE_DATA_IN_PROGRESS = 2;
    Entry.FILE_DATA_DONE = 3;
    Entry.prototype.setLastModDate = function(date) {
      var dosDateTime = dateToDosDateTime(date);
      this.lastModFileTime = dosDateTime.time;
      this.lastModFileDate = dosDateTime.date;
    };
    Entry.prototype.setFileAttributesMode = function(mode) {
      if ((mode & 65535) !== mode)
        throw new Error("invalid mode. expected: 0 <= " + mode + " <= " + 65535);
      this.externalFileAttributes = mode << 16 >>> 0;
    };
    Entry.prototype.setFileDataPumpFunction = function(doFileDataPump) {
      this.doFileDataPump = doFileDataPump;
      this.state = Entry.READY_TO_PUMP_FILE_DATA;
    };
    Entry.prototype.useZip64Format = function() {
      return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
    };
    var LOCAL_FILE_HEADER_FIXED_SIZE = 30;
    var VERSION_NEEDED_TO_EXTRACT_UTF8 = 20;
    var VERSION_NEEDED_TO_EXTRACT_ZIP64 = 45;
    var VERSION_MADE_BY = 3 << 8 | 63;
    var FILE_NAME_IS_UTF8 = 1 << 11;
    var UNKNOWN_CRC32_AND_FILE_SIZES = 1 << 3;
    Entry.prototype.getLocalFileHeader = function() {
      var crc322 = 0;
      var compressedSize = 0;
      var uncompressedSize = 0;
      if (this.crcAndFileSizeKnown) {
        crc322 = this.crc32;
        compressedSize = this.compressedSize;
        uncompressedSize = this.uncompressedSize;
      }
      var fixedSizeStuff = bufferAlloc(LOCAL_FILE_HEADER_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown)
        generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      fixedSizeStuff.writeUInt32LE(67324752, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_UTF8, 4);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 6);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 8);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 12);
      fixedSizeStuff.writeUInt32LE(crc322, 14);
      fixedSizeStuff.writeUInt32LE(compressedSize, 18);
      fixedSizeStuff.writeUInt32LE(uncompressedSize, 22);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 26);
      fixedSizeStuff.writeUInt16LE(0, 28);
      return Buffer.concat([
        fixedSizeStuff,
        this.utf8FileName
      ]);
    };
    var DATA_DESCRIPTOR_SIZE = 16;
    var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
    Entry.prototype.getDataDescriptor = function() {
      if (this.crcAndFileSizeKnown) {
        return EMPTY_BUFFER;
      }
      if (!this.useZip64Format()) {
        var buffer = bufferAlloc(DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        buffer.writeUInt32LE(this.compressedSize, 8);
        buffer.writeUInt32LE(this.uncompressedSize, 12);
        return buffer;
      } else {
        var buffer = bufferAlloc(ZIP64_DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        writeUInt64LE(buffer, this.compressedSize, 8);
        writeUInt64LE(buffer, this.uncompressedSize, 16);
        return buffer;
      }
    };
    var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
    var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
    Entry.prototype.getCentralDirectoryRecord = function() {
      var fixedSizeStuff = bufferAlloc(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown)
        generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      var normalCompressedSize = this.compressedSize;
      var normalUncompressedSize = this.uncompressedSize;
      var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
      var versionNeededToExtract;
      var zeiefBuffer;
      if (this.useZip64Format()) {
        normalCompressedSize = 4294967295;
        normalUncompressedSize = 4294967295;
        normalRelativeOffsetOfLocalHeader = 4294967295;
        versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;
        zeiefBuffer = bufferAlloc(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
        zeiefBuffer.writeUInt16LE(1, 0);
        zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
        writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
        writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
        writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
      } else {
        versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
        zeiefBuffer = EMPTY_BUFFER;
      }
      fixedSizeStuff.writeUInt32LE(33639248, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
      fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
      fixedSizeStuff.writeUInt32LE(this.crc32, 16);
      fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
      fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
      fixedSizeStuff.writeUInt16LE(zeiefBuffer.length, 30);
      fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
      fixedSizeStuff.writeUInt16LE(0, 34);
      fixedSizeStuff.writeUInt16LE(0, 36);
      fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
      fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);
      return Buffer.concat([
        fixedSizeStuff,
        this.utf8FileName,
        zeiefBuffer,
        this.fileComment
      ]);
    };
    Entry.prototype.getCompressionMethod = function() {
      var NO_COMPRESSION = 0;
      var DEFLATE_COMPRESSION = 8;
      return this.compress ? DEFLATE_COMPRESSION : NO_COMPRESSION;
    };
    function dateToDosDateTime(jsDate) {
      var date = 0;
      date |= jsDate.getDate() & 31;
      date |= (jsDate.getMonth() + 1 & 15) << 5;
      date |= (jsDate.getFullYear() - 1980 & 127) << 9;
      var time = 0;
      time |= Math.floor(jsDate.getSeconds() / 2);
      time |= (jsDate.getMinutes() & 63) << 5;
      time |= (jsDate.getHours() & 31) << 11;
      return { date, time };
    }
    function writeUInt64LE(buffer, n, offset) {
      var high = Math.floor(n / 4294967296);
      var low = n % 4294967296;
      buffer.writeUInt32LE(low, offset);
      buffer.writeUInt32LE(high, offset + 4);
    }
    util.inherits(ByteCounter, Transform);
    function ByteCounter(options) {
      Transform.call(this, options);
      this.byteCount = 0;
    }
    ByteCounter.prototype._transform = function(chunk, encoding, cb) {
      this.byteCount += chunk.length;
      cb(null, chunk);
    };
    util.inherits(Crc32Watcher, Transform);
    function Crc32Watcher(options) {
      Transform.call(this, options);
      this.crc32 = 0;
    }
    Crc32Watcher.prototype._transform = function(chunk, encoding, cb) {
      this.crc32 = crc32.unsigned(chunk, this.crc32);
      cb(null, chunk);
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    if (cp437.length !== 256)
      throw new Error("assertion failure");
    var reverseCp437 = null;
    function encodeCp437(string) {
      if (/^[\x20-\x7e]*$/.test(string)) {
        return bufferFrom(string, "utf-8");
      }
      if (reverseCp437 == null) {
        reverseCp437 = {};
        for (var i = 0; i < cp437.length; i++) {
          reverseCp437[cp437[i]] = i;
        }
      }
      var result = bufferAlloc(string.length);
      for (var i = 0; i < string.length; i++) {
        var b = reverseCp437[string[i]];
        if (b == null)
          throw new Error("character not encodable in CP437: " + JSON.stringify(string[i]));
        result[i] = b;
      }
      return result;
    }
    function bufferAlloc(size) {
      bufferAlloc = modern;
      try {
        return bufferAlloc(size);
      } catch (e) {
        bufferAlloc = legacy;
        return bufferAlloc(size);
      }
      function modern(size2) {
        return Buffer.allocUnsafe(size2);
      }
      function legacy(size2) {
        return new Buffer(size2);
      }
    }
    function bufferFrom(something, encoding) {
      bufferFrom = modern;
      try {
        return bufferFrom(something, encoding);
      } catch (e) {
        bufferFrom = legacy;
        return bufferFrom(something, encoding);
      }
      function modern(something2, encoding2) {
        return Buffer.from(something2, encoding2);
      }
      function legacy(something2, encoding2) {
        return new Buffer(something2, encoding2);
      }
    }
    function bufferIncludes(buffer, content) {
      bufferIncludes = modern;
      try {
        return bufferIncludes(buffer, content);
      } catch (e) {
        bufferIncludes = legacy;
        return bufferIncludes(buffer, content);
      }
      function modern(buffer2, content2) {
        return buffer2.includes(content2);
      }
      function legacy(buffer2, content2) {
        for (var i = 0; i <= buffer2.length - content2.length; i++) {
          for (var j = 0; ; j++) {
            if (j === content2.length)
              return true;
            if (buffer2[i + j] !== content2[j])
              break;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/playwright-core/lib/server/artifact.js
var require_artifact = __commonJS({
  "node_modules/playwright-core/lib/server/artifact.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Artifact = void 0;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _utils2 = require_utils();
    var _async = require_async();
    var _instrumentation = require_instrumentation();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Artifact = class extends _instrumentation.SdkObject {
      constructor(parent, localPath, unaccessibleErrorMessage, cancelCallback) {
        super(parent, "artifact");
        this._localPath = void 0;
        this._unaccessibleErrorMessage = void 0;
        this._cancelCallback = void 0;
        this._finishedPromise = new _async.ManualPromise();
        this._saveCallbacks = [];
        this._finished = false;
        this._deleted = false;
        this._failureError = null;
        this._localPath = localPath;
        this._unaccessibleErrorMessage = unaccessibleErrorMessage;
        this._cancelCallback = cancelCallback;
      }
      finishedPromise() {
        return this._finishedPromise;
      }
      localPath() {
        return this._localPath;
      }
      localPathAfterFinished() {
        return __async(this, null, function* () {
          if (this._unaccessibleErrorMessage)
            throw new Error(this._unaccessibleErrorMessage);
          yield this._finishedPromise;
          if (this._failureError)
            return null;
          return this._localPath;
        });
      }
      saveAs(saveCallback) {
        if (this._unaccessibleErrorMessage)
          throw new Error(this._unaccessibleErrorMessage);
        if (this._deleted)
          throw new Error(`File already deleted. Save before deleting.`);
        if (this._failureError)
          throw new Error(`File not found on disk. Check download.failure() for details.`);
        if (this._finished) {
          saveCallback(this._localPath).catch((e) => {
          });
          return;
        }
        this._saveCallbacks.push(saveCallback);
      }
      failureError() {
        return __async(this, null, function* () {
          if (this._unaccessibleErrorMessage)
            return this._unaccessibleErrorMessage;
          yield this._finishedPromise;
          return this._failureError;
        });
      }
      cancel() {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this._cancelCallback !== void 0);
          return this._cancelCallback();
        });
      }
      delete() {
        return __async(this, null, function* () {
          if (this._unaccessibleErrorMessage)
            return;
          const fileName = yield this.localPathAfterFinished();
          if (this._deleted)
            return;
          this._deleted = true;
          if (fileName)
            yield _fs2.default.promises.unlink(fileName).catch((e) => {
            });
        });
      }
      deleteOnContextClose() {
        return __async(this, null, function* () {
          if (this._deleted)
            return;
          this._deleted = true;
          if (!this._unaccessibleErrorMessage)
            yield _fs2.default.promises.unlink(this._localPath).catch((e) => {
            });
          yield this.reportFinished("File deleted upon browser context closure.");
        });
      }
      reportFinished(error) {
        return __async(this, null, function* () {
          if (this._finished)
            return;
          this._finished = true;
          this._failureError = error || null;
          if (error) {
            for (const callback of this._saveCallbacks)
              yield callback("", error);
          } else {
            for (const callback of this._saveCallbacks)
              yield callback(this._localPath);
          }
          this._saveCallbacks = [];
          this._finishedPromise.resolve();
        });
      }
    };
    exports2.Artifact = Artifact;
  }
});

// node_modules/playwright-core/lib/server/supplements/har/harTracer.js
var require_harTracer = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/har/harTracer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.HarTracer = void 0;
    var _browserContext = require_browserContext();
    var _fetch = require_fetch();
    var _helper = require_helper();
    var network = _interopRequireWildcard2(require_network());
    var _page = require_page();
    var _utils2 = require_utils();
    var _eventsHelper = require_eventsHelper();
    var mime = _interopRequireWildcard2(require_mime());
    var _async = require_async();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FALLBACK_HTTP_VERSION = "HTTP/1.1";
    var HarTracer = class {
      constructor(context, delegate, options) {
        this._context = void 0;
        this._barrierPromises = /* @__PURE__ */ new Set();
        this._delegate = void 0;
        this._options = void 0;
        this._pageEntries = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._started = false;
        this._entrySymbol = void 0;
        this._context = context;
        this._delegate = delegate;
        this._options = options;
        this._entrySymbol = Symbol("requestHarEntry");
      }
      start() {
        if (this._started)
          return;
        this._started = true;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, (page) => this._ensurePageEntry(page)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Request, (request) => this._onRequest(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFinished, ({
          request,
          response
        }) => this._onRequestFinished(request, response).catch(() => {
        })), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFailed, (request) => this._onRequestFailed(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Response, (response) => this._onResponse(response)), _eventsHelper.eventsHelper.addEventListener(this._context.fetchRequest, _fetch.APIRequestContext.Events.Request, (event) => this._onAPIRequest(event)), _eventsHelper.eventsHelper.addEventListener(this._context.fetchRequest, _fetch.APIRequestContext.Events.RequestFinished, (event) => this._onAPIRequestFinished(event))];
      }
      _entryForRequest(request) {
        return request[this._entrySymbol];
      }
      _ensurePageEntry(page) {
        let pageEntry = this._pageEntries.get(page);
        if (!pageEntry) {
          page.on(_page.Page.Events.DOMContentLoaded, () => this._onDOMContentLoaded(page));
          page.on(_page.Page.Events.Load, () => this._onLoad(page));
          pageEntry = {
            startedDateTime: new Date(),
            id: page.guid,
            title: "",
            pageTimings: {
              onContentLoad: -1,
              onLoad: -1
            }
          };
          this._pageEntries.set(page, pageEntry);
        }
        return pageEntry;
      }
      _onDOMContentLoaded(page) {
        const pageEntry = this._ensurePageEntry(page);
        const promise = page.mainFrame().evaluateExpression(String(() => {
          return {
            title: document.title,
            domContentLoaded: performance.timing.domContentLoadedEventStart
          };
        }), true, void 0, "utility").then((result) => {
          pageEntry.title = result.title;
          pageEntry.pageTimings.onContentLoad = result.domContentLoaded;
        }).catch(() => {
        });
        this._addBarrier(page, promise);
      }
      _onLoad(page) {
        const pageEntry = this._ensurePageEntry(page);
        const promise = page.mainFrame().evaluateExpression(String(() => {
          return {
            title: document.title,
            loaded: performance.timing.loadEventStart
          };
        }), true, void 0, "utility").then((result) => {
          pageEntry.title = result.title;
          pageEntry.pageTimings.onLoad = result.loaded;
        }).catch(() => {
        });
        this._addBarrier(page, promise);
      }
      _addBarrier(page, promise) {
        if (!this._options.waitForContentOnStop)
          return;
        const race = Promise.race([new Promise((f) => page.on("close", () => {
          this._barrierPromises.delete(race);
          f();
        })), promise]);
        this._barrierPromises.add(race);
      }
      _onAPIRequest(event) {
        var _event$postData;
        const harEntry = createHarEntry(event.method, event.url, "", "");
        harEntry.request.cookies = event.cookies;
        harEntry.request.headers = Object.entries(event.headers).map(([name, value]) => ({
          name,
          value
        }));
        harEntry.request.postData = postDataForBuffer(event.postData || null, event.headers["content-type"], this._options.content);
        harEntry.request.bodySize = ((_event$postData = event.postData) === null || _event$postData === void 0 ? void 0 : _event$postData.length) || 0;
        event[this._entrySymbol] = harEntry;
        if (this._started)
          this._delegate.onEntryStarted(harEntry);
      }
      _onAPIRequestFinished(event) {
        const harEntry = this._entryForRequest(event.requestEvent);
        if (!harEntry)
          return;
        harEntry.response.status = event.statusCode;
        harEntry.response.statusText = event.statusMessage;
        harEntry.response.httpVersion = event.httpVersion;
        harEntry.response.redirectURL = event.headers.location || "";
        for (let i = 0; i < event.rawHeaders.length; i += 2) {
          harEntry.response.headers.push({
            name: event.rawHeaders[i],
            value: event.rawHeaders[i + 1]
          });
        }
        harEntry.response.cookies = event.cookies.map((c) => {
          return __spreadProps(__spreadValues({}, c), {
            expires: c.expires === -1 ? void 0 : new Date(c.expires)
          });
        });
        const content = harEntry.response.content;
        const contentType = event.headers["content-type"];
        if (contentType)
          content.mimeType = contentType;
        this._storeResponseContent(event.body, content);
        if (this._started)
          this._delegate.onEntryFinished(harEntry);
      }
      _onRequest(request) {
        const page = request.frame()._page;
        const url = network.parsedURL(request.url());
        if (!url)
          return;
        const pageEntry = this._ensurePageEntry(page);
        const harEntry = createHarEntry(request.method(), url, request.guid, request.frame().guid);
        harEntry.pageref = pageEntry.id;
        harEntry.request.postData = postDataForRequest(request, this._options.content);
        harEntry.request.bodySize = request.bodySize();
        if (request.redirectedFrom()) {
          const fromEntry = this._entryForRequest(request.redirectedFrom());
          if (fromEntry)
            fromEntry.response.redirectURL = request.url();
        }
        request[this._entrySymbol] = harEntry;
        if (this._started)
          this._delegate.onEntryStarted(harEntry);
      }
      _onRequestFinished(request, response) {
        return __async(this, null, function* () {
          if (!response)
            return;
          const page = request.frame()._page;
          const harEntry = this._entryForRequest(request);
          if (!harEntry)
            return;
          const httpVersion = response.httpVersion();
          harEntry.request.httpVersion = httpVersion;
          harEntry.response.httpVersion = httpVersion;
          const compressionCalculationBarrier = {
            _encodedBodySize: -1,
            _decodedBodySize: -1,
            barrier: new _async.ManualPromise(),
            _check: function() {
              if (this._encodedBodySize !== -1 && this._decodedBodySize !== -1) {
                harEntry.response.content.compression = Math.max(0, this._decodedBodySize - this._encodedBodySize);
                this.barrier.resolve();
              }
            },
            setEncodedBodySize: function(encodedBodySize) {
              this._encodedBodySize = encodedBodySize;
              this._check();
            },
            setDecodedBodySize: function(decodedBodySize) {
              this._decodedBodySize = decodedBodySize;
              this._check();
            }
          };
          this._addBarrier(page, compressionCalculationBarrier.barrier);
          const promise = response.body().then((buffer) => {
            if (this._options.skipScripts && request.resourceType() === "script") {
              compressionCalculationBarrier.setDecodedBodySize(0);
              return;
            }
            const content = harEntry.response.content;
            compressionCalculationBarrier.setDecodedBodySize(buffer.length);
            this._storeResponseContent(buffer, content);
          }).catch(() => {
            compressionCalculationBarrier.setDecodedBodySize(0);
          }).then(() => {
            const postData = response.request().postDataBuffer();
            if (postData && harEntry.request.postData && this._options.content === "sha1") {
              harEntry.request.postData._sha1 = (0, _utils2.calculateSha1)(postData) + "." + (mime.getExtension(harEntry.request.postData.mimeType) || "dat");
              if (this._started)
                this._delegate.onContentBlob(harEntry.request.postData._sha1, postData);
            }
            if (this._started)
              this._delegate.onEntryFinished(harEntry);
          });
          this._addBarrier(page, promise);
          this._addBarrier(page, response.sizes().then((sizes) => {
            harEntry.response.bodySize = sizes.responseBodySize;
            harEntry.response.headersSize = sizes.responseHeadersSize;
            harEntry.response._transferSize = response.request().responseSize.transferSize || sizes.responseHeadersSize + sizes.responseBodySize;
            harEntry.request.headersSize = sizes.requestHeadersSize;
            compressionCalculationBarrier.setEncodedBodySize(sizes.responseBodySize);
          }));
        });
      }
      _onRequestFailed(request) {
        return __async(this, null, function* () {
          const harEntry = this._entryForRequest(request);
          if (!harEntry)
            return;
          if (request._failureText !== null)
            harEntry.response._failureText = request._failureText;
          if (this._started)
            this._delegate.onEntryFinished(harEntry);
        });
      }
      _storeResponseContent(buffer, content) {
        if (!buffer) {
          content.size = 0;
          return;
        }
        content.size = buffer.length;
        if (this._options.content === "embedded") {
          content.text = buffer.toString("base64");
          content.encoding = "base64";
        } else if (this._options.content === "sha1") {
          content._sha1 = (0, _utils2.calculateSha1)(buffer) + "." + (mime.getExtension(content.mimeType) || "dat");
          if (this._started)
            this._delegate.onContentBlob(content._sha1, buffer);
        }
      }
      _onResponse(response) {
        const page = response.frame()._page;
        const pageEntry = this._ensurePageEntry(page);
        const harEntry = this._entryForRequest(response.request());
        if (!harEntry)
          return;
        const request = response.request();
        harEntry.request.postData = postDataForRequest(request, this._options.content);
        harEntry.response = {
          status: response.status(),
          statusText: response.statusText(),
          httpVersion: response.httpVersion(),
          cookies: [],
          headers: [],
          content: {
            size: -1,
            mimeType: "x-unknown"
          },
          headersSize: -1,
          bodySize: -1,
          redirectURL: "",
          _transferSize: -1
        };
        const timing = response.timing();
        if (pageEntry.startedDateTime.valueOf() > timing.startTime)
          pageEntry.startedDateTime = new Date(timing.startTime);
        const dns = timing.domainLookupEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.domainLookupEnd - timing.domainLookupStart) : -1;
        const connect = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.connectStart) : -1;
        const ssl = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.secureConnectionStart) : -1;
        const wait = timing.responseStart !== -1 ? _helper.helper.millisToRoundishMillis(timing.responseStart - timing.requestStart) : -1;
        const receive = response.request()._responseEndTiming !== -1 ? _helper.helper.millisToRoundishMillis(response.request()._responseEndTiming - timing.responseStart) : -1;
        harEntry.timings = {
          dns,
          connect,
          ssl,
          send: 0,
          wait,
          receive
        };
        harEntry.time = [dns, connect, ssl, wait, receive].reduce((pre, cur) => cur > 0 ? cur + pre : pre, 0);
        this._addBarrier(page, response.serverAddr().then((server) => {
          if (server !== null && server !== void 0 && server.ipAddress)
            harEntry.serverIPAddress = server.ipAddress;
          if (server !== null && server !== void 0 && server.port)
            harEntry._serverPort = server.port;
        }));
        this._addBarrier(page, response.securityDetails().then((details) => {
          if (details)
            harEntry._securityDetails = details;
        }));
        this._addBarrier(page, request.rawRequestHeaders().then((headers) => {
          for (const header of headers.filter((header2) => header2.name.toLowerCase() === "cookie"))
            harEntry.request.cookies.push(...header.value.split(";").map(parseCookie));
          harEntry.request.headers = headers;
        }));
        this._addBarrier(page, response.rawResponseHeaders().then((headers) => {
          for (const header of headers.filter((header2) => header2.name.toLowerCase() === "set-cookie"))
            harEntry.response.cookies.push(parseCookie(header.value));
          harEntry.response.headers = headers;
          const contentType = headers.find((header) => header.name.toLowerCase() === "content-type");
          if (contentType)
            harEntry.response.content.mimeType = contentType.value;
        }));
      }
      flush() {
        return __async(this, null, function* () {
          yield Promise.all(this._barrierPromises);
        });
      }
      stop() {
        this._started = false;
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._barrierPromises.clear();
        const log = {
          version: "1.2",
          creator: {
            name: "Playwright",
            version: require_package()["version"]
          },
          browser: {
            name: this._context._browser.options.name,
            version: this._context._browser.version()
          },
          pages: Array.from(this._pageEntries.values()),
          entries: []
        };
        for (const pageEntry of log.pages) {
          if (pageEntry.pageTimings.onContentLoad >= 0)
            pageEntry.pageTimings.onContentLoad -= pageEntry.startedDateTime.valueOf();
          else
            pageEntry.pageTimings.onContentLoad = -1;
          if (pageEntry.pageTimings.onLoad >= 0)
            pageEntry.pageTimings.onLoad -= pageEntry.startedDateTime.valueOf();
          else
            pageEntry.pageTimings.onLoad = -1;
        }
        this._pageEntries.clear();
        return log;
      }
    };
    exports2.HarTracer = HarTracer;
    function createHarEntry(method, url, requestref, frameref) {
      const harEntry = {
        _requestref: requestref,
        _frameref: frameref,
        _monotonicTime: (0, _utils2.monotonicTime)(),
        startedDateTime: new Date(),
        time: -1,
        request: {
          method,
          url: url.toString(),
          httpVersion: FALLBACK_HTTP_VERSION,
          cookies: [],
          headers: [],
          queryString: [...url.searchParams].map((e) => ({
            name: e[0],
            value: e[1]
          })),
          headersSize: -1,
          bodySize: 0
        },
        response: {
          status: -1,
          statusText: "",
          httpVersion: FALLBACK_HTTP_VERSION,
          cookies: [],
          headers: [],
          content: {
            size: -1,
            mimeType: "x-unknown"
          },
          headersSize: -1,
          bodySize: -1,
          redirectURL: "",
          _transferSize: -1
        },
        cache: {
          beforeRequest: null,
          afterRequest: null
        },
        timings: {
          send: -1,
          wait: -1,
          receive: -1
        }
      };
      return harEntry;
    }
    function postDataForRequest(request, content) {
      const postData = request.postDataBuffer();
      if (!postData)
        return;
      const contentType = request.headerValue("content-type");
      return postDataForBuffer(postData, contentType, content);
    }
    function postDataForBuffer(postData, contentType, content) {
      var _contentType;
      if (!postData)
        return;
      (_contentType = contentType) !== null && _contentType !== void 0 ? _contentType : contentType = "application/octet-stream";
      const result = {
        mimeType: contentType,
        text: "",
        params: []
      };
      if (content === "embedded" && contentType !== "application/octet-stream")
        result.text = postData.toString();
      if (contentType === "application/x-www-form-urlencoded") {
        const parsed = new URLSearchParams(postData.toString());
        for (const [name, value] of parsed.entries())
          result.params.push({
            name,
            value
          });
      }
      return result;
    }
    function parseCookie(c) {
      const cookie = {
        name: "",
        value: ""
      };
      let first = true;
      for (const pair of c.split(/; */)) {
        const indexOfEquals = pair.indexOf("=");
        const name = indexOfEquals !== -1 ? pair.substr(0, indexOfEquals).trim() : pair.trim();
        const value = indexOfEquals !== -1 ? pair.substr(indexOfEquals + 1, pair.length).trim() : "";
        if (first) {
          first = false;
          cookie.name = name;
          cookie.value = value;
          continue;
        }
        if (name === "Domain")
          cookie.domain = value;
        if (name === "Expires")
          cookie.expires = new Date(value);
        if (name === "HttpOnly")
          cookie.httpOnly = true;
        if (name === "Max-Age")
          cookie.expires = new Date(Date.now() + +value * 1e3);
        if (name === "Path")
          cookie.path = value;
        if (name === "SameSite")
          cookie.sameSite = value;
        if (name === "Secure")
          cookie.secure = true;
      }
      return cookie;
    }
  }
});

// node_modules/playwright-core/lib/server/trace/common/traceEvents.js
var require_traceEvents = __commonJS({
  "node_modules/playwright-core/lib/server/trace/common/traceEvents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VERSION = void 0;
    var VERSION = 3;
    exports2.VERSION = VERSION;
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/snapshotterInjected.js
var require_snapshotterInjected = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/snapshotterInjected.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.frameSnapshotStreamer = frameSnapshotStreamer;
    function frameSnapshotStreamer(snapshotStreamer) {
      if (window[snapshotStreamer])
        return;
      const kShadowAttribute = "__playwright_shadow_root_";
      const kScrollTopAttribute = "__playwright_scroll_top_";
      const kScrollLeftAttribute = "__playwright_scroll_left_";
      const kStyleSheetAttribute = "__playwright_style_sheet_";
      const kBlobUrlPrefix = "http://playwright.bloburl/#";
      const kSnapshotFrameId = Symbol("__playwright_snapshot_frameid_");
      const kCachedData = Symbol("__playwright_snapshot_cache_");
      const kEndOfList = Symbol("__playwright_end_of_list_");
      function resetCachedData(obj) {
        delete obj[kCachedData];
      }
      function ensureCachedData(obj) {
        if (!obj[kCachedData])
          obj[kCachedData] = {};
        return obj[kCachedData];
      }
      function removeHash(url) {
        try {
          const u = new URL(url);
          u.hash = "";
          return u.toString();
        } catch (e) {
          return url;
        }
      }
      class Streamer {
        constructor() {
          this._removeNoScript = true;
          this._lastSnapshotNumber = 0;
          this._staleStyleSheets = /* @__PURE__ */ new Set();
          this._readingStyleSheet = false;
          this._fakeBase = void 0;
          this._observer = void 0;
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "insertRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "deleteRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "addRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "removeRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeGetter(window.CSSStyleSheet.prototype, "rules", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeGetter(window.CSSStyleSheet.prototype, "cssRules", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "replaceSync", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeAsyncMethod(window.CSSStyleSheet.prototype, "replace", (sheet) => this._invalidateStyleSheet(sheet));
          this._fakeBase = document.createElement("base");
          this._observer = new MutationObserver((list) => this._handleMutations(list));
          const observerConfig = {
            attributes: true,
            subtree: true
          };
          this._observer.observe(document, observerConfig);
        }
        _interceptNativeMethod(obj, method, cb) {
          const native = obj[method];
          if (!native)
            return;
          obj[method] = function(...args) {
            const result = native.call(this, ...args);
            cb(this, result);
            return result;
          };
        }
        _interceptNativeAsyncMethod(obj, method, cb) {
          const native = obj[method];
          if (!native)
            return;
          obj[method] = function(...args) {
            return __async(this, null, function* () {
              const result = yield native.call(this, ...args);
              cb(this, result);
              return result;
            });
          };
        }
        _interceptNativeGetter(obj, prop, cb) {
          const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
          Object.defineProperty(obj, prop, __spreadProps(__spreadValues({}, descriptor), {
            get: function() {
              const result = descriptor.get.call(this);
              cb(this, result);
              return result;
            }
          }));
        }
        _handleMutations(list) {
          for (const mutation of list)
            ensureCachedData(mutation.target).attributesCached = void 0;
        }
        _invalidateStyleSheet(sheet) {
          if (this._readingStyleSheet)
            return;
          this._staleStyleSheets.add(sheet);
        }
        _updateStyleElementStyleSheetTextIfNeeded(sheet, forceText) {
          const data = ensureCachedData(sheet);
          if (this._staleStyleSheets.has(sheet) || forceText && data.cssText === void 0) {
            this._staleStyleSheets.delete(sheet);
            try {
              data.cssText = this._getSheetText(sheet);
            } catch (e) {
              data.cssText = "";
            }
          }
          return data.cssText;
        }
        _updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber) {
          const data = ensureCachedData(sheet);
          if (this._staleStyleSheets.has(sheet)) {
            this._staleStyleSheets.delete(sheet);
            try {
              data.cssText = this._getSheetText(sheet);
              data.cssRef = snapshotNumber;
              return data.cssText;
            } catch (e) {
            }
          }
          return data.cssRef === void 0 ? void 0 : snapshotNumber - data.cssRef;
        }
        markIframe(iframeElement, frameId) {
          iframeElement[kSnapshotFrameId] = frameId;
        }
        reset() {
          this._staleStyleSheets.clear();
          const visitNode = (node) => {
            resetCachedData(node);
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node;
              if (element.shadowRoot)
                visitNode(element.shadowRoot);
            }
            for (let child = node.firstChild; child; child = child.nextSibling)
              visitNode(child);
          };
          visitNode(document.documentElement);
          visitNode(this._fakeBase);
        }
        __sanitizeMetaAttribute(name, value, httpEquiv) {
          if (name === "charset")
            return "utf-8";
          if (httpEquiv.toLowerCase() !== "content-type" || name !== "content")
            return value;
          const [type, ...params] = value.split(";");
          if (type !== "text/html" || params.length <= 0)
            return value;
          const charsetParamIdx = params.findIndex((param) => param.trim().startsWith("charset="));
          if (charsetParamIdx > -1)
            params[charsetParamIdx] = "charset=utf-8";
          return `${type}; ${params.join("; ")}`;
        }
        _sanitizeUrl(url) {
          if (url.startsWith("javascript:"))
            return "";
          if (url.startsWith("blob:"))
            return kBlobUrlPrefix + url;
          return url;
        }
        _sanitizeSrcSet(srcset) {
          return srcset.split(",").map((src) => {
            src = src.trim();
            const spaceIndex = src.lastIndexOf(" ");
            if (spaceIndex === -1)
              return this._sanitizeUrl(src);
            return this._sanitizeUrl(src.substring(0, spaceIndex).trim()) + src.substring(spaceIndex);
          }).join(", ");
        }
        _resolveUrl(base, url) {
          if (url === "")
            return "";
          try {
            return new URL(url, base).href;
          } catch (e) {
            return url;
          }
        }
        _getSheetBase(sheet) {
          let rootSheet = sheet;
          while (rootSheet.parentStyleSheet)
            rootSheet = rootSheet.parentStyleSheet;
          if (rootSheet.ownerNode)
            return rootSheet.ownerNode.baseURI;
          return document.baseURI;
        }
        _getSheetText(sheet) {
          this._readingStyleSheet = true;
          try {
            const rules = [];
            for (const rule of sheet.cssRules)
              rules.push(rule.cssText);
            return rules.join("\n");
          } finally {
            this._readingStyleSheet = false;
          }
        }
        captureSnapshot() {
          const timestamp = performance.now();
          const snapshotNumber = ++this._lastSnapshotNumber;
          let nodeCounter = 0;
          let shadowDomNesting = 0;
          this._handleMutations(this._observer.takeRecords());
          const visitNode = (node) => {
            const nodeType = node.nodeType;
            const nodeName = nodeType === Node.DOCUMENT_FRAGMENT_NODE ? "template" : node.nodeName;
            if (nodeType !== Node.ELEMENT_NODE && nodeType !== Node.DOCUMENT_FRAGMENT_NODE && nodeType !== Node.TEXT_NODE)
              return;
            if (nodeName === "SCRIPT")
              return;
            if (nodeName === "LINK" && nodeType === Node.ELEMENT_NODE) {
              var _getAttribute;
              const rel = (_getAttribute = node.getAttribute("rel")) === null || _getAttribute === void 0 ? void 0 : _getAttribute.toLowerCase();
              if (rel === "preload" || rel === "prefetch")
                return;
            }
            if (this._removeNoScript && nodeName === "NOSCRIPT")
              return;
            if (nodeName === "META" && node.httpEquiv.toLowerCase() === "content-security-policy")
              return;
            const data = ensureCachedData(node);
            const values = [];
            let equals = !!data.cached;
            let extraNodes = 0;
            const expectValue = (value) => {
              equals = equals && data.cached[values.length] === value;
              values.push(value);
            };
            const checkAndReturn = (n) => {
              data.attributesCached = true;
              if (equals)
                return {
                  equals: true,
                  n: [[snapshotNumber - data.ref[0], data.ref[1]]]
                };
              nodeCounter += extraNodes;
              data.ref = [snapshotNumber, nodeCounter++];
              data.cached = values;
              return {
                equals: false,
                n
              };
            };
            if (nodeType === Node.TEXT_NODE) {
              const value = node.nodeValue || "";
              expectValue(value);
              return checkAndReturn(value);
            }
            if (nodeName === "STYLE") {
              const sheet = node.sheet;
              let cssText;
              if (sheet)
                cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet);
              cssText = cssText || node.textContent || "";
              expectValue(cssText);
              extraNodes++;
              return checkAndReturn(["style", {}, cssText]);
            }
            const attrs = {};
            const result2 = [nodeName, attrs];
            const visitChild = (child) => {
              const snapshot = visitNode(child);
              if (snapshot) {
                result2.push(snapshot.n);
                expectValue(child);
                equals = equals && snapshot.equals;
              }
            };
            const visitChildStyleSheet = (child) => {
              const snapshot = visitStyleSheet(child);
              if (snapshot) {
                result2.push(snapshot.n);
                expectValue(child);
                equals = equals && snapshot.equals;
              }
            };
            if (nodeType === Node.DOCUMENT_FRAGMENT_NODE)
              attrs[kShadowAttribute] = "open";
            if (nodeType === Node.ELEMENT_NODE) {
              const element = node;
              if (nodeName === "INPUT") {
                const value = element.value;
                expectValue("value");
                expectValue(value);
                attrs["value"] = value;
                if (element.checked) {
                  expectValue("checked");
                  attrs["checked"] = "";
                }
              }
              if (element.scrollTop) {
                expectValue(kScrollTopAttribute);
                expectValue(element.scrollTop);
                attrs[kScrollTopAttribute] = "" + element.scrollTop;
              }
              if (element.scrollLeft) {
                expectValue(kScrollLeftAttribute);
                expectValue(element.scrollLeft);
                attrs[kScrollLeftAttribute] = "" + element.scrollLeft;
              }
              if (element.shadowRoot) {
                ++shadowDomNesting;
                visitChild(element.shadowRoot);
                --shadowDomNesting;
              }
            }
            if (nodeName === "TEXTAREA") {
              const value = node.value;
              expectValue(value);
              extraNodes++;
              result2.push(value);
            } else {
              if (nodeName === "HEAD") {
                this._fakeBase.setAttribute("href", document.baseURI);
                visitChild(this._fakeBase);
              }
              for (let child = node.firstChild; child; child = child.nextSibling)
                visitChild(child);
              expectValue(kEndOfList);
              let documentOrShadowRoot = null;
              if (node.ownerDocument.documentElement === node)
                documentOrShadowRoot = node.ownerDocument;
              else if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
                documentOrShadowRoot = node;
              if (documentOrShadowRoot) {
                for (const sheet of documentOrShadowRoot.adoptedStyleSheets || [])
                  visitChildStyleSheet(sheet);
                expectValue(kEndOfList);
              }
            }
            if (nodeName === "IFRAME" || nodeName === "FRAME") {
              const element = node;
              const frameId = element[kSnapshotFrameId];
              const name = "src";
              const value = frameId ? `/snapshot/${frameId}` : "";
              expectValue(name);
              expectValue(value);
              attrs[name] = value;
            }
            if (equals && data.attributesCached && !shadowDomNesting)
              return checkAndReturn(result2);
            if (nodeType === Node.ELEMENT_NODE) {
              const element = node;
              for (let i = 0; i < element.attributes.length; i++) {
                const name = element.attributes[i].name;
                if (name === "value" && (nodeName === "INPUT" || nodeName === "TEXTAREA"))
                  continue;
                if (nodeName === "LINK" && name === "integrity")
                  continue;
                if (nodeName === "IFRAME" && (name === "src" || name === "sandbox"))
                  continue;
                if (nodeName === "FRAME" && name === "src")
                  continue;
                let value = element.attributes[i].value;
                if (nodeName === "META")
                  value = this.__sanitizeMetaAttribute(name, value, node.httpEquiv);
                else if (name === "src" && nodeName === "IMG")
                  value = this._sanitizeUrl(value);
                else if (name === "srcset" && nodeName === "IMG")
                  value = this._sanitizeSrcSet(value);
                else if (name === "srcset" && nodeName === "SOURCE")
                  value = this._sanitizeSrcSet(value);
                else if (name === "href" && nodeName === "LINK")
                  value = this._sanitizeUrl(value);
                else if (name.startsWith("on"))
                  value = "";
                expectValue(name);
                expectValue(value);
                attrs[name] = value;
              }
              expectValue(kEndOfList);
            }
            if (result2.length === 2 && !Object.keys(attrs).length)
              result2.pop();
            return checkAndReturn(result2);
          };
          const visitStyleSheet = (sheet) => {
            const data = ensureCachedData(sheet);
            const oldCSSText = data.cssText;
            const cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet, true);
            if (cssText === oldCSSText)
              return {
                equals: true,
                n: [[snapshotNumber - data.ref[0], data.ref[1]]]
              };
            data.ref = [snapshotNumber, nodeCounter++];
            return {
              equals: false,
              n: ["template", {
                [kStyleSheetAttribute]: cssText
              }]
            };
          };
          let html;
          if (document.documentElement) {
            const {
              n
            } = visitNode(document.documentElement);
            html = n;
          } else {
            html = ["html"];
          }
          const result = {
            html,
            doctype: document.doctype ? document.doctype.name : void 0,
            resourceOverrides: [],
            viewport: {
              width: window.innerWidth,
              height: window.innerHeight
            },
            url: location.href,
            timestamp,
            collectionTime: 0
          };
          for (const sheet of this._staleStyleSheets) {
            if (sheet.href === null)
              continue;
            const content = this._updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber);
            if (content === void 0) {
              continue;
            }
            const base = this._getSheetBase(sheet);
            const url = removeHash(this._resolveUrl(base, sheet.href));
            result.resourceOverrides.push({
              url,
              content,
              contentType: "text/css"
            });
          }
          result.collectionTime = performance.now() - result.timestamp;
          return result;
        }
      }
      window[snapshotStreamer] = new Streamer();
    }
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/snapshotter.js
var require_snapshotter = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/snapshotter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Snapshotter = void 0;
    var _browserContext = require_browserContext();
    var _page = require_page();
    var _eventsHelper = require_eventsHelper();
    var _debugLogger = require_debugLogger();
    var _snapshotterInjected = require_snapshotterInjected();
    var _utils2 = require_utils();
    var mime = _interopRequireWildcard2(require_mime());
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Snapshotter = class {
      constructor(context, delegate) {
        this._context = void 0;
        this._delegate = void 0;
        this._eventListeners = [];
        this._snapshotStreamer = void 0;
        this._initialized = false;
        this._started = false;
        this._context = context;
        this._delegate = delegate;
        const guid = (0, _utils2.createGuid)();
        this._snapshotStreamer = "__playwright_snapshot_streamer_" + guid;
      }
      started() {
        return this._started;
      }
      start() {
        return __async(this, null, function* () {
          this._started = true;
          if (!this._initialized) {
            this._initialized = true;
            yield this._initialize();
          }
          yield this.reset();
        });
      }
      reset() {
        return __async(this, null, function* () {
          if (this._started)
            yield this._runInAllFrames(`window["${this._snapshotStreamer}"].reset()`);
        });
      }
      stop() {
        return __async(this, null, function* () {
          this._started = false;
        });
      }
      _initialize() {
        return __async(this, null, function* () {
          for (const page of this._context.pages())
            this._onPage(page);
          this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._onPage.bind(this))];
          const initScript = `(${_snapshotterInjected.frameSnapshotStreamer})("${this._snapshotStreamer}")`;
          yield this._context._doAddInitScript(initScript);
          yield this._runInAllFrames(initScript);
        });
      }
      _runInAllFrames(expression) {
        return __async(this, null, function* () {
          const frames = [];
          for (const page of this._context.pages())
            frames.push(...page.frames());
          yield Promise.all(frames.map((frame) => {
            return frame.nonStallingRawEvaluateInExistingMainContext(expression).catch((e) => _debugLogger.debugLogger.log("error", e));
          }));
        });
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      captureSnapshot(page, snapshotName, element) {
        return __async(this, null, function* () {
          const expression = `window["${this._snapshotStreamer}"].captureSnapshot(${JSON.stringify(snapshotName)})`;
          element === null || element === void 0 ? void 0 : element.callFunctionNoReply((element2, snapshotName2) => {
            element2.setAttribute("__playwright_target__", snapshotName2);
          }, snapshotName);
          const snapshots = page.frames().map((frame) => __async(this, null, function* () {
            const data = yield frame.nonStallingRawEvaluateInExistingMainContext(expression).catch((e) => _debugLogger.debugLogger.log("error", e));
            if (!data || !this._started)
              return;
            const snapshot = {
              snapshotName,
              pageId: page.guid,
              frameId: frame.guid,
              frameUrl: data.url,
              doctype: data.doctype,
              html: data.html,
              viewport: data.viewport,
              timestamp: (0, _utils2.monotonicTime)(),
              collectionTime: data.collectionTime,
              resourceOverrides: [],
              isMainFrame: page.mainFrame() === frame
            };
            for (const {
              url,
              content,
              contentType
            } of data.resourceOverrides) {
              if (typeof content === "string") {
                const buffer = Buffer.from(content);
                const sha1 = (0, _utils2.calculateSha1)(buffer) + "." + (mime.getExtension(contentType) || "dat");
                this._delegate.onSnapshotterBlob({
                  sha1,
                  buffer
                });
                snapshot.resourceOverrides.push({
                  url,
                  sha1
                });
              } else {
                snapshot.resourceOverrides.push({
                  url,
                  ref: content
                });
              }
            }
            this._delegate.onFrameSnapshot(snapshot);
          }));
          yield Promise.all(snapshots);
        });
      }
      _onPage(page) {
        for (const frame of page.frames())
          this._annotateFrameHierarchy(frame);
        this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.FrameAttached, (frame) => this._annotateFrameHierarchy(frame)));
      }
      _annotateFrameHierarchy(frame) {
        return __async(this, null, function* () {
          try {
            const frameElement = yield frame.frameElement();
            const parent = frame.parentFrame();
            if (!parent)
              return;
            const context = yield parent._mainContext();
            yield context === null || context === void 0 ? void 0 : context.evaluate(({
              snapshotStreamer,
              frameElement: frameElement2,
              frameId
            }) => {
              window[snapshotStreamer].markIframe(frameElement2, frameId);
            }, {
              snapshotStreamer: this._snapshotStreamer,
              frameElement,
              frameId: frame.guid
            });
            frameElement.dispose();
          } catch (e) {
          }
        });
      }
    };
    exports2.Snapshotter = Snapshotter;
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/tracing.js
var require_tracing = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.shouldCaptureSnapshot = shouldCaptureSnapshot;
    exports2.Tracing = void 0;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _path2 = _interopRequireDefault2(require("path"));
    var _yazl = _interopRequireDefault2(require_yazl());
    var _channels = require_channels();
    var _async = require_async();
    var _eventsHelper = require_eventsHelper();
    var _utils2 = require_utils();
    var _artifact = require_artifact();
    var _browserContext = require_browserContext();
    var _dom = require_dom();
    var _page = require_page();
    var _harTracer = require_harTracer();
    var _traceEvents = require_traceEvents();
    var _snapshotter = require_snapshotter();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var kScreencastOptions = {
      width: 800,
      height: 600,
      quality: 90
    };
    var Tracing = class {
      constructor(context) {
        this._writeChain = Promise.resolve();
        this._snapshotter = void 0;
        this._harTracer = void 0;
        this._screencastListeners = [];
        this._pendingCalls = /* @__PURE__ */ new Map();
        this._context = void 0;
        this._resourcesDir = void 0;
        this._state = void 0;
        this._isStopping = false;
        this._tracesDir = void 0;
        this._allResources = /* @__PURE__ */ new Set();
        this._contextCreatedEvent = void 0;
        this._context = context;
        this._tracesDir = context._browser.options.tracesDir;
        this._resourcesDir = _path2.default.join(this._tracesDir, "resources");
        this._snapshotter = new _snapshotter.Snapshotter(context, this);
        this._harTracer = new _harTracer.HarTracer(context, this, {
          content: "sha1",
          waitForContentOnStop: false,
          skipScripts: true
        });
        this._contextCreatedEvent = {
          version: _traceEvents.VERSION,
          type: "context-options",
          browserName: this._context._browser.options.name,
          options: this._context._options,
          platform: process.platform,
          wallTime: 0
        };
      }
      start(options) {
        if (this._isStopping)
          throw new Error("Cannot start tracing while stopping");
        if (this._state) {
          const o = this._state.options;
          if (o.name !== options.name || !o.screenshots !== !options.screenshots || !o.snapshots !== !options.snapshots)
            throw new Error("Tracing has been already started with different options");
          return;
        }
        const traceName = options.name || (0, _utils2.createGuid)();
        const traceFile = _path2.default.join(this._tracesDir, traceName + ".trace");
        const networkFile = _path2.default.join(this._tracesDir, traceName + ".network");
        this._state = {
          options,
          traceName,
          traceFile,
          networkFile,
          filesCount: 0,
          traceSha1s: /* @__PURE__ */ new Set(),
          networkSha1s: /* @__PURE__ */ new Set(),
          sources: /* @__PURE__ */ new Set(),
          recording: false
        };
        this._writeChain = _fs2.default.promises.mkdir(this._resourcesDir, {
          recursive: true
        }).then(() => _fs2.default.promises.writeFile(networkFile, ""));
        if (options.snapshots)
          this._harTracer.start();
      }
      startChunk() {
        return __async(this, arguments, function* (options = {}) {
          if (this._state && this._state.recording)
            yield this.stopChunk({
              mode: "doNotSave"
            });
          if (!this._state)
            throw new Error("Must start tracing before starting a new chunk");
          if (this._isStopping)
            throw new Error("Cannot start a trace chunk while stopping");
          const state = this._state;
          const suffix = state.filesCount ? `-${state.filesCount}` : ``;
          state.filesCount++;
          state.traceFile = _path2.default.join(this._tracesDir, `${state.traceName}${suffix}.trace`);
          state.recording = true;
          this._appendTraceOperation(() => __async(this, null, function* () {
            yield (0, _utils2.mkdirIfNeeded)(state.traceFile);
            yield _fs2.default.promises.appendFile(state.traceFile, JSON.stringify(__spreadProps(__spreadValues({}, this._contextCreatedEvent), {
              title: options.title,
              wallTime: Date.now()
            })) + "\n");
          }));
          this._context.instrumentation.addListener(this, this._context);
          if (state.options.screenshots)
            this._startScreencast();
          if (state.options.snapshots)
            yield this._snapshotter.start();
        });
      }
      _startScreencast() {
        for (const page of this._context.pages())
          this._startScreencastInPage(page);
        this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._startScreencastInPage.bind(this)));
      }
      _stopScreencast() {
        _eventsHelper.eventsHelper.removeEventListeners(this._screencastListeners);
        for (const page of this._context.pages())
          page.setScreencastOptions(null);
      }
      stop() {
        return __async(this, null, function* () {
          if (!this._state)
            return;
          if (this._isStopping)
            throw new Error(`Tracing is already stopping`);
          if (this._state.recording)
            throw new Error(`Must stop trace file before stopping tracing`);
          this._harTracer.stop();
          yield this._writeChain;
          this._state = void 0;
        });
      }
      dispose() {
        return __async(this, null, function* () {
          this._snapshotter.dispose();
          yield this._writeChain;
        });
      }
      stopChunk(params) {
        return __async(this, null, function* () {
          var _this$_state;
          if (this._isStopping)
            throw new Error(`Tracing is already stopping`);
          this._isStopping = true;
          if (!this._state || !this._state.recording) {
            this._isStopping = false;
            if (params.mode !== "doNotSave")
              throw new Error(`Must start tracing before stopping`);
            return {
              artifact: null,
              sourceEntries: []
            };
          }
          const state = this._state;
          this._context.instrumentation.removeListener(this);
          if ((_this$_state = this._state) !== null && _this$_state !== void 0 && _this$_state.options.screenshots)
            this._stopScreencast();
          for (const {
            sdkObject,
            metadata,
            beforeSnapshot,
            actionSnapshot,
            afterSnapshot
          } of this._pendingCalls.values()) {
            yield Promise.all([beforeSnapshot, actionSnapshot, afterSnapshot]);
            let callMetadata = metadata;
            if (!afterSnapshot) {
              callMetadata = __spreadProps(__spreadValues({}, metadata), {
                error: {
                  error: {
                    name: "Error",
                    message: "Action was interrupted"
                  }
                }
              });
            }
            yield this.onAfterCall(sdkObject, callMetadata);
          }
          if (state.options.snapshots)
            yield this._snapshotter.stop();
          return (yield this._appendTraceOperation(() => __async(this, null, function* () {
            if (params.mode === "doNotSave")
              return {
                artifact: null,
                sourceEntries: void 0
              };
            const networkFile = _path2.default.join(state.networkFile, "..", (0, _utils2.createGuid)());
            yield _fs2.default.promises.copyFile(state.networkFile, networkFile);
            const entries = [];
            entries.push({
              name: "trace.trace",
              value: state.traceFile
            });
            entries.push({
              name: "trace.network",
              value: networkFile
            });
            for (const sha1 of /* @__PURE__ */ new Set([...state.traceSha1s, ...state.networkSha1s]))
              entries.push({
                name: _path2.default.join("resources", sha1),
                value: _path2.default.join(this._resourcesDir, sha1)
              });
            let sourceEntries;
            if (state.sources.size) {
              sourceEntries = [];
              for (const value of state.sources) {
                const entry = {
                  name: "resources/src@" + (0, _utils2.calculateSha1)(value) + ".txt",
                  value
                };
                if (params.mode === "compressTraceAndSources") {
                  if (_fs2.default.existsSync(entry.value))
                    entries.push(entry);
                } else {
                  sourceEntries.push(entry);
                }
              }
            }
            const artifact = yield this._exportZip(entries, state).catch(() => null);
            return {
              artifact,
              sourceEntries
            };
          })).finally(() => {
            state.traceSha1s = /* @__PURE__ */ new Set();
            state.sources = /* @__PURE__ */ new Set();
            this._isStopping = false;
            state.recording = false;
          })) || {
            artifact: null,
            sourceEntries: void 0
          };
        });
      }
      _exportZip(entries, state) {
        return __async(this, null, function* () {
          const zipFile = new _yazl.default.ZipFile();
          const result = new _async.ManualPromise();
          zipFile.on("error", (error) => result.reject(error));
          for (const entry of entries)
            zipFile.addFile(entry.value, entry.name);
          zipFile.end();
          const zipFileName = state.traceFile + ".zip";
          zipFile.outputStream.pipe(_fs2.default.createWriteStream(zipFileName)).on("close", () => {
            const artifact = new _artifact.Artifact(this._context, zipFileName);
            artifact.reportFinished();
            result.resolve(artifact);
          });
          return result;
        });
      }
      _captureSnapshot(name, sdkObject, metadata, element) {
        return __async(this, null, function* () {
          if (!sdkObject.attribution.page)
            return;
          if (!this._snapshotter.started())
            return;
          if (!shouldCaptureSnapshot(metadata))
            return;
          const snapshotName = `${name}@${metadata.id}`;
          metadata.snapshots.push({
            title: name,
            snapshotName
          });
          if (!element && sdkObject instanceof _dom.ElementHandle)
            element = sdkObject;
          yield this._snapshotter.captureSnapshot(sdkObject.attribution.page, snapshotName, element).catch(() => {
          });
        });
      }
      onBeforeCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          var _sdkObject$attributio, _this$_state2;
          (_sdkObject$attributio = sdkObject.attribution.page) === null || _sdkObject$attributio === void 0 ? void 0 : _sdkObject$attributio.temporarlyDisableTracingScreencastThrottling();
          metadata.afterSnapshot = `after@${metadata.id}`;
          const beforeSnapshot = this._captureSnapshot("before", sdkObject, metadata);
          this._pendingCalls.set(metadata.id, {
            sdkObject,
            metadata,
            beforeSnapshot
          });
          if ((_this$_state2 = this._state) !== null && _this$_state2 !== void 0 && _this$_state2.options.sources) {
            for (const frame of metadata.stack || [])
              this._state.sources.add(frame.file);
          }
          yield beforeSnapshot;
        });
      }
      onBeforeInputAction(sdkObject, metadata, element) {
        return __async(this, null, function* () {
          var _sdkObject$attributio2;
          (_sdkObject$attributio2 = sdkObject.attribution.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.temporarlyDisableTracingScreencastThrottling();
          const actionSnapshot = this._captureSnapshot("action", sdkObject, metadata, element);
          this._pendingCalls.get(metadata.id).actionSnapshot = actionSnapshot;
          yield actionSnapshot;
        });
      }
      onAfterCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          var _sdkObject$attributio3;
          (_sdkObject$attributio3 = sdkObject.attribution.page) === null || _sdkObject$attributio3 === void 0 ? void 0 : _sdkObject$attributio3.temporarlyDisableTracingScreencastThrottling();
          const pendingCall = this._pendingCalls.get(metadata.id);
          if (!pendingCall || pendingCall.afterSnapshot)
            return;
          if (!sdkObject.attribution.context) {
            this._pendingCalls.delete(metadata.id);
            return;
          }
          pendingCall.afterSnapshot = this._captureSnapshot("after", sdkObject, metadata);
          yield pendingCall.afterSnapshot;
          const event = {
            type: "action",
            metadata
          };
          this._appendTraceEvent(event);
          this._pendingCalls.delete(metadata.id);
        });
      }
      onEvent(sdkObject, metadata) {
        if (!sdkObject.attribution.context)
          return;
        const event = {
          type: "event",
          metadata
        };
        this._appendTraceEvent(event);
      }
      onEntryStarted(entry) {
      }
      onEntryFinished(entry) {
        const event = {
          type: "resource-snapshot",
          snapshot: entry
        };
        this._appendTraceOperation(() => __async(this, null, function* () {
          visitSha1s(event, this._state.networkSha1s);
          yield _fs2.default.promises.appendFile(this._state.networkFile, JSON.stringify(event) + "\n");
        }));
      }
      onContentBlob(sha1, buffer) {
        this._appendResource(sha1, buffer);
      }
      onSnapshotterBlob(blob) {
        this._appendResource(blob.sha1, blob.buffer);
      }
      onFrameSnapshot(snapshot) {
        this._appendTraceEvent({
          type: "frame-snapshot",
          snapshot
        });
      }
      _startScreencastInPage(page) {
        page.setScreencastOptions(kScreencastOptions);
        const prefix = page.guid;
        let frameSeq = 0;
        this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.ScreencastFrame, (params) => {
          const suffix = String(++frameSeq).padStart(10, "0");
          const sha1 = `${prefix}-${suffix}.jpeg`;
          const event = {
            type: "screencast-frame",
            pageId: page.guid,
            sha1,
            width: params.width,
            height: params.height,
            timestamp: (0, _utils2.monotonicTime)()
          };
          this._appendResource(sha1, params.buffer);
          this._appendTraceEvent(event);
        }));
      }
      _appendTraceEvent(event) {
        this._appendTraceOperation(() => __async(this, null, function* () {
          visitSha1s(event, this._state.traceSha1s);
          yield _fs2.default.promises.appendFile(this._state.traceFile, JSON.stringify(event) + "\n");
        }));
      }
      _appendResource(sha1, buffer) {
        if (this._allResources.has(sha1))
          return;
        this._allResources.add(sha1);
        this._appendTraceOperation(() => __async(this, null, function* () {
          const resourcePath = _path2.default.join(this._resourcesDir, sha1);
          try {
            yield _fs2.default.promises.access(resourcePath);
          } catch (e) {
            yield _fs2.default.promises.writeFile(resourcePath, buffer).catch(() => {
            });
          }
        }));
      }
      _appendTraceOperation(cb) {
        return __async(this, null, function* () {
          let error;
          let result;
          this._writeChain = this._writeChain.then(() => __async(this, null, function* () {
            if (!this._context._browser.isConnected())
              return;
            try {
              result = yield cb();
            } catch (e) {
              error = e;
            }
          }));
          yield this._writeChain;
          if (error)
            throw error;
          return result;
        });
      }
    };
    exports2.Tracing = Tracing;
    function visitSha1s(object, sha1s) {
      if (Array.isArray(object)) {
        object.forEach((o) => visitSha1s(o, sha1s));
        return;
      }
      if (typeof object === "object") {
        for (const key in object) {
          if (key === "sha1" || key === "_sha1" || key.endsWith("Sha1")) {
            const sha1 = object[key];
            if (sha1)
              sha1s.add(sha1);
          }
          visitSha1s(object[key], sha1s);
        }
        return;
      }
    }
    function shouldCaptureSnapshot(metadata) {
      return _channels.commandsWithTracingSnapshots.has(metadata.type + "." + metadata.method);
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/har/harRecorder.js
var require_harRecorder = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/har/harRecorder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.HarRecorder = void 0;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _artifact = require_artifact();
    var _harTracer = require_harTracer();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var HarRecorder = class {
      constructor(context, options) {
        this._artifact = void 0;
        this._isFlushed = false;
        this._options = void 0;
        this._tracer = void 0;
        this._entries = [];
        this._artifact = new _artifact.Artifact(context, options.path);
        this._options = options;
        this._tracer = new _harTracer.HarTracer(context, this, {
          content: options.omitContent ? "omit" : "embedded",
          waitForContentOnStop: true,
          skipScripts: false
        });
        this._tracer.start();
      }
      onEntryStarted(entry) {
        this._entries.push(entry);
      }
      onEntryFinished(entry) {
      }
      onContentBlob(sha1, buffer) {
      }
      flush() {
        return __async(this, null, function* () {
          if (this._isFlushed)
            return;
          this._isFlushed = true;
          yield this._tracer.flush();
          const log = this._tracer.stop();
          log.entries = this._entries;
          yield _fs2.default.promises.writeFile(this._options.path, JSON.stringify({
            log
          }, void 0, 2));
        });
      }
      export() {
        return __async(this, null, function* () {
          yield this.flush();
          this._artifact.reportFinished();
          return this._artifact;
        });
      }
    };
    exports2.HarRecorder = HarRecorder;
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/utils.js
var require_utils3 = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toClickOptions = toClickOptions;
    exports2.toModifiers = toModifiers;
    exports2.describeFrame = describeFrame;
    function toClickOptions(action) {
      let method = "click";
      if (action.clickCount === 2)
        method = "dblclick";
      const modifiers = toModifiers(action.modifiers);
      const options = {};
      if (action.button !== "left")
        options.button = action.button;
      if (modifiers.length)
        options.modifiers = modifiers;
      if (action.clickCount > 2)
        options.clickCount = action.clickCount;
      if (action.position)
        options.position = action.position;
      return {
        method,
        options
      };
    }
    function toModifiers(modifiers) {
      const result = [];
      if (modifiers & 1)
        result.push("Alt");
      if (modifiers & 2)
        result.push("Control");
      if (modifiers & 4)
        result.push("Meta");
      if (modifiers & 8)
        result.push("Shift");
      return result;
    }
    function describeFrame(frame) {
      const page = frame._page;
      if (page.mainFrame() === frame)
        return {
          isMainFrame: true,
          frameUrl: frame.url()
        };
      const frames = page.frames().filter((f) => f.name() === frame.name());
      if (frames.length === 1 && frames[0] === frame)
        return {
          isMainFrame: false,
          frameUrl: frame.url(),
          frameName: frame.name()
        };
      return {
        isMainFrame: false,
        frameUrl: frame.url()
      };
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/codeGenerator.js
var require_codeGenerator = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/codeGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CodeGenerator = void 0;
    var _events = require("events");
    var _utils2 = require_utils3();
    var CodeGenerator = class extends _events.EventEmitter {
      constructor(browserName, generateHeaders, launchOptions, contextOptions, deviceName, saveStorage) {
        super();
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        this._enabled = void 0;
        this._options = void 0;
        launchOptions = __spreadValues({
          headless: false
        }, launchOptions);
        contextOptions = __spreadValues({}, contextOptions);
        this._enabled = generateHeaders;
        this._options = {
          browserName,
          generateHeaders,
          launchOptions,
          contextOptions,
          deviceName,
          saveStorage
        };
        this.restart();
      }
      restart() {
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        this.emit("change");
      }
      setEnabled(enabled) {
        this._enabled = enabled;
      }
      addAction(action) {
        if (!this._enabled)
          return;
        this.willPerformAction(action);
        this.didPerformAction(action);
      }
      willPerformAction(action) {
        if (!this._enabled)
          return;
        this._currentAction = action;
      }
      performedActionFailed(action) {
        if (!this._enabled)
          return;
        if (this._currentAction === action)
          this._currentAction = null;
      }
      didPerformAction(actionInContext) {
        if (!this._enabled)
          return;
        const {
          action,
          pageAlias
        } = actionInContext;
        let eraseLastAction = false;
        if (this._lastAction && this._lastAction.pageAlias === pageAlias) {
          const {
            action: lastAction
          } = this._lastAction;
          if (this._lastAction && action.name === "fill" && lastAction.name === "fill") {
            if (action.selector === lastAction.selector)
              eraseLastAction = true;
          }
          if (lastAction && action.name === "click" && lastAction.name === "click") {
            if (action.selector === lastAction.selector && action.clickCount > lastAction.clickCount)
              eraseLastAction = true;
          }
          if (lastAction && action.name === "navigate" && lastAction.name === "navigate") {
            if (action.url === lastAction.url) {
              this._currentAction = null;
              return;
            }
          }
          if (lastAction && (action.name === "check" || action.name === "uncheck") && lastAction.name === "click") {
            if (action.selector === lastAction.selector)
              eraseLastAction = true;
          }
        }
        this._lastAction = actionInContext;
        this._currentAction = null;
        if (eraseLastAction)
          this._actions.pop();
        this._actions.push(actionInContext);
        this.emit("change");
      }
      commitLastAction() {
        if (!this._enabled)
          return;
        const action = this._lastAction;
        if (action)
          action.committed = true;
      }
      signal(pageAlias, frame, signal) {
        if (!this._enabled)
          return;
        if (this._currentAction) {
          this._currentAction.action.signals.push(signal);
          return;
        }
        if (this._lastAction && !this._lastAction.committed) {
          const signals = this._lastAction.action.signals;
          if (signal.name === "navigation" && signals.length && signals[signals.length - 1].name === "download")
            return;
          if (signal.name === "download" && signals.length && signals[signals.length - 1].name === "navigation")
            signals.length = signals.length - 1;
          signal.isAsync = true;
          this._lastAction.action.signals.push(signal);
          this.emit("change");
          return;
        }
        if (signal.name === "navigation") {
          this.addAction(__spreadProps(__spreadValues({
            pageAlias
          }, (0, _utils2.describeFrame)(frame)), {
            committed: true,
            action: {
              name: "navigate",
              url: frame.url(),
              signals: []
            }
          }));
        }
      }
      generateText(languageGenerator) {
        const text = [];
        if (this._options.generateHeaders)
          text.push(languageGenerator.generateHeader(this._options));
        for (const action of this._actions) {
          const actionText = languageGenerator.generateAction(action);
          if (actionText)
            text.push(actionText);
        }
        if (this._options.generateHeaders)
          text.push(languageGenerator.generateFooter(this._options.saveStorage));
        return text.join("\n");
      }
    };
    exports2.CodeGenerator = CodeGenerator;
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/language.js
var require_language = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/language.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.sanitizeDeviceOptions = sanitizeDeviceOptions;
    exports2.toSignalMap = toSignalMap;
    function sanitizeDeviceOptions(device, options) {
      const cleanedOptions = {};
      for (const property in options) {
        if (JSON.stringify(device[property]) !== JSON.stringify(options[property]))
          cleanedOptions[property] = options[property];
      }
      return cleanedOptions;
    }
    function toSignalMap(action) {
      let waitForNavigation;
      let assertNavigation;
      let popup;
      let download;
      let dialog;
      for (const signal of action.signals) {
        if (signal.name === "navigation" && signal.isAsync)
          waitForNavigation = signal;
        else if (signal.name === "navigation" && !signal.isAsync)
          assertNavigation = signal;
        else if (signal.name === "popup")
          popup = signal;
        else if (signal.name === "download")
          download = signal;
        else if (signal.name === "dialog")
          dialog = signal;
      }
      return {
        waitForNavigation,
        assertNavigation,
        popup,
        download,
        dialog
      };
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/recorderActions.js
var require_recorderActions = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/recorderActions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.actionTitle = actionTitle;
    function actionTitle(action) {
      switch (action.name) {
        case "openPage":
          return `Open new page`;
        case "closePage":
          return `Close page`;
        case "check":
          return `Check ${action.selector}`;
        case "uncheck":
          return `Uncheck ${action.selector}`;
        case "click": {
          if (action.clickCount === 1)
            return `Click ${action.selector}`;
          if (action.clickCount === 2)
            return `Double click ${action.selector}`;
          if (action.clickCount === 3)
            return `Triple click ${action.selector}`;
          return `${action.clickCount}\xD7 click`;
        }
        case "fill":
          return `Fill ${action.selector}`;
        case "setInputFiles":
          if (action.files.length === 0)
            return `Clear selected files`;
          else
            return `Upload ${action.files.join(", ")}`;
        case "navigate":
          return `Go to ${action.url}`;
        case "press":
          return `Press ${action.key}` + (action.modifiers ? " with modifiers" : "");
        case "select":
          return `Select ${action.options.join(", ")}`;
      }
    }
  }
});

// node_modules/playwright-core/lib/server/deviceDescriptorsSource.json
var require_deviceDescriptorsSource = __commonJS({
  "node_modules/playwright-core/lib/server/deviceDescriptorsSource.json"(exports2, module2) {
    module2.exports = {
      "Blackberry PlayBook": {
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/15.4 Safari/536.2+",
        viewport: {
          width: 600,
          height: 1024
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Blackberry PlayBook landscape": {
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/15.4 Safari/536.2+",
        viewport: {
          width: 1024,
          height: 600
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "BlackBerry Z30": {
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/15.4 Mobile Safari/537.10+",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "BlackBerry Z30 landscape": {
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/15.4 Mobile Safari/537.10+",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note 3": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note 3 landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note II": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note II landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S III": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S III landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S5": {
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S8": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 740
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S8 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 740,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S9+": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 320,
          height: 658
        },
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S9+ landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 658,
          height: 320
        },
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy Tab S4": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Safari/537.36",
        viewport: {
          width: 712,
          height: 1138
        },
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy Tab S4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Safari/537.36",
        viewport: {
          width: 1138,
          height: 712
        },
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "iPad (gen 6)": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 768,
          height: 1024
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 6) landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1024,
          height: 768
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 7)": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 810,
          height: 1080
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 7) landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1080,
          height: 810
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Mini": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 768,
          height: 1024
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Mini landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1024,
          height: 768
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Pro 11": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 834,
          height: 1194
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Pro 11 landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1194,
          height: 834
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone SE": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/15.4 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 320,
          height: 568
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone SE landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/15.4 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 568,
          height: 320
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone X": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 812
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone X landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 812,
          height: 375
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone XR": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 414,
          height: 896
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone XR landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 896,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 414,
          height: 715
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 800,
          height: 364
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 375,
          height: 635
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 724,
          height: 325
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 414,
          height: 715
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 808,
          height: 364
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 340
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 340
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 428,
          height: 746
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 832,
          height: 378
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 342
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 342
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 428,
          height: 746
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 832,
          height: 380
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Mini": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 375,
          height: 629
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Mini landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 712,
          height: 327
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "JioPhone 2": {
        userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:95.0) Gecko/48.0 Firefox/95.0 KAIOS/2.5",
        viewport: {
          width: 240,
          height: 320
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "firefox"
      },
      "JioPhone 2 landscape": {
        userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:95.0) Gecko/48.0 Firefox/95.0 KAIOS/2.5",
        viewport: {
          width: 320,
          height: 240
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "firefox"
      },
      "Kindle Fire HDX": {
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
          width: 800,
          height: 1280
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Kindle Fire HDX landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
          width: 1280,
          height: 800
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "LG Optimus L70": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 384,
          height: 640
        },
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "LG Optimus L70 landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 384
        },
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 550": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 550 landscape": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 950": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 950 landscape": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 10": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Safari/537.36",
        viewport: {
          width: 800,
          height: 1280
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 10 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Safari/537.36",
        viewport: {
          width: 1280,
          height: 800
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 4": {
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 384,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 384
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5X": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5X landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6P": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6P landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 7": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Safari/537.36",
        viewport: {
          width: 600,
          height: 960
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 7 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Safari/537.36",
        viewport: {
          width: 960,
          height: 600
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia Lumia 520": {
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
          width: 320,
          height: 533
        },
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia Lumia 520 landscape": {
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
          width: 533,
          height: 320
        },
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia N9": {
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
          width: 480,
          height: 854
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Nokia N9 landscape": {
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
          width: 854,
          height: 480
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Pixel 2": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 411,
          height: 731
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 731,
          height: 411
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 XL": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 411,
          height: 823
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 XL landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 823,
          height: 411
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 3": {
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 393,
          height: 786
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 3 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 786,
          height: 393
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4": {
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 353,
          height: 745
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 745,
          height: 353
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4a (5G)": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        screen: {
          width: 412,
          height: 892
        },
        viewport: {
          width: 412,
          height: 765
        },
        deviceScaleFactor: 2.63,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4a (5G) landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        screen: {
          height: 892,
          width: 412
        },
        viewport: {
          width: 840,
          height: 312
        },
        deviceScaleFactor: 2.63,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 5": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        screen: {
          width: 393,
          height: 851
        },
        viewport: {
          width: 393,
          height: 727
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        screen: {
          width: 851,
          height: 393
        },
        viewport: {
          width: 802,
          height: 293
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Moto G4": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Moto G4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Desktop Chrome HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Safari/537.36",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Edge HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Safari/537.36 Edg/99.0.4812.0",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Firefox HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "firefox"
      },
      "Desktop Safari": {
        userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Safari/605.1.15",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "webkit"
      },
      "Desktop Chrome": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Safari/537.36",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Edge": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Safari/537.36 Edg/99.0.4812.0",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Firefox": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "firefox"
      }
    };
  }
});

// node_modules/playwright-core/lib/server/deviceDescriptors.js
var require_deviceDescriptors = __commonJS({
  "node_modules/playwright-core/lib/server/deviceDescriptors.js"(exports2, module2) {
    module2.exports = require_deviceDescriptorsSource();
  }
});

// node_modules/playwright-core/lib/utils/stringUtils.js
var require_stringUtils = __commonJS({
  "node_modules/playwright-core/lib/utils/stringUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.escapeWithQuotes = escapeWithQuotes;
    function escapeWithQuotes(text, char = "'") {
      const stringified = JSON.stringify(text);
      const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\"/g, '"');
      if (char === "'")
        return char + escapedText.replace(/[']/g, "\\'") + char;
      if (char === '"')
        return char + escapedText.replace(/["]/g, '\\"') + char;
      if (char === "`")
        return char + escapedText.replace(/[`]/g, "`") + char;
      throw new Error("Invalid escape char");
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/javascript.js
var require_javascript2 = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/javascript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JavaScriptFormatter = exports2.JavaScriptLanguageGenerator = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils2 = require_utils3();
    var _deviceDescriptors = _interopRequireDefault2(require_deviceDescriptors());
    var _stringUtils = require_stringUtils();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var JavaScriptLanguageGenerator = class {
      constructor(isTest) {
        this.id = void 0;
        this.fileName = void 0;
        this.highlighter = "javascript";
        this._isTest = void 0;
        this.id = isTest ? "test" : "javascript";
        this.fileName = isTest ? "Playwright Test" : "JavaScript";
        this._isTest = isTest;
      }
      generateAction(actionInContext) {
        const {
          action,
          pageAlias
        } = actionInContext;
        const formatter = new JavaScriptFormatter(2);
        formatter.newLine();
        formatter.add("// " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          if (this._isTest)
            return "";
          formatter.add(`const ${pageAlias} = await context.newPage();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`await ${pageAlias}.goto(${quote(action.url)});`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.frame(${formatObject({
          name: actionInContext.frameName
        })})` : `${pageAlias}.frame(${formatObject({
          url: actionInContext.frameUrl
        })})`;
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`  ${pageAlias}.once('dialog', dialog => {
    console.log(\`Dialog message: \${dialog.message()}\`);
    dialog.dismiss().catch(() => {});
  });`);
        }
        const emitPromiseAll = signals.waitForNavigation || signals.popup || signals.download;
        if (emitPromiseAll) {
          let leftHandSide = "";
          if (signals.popup)
            leftHandSide = `const [${signals.popup.popupAlias}] = `;
          else if (signals.download)
            leftHandSide = `const [download] = `;
          formatter.add(`${leftHandSide}await Promise.all([`);
        }
        if (signals.popup)
          formatter.add(`${pageAlias}.waitForEvent('popup'),`);
        if (signals.waitForNavigation)
          formatter.add(`${pageAlias}.waitForNavigation(/*{ url: ${quote(signals.waitForNavigation.url)} }*/),`);
        if (signals.download)
          formatter.add(`${pageAlias}.waitForEvent('download'),`);
        const prefix = signals.popup || signals.waitForNavigation || signals.download ? "" : "await ";
        const actionCall = this._generateActionCall(action);
        const suffix = signals.waitForNavigation || emitPromiseAll ? "" : ";";
        formatter.add(`${prefix}${subject}.${actionCall}${suffix}`);
        if (emitPromiseAll) {
          formatter.add(`]);`);
        } else if (signals.assertNavigation) {
          if (this._isTest)
            formatter.add(`  await expect(${pageAlias}).toHaveURL(${quote(signals.assertNavigation.url)});`);
          else
            formatter.add(`  // assert.equal(${pageAlias}.url(), ${quote(signals.assertNavigation.url)});`);
        }
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils2.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            const optionsString = formatOptions(options);
            return `${method}(${quote(action.selector)}${optionsString})`;
          }
          case "check":
            return `check(${quote(action.selector)})`;
          case "uncheck":
            return `uncheck(${quote(action.selector)})`;
          case "fill":
            return `fill(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `setInputFiles(${quote(action.selector)}, ${formatObject(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils2.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `press(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `goto(${quote(action.url)})`;
          case "select":
            return `selectOption(${quote(action.selector)}, ${formatObject(action.options.length > 1 ? action.options : action.options[0])})`;
        }
      }
      generateHeader(options) {
        if (this._isTest)
          return this.generateTestHeader(options);
        return this.generateStandaloneHeader(options);
      }
      generateFooter(saveStorage) {
        if (this._isTest)
          return this.generateTestFooter(saveStorage);
        return this.generateStandaloneFooter(saveStorage);
      }
      generateTestHeader(options) {
        const formatter = new JavaScriptFormatter();
        const useText = formatContextOptions(options.contextOptions, options.deviceName);
        formatter.add(`
      import { test, expect${options.deviceName ? ", devices" : ""} } from '@playwright/test';
${useText ? "\ntest.use(" + useText + ");\n" : ""}
      test('test', async ({ page }) => {`);
        return formatter.format();
      }
      generateTestFooter(saveStorage) {
        return `
});`;
      }
      generateStandaloneHeader(options) {
        const formatter = new JavaScriptFormatter();
        formatter.add(`
      const { ${options.browserName}${options.deviceName ? ", devices" : ""} } = require('playwright');

      (async () => {
        const browser = await ${options.browserName}.launch(${formatObjectOrVoid(options.launchOptions)});
        const context = await browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        return formatter.format();
      }
      generateStandaloneFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
  await context.storageState({ path: ${quote(saveStorage)} });` : "";
        return `
  // ---------------------${storageStateLine}
  await context.close();
  await browser.close();
})();`;
      }
    };
    exports2.JavaScriptLanguageGenerator = JavaScriptLanguageGenerator;
    function formatOptions(value) {
      const keys = Object.keys(value);
      if (!keys.length)
        return "";
      return ", " + formatObject(value);
    }
    function formatObject(value, indent = "  ") {
      if (typeof value === "string")
        return quote(value);
      if (Array.isArray(value))
        return `[${value.map((o) => formatObject(o)).join(", ")}]`;
      if (typeof value === "object") {
        const keys = Object.keys(value);
        if (!keys.length)
          return "{}";
        const tokens = [];
        for (const key of keys)
          tokens.push(`${key}: ${formatObject(value[key])}`);
        return `{
${indent}${tokens.join(`,
${indent}`)}
}`;
      }
      return String(value);
    }
    function formatObjectOrVoid(value, indent = "  ") {
      const result = formatObject(value, indent);
      return result === "{}" ? "" : result;
    }
    function formatContextOptions(options, deviceName) {
      const device = deviceName && _deviceDescriptors.default[deviceName];
      if (!device)
        return formatObjectOrVoid(options);
      let serializedObject = formatObjectOrVoid((0, _language.sanitizeDeviceOptions)(device, options));
      if (!serializedObject)
        serializedObject = "{\n}";
      const lines = serializedObject.split("\n");
      lines.splice(1, 0, `...devices[${quote(deviceName)}],`);
      return lines.join("\n");
    }
    var JavaScriptFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(2);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        let previousLine = "";
        return this._lines.map((line) => {
          if (line === "")
            return line;
          if (line.startsWith("}") || line.startsWith("]"))
            spaces = spaces.substring(this._baseIndent.length);
          const extraSpaces = /^(for|while|if|try).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
          previousLine = line;
          const callCarryOver = line.startsWith(".set");
          line = spaces + extraSpaces + (callCarryOver ? this._baseIndent : "") + line;
          if (line.endsWith("{") || line.endsWith("["))
            spaces += this._baseIndent;
          return this._baseOffset + line;
        }).join("\n");
      }
    };
    exports2.JavaScriptFormatter = JavaScriptFormatter;
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, "'");
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/java.js
var require_java = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/java.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JavaLanguageGenerator = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils2 = require_utils3();
    var _deviceDescriptors = _interopRequireDefault2(require_deviceDescriptors());
    var _javascript = require_javascript2();
    var _stringUtils = require_stringUtils();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var JavaLanguageGenerator = class {
      constructor() {
        this.id = "java";
        this.fileName = "Java";
        this.highlighter = "java";
      }
      generateAction(actionInContext) {
        const {
          action,
          pageAlias
        } = actionInContext;
        const formatter = new _javascript.JavaScriptFormatter(6);
        formatter.newLine();
        formatter.add("// " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          formatter.add(`Page ${pageAlias} = context.newPage();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`${pageAlias}.navigate(${quote(action.url)});`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.frame(${quote(actionInContext.frameName)})` : `${pageAlias}.frameByUrl(${quote(actionInContext.frameUrl)})`;
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`  ${pageAlias}.onceDialog(dialog -> {
        System.out.println(String.format("Dialog message: %s", dialog.message()));
        dialog.dismiss();
      });`);
        }
        const actionCall = this._generateActionCall(action, actionInContext.isMainFrame);
        let code = `${subject}.${actionCall};`;
        if (signals.popup) {
          code = `Page ${signals.popup.popupAlias} = ${pageAlias}.waitForPopup(() -> {
        ${code}
      });`;
        }
        if (signals.download) {
          code = `Download download = ${pageAlias}.waitForDownload(() -> {
        ${code}
      });`;
        }
        if (signals.waitForNavigation) {
          code = `
      // ${pageAlias}.waitForNavigation(new Page.WaitForNavigationOptions().setUrl(${quote(signals.waitForNavigation.url)}), () ->
      ${pageAlias}.waitForNavigation(() -> {
        ${code}
      });`;
        }
        formatter.add(code);
        if (signals.assertNavigation)
          formatter.add(`// assert ${pageAlias}.url().equals(${quote(signals.assertNavigation.url)});`);
        return formatter.format();
      }
      _generateActionCall(action, isPage) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils2.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            const optionsText = formatClickOptions(options, isPage);
            return `${method}(${quote(action.selector)}${optionsText ? ", " : ""}${optionsText})`;
          }
          case "check":
            return `check(${quote(action.selector)})`;
          case "uncheck":
            return `uncheck(${quote(action.selector)})`;
          case "fill":
            return `fill(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `setInputFiles(${quote(action.selector)}, ${formatPath(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils2.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `press(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `navigate(${quote(action.url)})`;
          case "select":
            return `selectOption(${quote(action.selector)}, ${formatSelectOption(action.options.length > 1 ? action.options : action.options[0])})`;
        }
      }
      generateHeader(options) {
        const formatter = new _javascript.JavaScriptFormatter();
        formatter.add(`
    import com.microsoft.playwright.*;
    import com.microsoft.playwright.options.*;
    import java.util.*;

    public class Example {
      public static void main(String[] args) {
        try (Playwright playwright = Playwright.create()) {
          Browser browser = playwright.${options.browserName}().launch(${formatLaunchOptions(options.launchOptions)});
          BrowserContext context = browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        return formatter.format();
      }
      generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
      context.storageState(new BrowserContext.StorageStateOptions().setPath(${quote(saveStorage)}));
` : "";
        return `${storageStateLine}    }
  }
}`;
      }
    };
    exports2.JavaLanguageGenerator = JavaLanguageGenerator;
    function formatPath(files) {
      if (Array.isArray(files)) {
        if (files.length === 0)
          return "new Path[0]";
        return `new Path[] {${files.map((s) => "Paths.get(" + quote(s) + ")").join(", ")}}`;
      }
      return `Paths.get(${quote(files)})`;
    }
    function formatSelectOption(options) {
      if (Array.isArray(options)) {
        if (options.length === 0)
          return "new String[0]";
        return `new String[] {${options.map((s) => quote(s)).join(", ")}}`;
      }
      return quote(options);
    }
    function formatLaunchOptions(options) {
      const lines = [];
      if (!Object.keys(options).length)
        return "";
      lines.push("new BrowserType.LaunchOptions()");
      if (typeof options.headless === "boolean")
        lines.push(`  .setHeadless(false)`);
      if (options.channel)
        lines.push(`  .setChannel(${quote(options.channel)})`);
      return lines.join("\n");
    }
    function formatContextOptions(contextOptions, deviceName) {
      const lines = [];
      if (!Object.keys(contextOptions).length && !deviceName)
        return "";
      const device = deviceName ? _deviceDescriptors.default[deviceName] : {};
      const options = __spreadValues(__spreadValues({}, device), contextOptions);
      lines.push("new Browser.NewContextOptions()");
      if (options.acceptDownloads)
        lines.push(`  .setAcceptDownloads(true)`);
      if (options.bypassCSP)
        lines.push(`  .setBypassCSP(true)`);
      if (options.colorScheme)
        lines.push(`  .setColorScheme(ColorScheme.${options.colorScheme.toUpperCase()})`);
      if (options.deviceScaleFactor)
        lines.push(`  .setDeviceScaleFactor(${options.deviceScaleFactor})`);
      if (options.geolocation)
        lines.push(`  .setGeolocation(${options.geolocation.latitude}, ${options.geolocation.longitude})`);
      if (options.hasTouch)
        lines.push(`  .setHasTouch(${options.hasTouch})`);
      if (options.isMobile)
        lines.push(`  .setIsMobile(${options.isMobile})`);
      if (options.locale)
        lines.push(`  .setLocale(${quote(options.locale)})`);
      if (options.proxy)
        lines.push(`  .setProxy(new Proxy(${quote(options.proxy.server)}))`);
      if (options.storageState)
        lines.push(`  .setStorageStatePath(Paths.get(${quote(options.storageState)}))`);
      if (options.timezoneId)
        lines.push(`  .setTimezoneId(${quote(options.timezoneId)})`);
      if (options.userAgent)
        lines.push(`  .setUserAgent(${quote(options.userAgent)})`);
      if (options.viewport)
        lines.push(`  .setViewportSize(${options.viewport.width}, ${options.viewport.height})`);
      return lines.join("\n");
    }
    function formatClickOptions(options, isPage) {
      const lines = [];
      if (options.button)
        lines.push(`  .setButton(MouseButton.${options.button.toUpperCase()})`);
      if (options.modifiers)
        lines.push(`  .setModifiers(Arrays.asList(${options.modifiers.map((m) => `KeyboardModifier.${m.toUpperCase()}`).join(", ")}))`);
      if (options.clickCount)
        lines.push(`  .setClickCount(${options.clickCount})`);
      if (options.position)
        lines.push(`  .setPosition(${options.position.x}, ${options.position.y})`);
      if (!lines.length)
        return "";
      lines.unshift(`new ${isPage ? "Page" : "Frame"}.ClickOptions()`);
      return lines.join("\n");
    }
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, '"');
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/csharp.js
var require_csharp = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/csharp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CSharpLanguageGenerator = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils2 = require_utils3();
    var _stringUtils = require_stringUtils();
    var _deviceDescriptors = _interopRequireDefault2(require_deviceDescriptors());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var CSharpLanguageGenerator = class {
      constructor() {
        this.id = "csharp";
        this.fileName = "C#";
        this.highlighter = "csharp";
      }
      generateAction(actionInContext) {
        const {
          action,
          pageAlias
        } = actionInContext;
        const formatter = new CSharpFormatter(8);
        formatter.newLine();
        formatter.add("// " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          formatter.add(`var ${pageAlias} = await context.NewPageAsync();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`await ${pageAlias}.GotoAsync(${quote(action.url)});`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.Frame(${quote(actionInContext.frameName)})` : `${pageAlias}.FrameByUrl(${quote(actionInContext.frameUrl)})`;
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`    void ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler(object sender, IDialog dialog)
      {
          Console.WriteLine($"Dialog message: {dialog.Message}");
          dialog.DismissAsync();
          ${pageAlias}.Dialog -= ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;
      }
      ${pageAlias}.Dialog += ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;`);
        }
        const lines = [];
        const actionCall = this._generateActionCall(action, actionInContext.isMainFrame);
        if (signals.waitForNavigation) {
          lines.push(`await ${pageAlias}.RunAndWaitForNavigationAsync(async () =>`);
          lines.push(`{`);
          lines.push(`    await ${subject}.${actionCall};`);
          lines.push(`}/*, new ${actionInContext.isMainFrame ? "Page" : "Frame"}WaitForNavigationOptions`);
          lines.push(`{`);
          lines.push(`    UrlString = ${quote(signals.waitForNavigation.url)}`);
          lines.push(`}*/);`);
        } else {
          lines.push(`await ${subject}.${actionCall};`);
        }
        if (signals.download) {
          lines.unshift(`var download${signals.download.downloadAlias} = await ${pageAlias}.RunAndWaitForDownloadAsync(async () =>
{`);
          lines.push(`});`);
        }
        if (signals.popup) {
          lines.unshift(`var ${signals.popup.popupAlias} = await ${pageAlias}.RunAndWaitForPopupAsync(async () =>
{`);
          lines.push(`});`);
        }
        for (const line of lines)
          formatter.add(line);
        if (signals.assertNavigation)
          formatter.add(`  // Assert.AreEqual(${quote(signals.assertNavigation.url)}, ${pageAlias}.Url);`);
        return formatter.format();
      }
      _generateActionCall(action, isPage) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "CloseAsync()";
          case "click": {
            let method = "Click";
            if (action.clickCount === 2)
              method = "DblClick";
            const modifiers = (0, _utils2.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            if (!Object.entries(options).length)
              return `${method}Async(${quote(action.selector)})`;
            const optionsString = formatObject(options, "    ", (isPage ? "Page" : "Frame") + method + "Options");
            return `${method}Async(${quote(action.selector)}, ${optionsString})`;
          }
          case "check":
            return `CheckAsync(${quote(action.selector)})`;
          case "uncheck":
            return `UncheckAsync(${quote(action.selector)})`;
          case "fill":
            return `FillAsync(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `SetInputFilesAsync(${quote(action.selector)}, ${formatObject(action.files)})`;
          case "press": {
            const modifiers = (0, _utils2.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `PressAsync(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `GotoAsync(${quote(action.url)})`;
          case "select":
            return `SelectOptionAsync(${quote(action.selector)}, ${formatObject(action.options)})`;
        }
      }
      generateHeader(options) {
        const formatter = new CSharpFormatter(0);
        formatter.add(`
      using Microsoft.Playwright;
      using System;
      using System.Threading.Tasks;

      class Program
      {
          public static async Task Main()
          {
              using var playwright = await Playwright.CreateAsync();
              await using var browser = await playwright.${toPascal(options.browserName)}.LaunchAsync(${formatObject(options.launchOptions, "    ", "BrowserTypeLaunchOptions")});
              var context = await browser.NewContextAsync(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        return formatter.format();
      }
      generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
        await context.StorageStateAsync(new BrowserContextStorageStateOptions
        {
            Path = ${quote(saveStorage)}
        });
` : "";
        return `${storageStateLine}    }
}
`;
      }
    };
    exports2.CSharpLanguageGenerator = CSharpLanguageGenerator;
    function formatObject(value, indent = "    ", name = "") {
      if (typeof value === "string") {
        if (["permissions", "colorScheme", "modifiers", "button"].includes(name))
          return `${getClassName(name)}.${toPascal(value)}`;
        return quote(value);
      }
      if (Array.isArray(value))
        return `new[] { ${value.map((o) => formatObject(o, indent, name)).join(", ")} }`;
      if (typeof value === "object") {
        const keys = Object.keys(value);
        if (!keys.length)
          return name ? `new ${getClassName(name)}` : "";
        const tokens = [];
        for (const key of keys) {
          const property = getPropertyName(key);
          tokens.push(`${property} = ${formatObject(value[key], indent, key)},`);
        }
        if (name)
          return `new ${getClassName(name)}
{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
        return `{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
      }
      if (name === "latitude" || name === "longitude")
        return String(value) + "m";
      return String(value);
    }
    function getClassName(value) {
      switch (value) {
        case "viewport":
          return "ViewportSize";
        case "proxy":
          return "ProxySettings";
        case "permissions":
          return "ContextPermission";
        case "modifiers":
          return "KeyboardModifier";
        case "button":
          return "MouseButton";
        default:
          return toPascal(value);
      }
    }
    function getPropertyName(key) {
      switch (key) {
        case "storageState":
          return "StorageStatePath";
        case "viewport":
          return "ViewportSize";
        default:
          return toPascal(key);
      }
    }
    function toPascal(value) {
      return value[0].toUpperCase() + value.slice(1);
    }
    function formatContextOptions(options, deviceName) {
      const device = deviceName && _deviceDescriptors.default[deviceName];
      if (!device) {
        if (!Object.entries(options).length)
          return "";
        return formatObject(options, "    ", "BrowserNewContextOptions");
      }
      options = (0, _language.sanitizeDeviceOptions)(device, options);
      if (!Object.entries(options).length)
        return `playwright.Devices[${quote(deviceName)}]`;
      return formatObject(options, "    ", `BrowserNewContextOptions(playwright.Devices[${quote(deviceName)}])`);
    }
    var CSharpFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(4);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        let previousLine = "";
        return this._lines.map((line) => {
          if (line === "")
            return line;
          if (line.startsWith("}") || line.startsWith("]") || line.includes("});") || line === ");")
            spaces = spaces.substring(this._baseIndent.length);
          const extraSpaces = /^(for|while|if).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
          previousLine = line;
          line = spaces + extraSpaces + line;
          if (line.endsWith("{") || line.endsWith("[") || line.endsWith("("))
            spaces += this._baseIndent;
          if (line.endsWith("));"))
            spaces = spaces.substring(this._baseIndent.length);
          return this._baseOffset + line;
        }).join("\n");
      }
    };
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, '"');
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/python.js
var require_python = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/python.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PythonLanguageGenerator = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils2 = require_utils3();
    var _stringUtils = require_stringUtils();
    var _deviceDescriptors = _interopRequireDefault2(require_deviceDescriptors());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var PythonLanguageGenerator = class {
      constructor(isAsync) {
        this.id = "python";
        this.fileName = "Python";
        this.highlighter = "python";
        this._awaitPrefix = void 0;
        this._asyncPrefix = void 0;
        this._isAsync = void 0;
        this.id = isAsync ? "python-async" : "python";
        this.fileName = isAsync ? "Python Async" : "Python";
        this._isAsync = isAsync;
        this._awaitPrefix = isAsync ? "await " : "";
        this._asyncPrefix = isAsync ? "async " : "";
      }
      generateAction(actionInContext) {
        const {
          action,
          pageAlias
        } = actionInContext;
        const formatter = new PythonFormatter(4);
        formatter.newLine();
        formatter.add("# " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          formatter.add(`${pageAlias} = ${this._awaitPrefix}context.new_page()`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`${this._awaitPrefix}${pageAlias}.goto(${quote(action.url)})`);
          return formatter.format();
        }
        const subject = actionInContext.isMainFrame ? pageAlias : actionInContext.frameName ? `${pageAlias}.frame(${formatOptions({
          name: actionInContext.frameName
        }, false)})` : `${pageAlias}.frame(${formatOptions({
          url: actionInContext.frameUrl
        }, false)})`;
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog)
          formatter.add(`  ${pageAlias}.once("dialog", lambda dialog: dialog.dismiss())`);
        const actionCall = this._generateActionCall(action);
        let code = `${this._awaitPrefix}${subject}.${actionCall}`;
        if (signals.popup) {
          code = `${this._asyncPrefix}with ${pageAlias}.expect_popup() as popup_info {
        ${code}
      }
      ${signals.popup.popupAlias} = ${this._awaitPrefix}popup_info.value`;
        }
        if (signals.download) {
          code = `${this._asyncPrefix}with ${pageAlias}.expect_download() as download_info {
        ${code}
      }
      download = ${this._awaitPrefix}download_info.value`;
        }
        if (signals.waitForNavigation) {
          code = `
      # ${this._asyncPrefix}with ${pageAlias}.expect_navigation(url=${quote(signals.waitForNavigation.url)}):
      ${this._asyncPrefix}with ${pageAlias}.expect_navigation() {
        ${code}
      }`;
        }
        formatter.add(code);
        if (signals.assertNavigation)
          formatter.add(`  # assert ${pageAlias}.url == ${quote(signals.assertNavigation.url)}`);
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils2.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            const optionsString = formatOptions(options, true);
            return `${method}(${quote(action.selector)}${optionsString})`;
          }
          case "check":
            return `check(${quote(action.selector)})`;
          case "uncheck":
            return `uncheck(${quote(action.selector)})`;
          case "fill":
            return `fill(${quote(action.selector)}, ${quote(action.text)})`;
          case "setInputFiles":
            return `set_input_files(${quote(action.selector)}, ${formatValue(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils2.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return `press(${quote(action.selector)}, ${quote(shortcut)})`;
          }
          case "navigate":
            return `goto(${quote(action.url)})`;
          case "select":
            return `select_option(${quote(action.selector)}, ${formatValue(action.options.length === 1 ? action.options[0] : action.options)})`;
        }
      }
      generateHeader(options) {
        const formatter = new PythonFormatter();
        if (this._isAsync) {
          formatter.add(`
import asyncio

from playwright.async_api import Playwright, async_playwright


async def run(playwright: Playwright) -> None {
    browser = await playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})
    context = await browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);
        } else {
          formatter.add(`
from playwright.sync_api import Playwright, sync_playwright


def run(playwright: Playwright) -> None {
    browser = playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})
    context = browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);
        }
        return formatter.format();
      }
      generateFooter(saveStorage) {
        if (this._isAsync) {
          const storageStateLine = saveStorage ? `
    await context.storage_state(path=${quote(saveStorage)})` : "";
          return `
    # ---------------------${storageStateLine}
    await context.close()
    await browser.close()


async def main() -> None:
    async with async_playwright() as playwright:
        await run(playwright)


asyncio.run(main())
`;
        } else {
          const storageStateLine = saveStorage ? `
    context.storage_state(path=${quote(saveStorage)})` : "";
          return `
    # ---------------------${storageStateLine}
    context.close()
    browser.close()


with sync_playwright() as playwright:
    run(playwright)
`;
        }
      }
    };
    exports2.PythonLanguageGenerator = PythonLanguageGenerator;
    function formatValue(value) {
      if (value === false)
        return "False";
      if (value === true)
        return "True";
      if (value === void 0)
        return "None";
      if (Array.isArray(value))
        return `[${value.map(formatValue).join(", ")}]`;
      if (typeof value === "string")
        return quote(value);
      if (typeof value === "object")
        return JSON.stringify(value);
      return String(value);
    }
    function toSnakeCase(name) {
      const toSnakeCaseRegex = /((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))/g;
      return name.replace(toSnakeCaseRegex, `_$1`).toLowerCase();
    }
    function formatOptions(value, hasArguments) {
      const keys = Object.keys(value);
      if (!keys.length)
        return "";
      return (hasArguments ? ", " : "") + keys.map((key) => `${toSnakeCase(key)}=${formatValue(value[key])}`).join(", ");
    }
    function formatContextOptions(options, deviceName) {
      const device = deviceName && _deviceDescriptors.default[deviceName];
      if (!device)
        return formatOptions(options, false);
      return `**playwright.devices[${quote(deviceName)}]` + formatOptions((0, _language.sanitizeDeviceOptions)(device, options), true);
    }
    var PythonFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(4);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        const lines = [];
        this._lines.forEach((line) => {
          if (line === "")
            return lines.push(line);
          if (line === "}") {
            spaces = spaces.substring(this._baseIndent.length);
            return;
          }
          line = spaces + line;
          if (line.endsWith("{")) {
            spaces += this._baseIndent;
            line = line.substring(0, line.length - 1).trimEnd() + ":";
          }
          return lines.push(this._baseOffset + line);
        });
        return lines.join("\n");
      }
    };
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, '"');
    }
  }
});

// node_modules/playwright-core/lib/generated/recorderSource.js
var require_recorderSource = __commonJS({
  "node_modules/playwright-core/lib/generated/recorderSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = 'var pwExport;(()=>{"use strict";var e={317:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseCSS=function(e,t){let n;try{n=r.tokenize(e),n[n.length-1]instanceof r.EOFToken||n.push(new r.EOFToken)}catch(t){const n=t.message+` while parsing selector "${e}"`,o=(t.stack||"").indexOf(t.message);throw-1!==o&&(t.stack=t.stack.substring(0,o)+n+t.stack.substring(o+t.message.length)),t.message=n,t}const i=n.find((e=>e instanceof r.AtKeywordToken||e instanceof r.BadStringToken||e instanceof r.BadURLToken||e instanceof r.ColumnToken||e instanceof r.CDOToken||e instanceof r.CDCToken||e instanceof r.SemicolonToken||e instanceof r.OpenCurlyToken||e instanceof r.CloseCurlyToken||e instanceof r.URLToken||e instanceof r.PercentageToken));if(i)throw new o.InvalidSelectorError(`Unsupported token "${i.toSource()}" while parsing selector "${e}"`);let s=0;const c=new Set;function l(){return new o.InvalidSelectorError(`Unexpected token "${n[s].toSource()}" while parsing selector "${e}"`)}function a(){for(;n[s]instanceof r.WhitespaceToken;)s++}function h(e=s){return n[e]instanceof r.IdentToken}function u(e=s){return n[e]instanceof r.CommaToken}function p(e=s){return n[e]instanceof r.CloseParenToken}function f(e=s){return n[e]instanceof r.DelimToken&&"*"===n[e].value}function d(e=s){return n[e]instanceof r.EOFToken}function m(e=s){return n[e]instanceof r.DelimToken&&[">","+","~"].includes(n[e].value)}function g(e=s){return u(e)||p(e)||d(e)||m(e)||n[e]instanceof r.WhitespaceToken}function y(){const e=[_()];for(;a(),u();)s++,e.push(_());return e}function _(){return a(),function(e=s){return n[e]instanceof r.NumberToken}()||function(e=s){return n[e]instanceof r.StringToken}()?n[s++].value:function(){const e={simples:[]};for(a(),m()?e.simples.push({selector:{functions:[{name:"scope",args:[]}]},combinator:""}):e.simples.push({selector:v(),combinator:""});;){if(a(),m())e.simples[e.simples.length-1].combinator=n[s++].value,a();else if(g())break;e.simples.push({combinator:"",selector:v()})}return e}()}function v(){let e="";const o=[];for(;!g();)if(h()||f())e+=n[s++].toSource();else if(n[s]instanceof r.HashToken)e+=n[s++].toSource();else if(n[s]instanceof r.DelimToken&&"."===n[s].value){if(s++,!h())throw l();e+="."+n[s++].toSource()}else if(n[s]instanceof r.ColonToken)if(s++,h())if(t.has(n[s].value.toLowerCase())){const e=n[s++].value.toLowerCase();o.push({name:e,args:[]}),c.add(e)}else e+=":"+n[s++].toSource();else{if(!(n[s]instanceof r.FunctionToken))throw l();{const r=n[s++].value.toLowerCase();if(t.has(r)?(o.push({name:r,args:y()}),c.add(r)):e+=`:${r}(${w()})`,a(),!p())throw l();s++}}else{if(!(n[s]instanceof r.OpenSquareToken))throw l();for(e+="[",s++;!(n[s]instanceof r.CloseSquareToken||d());)e+=n[s++].toSource();if(!(n[s]instanceof r.CloseSquareToken))throw l();e+="]",s++}if(!e&&!o.length)throw l();return{css:e||void 0,functions:o}}function w(){let e="";for(;!p()&&!d();)e+=n[s++].toSource();return e}const E=y();if(!d())throw new o.InvalidSelectorError(`Error while parsing selector "${e}"`);if(E.some((e=>"object"!=typeof e||!("simples"in e))))throw new o.InvalidSelectorError(`Error while parsing selector "${e}"`);return{selector:E,names:Array.from(c)}},t.serializeSelector=function e(t){return t.map((t=>"string"==typeof t?`"${t}"`:"number"==typeof t?String(t):t.simples.map((({selector:t,combinator:n})=>{let o=t.css||"";return o+=t.functions.map((t=>`:${t.name}(${e(t.args)})`)).join(""),n&&(o+=" "+n),o})).join(" "))).join(", ")};var o=n(672),r=function(e,t){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var n=i(t);if(n&&n.has(e))return n.get(e);var o={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var c=r?Object.getOwnPropertyDescriptor(e,s):null;c&&(c.get||c.set)?Object.defineProperty(o,s,c):o[s]=e[s]}return o.default=e,n&&n.set(e,o),o}(n(503));function i(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,n=new WeakMap;return(i=function(e){return e?n:t})(e)}},503:(e,t)=>{var n,o;n=function(e){var t=function(e,t,n){return e>=t&&e<=n};function n(e){return t(e,48,57)}function o(e){return n(e)||t(e,65,70)||t(e,97,102)}function r(e){return function(e){return t(e,65,90)}(e)||function(e){return t(e,97,122)}(e)}function i(e){return r(e)||function(e){return e>=128}(e)||95==e}function s(e){return i(e)||n(e)||45==e}function c(e){return t(e,0,8)||11==e||t(e,14,31)||127==e}function l(e){return 10==e}function a(e){return l(e)||9==e||32==e}var h=function(e){this.message=e};function u(e){if(e<=65535)return String.fromCharCode(e);e-=Math.pow(2,16);var t=Math.floor(e/Math.pow(2,10))+55296,n=e%Math.pow(2,10)+56320;return String.fromCharCode(t)+String.fromCharCode(n)}function p(){throw"Abstract Base Class"}function f(){return this}function d(){return this}function m(){return this}function g(){return this}function y(){return this}function _(){return this}function v(){return this}function w(){return this}function E(){throw"Abstract Base Class"}function S(){return this.value="{",this.mirror="}",this}function T(){return this.value="}",this.mirror="{",this}function b(){return this.value="[",this.mirror="]",this}function M(){return this.value="]",this.mirror="[",this}function k(){return this.value="(",this.mirror=")",this}function x(){return this.value=")",this.mirror="(",this}function C(){return this}function P(){return this}function A(){return this}function O(){return this}function N(){return this}function I(){return this}function R(){return this}function j(e){return this.value=u(e),this}function D(){throw"Abstract Base Class"}function $(e){this.value=e}function L(e){this.value=e,this.mirror=")"}function U(e){this.value=e}function q(e){this.value=e,this.type="unrestricted"}function G(e){this.value=e}function H(e){this.value=e}function F(){this.value=null,this.type="integer",this.repr=""}function K(){this.value=null,this.repr=""}function B(){this.value=null,this.type="integer",this.repr="",this.unit=""}function W(e){for(var n="",o=(e=""+e).charCodeAt(0),r=0;r<e.length;r++){var i=e.charCodeAt(r);if(0==i)throw new h("Invalid character: the input contains U+0000.");t(i,1,31)||127==i||0==r&&t(i,48,57)||1==r&&t(i,48,57)&&45==o?n+="\\\\"+i.toString(16)+" ":i>=128||45==i||95==i||t(i,48,57)||t(i,65,90)||t(i,97,122)?n+=e[r]:n+="\\\\"+e[r]}return n}function J(e){e=""+e;for(var n="",o=0;o<e.length;o++){var r=e.charCodeAt(o);if(0==r)throw new h("Invalid character: the input contains U+0000.");t(r,1,31)||127==r?n+="\\\\"+r.toString(16)+" ":n+=34==r||92==r?"\\\\"+e[o]:e[o]}return n}(h.prototype=new Error).name="InvalidCharacterError",p.prototype.toJSON=function(){return{token:this.tokenType}},p.prototype.toString=function(){return this.tokenType},p.prototype.toSource=function(){return""+this},f.prototype=Object.create(p.prototype),f.prototype.tokenType="BADSTRING",d.prototype=Object.create(p.prototype),d.prototype.tokenType="BADURL",m.prototype=Object.create(p.prototype),m.prototype.tokenType="WHITESPACE",m.prototype.toString=function(){return"WS"},m.prototype.toSource=function(){return" "},g.prototype=Object.create(p.prototype),g.prototype.tokenType="CDO",g.prototype.toSource=function(){return"\\x3c!--"},y.prototype=Object.create(p.prototype),y.prototype.tokenType="CDC",y.prototype.toSource=function(){return"--\\x3e"},_.prototype=Object.create(p.prototype),_.prototype.tokenType=":",v.prototype=Object.create(p.prototype),v.prototype.tokenType=";",w.prototype=Object.create(p.prototype),w.prototype.tokenType=",",E.prototype=Object.create(p.prototype),S.prototype=Object.create(E.prototype),S.prototype.tokenType="{",T.prototype=Object.create(E.prototype),T.prototype.tokenType="}",b.prototype=Object.create(E.prototype),b.prototype.tokenType="[",M.prototype=Object.create(E.prototype),M.prototype.tokenType="]",k.prototype=Object.create(E.prototype),k.prototype.tokenType="(",x.prototype=Object.create(E.prototype),x.prototype.tokenType=")",C.prototype=Object.create(p.prototype),C.prototype.tokenType="~=",P.prototype=Object.create(p.prototype),P.prototype.tokenType="|=",A.prototype=Object.create(p.prototype),A.prototype.tokenType="^=",O.prototype=Object.create(p.prototype),O.prototype.tokenType="$=",N.prototype=Object.create(p.prototype),N.prototype.tokenType="*=",I.prototype=Object.create(p.prototype),I.prototype.tokenType="||",R.prototype=Object.create(p.prototype),R.prototype.tokenType="EOF",R.prototype.toSource=function(){return""},j.prototype=Object.create(p.prototype),j.prototype.tokenType="DELIM",j.prototype.toString=function(){return"DELIM("+this.value+")"},j.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},j.prototype.toSource=function(){return"\\\\"==this.value?"\\\\\\n":this.value},D.prototype=Object.create(p.prototype),D.prototype.ASCIIMatch=function(e){return this.value.toLowerCase()==e.toLowerCase()},D.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},$.prototype=Object.create(D.prototype),$.prototype.tokenType="IDENT",$.prototype.toString=function(){return"IDENT("+this.value+")"},$.prototype.toSource=function(){return W(this.value)},L.prototype=Object.create(D.prototype),L.prototype.tokenType="FUNCTION",L.prototype.toString=function(){return"FUNCTION("+this.value+")"},L.prototype.toSource=function(){return W(this.value)+"("},U.prototype=Object.create(D.prototype),U.prototype.tokenType="AT-KEYWORD",U.prototype.toString=function(){return"AT("+this.value+")"},U.prototype.toSource=function(){return"@"+W(this.value)},q.prototype=Object.create(D.prototype),q.prototype.tokenType="HASH",q.prototype.toString=function(){return"HASH("+this.value+")"},q.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e},q.prototype.toSource=function(){return"id"==this.type?"#"+W(this.value):"#"+function(e){for(var n="",o=((e=""+e).charCodeAt(0),0);o<e.length;o++){var r=e.charCodeAt(o);if(0==r)throw new h("Invalid character: the input contains U+0000.");r>=128||45==r||95==r||t(r,48,57)||t(r,65,90)||t(r,97,122)?n+=e[o]:n+="\\\\"+r.toString(16)+" "}return n}(this.value)},G.prototype=Object.create(D.prototype),G.prototype.tokenType="STRING",G.prototype.toString=function(){return\'"\'+J(this.value)+\'"\'},H.prototype=Object.create(D.prototype),H.prototype.tokenType="URL",H.prototype.toString=function(){return"URL("+this.value+")"},H.prototype.toSource=function(){return\'url("\'+J(this.value)+\'")\'},F.prototype=Object.create(p.prototype),F.prototype.tokenType="NUMBER",F.prototype.toString=function(){return"integer"==this.type?"INT("+this.value+")":"NUMBER("+this.value+")"},F.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e},F.prototype.toSource=function(){return this.repr},K.prototype=Object.create(p.prototype),K.prototype.tokenType="PERCENTAGE",K.prototype.toString=function(){return"PERCENTAGE("+this.value+")"},K.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.repr=this.repr,e},K.prototype.toSource=function(){return this.repr+"%"},B.prototype=Object.create(p.prototype),B.prototype.tokenType="DIMENSION",B.prototype.toString=function(){return"DIM("+this.value+","+this.unit+")"},B.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e.unit=this.unit,e},B.prototype.toSource=function(){var e=this.repr,n=W(this.unit);return"e"!=n[0].toLowerCase()||"-"!=n[1]&&!t(n.charCodeAt(1),48,57)||(n="\\\\65 "+n.slice(1,n.length)),e+n},e.tokenize=function(e){e=function(e){for(var n=[],o=0;o<e.length;o++){var r=e.charCodeAt(o);if(13==r&&10==e.charCodeAt(o+1)&&(r=10,o++),13!=r&&12!=r||(r=10),0==r&&(r=65533),t(r,55296,56319)&&t(e.charCodeAt(o+1),56320,57343)){var i=r-55296,s=e.charCodeAt(o+1)-56320;r=Math.pow(2,16)+i*Math.pow(2,10)+s,o++}n.push(r)}return n}(e);for(var r,h=-1,p=[],E=0,D=0,W=0,J={line:E,column:D},Q=function(t){return t>=e.length?-1:e[t]},z=function(e){if(void 0===e&&(e=1),e>3)throw"Spec Error: no more than three codepoints of lookahead.";return Q(h+e)},V=function(e){return void 0===e&&(e=1),l(r=Q(h+=e))?(E+=1,W=D,D=0):D+=e,!0},X=function(){return h-=1,l(r)?(E-=1,D=W):D-=1,J.line=E,J.column=D,!0},Y=function(e){return void 0===e&&(e=r),-1==e},Z=function(){return console.log("Parse error at index "+h+", processing codepoint 0x"+r.toString(16)+"."),!0},ee=function(){if(te(),V(),a(r)){for(;a(z());)V();return new m}if(34==r)return re();if(35==r){if(s(z())||ce(z(1),z(2))){var e=new q;return ae(z(1),z(2),z(3))&&(e.type="id"),e.value=pe(),e}return new j(r)}return 36==r?61==z()?(V(),new O):new j(r):39==r?re():40==r?new k:41==r?new x:42==r?61==z()?(V(),new N):new j(r):43==r?ue()?(X(),ne()):new j(r):44==r?new w:45==r?ue()?(X(),ne()):45==z(1)&&62==z(2)?(V(2),new y):he()?(X(),oe()):new j(r):46==r?ue()?(X(),ne()):new j(r):58==r?new _:59==r?new v:60==r?33==z(1)&&45==z(2)&&45==z(3)?(V(3),new g):new j(r):64==r?ae(z(1),z(2),z(3))?new U(pe()):new j(r):91==r?new b:92==r?le()?(X(),oe()):(Z(),new j(r)):93==r?new M:94==r?61==z()?(V(),new A):new j(r):123==r?new S:124==r?61==z()?(V(),new P):124==z()?(V(),new I):new j(r):125==r?new T:126==r?61==z()?(V(),new C):new j(r):n(r)?(X(),ne()):i(r)?(X(),oe()):Y()?new R:new j(r)},te=function(){for(;47==z(1)&&42==z(2);)for(V(2);;){if(V(),42==r&&47==z()){V();break}if(Y())return void Z()}},ne=function(){var e,t=fe();return ae(z(1),z(2),z(3))?((e=new B).value=t.value,e.repr=t.repr,e.type=t.type,e.unit=pe(),e):37==z()?(V(),(e=new K).value=t.value,e.repr=t.repr,e):((e=new F).value=t.value,e.repr=t.repr,e.type=t.type,e)},oe=function(){var e=pe();if("url"==e.toLowerCase()&&40==z()){for(V();a(z(1))&&a(z(2));)V();return 34==z()||39==z()?new L(e):!a(z())||34!=z(2)&&39!=z(2)?ie():new L(e)}return 40==z()?(V(),new L(e)):new $(e)},re=function(e){void 0===e&&(e=r);for(var t="";V();){if(r==e||Y())return new G(t);if(l(r))return Z(),X(),new f;92==r?Y(z())||(l(z())?V():t+=u(se())):t+=u(r)}},ie=function(){for(var e=new H("");a(z());)V();if(Y(z()))return e;for(;V();){if(41==r||Y())return e;if(a(r)){for(;a(z());)V();return 41==z()||Y(z())?(V(),e):(me(),new d)}if(34==r||39==r||40==r||c(r))return Z(),me(),new d;if(92==r){if(!le())return Z(),me(),new d;e.value+=u(se())}else e.value+=u(r)}},se=function(){if(V(),o(r)){for(var e=[r],t=0;t<5&&o(z());t++)V(),e.push(r);a(z())&&V();var n=parseInt(e.map((function(e){return String.fromCharCode(e)})).join(""),16);return n>1114111&&(n=65533),n}return Y()?65533:r},ce=function(e,t){return 92==e&&!l(t)},le=function(){return ce(r,z())},ae=function(e,t,n){return 45==e?i(t)||45==t||ce(t,n):!!i(e)||92==e&&ce(e,t)},he=function(){return ae(r,z(1),z(2))},ue=function(){return e=r,t=z(1),o=z(2),43==e||45==e?!!n(t)||!(46!=t||!n(o)):46==e?!!n(t):!!n(e);var e,t,o},pe=function(){for(var e="";V();)if(s(r))e+=u(r);else{if(!le())return X(),e;e+=u(se())}},fe=function(){var e=[],t="integer";for(43!=z()&&45!=z()||(V(),e+=u(r));n(z());)V(),e+=u(r);if(46==z(1)&&n(z(2)))for(V(),e+=u(r),V(),e+=u(r),t="number";n(z());)V(),e+=u(r);var o=z(1),i=z(2),s=z(3);if(69!=o&&101!=o||!n(i)){if((69==o||101==o)&&(43==i||45==i)&&n(s))for(V(),e+=u(r),V(),e+=u(r),V(),e+=u(r),t="number";n(z());)V(),e+=u(r)}else for(V(),e+=u(r),V(),e+=u(r),t="number";n(z());)V(),e+=u(r);return{type:t,value:de(e),repr:e}},de=function(e){return+e},me=function(){for(;V();){if(41==r||Y())return;le()&&se()}},ge=0;!Y(z());)if(p.push(ee()),++ge>2*e.length)return"I\'m infinite-looping!";return p},e.IdentToken=$,e.FunctionToken=L,e.AtKeywordToken=U,e.HashToken=q,e.StringToken=G,e.BadStringToken=f,e.URLToken=H,e.BadURLToken=d,e.DelimToken=j,e.NumberToken=F,e.PercentageToken=K,e.DimensionToken=B,e.IncludeMatchToken=C,e.DashMatchToken=P,e.PrefixMatchToken=A,e.SuffixMatchToken=O,e.SubstringMatchToken=N,e.ColumnToken=I,e.WhitespaceToken=m,e.CDOToken=g,e.CDCToken=y,e.ColonToken=_,e.SemicolonToken=v,e.CommaToken=w,e.OpenParenToken=k,e.CloseParenToken=x,e.OpenSquareToken=b,e.CloseSquareToken=M,e.OpenCurlyToken=S,e.CloseCurlyToken=T,e.EOFToken=R,e.CSSParserToken=p,e.GroupingToken=E},void 0===(o=n.apply(t,[t]))||(e.exports=o)},672:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isInvalidSelectorError=function(e){return e instanceof n},t.InvalidSelectorError=void 0;class n extends Error{}t.InvalidSelectorError=n},461:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSelector=s,t.splitSelectorByFrame=function(e){const t=s(e),n=[];let r={parts:[]},i=0;for(let e=0;e<t.parts.length;++e){const s=t.parts[e];if("control"!==s.name||"enter-frame"!==s.body)t.capture===e&&(r.capture=e-i),r.parts.push(s);else{if(!r.parts.length)throw new o.InvalidSelectorError("Selector cannot start with entering frame, select the iframe first");n.push(r),r={parts:[]},i=e+1}}if(!r.parts.length)throw new o.InvalidSelectorError(`Selector cannot end with entering frame, while parsing selector ${e}`);if(n.push(r),"number"==typeof t.capture&&"number"!=typeof n[n.length-1].capture)throw new o.InvalidSelectorError("Can not capture the selector before diving into the frame. Only use * after the last frame has been selected");return n},t.stringifySelector=function(e){return"string"==typeof e?e:e.parts.map(((t,n)=>{const o="css"===t.name?"":t.name+"=";return`${n===e.capture?"*":""}${o}${t.source}`})).join(" >> ")},t.customCSSNames=void 0;var o=n(672),r=n(317);const i=new Set(["not","is","where","has","scope","light","visible","text","text-matches","text-is","has-text","above","below","right-of","left-of","near","nth-match"]);function s(e){const t=function(e){let t,n=0,r=0;const i={parts:[]},s=()=>{const t=e.substring(r,n).trim(),s=t.indexOf("=");let c,l;-1!==s&&t.substring(0,s).trim().match(/^[a-zA-Z_0-9-+:*]+$/)?(c=t.substring(0,s).trim(),l=t.substring(s+1)):t.length>1&&\'"\'===t[0]&&\'"\'===t[t.length-1]||t.length>1&&"\'"===t[0]&&"\'"===t[t.length-1]?(c="text",l=t):/^\\(*\\/\\//.test(t)||t.startsWith("..")?(c="xpath",l=t):(c="css",l=t);let a=!1;if("*"===c[0]&&(a=!0,c=c.substring(1)),i.parts.push({name:c,body:l}),a){if(void 0!==i.capture)throw new o.InvalidSelectorError("Only one of the selectors can capture using * modifier");i.capture=i.parts.length-1}};if(!e.includes(">>"))return n=e.length,s(),i;for(;n<e.length;){const o=e[n];"\\\\"===o&&n+1<e.length?n+=2:o===t?(t=void 0,n++):t||\'"\'!==o&&"\'"!==o&&"`"!==o?t||">"!==o||">"!==e[n+1]?n++:(s(),n+=2,r=n):(t=o,n++)}return s(),i}(e),n=t.parts.map((e=>"css"===e.name||"css:light"===e.name?("css:light"===e.name&&(e.body=":light("+e.body+")"),{name:"css",body:(0,r.parseCSS)(e.body,i).selector,source:e.body}):{...e,source:e.body}));return{capture:t.capture,parts:n}}t.customCSSNames=i},141:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Highlight=void 0,t.Highlight=class{constructor(e){this._outerGlassPaneElement=void 0,this._glassPaneShadow=void 0,this._innerGlassPaneElement=void 0,this._highlightElements=[],this._tooltipElement=void 0,this._actionPointElement=void 0,this._isUnderTest=void 0,this._isUnderTest=e,this._outerGlassPaneElement=document.createElement("x-pw-glass"),this._outerGlassPaneElement.style.position="fixed",this._outerGlassPaneElement.style.top="0",this._outerGlassPaneElement.style.right="0",this._outerGlassPaneElement.style.bottom="0",this._outerGlassPaneElement.style.left="0",this._outerGlassPaneElement.style.zIndex="2147483647",this._outerGlassPaneElement.style.pointerEvents="none",this._outerGlassPaneElement.style.display="flex",this._tooltipElement=document.createElement("x-pw-tooltip"),this._actionPointElement=document.createElement("x-pw-action-point"),this._actionPointElement.setAttribute("hidden","true"),this._innerGlassPaneElement=document.createElement("x-pw-glass-inner"),this._innerGlassPaneElement.style.flex="auto",this._innerGlassPaneElement.appendChild(this._tooltipElement),this._glassPaneShadow=this._outerGlassPaneElement.attachShadow({mode:this._isUnderTest?"open":"closed"}),this._glassPaneShadow.appendChild(this._innerGlassPaneElement),this._glassPaneShadow.appendChild(this._actionPointElement);const t=document.createElement("style");t.textContent="\\n        x-pw-tooltip {\\n          align-items: center;\\n          backdrop-filter: blur(5px);\\n          background-color: rgba(0, 0, 0, 0.7);\\n          border-radius: 2px;\\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\\n          color: rgb(204, 204, 204);\\n          display: none;\\n          font-family: \'Dank Mono\', \'Operator Mono\', Inconsolata, \'Fira Mono\',\\n                      \'SF Mono\', Monaco, \'Droid Sans Mono\', \'Source Code Pro\', monospace;\\n          font-size: 12.8px;\\n          font-weight: normal;\\n          left: 0;\\n          line-height: 1.5;\\n          max-width: 600px;\\n          padding: 3.2px 5.12px 3.2px;\\n          position: absolute;\\n          top: 0;\\n        }\\n        x-pw-action-point {\\n          position: absolute;\\n          width: 20px;\\n          height: 20px;\\n          background: red;\\n          border-radius: 10px;\\n          pointer-events: none;\\n          margin: -10px 0 0 -10px;\\n          z-index: 2;\\n        }\\n        *[hidden] {\\n          display: none !important;\\n        }\\n    ",this._glassPaneShadow.appendChild(t)}install(){document.documentElement.appendChild(this._outerGlassPaneElement)}uninstall(){this._outerGlassPaneElement.remove()}isInstalled(){return this._outerGlassPaneElement.parentElement===document.documentElement&&!this._outerGlassPaneElement.nextElementSibling}showActionPoint(e,t){this._actionPointElement.style.top=t+"px",this._actionPointElement.style.left=e+"px",this._actionPointElement.hidden=!1}hideActionPoint(){this._actionPointElement.hidden=!0}updateHighlight(e,t,n){this._tooltipElement.textContent=t,this._tooltipElement.style.top="0",this._tooltipElement.style.left="0",this._tooltipElement.style.display="flex";const o=e.map((e=>e.getBoundingClientRect())),r=this._tooltipElement.offsetWidth,i=this._tooltipElement.offsetHeight,s=this._innerGlassPaneElement.offsetWidth,c=this._innerGlassPaneElement.offsetHeight;if(o.length){const e=o[0];let t=e.left;t+r>s-5&&(t=s-r-5);let n=e.bottom+5;n+i>c-5&&(n=e.top>i+5?e.top-i-5:c-5-i),this._tooltipElement.style.top=n+"px",this._tooltipElement.style.left=t+"px"}else this._tooltipElement.style.display="none";const l=this._highlightElements;this._highlightElements=[];for(const e of o){const t=l.length?l.shift():this._createHighlightElement(),o=n?"#dc6f6f7f":"#6fa8dc7f";t.style.backgroundColor=this._highlightElements.length?"#f6b26b7f":o,t.style.left=e.x+"px",t.style.top=e.y+"px",t.style.width=e.width+"px",t.style.height=e.height+"px",t.style.display="block",this._highlightElements.push(t)}for(const e of l)e.style.display="none",this._highlightElements.push(e)}_createHighlightElement(){const e=document.createElement("x-pw-highlight");return e.style.position="absolute",e.style.top="0",e.style.left="0",e.style.width="0",e.style.height="0",e.style.boxSizing="border-box",this._glassPaneShadow.appendChild(e),e}}},848:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createLaxTextMatcher=d,t.createStrictTextMatcher=m,t.createRegexTextMatcher=g,t.elementText=_,t.elementMatchesText=v,t.isInsideScope=function(e,t){for(;t;){if(e.contains(t))return!0;for(;t.parentElement;)t=t.parentElement;t=x(t)}return!1},t.parentElementOrShadowHost=x,t.isVisible=A,t.SelectorEvaluatorImpl=void 0;var o=n(461);t.SelectorEvaluatorImpl=class{constructor(e){this._engines=new Map,this._cacheQueryCSS=new Map,this._cacheMatches=new Map,this._cacheQuery=new Map,this._cacheMatchesSimple=new Map,this._cacheMatchesParents=new Map,this._cacheCallMatches=new Map,this._cacheCallQuery=new Map,this._cacheQuerySimple=new Map,this._cacheText=new Map,this._scoreMap=void 0,this._retainCacheCounter=0;for(const[t,n]of e)this._engines.set(t,n);this._engines.set("not",c),this._engines.set("is",r),this._engines.set("where",r),this._engines.set("has",i),this._engines.set("scope",s),this._engines.set("light",l),this._engines.set("visible",a),this._engines.set("text",h),this._engines.set("text-is",u),this._engines.set("text-matches",p),this._engines.set("has-text",f),this._engines.set("right-of",M("right-of",w)),this._engines.set("left-of",M("left-of",E)),this._engines.set("above",M("above",S)),this._engines.set("below",M("below",T)),this._engines.set("near",M("near",b)),this._engines.set("nth-match",k);const t=[...this._engines.keys()];t.sort();const n=[...o.customCSSNames];if(n.sort(),t.join("|")!==n.join("|"))throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${t.join("|")} vs ${n.join("|")}`)}begin(){++this._retainCacheCounter}end(){--this._retainCacheCounter,this._retainCacheCounter||(this._cacheQueryCSS.clear(),this._cacheMatches.clear(),this._cacheQuery.clear(),this._cacheMatchesSimple.clear(),this._cacheMatchesParents.clear(),this._cacheCallMatches.clear(),this._cacheCallQuery.clear(),this._cacheQuerySimple.clear(),this._cacheText.clear())}_cached(e,t,n,o){e.has(t)||e.set(t,[]);const r=e.get(t),i=r.find((e=>n.every(((t,n)=>e.rest[n]===t))));if(i)return i.result;const s=o();return r.push({rest:n,result:s}),s}_checkSelector(e){if("object"!=typeof e||!e||!(Array.isArray(e)||"simples"in e&&e.simples.length))throw new Error(`Malformed selector "${e}"`);return e}matches(e,t,n){const o=this._checkSelector(t);this.begin();try{return this._cached(this._cacheMatches,e,[o,n.scope,n.pierceShadow],(()=>Array.isArray(o)?this._matchesEngine(r,e,o,n):!!this._matchesSimple(e,o.simples[o.simples.length-1].selector,n)&&this._matchesParents(e,o,o.simples.length-2,n)))}finally{this.end()}}query(e,t){const n=this._checkSelector(t);this.begin();try{return this._cached(this._cacheQuery,n,[e.scope,e.pierceShadow],(()=>{if(Array.isArray(n))return this._queryEngine(r,e,n);const t=this._scoreMap;this._scoreMap=new Map;let o=this._querySimple(e,n.simples[n.simples.length-1].selector);return o=o.filter((t=>this._matchesParents(t,n,n.simples.length-2,e))),this._scoreMap.size&&o.sort(((e,t)=>{const n=this._scoreMap.get(e),o=this._scoreMap.get(t);return n===o?0:void 0===n?1:void 0===o?-1:n-o})),this._scoreMap=t,o}))}finally{this.end()}}_markScore(e,t){this._scoreMap&&this._scoreMap.set(e,t)}_matchesSimple(e,t,n){return this._cached(this._cacheMatchesSimple,e,[t,n.scope,n.pierceShadow],(()=>{if(!t.functions.some((e=>"scope"===e.name||"is"===e.name))&&e===n.scope)return!1;if(t.css&&!this._matchesCSS(e,t.css))return!1;for(const o of t.functions)if(!this._matchesEngine(this._getEngine(o.name),e,o.args,n))return!1;return!0}))}_querySimple(e,t){return t.functions.length?this._cached(this._cacheQuerySimple,t,[e.scope,e.pierceShadow],(()=>{let n=t.css;const o=t.functions;let r;"*"===n&&o.length&&(n=void 0);let i=-1;void 0!==n?(r=this._queryCSS(e,n),o.some((e=>"scope"===e.name))&&1===e.scope.nodeType&&r.unshift(e.scope)):(i=o.findIndex((e=>void 0!==this._getEngine(e.name).query)),-1===i&&(i=0),r=this._queryEngine(this._getEngine(o[i].name),e,o[i].args));for(let t=0;t<o.length;t++){if(t===i)continue;const n=this._getEngine(o[t].name);void 0!==n.matches&&(r=r.filter((r=>this._matchesEngine(n,r,o[t].args,e))))}for(let t=0;t<o.length;t++){if(t===i)continue;const n=this._getEngine(o[t].name);void 0===n.matches&&(r=r.filter((r=>this._matchesEngine(n,r,o[t].args,e))))}return r})):this._queryCSS(e,t.css||"*")}_matchesParents(e,t,n,o){return n<0||this._cached(this._cacheMatchesParents,e,[t,n,o.scope,o.pierceShadow],(()=>{const{selector:r,combinator:i}=t.simples[n];if(">"===i){const i=C(e,o);return!(!i||!this._matchesSimple(i,r,o))&&this._matchesParents(i,t,n-1,o)}if("+"===i){const i=P(e,o);return!(!i||!this._matchesSimple(i,r,o))&&this._matchesParents(i,t,n-1,o)}if(""===i){let i=C(e,o);for(;i;){if(this._matchesSimple(i,r,o)){if(this._matchesParents(i,t,n-1,o))return!0;if(""===t.simples[n-1].combinator)break}i=C(i,o)}return!1}if("~"===i){let i=P(e,o);for(;i;){if(this._matchesSimple(i,r,o)){if(this._matchesParents(i,t,n-1,o))return!0;if("~"===t.simples[n-1].combinator)break}i=P(i,o)}return!1}if(">="===i){let i=e;for(;i;){if(this._matchesSimple(i,r,o)){if(this._matchesParents(i,t,n-1,o))return!0;if(""===t.simples[n-1].combinator)break}i=C(i,o)}return!1}throw new Error(`Unsupported combinator "${i}"`)}))}_matchesEngine(e,t,n,o){if(e.matches)return this._callMatches(e,t,n,o);if(e.query)return this._callQuery(e,n,o).includes(t);throw new Error(\'Selector engine should implement "matches" or "query"\')}_queryEngine(e,t,n){if(e.query)return this._callQuery(e,n,t);if(e.matches)return this._queryCSS(t,"*").filter((o=>this._callMatches(e,o,n,t)));throw new Error(\'Selector engine should implement "matches" or "query"\')}_callMatches(e,t,n,o){return this._cached(this._cacheCallMatches,t,[e,o.scope,o.pierceShadow,...n],(()=>e.matches(t,n,o,this)))}_callQuery(e,t,n){return this._cached(this._cacheCallQuery,e,[n.scope,n.pierceShadow,...t],(()=>e.query(n,t,this)))}_matchesCSS(e,t){return e.matches(t)}_queryCSS(e,t){return this._cached(this._cacheQueryCSS,t,[e.scope,e.pierceShadow],(()=>{let n=[];return function o(r){if(n=n.concat([...r.querySelectorAll(t)]),e.pierceShadow){r.shadowRoot&&o(r.shadowRoot);for(const e of r.querySelectorAll("*"))e.shadowRoot&&o(e.shadowRoot)}}(e.scope),n}))}_getEngine(e){const t=this._engines.get(e);if(!t)throw new Error(`Unknown selector engine "${e}"`);return t}};const r={matches(e,t,n,o){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');return t.some((t=>o.matches(e,t,n)))},query(e,t,n){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');let o=[];for(const r of t)o=o.concat(n.query(e,r));return 1===t.length?o:function(e){const t=new Map,n=[],o=[];function r(e){let o=t.get(e);if(o)return o;const i=x(e);return i?r(i).children.push(e):n.push(e),o={children:[],taken:!1},t.set(e,o),o}return e.forEach((e=>r(e).taken=!0)),n.forEach((function e(n){const r=t.get(n);if(r.taken&&o.push(n),r.children.length>1){const e=new Set(r.children);r.children=[];let t=n.firstElementChild;for(;t&&r.children.length<e.size;)e.has(t)&&r.children.push(t),t=t.nextElementSibling;for(t=n.shadowRoot?n.shadowRoot.firstElementChild:null;t&&r.children.length<e.size;)e.has(t)&&r.children.push(t),t=t.nextElementSibling}r.children.forEach(e)})),o}(o)}},i={matches(e,t,n,o){if(0===t.length)throw new Error(\'"has" engine expects non-empty selector list\');return o.query({...n,scope:e},t).length>0}},s={matches(e,t,n,o){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');return 9===n.scope.nodeType?e===n.scope.documentElement:e===n.scope},query(e,t,n){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');if(9===e.scope.nodeType){const t=e.scope.documentElement;return t?[t]:[]}return 1===e.scope.nodeType?[e.scope]:[]}},c={matches(e,t,n,o){if(0===t.length)throw new Error(\'"not" engine expects non-empty selector list\');return!o.matches(e,t,n)}},l={query:(e,t,n)=>n.query({...e,pierceShadow:!1},t),matches:(e,t,n,o)=>o.matches(e,t,{...n,pierceShadow:!1})},a={matches(e,t,n,o){if(t.length)throw new Error(\'"visible" engine expects no arguments\');return A(e)}},h={matches(e,t,n,o){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text" engine expects a single string\');return"self"===v(o,e,d(t[0]))}},u={matches(e,t,n,o){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text-is" engine expects a single string\');return"none"!==v(o,e,m(t[0]))}},p={matches(e,t,n,o){if(0===t.length||"string"!=typeof t[0]||t.length>2||2===t.length&&"string"!=typeof t[1])throw new Error(\'"text-matches" engine expects a regexp body and optional regexp flags\');return"self"===v(o,e,g(t[0],2===t.length?t[1]:void 0))}},f={matches(e,t,n,o){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"has-text" engine expects a single string\');return!y(e)&&d(t[0])(_(o,e))}};function d(e){return e=e.trim().replace(/\\s+/g," ").toLowerCase(),t=>t.full.trim().replace(/\\s+/g," ").toLowerCase().includes(e)}function m(e){return e=e.trim().replace(/\\s+/g," "),t=>!e&&!t.immediate.length||t.immediate.some((t=>t.trim().replace(/\\s+/g," ")===e))}function g(e,t){const n=new RegExp(e,t);return e=>n.test(e.full)}function y(e){return"SCRIPT"===e.nodeName||"STYLE"===e.nodeName||document.head&&document.head.contains(e)}function _(e,t){let n=e._cacheText.get(t);if(void 0===n){if(n={full:"",immediate:[]},!y(t)){let o="";if(t instanceof HTMLInputElement&&("submit"===t.type||"button"===t.type))n={full:t.value,immediate:[t.value]};else{for(let r=t.firstChild;r;r=r.nextSibling)r.nodeType===Node.TEXT_NODE?(n.full+=r.nodeValue||"",o+=r.nodeValue||""):(o&&n.immediate.push(o),o="",r.nodeType===Node.ELEMENT_NODE&&(n.full+=_(e,r).full));o&&n.immediate.push(o),t.shadowRoot&&(n.full+=_(e,t.shadowRoot).full)}}e._cacheText.set(t,n)}return n}function v(e,t,n){if(y(t))return"none";if(!n(_(e,t)))return"none";for(let o=t.firstChild;o;o=o.nextSibling)if(o.nodeType===Node.ELEMENT_NODE&&n(_(e,o)))return"selfAndChildren";return t.shadowRoot&&n(_(e,t.shadowRoot))?"selfAndChildren":"self"}function w(e,t,n){const o=e.left-t.right;if(!(o<0||void 0!==n&&o>n))return o+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function E(e,t,n){const o=t.left-e.right;if(!(o<0||void 0!==n&&o>n))return o+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function S(e,t,n){const o=t.top-e.bottom;if(!(o<0||void 0!==n&&o>n))return o+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function T(e,t,n){const o=e.top-t.bottom;if(!(o<0||void 0!==n&&o>n))return o+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function b(e,t,n){const o=void 0===n?50:n;let r=0;return e.left-t.right>=0&&(r+=e.left-t.right),t.left-e.right>=0&&(r+=t.left-e.right),t.top-e.bottom>=0&&(r+=t.top-e.bottom),e.top-t.bottom>=0&&(r+=e.top-t.bottom),r>o?void 0:r}function M(e,t){return{matches(n,o,r,i){const s=o.length&&"number"==typeof o[o.length-1]?o[o.length-1]:void 0,c=void 0===s?o:o.slice(0,o.length-1);if(o.length<1+(void 0===s?0:1))throw new Error(`"${e}" engine expects a selector list and optional maximum distance in pixels`);const l=n.getBoundingClientRect();let a;for(const e of i.query(r,c)){if(e===n)continue;const o=t(l,e.getBoundingClientRect(),s);void 0!==o&&(void 0===a||o<a)&&(a=o)}return void 0!==a&&(i._markScore(n,a),!0)}}}const k={query(e,t,n){let o=t[t.length-1];if(t.length<2)throw new Error(\'"nth-match" engine expects non-empty selector list and an index argument\');if("number"!=typeof o||o<1)throw new Error(\'"nth-match" engine expects a one-based index as the last argument\');const i=r.query(e,t.slice(0,t.length-1),n);return o--,o<i.length?[i[o]]:[]}};function x(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:void 0}function C(e,t){if(e!==t.scope)return t.pierceShadow?x(e):e.parentElement||void 0}function P(e,t){if(e!==t.scope)return e.previousElementSibling||void 0}function A(e){if(!e.ownerDocument||!e.ownerDocument.defaultView)return!0;const t=e.ownerDocument.defaultView.getComputedStyle(e);if(!t||"hidden"===t.visibility)return!1;if("contents"===t.display){for(let t=e.firstChild;t;t=t.nextSibling){if(1===t.nodeType&&A(t))return!0;if(3===t.nodeType&&O(t))return!0}return!1}const n=e.getBoundingClientRect();return n.width>0&&n.height>0}function O(e){const t=document.createRange();t.selectNode(e);const n=t.getBoundingClientRect();return n.width>0&&n.height>0}},854:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.querySelector=function(e,t,n){try{const o=e.parseSelector(t);return{selector:t,elements:e.querySelectorAll(o,n)}}catch(e){return{selector:t,elements:[]}}},t.generateSelector=function(e,t){e._evaluator.begin();try{const n=function(e,t){if(t.ownerDocument.documentElement===t)return[{engine:"css",selector:"html",score:1}];const n=(a,u)=>{const m=u?r:i;let g=m.get(a);return void 0===g&&(g=((r,i)=>{const a=r===t;let u=i?function(e,t,n){if("SELECT"===t.nodeName)return[];const r=(0,o.elementText)(e._evaluator,t).full.trim().replace(/\\s+/g," ").substring(0,80);if(!r)return[];const i=[];let s=r;if((r.includes(\'"\')||r.includes(">>")||"/"===r[0])&&(s=`/.*${function(e){return e.replace(/[.*+?^>${}()|[\\]\\\\]/g,"\\\\$&")}(r)}.*/`),i.push({engine:"text",selector:s,score:10}),n&&s===r){let e=t.nodeName.toLowerCase();t.hasAttribute("role")&&(e+=`[role=${h(t.getAttribute("role"))}]`),i.push({engine:"css",selector:`${e}:has-text("${r}")`,score:30})}return i}(e,r,r===t).map((e=>[e])):[];r!==t&&(u=s(u));const m=function(e,t){const n=[];for(const e of["data-testid","data-test-id","data-test"])t.hasAttribute(e)&&n.push({engine:"css",selector:`[${e}=${h(t.getAttribute(e))}]`,score:1});if("INPUT"===t.nodeName){const e=t;e.placeholder&&n.push({engine:"css",selector:`[placeholder=${h(e.placeholder)}]`,score:10})}t.hasAttribute("aria-label")&&n.push({engine:"css",selector:`[aria-label=${h(t.getAttribute("aria-label"))}]`,score:10}),t.getAttribute("alt")&&["APPLET","AREA","IMG","INPUT"].includes(t.nodeName)&&n.push({engine:"css",selector:`${d(t.nodeName.toLowerCase())}[alt=${h(t.getAttribute("alt"))}]`,score:10}),t.hasAttribute("role")&&n.push({engine:"css",selector:`${d(t.nodeName.toLowerCase())}[role=${h(t.getAttribute("role"))}]`,score:50}),t.getAttribute("name")&&["BUTTON","FORM","FIELDSET","IFRAME","INPUT","KEYGEN","OBJECT","OUTPUT","SELECT","TEXTAREA","MAP","META","PARAM"].includes(t.nodeName)&&n.push({engine:"css",selector:`${d(t.nodeName.toLowerCase())}[name=${h(t.getAttribute("name"))}]`,score:50}),["INPUT","TEXTAREA"].includes(t.nodeName)&&"hidden"!==t.getAttribute("type")&&t.getAttribute("type")&&n.push({engine:"css",selector:`${d(t.nodeName.toLowerCase())}[type=${h(t.getAttribute("type"))}]`,score:50}),["INPUT","TEXTAREA","SELECT"].includes(t.nodeName)&&n.push({engine:"css",selector:d(t.nodeName.toLowerCase()),score:50});const o=t.getAttribute("id");return o&&!function(e){let t,n=0;for(let o=0;o<e.length;++o){const r=e[o];let i;"-"!==r&&"_"!==r&&(i=r>="a"&&r<="z"?"lower":r>="A"&&r<="Z"?"upper":r>="0"&&r<="9"?"digit":"other","lower"!==i||"upper"!==t?(t&&t!==i&&++n,t=i):t=i)}return n>=e.length/4}(o)&&n.push({engine:"css",selector:l(o),score:100}),n.push({engine:"css",selector:d(t.nodeName.toLowerCase()),score:200}),n}(0,r).map((e=>[e]));let g=f(e,t.ownerDocument,r,[...u,...m],a);u=s(u);const y=t=>{const o=i&&!t.length,s=[...t,...m].filter((e=>!g||p(e)<p(g)));let l=s[0];if(l)for(let t=c(r);t;t=c(t)){const i=n(t,o);if(!i)continue;if(g&&p([...i,...l])>=p(g))continue;if(l=f(e,t,r,s,a),!l)return;const c=[...i,...l];(!g||p(c)<p(g))&&(g=c)}};return y(u),r===t&&u.length&&y([]),g})(a,u),m.set(a,g)),g};return n(t,!0)}(e,t=t.closest("button,select,input,[role=button],[role=checkbox],[role=radio]")||t),m=u(n||[a(e,t)]),g=e.parseSelector(m);return{selector:m,elements:e.querySelectorAll(g,t.ownerDocument)}}finally{r.clear(),i.clear(),e._evaluator.end()}};var o=n(848);const r=new Map,i=new Map;function s(e){return e.filter((e=>"/"!==e[0].selector[0]))}function c(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:null}function l(e){return/^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(e)?"#"+e:`[id="${d(e)}"]`}function a(e,t){const n=1e7,o=t.ownerDocument,r=[];function i(n){const o=r.slice();n&&o.unshift(n);const i=o.join(" "),s=e.parseSelector(i);return e.querySelector(s,t.ownerDocument,!1)===t?i:void 0}for(let e=t;e&&e!==o;e=c(e)){const t=e.nodeName.toLowerCase();let o="";if(e.id){const t=l(e.id),r=i(t);if(r)return{engine:"css",selector:r,score:n};o=t}const s=e.parentNode,c=[...e.classList];for(let e=0;e<c.length;++e){const t="."+c.slice(0,e+1).join("."),r=i(t);if(r)return{engine:"css",selector:r,score:n};!o&&s&&1===s.querySelectorAll(t).length&&(o=t)}if(s){const r=[...s.children],c=0===r.filter((e=>e.nodeName.toLowerCase()===t)).indexOf(e)?d(t):`${d(t)}:nth-child(${1+r.indexOf(e)})`,l=i(c);if(l)return{engine:"css",selector:l,score:n};o||(o=c)}else o||(o=t);r.unshift(o)}return{engine:"css",selector:i(),score:n}}function h(e){return`"${d(e)}"`}function u(e){const t=[];let n="";for(const{engine:o,selector:r}of e)t.length&&("css"!==n||"css"!==o||r.startsWith(":nth-match("))&&t.push(">>"),n=o,"css"===o?t.push(r):t.push(`${o}=${r}`);return t.join(" ")}function p(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n].score*(e.length-n);return t}function f(e,t,n,o,r){const i=o.map((e=>({tokens:e,score:p(e)})));i.sort(((e,t)=>e.score-t.score));let s=null;for(const{tokens:o}of i){const i=e.parseSelector(u(o)),c=e.querySelectorAll(i,t),l=c.indexOf(n);if(0===l)return o;if(!r||s||-1===l||c.length>5)continue;const a=o.map((e=>"text"!==e.engine?e:e.selector.startsWith("/")&&e.selector.endsWith("/")?{engine:"css",selector:`:text-matches("${e.selector.substring(1,e.selector.length-1)}")`,score:e.score}:{engine:"css",selector:`:text("${e.selector}")`,score:e.score}));s=[{engine:"css",selector:`:nth-match(${u(a)}, ${l+1})`,score:p(a)+1e3}]}return s}function d(e){let t="";for(let n=0;n<e.length;n++)t+=m(e,n);return t}function m(e,t){const n=e.charCodeAt(t);return 0===n?"\uFFFD":n>=1&&n<=31||n>=48&&n<=57&&(0===t||1===t&&45===e.charCodeAt(0))?"\\\\"+n.toString(16)+" ":0===t&&45===n&&1===e.length?"\\\\"+e.charAt(t):n>=128||45===n||95===n||n>=48&&n<=57||n>=65&&n<=90||n>=97&&n<=122?e.charAt(t):"\\\\"+e.charAt(t)}}},t={};function n(o){var r=t[o];if(void 0!==r)return r.exports;var i=t[o]={exports:{}};return e[o](i,i.exports,n),i.exports}var o={};(()=>{var e=o;e.default=void 0;var t=n(854),r=n(141);function i(e){return(e.altKey?1:0)|(e.ctrlKey?2:0)|(e.metaKey?4:0)|(e.shiftKey?8:0)}function s(e){switch(e.which){case 1:return"left";case 2:return"middle";case 3:return"right"}return"left"}function c(e){if("CANVAS"===e.target.nodeName)return{x:e.offsetX,y:e.offsetY}}function l(e){e.preventDefault(),e.stopPropagation(),e.stopImmediatePropagation()}function a(e){if(!e||"INPUT"!==e.nodeName)return null;const t=e;return"checkbox"===t.type?t:null}function h(e,t,n,o){return e.addEventListener(t,n,o),()=>{e.removeEventListener(t,n,o)}}var u=class{constructor(e,t){this._injectedScript=void 0,this._performingAction=!1,this._listeners=[],this._hoveredModel=null,this._hoveredElement=null,this._activeModel=null,this._expectProgrammaticKeyUp=!1,this._pollRecorderModeTimer=void 0,this._mode="none",this._actionPoint=void 0,this._actionSelector=void 0,this._params=void 0,this._highlight=void 0,this._params=t,this._injectedScript=e,this._highlight=new r.Highlight(t.isUnderTest),this._refreshListenersIfNeeded(),e.onGlobalListenersRemoved.add((()=>this._refreshListenersIfNeeded())),globalThis._playwrightRefreshOverlay=()=>{this._pollRecorderMode().catch((e=>console.log(e)))},globalThis._playwrightRefreshOverlay(),t.isUnderTest&&console.error("Recorder script ready for test")}_refreshListenersIfNeeded(){this._highlight.isInstalled()||(function(e){for(const t of e)t();e.splice(0,e.length)}(this._listeners),this._listeners=[h(document,"click",(e=>this._onClick(e)),!0),h(document,"auxclick",(e=>this._onClick(e)),!0),h(document,"input",(e=>this._onInput(e)),!0),h(document,"keydown",(e=>this._onKeyDown(e)),!0),h(document,"keyup",(e=>this._onKeyUp(e)),!0),h(document,"mousedown",(e=>this._onMouseDown(e)),!0),h(document,"mouseup",(e=>this._onMouseUp(e)),!0),h(document,"mousemove",(e=>this._onMouseMove(e)),!0),h(document,"mouseleave",(e=>this._onMouseLeave(e)),!0),h(document,"focus",(()=>this._onFocus()),!0),h(document,"scroll",(()=>{this._hoveredModel=null,this._highlight.hideActionPoint(),this._updateHighlight()}),!0)],this._highlight.install())}async _pollRecorderMode(){var e;this._pollRecorderModeTimer&&clearTimeout(this._pollRecorderModeTimer);const n=await globalThis._playwrightRecorderState().catch((e=>null));if(!n)return void(this._pollRecorderModeTimer=setTimeout((()=>this._pollRecorderMode()),1e3));const{mode:o,actionPoint:r,actionSelector:i}=n;o!==this._mode&&(this._mode=o,this._clearHighlight()),r&&this._actionPoint&&r.x===this._actionPoint.x&&r.y===this._actionPoint.y||(r||this._actionPoint)&&(r?this._highlight.showActionPoint(r.x,r.y):this._highlight.hideActionPoint(),this._actionPoint=r),!this._actionSelector||null!==(e=this._hoveredModel)&&void 0!==e&&e.elements.length||(this._actionSelector=void 0),i!==this._actionSelector&&(this._hoveredModel=i?(0,t.querySelector)(this._injectedScript,i,document):null,this._updateHighlight(),this._actionSelector=i),this._pollRecorderModeTimer=setTimeout((()=>this._pollRecorderMode()),1e3)}_clearHighlight(){this._hoveredModel=null,this._activeModel=null,this._updateHighlight()}_actionInProgress(e){return!!this._performingAction||(l(e),!1)}_consumedDueToNoModel(e,t){return!t&&(l(e),!0)}_consumedDueWrongTarget(e){return!(this._activeModel&&this._activeModel.elements[0]===this._deepEventTarget(e)||(l(e),0))}_onClick(e){if("inspecting"===this._mode&&globalThis._playwrightRecorderSetSelector(this._hoveredModel?this._hoveredModel.selector:""),this._shouldIgnoreMouseEvent(e))return;if(this._actionInProgress(e))return;if(this._consumedDueToNoModel(e,this._hoveredModel))return;const t=a(this._deepEventTarget(e));t?this._performAction({name:t.checked?"check":"uncheck",selector:this._hoveredModel.selector,signals:[]}):this._performAction({name:"click",selector:this._hoveredModel.selector,position:c(e),signals:[],button:s(e),modifiers:i(e),clickCount:e.detail})}_shouldIgnoreMouseEvent(e){const t=this._deepEventTarget(e);if("none"===this._mode)return!0;if("inspecting"===this._mode)return l(e),!0;const n=t.nodeName;return"SELECT"===n||!("INPUT"!==n||!["date"].includes(t.type))}_onMouseDown(e){this._shouldIgnoreMouseEvent(e)||(this._performingAction||l(e),this._activeModel=this._hoveredModel)}_onMouseUp(e){this._shouldIgnoreMouseEvent(e)||this._performingAction||l(e)}_onMouseMove(e){if("none"===this._mode)return;const t=this._deepEventTarget(e);this._hoveredElement!==t&&(this._hoveredElement=t,this._updateModelForHoveredElement())}_onMouseLeave(e){this._deepEventTarget(e).nodeType===Node.DOCUMENT_NODE&&(this._hoveredElement=null,this._updateModelForHoveredElement())}_onFocus(){const e=this._deepActiveElement(document),n=e?(0,t.generateSelector)(this._injectedScript,e):null;this._activeModel=n&&n.selector?n:null,this._params.isUnderTest&&console.error("Highlight updated for test: "+(n?n.selector:null))}_updateModelForHoveredElement(){if(!this._hoveredElement)return this._hoveredModel=null,void this._updateHighlight();const e=this._hoveredElement,{selector:n,elements:o}=(0,t.generateSelector)(this._injectedScript,e);this._hoveredModel&&this._hoveredModel.selector===n||this._hoveredElement!==e||(this._hoveredModel=n?{selector:n,elements:o}:null,this._updateHighlight(),this._params.isUnderTest&&console.error("Highlight updated for test: "+n))}_updateHighlight(){const e=this._hoveredModel?this._hoveredModel.elements:[],t=this._hoveredModel?this._hoveredModel.selector:"";this._highlight.updateHighlight(e,t,"recording"===this._mode)}_onInput(e){if("recording"!==this._mode)return!0;const t=this._deepEventTarget(e);if(["INPUT","TEXTAREA"].includes(t.nodeName)){const n=t,o=(n.type||"").toLowerCase();if("checkbox"===o)return;if("file"===o)return void globalThis._playwrightRecorderRecordAction({name:"setInputFiles",selector:this._activeModel.selector,signals:[],files:[...n.files||[]].map((e=>e.name))});if(this._consumedDueWrongTarget(e))return;globalThis._playwrightRecorderRecordAction({name:"fill",selector:this._activeModel.selector,signals:[],text:n.value})}if("SELECT"===t.nodeName){const n=t;if(this._actionInProgress(e))return;this._performAction({name:"select",selector:this._hoveredModel.selector,options:[...n.selectedOptions].map((e=>e.value)),signals:[]})}}_shouldGenerateKeyPressFor(e){if(["Backspace","Delete","AltGraph"].includes(e.key))return!1;if("@"===e.key&&"KeyL"===e.code)return!1;if(navigator.platform.includes("Mac")){if("v"===e.key&&e.metaKey)return!1}else{if("v"===e.key&&e.ctrlKey)return!1;if("Insert"===e.key&&e.shiftKey)return!1}if(["Shift","Control","Meta","Alt"].includes(e.key))return!1;const t=e.ctrlKey||e.altKey||e.metaKey;return!(1===e.key.length&&!t&&!a(this._deepEventTarget(e)))}_onKeyDown(e){if("inspecting"!==this._mode){if("recording"===this._mode&&this._shouldGenerateKeyPressFor(e))if(this._actionInProgress(e))this._expectProgrammaticKeyUp=!0;else if(!this._consumedDueWrongTarget(e)){if(" "===e.key){const t=a(this._deepEventTarget(e));if(t)return void this._performAction({name:t.checked?"uncheck":"check",selector:this._activeModel.selector,signals:[]})}this._performAction({name:"press",selector:this._activeModel.selector,signals:[],key:e.key,modifiers:i(e)})}}else l(e)}_onKeyUp(e){"none"!==this._mode&&this._shouldGenerateKeyPressFor(e)&&(this._expectProgrammaticKeyUp?this._expectProgrammaticKeyUp=!1:l(e))}async _performAction(e){this._performingAction=!0,await globalThis._playwrightRecorderPerformAction(e).catch((()=>{})),this._performingAction=!1,this._updateModelForHoveredElement(),this._onFocus(),this._params.isUnderTest&&console.error("Action performed for test: "+JSON.stringify({hovered:this._hoveredModel?this._hoveredModel.selector:null,active:this._activeModel?this._activeModel.selector:null}))}_deepEventTarget(e){return e.composedPath()[0]}_deepActiveElement(e){let t=e.activeElement;for(;t&&t.shadowRoot&&t.shadowRoot.activeElement;)t=t.shadowRoot.activeElement;return t}};e.default=u})(),pwExport=o.default})();';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/generated/consoleApiSource.js
var require_consoleApiSource = __commonJS({
  "node_modules/playwright-core/lib/generated/consoleApiSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = 'var pwExport;(()=>{"use strict";var e={317:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseCSS=function(e,t){let r;try{r=o.tokenize(e),r[r.length-1]instanceof o.EOFToken||r.push(new o.EOFToken)}catch(t){const r=t.message+` while parsing selector "${e}"`,n=(t.stack||"").indexOf(t.message);throw-1!==n&&(t.stack=t.stack.substring(0,n)+r+t.stack.substring(n+t.message.length)),t.message=r,t}const i=r.find((e=>e instanceof o.AtKeywordToken||e instanceof o.BadStringToken||e instanceof o.BadURLToken||e instanceof o.ColumnToken||e instanceof o.CDOToken||e instanceof o.CDCToken||e instanceof o.SemicolonToken||e instanceof o.OpenCurlyToken||e instanceof o.CloseCurlyToken||e instanceof o.URLToken||e instanceof o.PercentageToken));if(i)throw new n.InvalidSelectorError(`Unsupported token "${i.toSource()}" while parsing selector "${e}"`);let s=0;const c=new Set;function a(){return new n.InvalidSelectorError(`Unexpected token "${r[s].toSource()}" while parsing selector "${e}"`)}function u(){for(;r[s]instanceof o.WhitespaceToken;)s++}function l(e=s){return r[e]instanceof o.IdentToken}function p(e=s){return r[e]instanceof o.CommaToken}function h(e=s){return r[e]instanceof o.CloseParenToken}function f(e=s){return r[e]instanceof o.DelimToken&&"*"===r[e].value}function y(e=s){return r[e]instanceof o.EOFToken}function g(e=s){return r[e]instanceof o.DelimToken&&[">","+","~"].includes(r[e].value)}function m(e=s){return p(e)||h(e)||y(e)||g(e)||r[e]instanceof o.WhitespaceToken}function d(){const e=[w()];for(;u(),p();)s++,e.push(w());return e}function w(){return u(),function(e=s){return r[e]instanceof o.NumberToken}()||function(e=s){return r[e]instanceof o.StringToken}()?r[s++].value:function(){const e={simples:[]};for(u(),g()?e.simples.push({selector:{functions:[{name:"scope",args:[]}]},combinator:""}):e.simples.push({selector:S(),combinator:""});;){if(u(),g())e.simples[e.simples.length-1].combinator=r[s++].value,u();else if(m())break;e.simples.push({combinator:"",selector:S()})}return e}()}function S(){let e="";const n=[];for(;!m();)if(l()||f())e+=r[s++].toSource();else if(r[s]instanceof o.HashToken)e+=r[s++].toSource();else if(r[s]instanceof o.DelimToken&&"."===r[s].value){if(s++,!l())throw a();e+="."+r[s++].toSource()}else if(r[s]instanceof o.ColonToken)if(s++,l())if(t.has(r[s].value.toLowerCase())){const e=r[s++].value.toLowerCase();n.push({name:e,args:[]}),c.add(e)}else e+=":"+r[s++].toSource();else{if(!(r[s]instanceof o.FunctionToken))throw a();{const o=r[s++].value.toLowerCase();if(t.has(o)?(n.push({name:o,args:d()}),c.add(o)):e+=`:${o}(${v()})`,u(),!h())throw a();s++}}else{if(!(r[s]instanceof o.OpenSquareToken))throw a();for(e+="[",s++;!(r[s]instanceof o.CloseSquareToken||y());)e+=r[s++].toSource();if(!(r[s]instanceof o.CloseSquareToken))throw a();e+="]",s++}if(!e&&!n.length)throw a();return{css:e||void 0,functions:n}}function v(){let e="";for(;!h()&&!y();)e+=r[s++].toSource();return e}const _=d();if(!y())throw new n.InvalidSelectorError(`Error while parsing selector "${e}"`);if(_.some((e=>"object"!=typeof e||!("simples"in e))))throw new n.InvalidSelectorError(`Error while parsing selector "${e}"`);return{selector:_,names:Array.from(c)}},t.serializeSelector=function e(t){return t.map((t=>"string"==typeof t?`"${t}"`:"number"==typeof t?String(t):t.simples.map((({selector:t,combinator:r})=>{let n=t.css||"";return n+=t.functions.map((t=>`:${t.name}(${e(t.args)})`)).join(""),r&&(n+=" "+r),n})).join(" "))).join(", ")};var n=r(672),o=function(e,t){if(e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var r=i(t);if(r&&r.has(e))return r.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var c=o?Object.getOwnPropertyDescriptor(e,s):null;c&&(c.get||c.set)?Object.defineProperty(n,s,c):n[s]=e[s]}return n.default=e,r&&r.set(e,n),n}(r(503));function i(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return(i=function(e){return e?r:t})(e)}},503:(e,t)=>{var r,n;r=function(e){var t=function(e,t,r){return e>=t&&e<=r};function r(e){return t(e,48,57)}function n(e){return r(e)||t(e,65,70)||t(e,97,102)}function o(e){return function(e){return t(e,65,90)}(e)||function(e){return t(e,97,122)}(e)}function i(e){return o(e)||function(e){return e>=128}(e)||95==e}function s(e){return i(e)||r(e)||45==e}function c(e){return t(e,0,8)||11==e||t(e,14,31)||127==e}function a(e){return 10==e}function u(e){return a(e)||9==e||32==e}var l=function(e){this.message=e};function p(e){if(e<=65535)return String.fromCharCode(e);e-=Math.pow(2,16);var t=Math.floor(e/Math.pow(2,10))+55296,r=e%Math.pow(2,10)+56320;return String.fromCharCode(t)+String.fromCharCode(r)}function h(){throw"Abstract Base Class"}function f(){return this}function y(){return this}function g(){return this}function m(){return this}function d(){return this}function w(){return this}function S(){return this}function v(){return this}function _(){throw"Abstract Base Class"}function T(){return this.value="{",this.mirror="}",this}function b(){return this.value="}",this.mirror="{",this}function E(){return this.value="[",this.mirror="]",this}function k(){return this.value="]",this.mirror="[",this}function C(){return this.value="(",this.mirror=")",this}function O(){return this.value=")",this.mirror="(",this}function x(){return this}function M(){return this}function A(){return this}function N(){return this}function j(){return this}function $(){return this}function I(){return this}function q(e){return this.value=p(e),this}function P(){throw"Abstract Base Class"}function R(e){this.value=e}function D(e){this.value=e,this.mirror=")"}function L(e){this.value=e}function U(e){this.value=e,this.type="unrestricted"}function B(e){this.value=e}function Q(e){this.value=e}function W(){this.value=null,this.type="integer",this.repr=""}function F(){this.value=null,this.repr=""}function J(){this.value=null,this.type="integer",this.repr="",this.unit=""}function z(e){for(var r="",n=(e=""+e).charCodeAt(0),o=0;o<e.length;o++){var i=e.charCodeAt(o);if(0==i)throw new l("Invalid character: the input contains U+0000.");t(i,1,31)||127==i||0==o&&t(i,48,57)||1==o&&t(i,48,57)&&45==n?r+="\\\\"+i.toString(16)+" ":i>=128||45==i||95==i||t(i,48,57)||t(i,65,90)||t(i,97,122)?r+=e[o]:r+="\\\\"+e[o]}return r}function G(e){e=""+e;for(var r="",n=0;n<e.length;n++){var o=e.charCodeAt(n);if(0==o)throw new l("Invalid character: the input contains U+0000.");t(o,1,31)||127==o?r+="\\\\"+o.toString(16)+" ":r+=34==o||92==o?"\\\\"+e[n]:e[n]}return r}(l.prototype=new Error).name="InvalidCharacterError",h.prototype.toJSON=function(){return{token:this.tokenType}},h.prototype.toString=function(){return this.tokenType},h.prototype.toSource=function(){return""+this},f.prototype=Object.create(h.prototype),f.prototype.tokenType="BADSTRING",y.prototype=Object.create(h.prototype),y.prototype.tokenType="BADURL",g.prototype=Object.create(h.prototype),g.prototype.tokenType="WHITESPACE",g.prototype.toString=function(){return"WS"},g.prototype.toSource=function(){return" "},m.prototype=Object.create(h.prototype),m.prototype.tokenType="CDO",m.prototype.toSource=function(){return"\\x3c!--"},d.prototype=Object.create(h.prototype),d.prototype.tokenType="CDC",d.prototype.toSource=function(){return"--\\x3e"},w.prototype=Object.create(h.prototype),w.prototype.tokenType=":",S.prototype=Object.create(h.prototype),S.prototype.tokenType=";",v.prototype=Object.create(h.prototype),v.prototype.tokenType=",",_.prototype=Object.create(h.prototype),T.prototype=Object.create(_.prototype),T.prototype.tokenType="{",b.prototype=Object.create(_.prototype),b.prototype.tokenType="}",E.prototype=Object.create(_.prototype),E.prototype.tokenType="[",k.prototype=Object.create(_.prototype),k.prototype.tokenType="]",C.prototype=Object.create(_.prototype),C.prototype.tokenType="(",O.prototype=Object.create(_.prototype),O.prototype.tokenType=")",x.prototype=Object.create(h.prototype),x.prototype.tokenType="~=",M.prototype=Object.create(h.prototype),M.prototype.tokenType="|=",A.prototype=Object.create(h.prototype),A.prototype.tokenType="^=",N.prototype=Object.create(h.prototype),N.prototype.tokenType="$=",j.prototype=Object.create(h.prototype),j.prototype.tokenType="*=",$.prototype=Object.create(h.prototype),$.prototype.tokenType="||",I.prototype=Object.create(h.prototype),I.prototype.tokenType="EOF",I.prototype.toSource=function(){return""},q.prototype=Object.create(h.prototype),q.prototype.tokenType="DELIM",q.prototype.toString=function(){return"DELIM("+this.value+")"},q.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},q.prototype.toSource=function(){return"\\\\"==this.value?"\\\\\\n":this.value},P.prototype=Object.create(h.prototype),P.prototype.ASCIIMatch=function(e){return this.value.toLowerCase()==e.toLowerCase()},P.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e},R.prototype=Object.create(P.prototype),R.prototype.tokenType="IDENT",R.prototype.toString=function(){return"IDENT("+this.value+")"},R.prototype.toSource=function(){return z(this.value)},D.prototype=Object.create(P.prototype),D.prototype.tokenType="FUNCTION",D.prototype.toString=function(){return"FUNCTION("+this.value+")"},D.prototype.toSource=function(){return z(this.value)+"("},L.prototype=Object.create(P.prototype),L.prototype.tokenType="AT-KEYWORD",L.prototype.toString=function(){return"AT("+this.value+")"},L.prototype.toSource=function(){return"@"+z(this.value)},U.prototype=Object.create(P.prototype),U.prototype.tokenType="HASH",U.prototype.toString=function(){return"HASH("+this.value+")"},U.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e},U.prototype.toSource=function(){return"id"==this.type?"#"+z(this.value):"#"+function(e){for(var r="",n=((e=""+e).charCodeAt(0),0);n<e.length;n++){var o=e.charCodeAt(n);if(0==o)throw new l("Invalid character: the input contains U+0000.");o>=128||45==o||95==o||t(o,48,57)||t(o,65,90)||t(o,97,122)?r+=e[n]:r+="\\\\"+o.toString(16)+" "}return r}(this.value)},B.prototype=Object.create(P.prototype),B.prototype.tokenType="STRING",B.prototype.toString=function(){return\'"\'+G(this.value)+\'"\'},Q.prototype=Object.create(P.prototype),Q.prototype.tokenType="URL",Q.prototype.toString=function(){return"URL("+this.value+")"},Q.prototype.toSource=function(){return\'url("\'+G(this.value)+\'")\'},W.prototype=Object.create(h.prototype),W.prototype.tokenType="NUMBER",W.prototype.toString=function(){return"integer"==this.type?"INT("+this.value+")":"NUMBER("+this.value+")"},W.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e},W.prototype.toSource=function(){return this.repr},F.prototype=Object.create(h.prototype),F.prototype.tokenType="PERCENTAGE",F.prototype.toString=function(){return"PERCENTAGE("+this.value+")"},F.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.repr=this.repr,e},F.prototype.toSource=function(){return this.repr+"%"},J.prototype=Object.create(h.prototype),J.prototype.tokenType="DIMENSION",J.prototype.toString=function(){return"DIM("+this.value+","+this.unit+")"},J.prototype.toJSON=function(){var e=this.constructor.prototype.constructor.prototype.toJSON.call(this);return e.value=this.value,e.type=this.type,e.repr=this.repr,e.unit=this.unit,e},J.prototype.toSource=function(){var e=this.repr,r=z(this.unit);return"e"!=r[0].toLowerCase()||"-"!=r[1]&&!t(r.charCodeAt(1),48,57)||(r="\\\\65 "+r.slice(1,r.length)),e+r},e.tokenize=function(e){e=function(e){for(var r=[],n=0;n<e.length;n++){var o=e.charCodeAt(n);if(13==o&&10==e.charCodeAt(n+1)&&(o=10,n++),13!=o&&12!=o||(o=10),0==o&&(o=65533),t(o,55296,56319)&&t(e.charCodeAt(n+1),56320,57343)){var i=o-55296,s=e.charCodeAt(n+1)-56320;o=Math.pow(2,16)+i*Math.pow(2,10)+s,n++}r.push(o)}return r}(e);for(var o,l=-1,h=[],_=0,P=0,z=0,G={line:_,column:P},H=function(t){return t>=e.length?-1:e[t]},V=function(e){if(void 0===e&&(e=1),e>3)throw"Spec Error: no more than three codepoints of lookahead.";return H(l+e)},K=function(e){return void 0===e&&(e=1),a(o=H(l+=e))?(_+=1,z=P,P=0):P+=e,!0},X=function(){return l-=1,a(o)?(_-=1,P=z):P-=1,G.line=_,G.column=P,!0},Z=function(e){return void 0===e&&(e=o),-1==e},Y=function(){return console.log("Parse error at index "+l+", processing codepoint 0x"+o.toString(16)+"."),!0},ee=function(){if(te(),K(),u(o)){for(;u(V());)K();return new g}if(34==o)return oe();if(35==o){if(s(V())||ce(V(1),V(2))){var e=new U;return ue(V(1),V(2),V(3))&&(e.type="id"),e.value=he(),e}return new q(o)}return 36==o?61==V()?(K(),new N):new q(o):39==o?oe():40==o?new C:41==o?new O:42==o?61==V()?(K(),new j):new q(o):43==o?pe()?(X(),re()):new q(o):44==o?new v:45==o?pe()?(X(),re()):45==V(1)&&62==V(2)?(K(2),new d):le()?(X(),ne()):new q(o):46==o?pe()?(X(),re()):new q(o):58==o?new w:59==o?new S:60==o?33==V(1)&&45==V(2)&&45==V(3)?(K(3),new m):new q(o):64==o?ue(V(1),V(2),V(3))?new L(he()):new q(o):91==o?new E:92==o?ae()?(X(),ne()):(Y(),new q(o)):93==o?new k:94==o?61==V()?(K(),new A):new q(o):123==o?new T:124==o?61==V()?(K(),new M):124==V()?(K(),new $):new q(o):125==o?new b:126==o?61==V()?(K(),new x):new q(o):r(o)?(X(),re()):i(o)?(X(),ne()):Z()?new I:new q(o)},te=function(){for(;47==V(1)&&42==V(2);)for(K(2);;){if(K(),42==o&&47==V()){K();break}if(Z())return void Y()}},re=function(){var e,t=fe();return ue(V(1),V(2),V(3))?((e=new J).value=t.value,e.repr=t.repr,e.type=t.type,e.unit=he(),e):37==V()?(K(),(e=new F).value=t.value,e.repr=t.repr,e):((e=new W).value=t.value,e.repr=t.repr,e.type=t.type,e)},ne=function(){var e=he();if("url"==e.toLowerCase()&&40==V()){for(K();u(V(1))&&u(V(2));)K();return 34==V()||39==V()?new D(e):!u(V())||34!=V(2)&&39!=V(2)?ie():new D(e)}return 40==V()?(K(),new D(e)):new R(e)},oe=function(e){void 0===e&&(e=o);for(var t="";K();){if(o==e||Z())return new B(t);if(a(o))return Y(),X(),new f;92==o?Z(V())||(a(V())?K():t+=p(se())):t+=p(o)}},ie=function(){for(var e=new Q("");u(V());)K();if(Z(V()))return e;for(;K();){if(41==o||Z())return e;if(u(o)){for(;u(V());)K();return 41==V()||Z(V())?(K(),e):(ge(),new y)}if(34==o||39==o||40==o||c(o))return Y(),ge(),new y;if(92==o){if(!ae())return Y(),ge(),new y;e.value+=p(se())}else e.value+=p(o)}},se=function(){if(K(),n(o)){for(var e=[o],t=0;t<5&&n(V());t++)K(),e.push(o);u(V())&&K();var r=parseInt(e.map((function(e){return String.fromCharCode(e)})).join(""),16);return r>1114111&&(r=65533),r}return Z()?65533:o},ce=function(e,t){return 92==e&&!a(t)},ae=function(){return ce(o,V())},ue=function(e,t,r){return 45==e?i(t)||45==t||ce(t,r):!!i(e)||92==e&&ce(e,t)},le=function(){return ue(o,V(1),V(2))},pe=function(){return e=o,t=V(1),n=V(2),43==e||45==e?!!r(t)||!(46!=t||!r(n)):46==e?!!r(t):!!r(e);var e,t,n},he=function(){for(var e="";K();)if(s(o))e+=p(o);else{if(!ae())return X(),e;e+=p(se())}},fe=function(){var e=[],t="integer";for(43!=V()&&45!=V()||(K(),e+=p(o));r(V());)K(),e+=p(o);if(46==V(1)&&r(V(2)))for(K(),e+=p(o),K(),e+=p(o),t="number";r(V());)K(),e+=p(o);var n=V(1),i=V(2),s=V(3);if(69!=n&&101!=n||!r(i)){if((69==n||101==n)&&(43==i||45==i)&&r(s))for(K(),e+=p(o),K(),e+=p(o),K(),e+=p(o),t="number";r(V());)K(),e+=p(o)}else for(K(),e+=p(o),K(),e+=p(o),t="number";r(V());)K(),e+=p(o);return{type:t,value:ye(e),repr:e}},ye=function(e){return+e},ge=function(){for(;K();){if(41==o||Z())return;ae()&&se()}},me=0;!Z(V());)if(h.push(ee()),++me>2*e.length)return"I\'m infinite-looping!";return h},e.IdentToken=R,e.FunctionToken=D,e.AtKeywordToken=L,e.HashToken=U,e.StringToken=B,e.BadStringToken=f,e.URLToken=Q,e.BadURLToken=y,e.DelimToken=q,e.NumberToken=W,e.PercentageToken=F,e.DimensionToken=J,e.IncludeMatchToken=x,e.DashMatchToken=M,e.PrefixMatchToken=A,e.SuffixMatchToken=N,e.SubstringMatchToken=j,e.ColumnToken=$,e.WhitespaceToken=g,e.CDOToken=m,e.CDCToken=d,e.ColonToken=w,e.SemicolonToken=S,e.CommaToken=v,e.OpenParenToken=C,e.CloseParenToken=O,e.OpenSquareToken=E,e.CloseSquareToken=k,e.OpenCurlyToken=T,e.CloseCurlyToken=b,e.EOFToken=I,e.CSSParserToken=h,e.GroupingToken=_},void 0===(n=r.apply(t,[t]))||(e.exports=n)},672:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isInvalidSelectorError=function(e){return e instanceof r},t.InvalidSelectorError=void 0;class r extends Error{}t.InvalidSelectorError=r},461:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSelector=s,t.splitSelectorByFrame=function(e){const t=s(e),r=[];let o={parts:[]},i=0;for(let e=0;e<t.parts.length;++e){const s=t.parts[e];if("control"!==s.name||"enter-frame"!==s.body)t.capture===e&&(o.capture=e-i),o.parts.push(s);else{if(!o.parts.length)throw new n.InvalidSelectorError("Selector cannot start with entering frame, select the iframe first");r.push(o),o={parts:[]},i=e+1}}if(!o.parts.length)throw new n.InvalidSelectorError(`Selector cannot end with entering frame, while parsing selector ${e}`);if(r.push(o),"number"==typeof t.capture&&"number"!=typeof r[r.length-1].capture)throw new n.InvalidSelectorError("Can not capture the selector before diving into the frame. Only use * after the last frame has been selected");return r},t.stringifySelector=function(e){return"string"==typeof e?e:e.parts.map(((t,r)=>{const n="css"===t.name?"":t.name+"=";return`${r===e.capture?"*":""}${n}${t.source}`})).join(" >> ")},t.customCSSNames=void 0;var n=r(672),o=r(317);const i=new Set(["not","is","where","has","scope","light","visible","text","text-matches","text-is","has-text","above","below","right-of","left-of","near","nth-match"]);function s(e){const t=function(e){let t,r=0,o=0;const i={parts:[]},s=()=>{const t=e.substring(o,r).trim(),s=t.indexOf("=");let c,a;-1!==s&&t.substring(0,s).trim().match(/^[a-zA-Z_0-9-+:*]+$/)?(c=t.substring(0,s).trim(),a=t.substring(s+1)):t.length>1&&\'"\'===t[0]&&\'"\'===t[t.length-1]||t.length>1&&"\'"===t[0]&&"\'"===t[t.length-1]?(c="text",a=t):/^\\(*\\/\\//.test(t)||t.startsWith("..")?(c="xpath",a=t):(c="css",a=t);let u=!1;if("*"===c[0]&&(u=!0,c=c.substring(1)),i.parts.push({name:c,body:a}),u){if(void 0!==i.capture)throw new n.InvalidSelectorError("Only one of the selectors can capture using * modifier");i.capture=i.parts.length-1}};if(!e.includes(">>"))return r=e.length,s(),i;for(;r<e.length;){const n=e[r];"\\\\"===n&&r+1<e.length?r+=2:n===t?(t=void 0,r++):t||\'"\'!==n&&"\'"!==n&&"`"!==n?t||">"!==n||">"!==e[r+1]?r++:(s(),r+=2,o=r):(t=n,r++)}return s(),i}(e),r=t.parts.map((e=>"css"===e.name||"css:light"===e.name?("css:light"===e.name&&(e.body=":light("+e.body+")"),{name:"css",body:(0,o.parseCSS)(e.body,i).selector,source:e.body}):{...e,source:e.body}));return{capture:t.capture,parts:r}}t.customCSSNames=i},848:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createLaxTextMatcher=y,t.createStrictTextMatcher=g,t.createRegexTextMatcher=m,t.elementText=w,t.elementMatchesText=S,t.isInsideScope=function(e,t){for(;t;){if(e.contains(t))return!0;for(;t.parentElement;)t=t.parentElement;t=O(t)}return!1},t.parentElementOrShadowHost=O,t.isVisible=A,t.SelectorEvaluatorImpl=void 0;var n=r(461);t.SelectorEvaluatorImpl=class{constructor(e){this._engines=new Map,this._cacheQueryCSS=new Map,this._cacheMatches=new Map,this._cacheQuery=new Map,this._cacheMatchesSimple=new Map,this._cacheMatchesParents=new Map,this._cacheCallMatches=new Map,this._cacheCallQuery=new Map,this._cacheQuerySimple=new Map,this._cacheText=new Map,this._scoreMap=void 0,this._retainCacheCounter=0;for(const[t,r]of e)this._engines.set(t,r);this._engines.set("not",c),this._engines.set("is",o),this._engines.set("where",o),this._engines.set("has",i),this._engines.set("scope",s),this._engines.set("light",a),this._engines.set("visible",u),this._engines.set("text",l),this._engines.set("text-is",p),this._engines.set("text-matches",h),this._engines.set("has-text",f),this._engines.set("right-of",k("right-of",v)),this._engines.set("left-of",k("left-of",_)),this._engines.set("above",k("above",T)),this._engines.set("below",k("below",b)),this._engines.set("near",k("near",E)),this._engines.set("nth-match",C);const t=[...this._engines.keys()];t.sort();const r=[...n.customCSSNames];if(r.sort(),t.join("|")!==r.join("|"))throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${t.join("|")} vs ${r.join("|")}`)}begin(){++this._retainCacheCounter}end(){--this._retainCacheCounter,this._retainCacheCounter||(this._cacheQueryCSS.clear(),this._cacheMatches.clear(),this._cacheQuery.clear(),this._cacheMatchesSimple.clear(),this._cacheMatchesParents.clear(),this._cacheCallMatches.clear(),this._cacheCallQuery.clear(),this._cacheQuerySimple.clear(),this._cacheText.clear())}_cached(e,t,r,n){e.has(t)||e.set(t,[]);const o=e.get(t),i=o.find((e=>r.every(((t,r)=>e.rest[r]===t))));if(i)return i.result;const s=n();return o.push({rest:r,result:s}),s}_checkSelector(e){if("object"!=typeof e||!e||!(Array.isArray(e)||"simples"in e&&e.simples.length))throw new Error(`Malformed selector "${e}"`);return e}matches(e,t,r){const n=this._checkSelector(t);this.begin();try{return this._cached(this._cacheMatches,e,[n,r.scope,r.pierceShadow],(()=>Array.isArray(n)?this._matchesEngine(o,e,n,r):!!this._matchesSimple(e,n.simples[n.simples.length-1].selector,r)&&this._matchesParents(e,n,n.simples.length-2,r)))}finally{this.end()}}query(e,t){const r=this._checkSelector(t);this.begin();try{return this._cached(this._cacheQuery,r,[e.scope,e.pierceShadow],(()=>{if(Array.isArray(r))return this._queryEngine(o,e,r);const t=this._scoreMap;this._scoreMap=new Map;let n=this._querySimple(e,r.simples[r.simples.length-1].selector);return n=n.filter((t=>this._matchesParents(t,r,r.simples.length-2,e))),this._scoreMap.size&&n.sort(((e,t)=>{const r=this._scoreMap.get(e),n=this._scoreMap.get(t);return r===n?0:void 0===r?1:void 0===n?-1:r-n})),this._scoreMap=t,n}))}finally{this.end()}}_markScore(e,t){this._scoreMap&&this._scoreMap.set(e,t)}_matchesSimple(e,t,r){return this._cached(this._cacheMatchesSimple,e,[t,r.scope,r.pierceShadow],(()=>{if(!t.functions.some((e=>"scope"===e.name||"is"===e.name))&&e===r.scope)return!1;if(t.css&&!this._matchesCSS(e,t.css))return!1;for(const n of t.functions)if(!this._matchesEngine(this._getEngine(n.name),e,n.args,r))return!1;return!0}))}_querySimple(e,t){return t.functions.length?this._cached(this._cacheQuerySimple,t,[e.scope,e.pierceShadow],(()=>{let r=t.css;const n=t.functions;let o;"*"===r&&n.length&&(r=void 0);let i=-1;void 0!==r?(o=this._queryCSS(e,r),n.some((e=>"scope"===e.name))&&1===e.scope.nodeType&&o.unshift(e.scope)):(i=n.findIndex((e=>void 0!==this._getEngine(e.name).query)),-1===i&&(i=0),o=this._queryEngine(this._getEngine(n[i].name),e,n[i].args));for(let t=0;t<n.length;t++){if(t===i)continue;const r=this._getEngine(n[t].name);void 0!==r.matches&&(o=o.filter((o=>this._matchesEngine(r,o,n[t].args,e))))}for(let t=0;t<n.length;t++){if(t===i)continue;const r=this._getEngine(n[t].name);void 0===r.matches&&(o=o.filter((o=>this._matchesEngine(r,o,n[t].args,e))))}return o})):this._queryCSS(e,t.css||"*")}_matchesParents(e,t,r,n){return r<0||this._cached(this._cacheMatchesParents,e,[t,r,n.scope,n.pierceShadow],(()=>{const{selector:o,combinator:i}=t.simples[r];if(">"===i){const i=x(e,n);return!(!i||!this._matchesSimple(i,o,n))&&this._matchesParents(i,t,r-1,n)}if("+"===i){const i=M(e,n);return!(!i||!this._matchesSimple(i,o,n))&&this._matchesParents(i,t,r-1,n)}if(""===i){let i=x(e,n);for(;i;){if(this._matchesSimple(i,o,n)){if(this._matchesParents(i,t,r-1,n))return!0;if(""===t.simples[r-1].combinator)break}i=x(i,n)}return!1}if("~"===i){let i=M(e,n);for(;i;){if(this._matchesSimple(i,o,n)){if(this._matchesParents(i,t,r-1,n))return!0;if("~"===t.simples[r-1].combinator)break}i=M(i,n)}return!1}if(">="===i){let i=e;for(;i;){if(this._matchesSimple(i,o,n)){if(this._matchesParents(i,t,r-1,n))return!0;if(""===t.simples[r-1].combinator)break}i=x(i,n)}return!1}throw new Error(`Unsupported combinator "${i}"`)}))}_matchesEngine(e,t,r,n){if(e.matches)return this._callMatches(e,t,r,n);if(e.query)return this._callQuery(e,r,n).includes(t);throw new Error(\'Selector engine should implement "matches" or "query"\')}_queryEngine(e,t,r){if(e.query)return this._callQuery(e,r,t);if(e.matches)return this._queryCSS(t,"*").filter((n=>this._callMatches(e,n,r,t)));throw new Error(\'Selector engine should implement "matches" or "query"\')}_callMatches(e,t,r,n){return this._cached(this._cacheCallMatches,t,[e,n.scope,n.pierceShadow,...r],(()=>e.matches(t,r,n,this)))}_callQuery(e,t,r){return this._cached(this._cacheCallQuery,e,[r.scope,r.pierceShadow,...t],(()=>e.query(r,t,this)))}_matchesCSS(e,t){return e.matches(t)}_queryCSS(e,t){return this._cached(this._cacheQueryCSS,t,[e.scope,e.pierceShadow],(()=>{let r=[];return function n(o){if(r=r.concat([...o.querySelectorAll(t)]),e.pierceShadow){o.shadowRoot&&n(o.shadowRoot);for(const e of o.querySelectorAll("*"))e.shadowRoot&&n(e.shadowRoot)}}(e.scope),r}))}_getEngine(e){const t=this._engines.get(e);if(!t)throw new Error(`Unknown selector engine "${e}"`);return t}};const o={matches(e,t,r,n){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');return t.some((t=>n.matches(e,t,r)))},query(e,t,r){if(0===t.length)throw new Error(\'"is" engine expects non-empty selector list\');let n=[];for(const o of t)n=n.concat(r.query(e,o));return 1===t.length?n:function(e){const t=new Map,r=[],n=[];function o(e){let n=t.get(e);if(n)return n;const i=O(e);return i?o(i).children.push(e):r.push(e),n={children:[],taken:!1},t.set(e,n),n}return e.forEach((e=>o(e).taken=!0)),r.forEach((function e(r){const o=t.get(r);if(o.taken&&n.push(r),o.children.length>1){const e=new Set(o.children);o.children=[];let t=r.firstElementChild;for(;t&&o.children.length<e.size;)e.has(t)&&o.children.push(t),t=t.nextElementSibling;for(t=r.shadowRoot?r.shadowRoot.firstElementChild:null;t&&o.children.length<e.size;)e.has(t)&&o.children.push(t),t=t.nextElementSibling}o.children.forEach(e)})),n}(n)}},i={matches(e,t,r,n){if(0===t.length)throw new Error(\'"has" engine expects non-empty selector list\');return n.query({...r,scope:e},t).length>0}},s={matches(e,t,r,n){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');return 9===r.scope.nodeType?e===r.scope.documentElement:e===r.scope},query(e,t,r){if(0!==t.length)throw new Error(\'"scope" engine expects no arguments\');if(9===e.scope.nodeType){const t=e.scope.documentElement;return t?[t]:[]}return 1===e.scope.nodeType?[e.scope]:[]}},c={matches(e,t,r,n){if(0===t.length)throw new Error(\'"not" engine expects non-empty selector list\');return!n.matches(e,t,r)}},a={query:(e,t,r)=>r.query({...e,pierceShadow:!1},t),matches:(e,t,r,n)=>n.matches(e,t,{...r,pierceShadow:!1})},u={matches(e,t,r,n){if(t.length)throw new Error(\'"visible" engine expects no arguments\');return A(e)}},l={matches(e,t,r,n){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text" engine expects a single string\');return"self"===S(n,e,y(t[0]))}},p={matches(e,t,r,n){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"text-is" engine expects a single string\');return"none"!==S(n,e,g(t[0]))}},h={matches(e,t,r,n){if(0===t.length||"string"!=typeof t[0]||t.length>2||2===t.length&&"string"!=typeof t[1])throw new Error(\'"text-matches" engine expects a regexp body and optional regexp flags\');return"self"===S(n,e,m(t[0],2===t.length?t[1]:void 0))}},f={matches(e,t,r,n){if(1!==t.length||"string"!=typeof t[0])throw new Error(\'"has-text" engine expects a single string\');return!d(e)&&y(t[0])(w(n,e))}};function y(e){return e=e.trim().replace(/\\s+/g," ").toLowerCase(),t=>t.full.trim().replace(/\\s+/g," ").toLowerCase().includes(e)}function g(e){return e=e.trim().replace(/\\s+/g," "),t=>!e&&!t.immediate.length||t.immediate.some((t=>t.trim().replace(/\\s+/g," ")===e))}function m(e,t){const r=new RegExp(e,t);return e=>r.test(e.full)}function d(e){return"SCRIPT"===e.nodeName||"STYLE"===e.nodeName||document.head&&document.head.contains(e)}function w(e,t){let r=e._cacheText.get(t);if(void 0===r){if(r={full:"",immediate:[]},!d(t)){let n="";if(t instanceof HTMLInputElement&&("submit"===t.type||"button"===t.type))r={full:t.value,immediate:[t.value]};else{for(let o=t.firstChild;o;o=o.nextSibling)o.nodeType===Node.TEXT_NODE?(r.full+=o.nodeValue||"",n+=o.nodeValue||""):(n&&r.immediate.push(n),n="",o.nodeType===Node.ELEMENT_NODE&&(r.full+=w(e,o).full));n&&r.immediate.push(n),t.shadowRoot&&(r.full+=w(e,t.shadowRoot).full)}}e._cacheText.set(t,r)}return r}function S(e,t,r){if(d(t))return"none";if(!r(w(e,t)))return"none";for(let n=t.firstChild;n;n=n.nextSibling)if(n.nodeType===Node.ELEMENT_NODE&&r(w(e,n)))return"selfAndChildren";return t.shadowRoot&&r(w(e,t.shadowRoot))?"selfAndChildren":"self"}function v(e,t,r){const n=e.left-t.right;if(!(n<0||void 0!==r&&n>r))return n+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function _(e,t,r){const n=t.left-e.right;if(!(n<0||void 0!==r&&n>r))return n+Math.max(t.bottom-e.bottom,0)+Math.max(e.top-t.top,0)}function T(e,t,r){const n=t.top-e.bottom;if(!(n<0||void 0!==r&&n>r))return n+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function b(e,t,r){const n=e.top-t.bottom;if(!(n<0||void 0!==r&&n>r))return n+Math.max(e.left-t.left,0)+Math.max(t.right-e.right,0)}function E(e,t,r){const n=void 0===r?50:r;let o=0;return e.left-t.right>=0&&(o+=e.left-t.right),t.left-e.right>=0&&(o+=t.left-e.right),t.top-e.bottom>=0&&(o+=t.top-e.bottom),e.top-t.bottom>=0&&(o+=e.top-t.bottom),o>n?void 0:o}function k(e,t){return{matches(r,n,o,i){const s=n.length&&"number"==typeof n[n.length-1]?n[n.length-1]:void 0,c=void 0===s?n:n.slice(0,n.length-1);if(n.length<1+(void 0===s?0:1))throw new Error(`"${e}" engine expects a selector list and optional maximum distance in pixels`);const a=r.getBoundingClientRect();let u;for(const e of i.query(o,c)){if(e===r)continue;const n=t(a,e.getBoundingClientRect(),s);void 0!==n&&(void 0===u||n<u)&&(u=n)}return void 0!==u&&(i._markScore(r,u),!0)}}}const C={query(e,t,r){let n=t[t.length-1];if(t.length<2)throw new Error(\'"nth-match" engine expects non-empty selector list and an index argument\');if("number"!=typeof n||n<1)throw new Error(\'"nth-match" engine expects a one-based index as the last argument\');const i=o.query(e,t.slice(0,t.length-1),r);return n--,n<i.length?[i[n]]:[]}};function O(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:void 0}function x(e,t){if(e!==t.scope)return t.pierceShadow?O(e):e.parentElement||void 0}function M(e,t){if(e!==t.scope)return e.previousElementSibling||void 0}function A(e){if(!e.ownerDocument||!e.ownerDocument.defaultView)return!0;const t=e.ownerDocument.defaultView.getComputedStyle(e);if(!t||"hidden"===t.visibility)return!1;if("contents"===t.display){for(let t=e.firstChild;t;t=t.nextSibling){if(1===t.nodeType&&A(t))return!0;if(3===t.nodeType&&N(t))return!0}return!1}const r=e.getBoundingClientRect();return r.width>0&&r.height>0}function N(e){const t=document.createRange();t.selectNode(e);const r=t.getBoundingClientRect();return r.width>0&&r.height>0}},854:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.querySelector=function(e,t,r){try{const n=e.parseSelector(t);return{selector:t,elements:e.querySelectorAll(n,r)}}catch(e){return{selector:t,elements:[]}}},t.generateSelector=function(e,t){e._evaluator.begin();try{const r=function(e,t){if(t.ownerDocument.documentElement===t)return[{engine:"css",selector:"html",score:1}];const r=(u,p)=>{const g=p?o:i;let m=g.get(u);return void 0===m&&(m=((o,i)=>{const u=o===t;let p=i?function(e,t,r){if("SELECT"===t.nodeName)return[];const o=(0,n.elementText)(e._evaluator,t).full.trim().replace(/\\s+/g," ").substring(0,80);if(!o)return[];const i=[];let s=o;if((o.includes(\'"\')||o.includes(">>")||"/"===o[0])&&(s=`/.*${function(e){return e.replace(/[.*+?^>${}()|[\\]\\\\]/g,"\\\\$&")}(o)}.*/`),i.push({engine:"text",selector:s,score:10}),r&&s===o){let e=t.nodeName.toLowerCase();t.hasAttribute("role")&&(e+=`[role=${l(t.getAttribute("role"))}]`),i.push({engine:"css",selector:`${e}:has-text("${o}")`,score:30})}return i}(e,o,o===t).map((e=>[e])):[];o!==t&&(p=s(p));const g=function(e,t){const r=[];for(const e of["data-testid","data-test-id","data-test"])t.hasAttribute(e)&&r.push({engine:"css",selector:`[${e}=${l(t.getAttribute(e))}]`,score:1});if("INPUT"===t.nodeName){const e=t;e.placeholder&&r.push({engine:"css",selector:`[placeholder=${l(e.placeholder)}]`,score:10})}t.hasAttribute("aria-label")&&r.push({engine:"css",selector:`[aria-label=${l(t.getAttribute("aria-label"))}]`,score:10}),t.getAttribute("alt")&&["APPLET","AREA","IMG","INPUT"].includes(t.nodeName)&&r.push({engine:"css",selector:`${y(t.nodeName.toLowerCase())}[alt=${l(t.getAttribute("alt"))}]`,score:10}),t.hasAttribute("role")&&r.push({engine:"css",selector:`${y(t.nodeName.toLowerCase())}[role=${l(t.getAttribute("role"))}]`,score:50}),t.getAttribute("name")&&["BUTTON","FORM","FIELDSET","IFRAME","INPUT","KEYGEN","OBJECT","OUTPUT","SELECT","TEXTAREA","MAP","META","PARAM"].includes(t.nodeName)&&r.push({engine:"css",selector:`${y(t.nodeName.toLowerCase())}[name=${l(t.getAttribute("name"))}]`,score:50}),["INPUT","TEXTAREA"].includes(t.nodeName)&&"hidden"!==t.getAttribute("type")&&t.getAttribute("type")&&r.push({engine:"css",selector:`${y(t.nodeName.toLowerCase())}[type=${l(t.getAttribute("type"))}]`,score:50}),["INPUT","TEXTAREA","SELECT"].includes(t.nodeName)&&r.push({engine:"css",selector:y(t.nodeName.toLowerCase()),score:50});const n=t.getAttribute("id");return n&&!function(e){let t,r=0;for(let n=0;n<e.length;++n){const o=e[n];let i;"-"!==o&&"_"!==o&&(i=o>="a"&&o<="z"?"lower":o>="A"&&o<="Z"?"upper":o>="0"&&o<="9"?"digit":"other","lower"!==i||"upper"!==t?(t&&t!==i&&++r,t=i):t=i)}return r>=e.length/4}(n)&&r.push({engine:"css",selector:a(n),score:100}),r.push({engine:"css",selector:y(t.nodeName.toLowerCase()),score:200}),r}(0,o).map((e=>[e]));let m=f(e,t.ownerDocument,o,[...p,...g],u);p=s(p);const d=t=>{const n=i&&!t.length,s=[...t,...g].filter((e=>!m||h(e)<h(m)));let a=s[0];if(a)for(let t=c(o);t;t=c(t)){const i=r(t,n);if(!i)continue;if(m&&h([...i,...a])>=h(m))continue;if(a=f(e,t,o,s,u),!a)return;const c=[...i,...a];(!m||h(c)<h(m))&&(m=c)}};return d(p),o===t&&p.length&&d([]),m})(u,p),g.set(u,m)),m};return r(t,!0)}(e,t=t.closest("button,select,input,[role=button],[role=checkbox],[role=radio]")||t),g=p(r||[u(e,t)]),m=e.parseSelector(g);return{selector:g,elements:e.querySelectorAll(m,t.ownerDocument)}}finally{o.clear(),i.clear(),e._evaluator.end()}};var n=r(848);const o=new Map,i=new Map;function s(e){return e.filter((e=>"/"!==e[0].selector[0]))}function c(e){return e.parentElement?e.parentElement:e.parentNode&&e.parentNode.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.parentNode.host?e.parentNode.host:null}function a(e){return/^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(e)?"#"+e:`[id="${y(e)}"]`}function u(e,t){const r=1e7,n=t.ownerDocument,o=[];function i(r){const n=o.slice();r&&n.unshift(r);const i=n.join(" "),s=e.parseSelector(i);return e.querySelector(s,t.ownerDocument,!1)===t?i:void 0}for(let e=t;e&&e!==n;e=c(e)){const t=e.nodeName.toLowerCase();let n="";if(e.id){const t=a(e.id),o=i(t);if(o)return{engine:"css",selector:o,score:r};n=t}const s=e.parentNode,c=[...e.classList];for(let e=0;e<c.length;++e){const t="."+c.slice(0,e+1).join("."),o=i(t);if(o)return{engine:"css",selector:o,score:r};!n&&s&&1===s.querySelectorAll(t).length&&(n=t)}if(s){const o=[...s.children],c=0===o.filter((e=>e.nodeName.toLowerCase()===t)).indexOf(e)?y(t):`${y(t)}:nth-child(${1+o.indexOf(e)})`,a=i(c);if(a)return{engine:"css",selector:a,score:r};n||(n=c)}else n||(n=t);o.unshift(n)}return{engine:"css",selector:i(),score:r}}function l(e){return`"${y(e)}"`}function p(e){const t=[];let r="";for(const{engine:n,selector:o}of e)t.length&&("css"!==r||"css"!==n||o.startsWith(":nth-match("))&&t.push(">>"),r=n,"css"===n?t.push(o):t.push(`${n}=${o}`);return t.join(" ")}function h(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r].score*(e.length-r);return t}function f(e,t,r,n,o){const i=n.map((e=>({tokens:e,score:h(e)})));i.sort(((e,t)=>e.score-t.score));let s=null;for(const{tokens:n}of i){const i=e.parseSelector(p(n)),c=e.querySelectorAll(i,t),a=c.indexOf(r);if(0===a)return n;if(!o||s||-1===a||c.length>5)continue;const u=n.map((e=>"text"!==e.engine?e:e.selector.startsWith("/")&&e.selector.endsWith("/")?{engine:"css",selector:`:text-matches("${e.selector.substring(1,e.selector.length-1)}")`,score:e.score}:{engine:"css",selector:`:text("${e.selector}")`,score:e.score}));s=[{engine:"css",selector:`:nth-match(${p(u)}, ${a+1})`,score:h(u)+1e3}]}return s}function y(e){let t="";for(let r=0;r<e.length;r++)t+=g(e,r);return t}function g(e,t){const r=e.charCodeAt(t);return 0===r?"\uFFFD":r>=1&&r<=31||r>=48&&r<=57&&(0===t||1===t&&45===e.charCodeAt(0))?"\\\\"+r.toString(16)+" ":0===t&&45===r&&1===e.length?"\\\\"+e.charAt(t):r>=128||45===r||95===r||r>=48&&r<=57||r>=65&&r<=90||r>=97&&r<=122?e.charAt(t):"\\\\"+e.charAt(t)}},523:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.escapeWithQuotes=function(e,t="\'"){const r=JSON.stringify(e),n=r.substring(1,r.length-1).replace(/\\\\"/g,\'"\');if("\'"===t)return t+n.replace(/[\']/g,"\\\\\'")+t;if(\'"\'===t)return t+n.replace(/["]/g,\'\\\\"\')+t;if("`"===t)return t+n.replace(/[`]/g,"`")+t;throw new Error("Invalid escape char")}}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var i=t[n]={exports:{}};return e[n](i,i.exports,r),i.exports}var n={};(()=>{var e=n;e.default=void 0;var t=r(523),o=r(854);var i=class{constructor(e){this._injectedScript=void 0,this._injectedScript=e,window.playwright||(window.playwright={$:(e,t)=>this._querySelector(e,!!t),$$:e=>this._querySelectorAll(e),locator:(e,r)=>function(e,r,n){class o{constructor(r,n){if(this.selector=void 0,this.element=void 0,this.elements=void 0,this.selector=r,null!=n&&n.hasText){const e=n.hasText;e instanceof RegExp?this.selector+=` >> :scope:text-matches(${(0,t.escapeWithQuotes)(e.source,\'"\')}, "${e.flags}")`:this.selector+=` >> :scope:has-text(${(0,t.escapeWithQuotes)(e)})`}const o=e.parseSelector(this.selector);this.element=e.querySelector(o,document,!1),this.elements=e.querySelectorAll(o,document)}locator(e,t){return new o(this.selector?this.selector+" >> "+e:e,t)}}return new o(r,n)}(this._injectedScript,e,r),inspect:e=>this._inspect(e),selector:e=>this._selector(e),resume:()=>this._resume()})}_querySelector(e,t){if("string"!=typeof e)throw new Error("Usage: playwright.query(\'Playwright >> selector\').");const r=this._injectedScript.parseSelector(e);return this._injectedScript.querySelector(r,document,t)}_querySelectorAll(e){if("string"!=typeof e)throw new Error("Usage: playwright.$$(\'Playwright >> selector\').");const t=this._injectedScript.parseSelector(e);return this._injectedScript.querySelectorAll(t,document)}_inspect(e){if("string"!=typeof e)throw new Error("Usage: playwright.inspect(\'Playwright >> selector\').");window.inspect(this._querySelector(e,!1))}_selector(e){if(!(e instanceof Element))throw new Error("Usage: playwright.selector(element).");return(0,o.generateSelector)(this._injectedScript,e).selector}_resume(){window._playwrightResume().catch((()=>{}))}};e.default=i})(),pwExport=n.default})();';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/server/chromium/crApp.js
var require_crApp = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crApp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.installAppIcon = installAppIcon;
    var _fs2 = _interopRequireDefault2(require("fs"));
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function installAppIcon(page) {
      return __async(this, null, function* () {
        const icon = yield _fs2.default.promises.readFile(require.resolve("./appIcon.png"));
        const crPage = page._delegate;
        yield crPage._mainFrameSession._client.send("Browser.setDockTile", {
          image: icon.toString("base64")
        });
      });
    }
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (!fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (!fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = function(fs$rename) {
          return function(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          };
        }(fs.rename);
      }
      fs.read = function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path, mode, callback) {
          fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs2.fchmod(fd, mode, function(err2) {
              fs2.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs2.lchmodSync = function(path, mode) {
          var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs2) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs2.lutimes = function(path, at, mt, cb) {
            fs2.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path, at, mt) {
            var fd = fs2.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret;
          };
        } else {
          fs2.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self2 = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs[gracefulQueue]);
          require("assert").equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }
    module2.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module2.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readdir(path, options, cb);
        function go$readdir(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readdir, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          });
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs2.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs2.WriteStream(path, options);
      }
      var fs$open = fs2.open;
      fs2.open = open2;
      function open2(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now;
          fs[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self2 = this;
      var timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/signals.js"(exports2, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    }
    if (process.platform === "linux") {
      module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/signal-exit/index.js"(exports2, module2) {
    var process2 = global.process;
    var processOk = function(process3) {
      return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    };
    if (!processOk(process2)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert = require("assert");
      signals = require_signals();
      isWin = /^win/i.test(process2.platform);
      EE = require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process2.__signal_exit_emitter__) {
        emitter = process2.__signal_exit_emitter__;
      } else {
        emitter = process2.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process2.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process2.emit = originalProcessEmit;
        process2.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process2.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process2.kill(process2.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process2.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process2.emit = processEmit;
        process2.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process2.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process2.exitCode = code || 0;
        emit("exit", process2.exitCode, null);
        emit("afterexit", process2.exitCode, null);
        originalProcessReallyExit.call(process2, process2.exitCode);
      };
      originalProcessEmit = process2.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process2.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process2.exitCode, null);
          emit("afterexit", process2.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/proper-lockfile/lib/mtime-precision.js
var require_mtime_precision = __commonJS({
  "node_modules/proper-lockfile/lib/mtime-precision.js"(exports2, module2) {
    "use strict";
    var cacheSymbol = Symbol();
    function probe(file, fs, callback) {
      const cachedPrecision = fs[cacheSymbol];
      if (cachedPrecision) {
        return fs.stat(file, (err, stat) => {
          if (err) {
            return callback(err);
          }
          callback(null, stat.mtime, cachedPrecision);
        });
      }
      const mtime = new Date(Math.ceil(Date.now() / 1e3) * 1e3 + 5);
      fs.utimes(file, mtime, mtime, (err) => {
        if (err) {
          return callback(err);
        }
        fs.stat(file, (err2, stat) => {
          if (err2) {
            return callback(err2);
          }
          const precision = stat.mtime.getTime() % 1e3 === 0 ? "s" : "ms";
          Object.defineProperty(fs, cacheSymbol, { value: precision });
          callback(null, stat.mtime, precision);
        });
      });
    }
    function getMtime(precision) {
      let now = Date.now();
      if (precision === "s") {
        now = Math.ceil(now / 1e3) * 1e3;
      }
      return new Date(now);
    }
    module2.exports.probe = probe;
    module2.exports.getMtime = getMtime;
  }
});

// node_modules/proper-lockfile/lib/lockfile.js
var require_lockfile = __commonJS({
  "node_modules/proper-lockfile/lib/lockfile.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fs = require_graceful_fs();
    var retry = require_retry2();
    var onExit = require_signal_exit();
    var mtimePrecision = require_mtime_precision();
    var locks = {};
    function getLockFile(file, options) {
      return options.lockfilePath || `${file}.lock`;
    }
    function resolveCanonicalPath(file, options, callback) {
      if (!options.realpath) {
        return callback(null, path.resolve(file));
      }
      options.fs.realpath(file, callback);
    }
    function acquireLock(file, options, callback) {
      const lockfilePath = getLockFile(file, options);
      options.fs.mkdir(lockfilePath, (err) => {
        if (!err) {
          return mtimePrecision.probe(lockfilePath, options.fs, (err2, mtime, mtimePrecision2) => {
            if (err2) {
              options.fs.rmdir(lockfilePath, () => {
              });
              return callback(err2);
            }
            callback(null, mtime, mtimePrecision2);
          });
        }
        if (err.code !== "EEXIST") {
          return callback(err);
        }
        if (options.stale <= 0) {
          return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
        }
        options.fs.stat(lockfilePath, (err2, stat) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return acquireLock(file, __spreadProps(__spreadValues({}, options), { stale: 0 }), callback);
            }
            return callback(err2);
          }
          if (!isLockStale(stat, options)) {
            return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
          }
          removeLock(file, options, (err3) => {
            if (err3) {
              return callback(err3);
            }
            acquireLock(file, __spreadProps(__spreadValues({}, options), { stale: 0 }), callback);
          });
        });
      });
    }
    function isLockStale(stat, options) {
      return stat.mtime.getTime() < Date.now() - options.stale;
    }
    function removeLock(file, options, callback) {
      options.fs.rmdir(getLockFile(file, options), (err) => {
        if (err && err.code !== "ENOENT") {
          return callback(err);
        }
        callback();
      });
    }
    function updateLock(file, options) {
      const lock2 = locks[file];
      if (lock2.updateTimeout) {
        return;
      }
      lock2.updateDelay = lock2.updateDelay || options.update;
      lock2.updateTimeout = setTimeout(() => {
        lock2.updateTimeout = null;
        options.fs.stat(lock2.lockfilePath, (err, stat) => {
          const isOverThreshold = lock2.lastUpdate + options.stale < Date.now();
          if (err) {
            if (err.code === "ENOENT" || isOverThreshold) {
              return setLockAsCompromised(file, lock2, Object.assign(err, { code: "ECOMPROMISED" }));
            }
            lock2.updateDelay = 1e3;
            return updateLock(file, options);
          }
          const isMtimeOurs = lock2.mtime.getTime() === stat.mtime.getTime();
          if (!isMtimeOurs) {
            return setLockAsCompromised(file, lock2, Object.assign(new Error("Unable to update lock within the stale threshold"), { code: "ECOMPROMISED" }));
          }
          const mtime = mtimePrecision.getMtime(lock2.mtimePrecision);
          options.fs.utimes(lock2.lockfilePath, mtime, mtime, (err2) => {
            const isOverThreshold2 = lock2.lastUpdate + options.stale < Date.now();
            if (lock2.released) {
              return;
            }
            if (err2) {
              if (err2.code === "ENOENT" || isOverThreshold2) {
                return setLockAsCompromised(file, lock2, Object.assign(err2, { code: "ECOMPROMISED" }));
              }
              lock2.updateDelay = 1e3;
              return updateLock(file, options);
            }
            lock2.mtime = mtime;
            lock2.lastUpdate = Date.now();
            lock2.updateDelay = null;
            updateLock(file, options);
          });
        });
      }, lock2.updateDelay);
      if (lock2.updateTimeout.unref) {
        lock2.updateTimeout.unref();
      }
    }
    function setLockAsCompromised(file, lock2, err) {
      lock2.released = true;
      if (lock2.updateTimeout) {
        clearTimeout(lock2.updateTimeout);
      }
      if (locks[file] === lock2) {
        delete locks[file];
      }
      lock2.options.onCompromised(err);
    }
    function lock(file, options, callback) {
      options = __spreadValues({
        stale: 1e4,
        update: null,
        realpath: true,
        retries: 0,
        fs,
        onCompromised: (err) => {
          throw err;
        }
      }, options);
      options.retries = options.retries || 0;
      options.retries = typeof options.retries === "number" ? { retries: options.retries } : options.retries;
      options.stale = Math.max(options.stale || 0, 2e3);
      options.update = options.update == null ? options.stale / 2 : options.update || 0;
      options.update = Math.max(Math.min(options.update, options.stale / 2), 1e3);
      resolveCanonicalPath(file, options, (err, file2) => {
        if (err) {
          return callback(err);
        }
        const operation = retry.operation(options.retries);
        operation.attempt(() => {
          acquireLock(file2, options, (err2, mtime, mtimePrecision2) => {
            if (operation.retry(err2)) {
              return;
            }
            if (err2) {
              return callback(operation.mainError());
            }
            const lock2 = locks[file2] = {
              lockfilePath: getLockFile(file2, options),
              mtime,
              mtimePrecision: mtimePrecision2,
              options,
              lastUpdate: Date.now()
            };
            updateLock(file2, options);
            callback(null, (releasedCallback) => {
              if (lock2.released) {
                return releasedCallback && releasedCallback(Object.assign(new Error("Lock is already released"), { code: "ERELEASED" }));
              }
              unlock(file2, __spreadProps(__spreadValues({}, options), { realpath: false }), releasedCallback);
            });
          });
        });
      });
    }
    function unlock(file, options, callback) {
      options = __spreadValues({
        fs,
        realpath: true
      }, options);
      resolveCanonicalPath(file, options, (err, file2) => {
        if (err) {
          return callback(err);
        }
        const lock2 = locks[file2];
        if (!lock2) {
          return callback(Object.assign(new Error("Lock is not acquired/owned by you"), { code: "ENOTACQUIRED" }));
        }
        lock2.updateTimeout && clearTimeout(lock2.updateTimeout);
        lock2.released = true;
        delete locks[file2];
        removeLock(file2, options, callback);
      });
    }
    function check(file, options, callback) {
      options = __spreadValues({
        stale: 1e4,
        realpath: true,
        fs
      }, options);
      options.stale = Math.max(options.stale || 0, 2e3);
      resolveCanonicalPath(file, options, (err, file2) => {
        if (err) {
          return callback(err);
        }
        options.fs.stat(getLockFile(file2, options), (err2, stat) => {
          if (err2) {
            return err2.code === "ENOENT" ? callback(null, false) : callback(err2);
          }
          return callback(null, !isLockStale(stat, options));
        });
      });
    }
    function getLocks() {
      return locks;
    }
    onExit(() => {
      for (const file in locks) {
        const options = locks[file].options;
        try {
          options.fs.rmdirSync(getLockFile(file, options));
        } catch (e) {
        }
      }
    });
    module2.exports.lock = lock;
    module2.exports.unlock = unlock;
    module2.exports.check = check;
    module2.exports.getLocks = getLocks;
  }
});

// node_modules/proper-lockfile/lib/adapter.js
var require_adapter = __commonJS({
  "node_modules/proper-lockfile/lib/adapter.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    function createSyncFs(fs2) {
      const methods = ["mkdir", "realpath", "stat", "rmdir", "utimes"];
      const newFs = __spreadValues({}, fs2);
      methods.forEach((method) => {
        newFs[method] = (...args) => {
          const callback = args.pop();
          let ret;
          try {
            ret = fs2[`${method}Sync`](...args);
          } catch (err) {
            return callback(err);
          }
          callback(null, ret);
        };
      });
      return newFs;
    }
    function toPromise(method) {
      return (...args) => new Promise((resolve, reject) => {
        args.push((err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        });
        method(...args);
      });
    }
    function toSync(method) {
      return (...args) => {
        let err;
        let result;
        args.push((_err, _result) => {
          err = _err;
          result = _result;
        });
        method(...args);
        if (err) {
          throw err;
        }
        return result;
      };
    }
    function toSyncOptions(options) {
      options = __spreadValues({}, options);
      options.fs = createSyncFs(options.fs || fs);
      if (typeof options.retries === "number" && options.retries > 0 || options.retries && typeof options.retries.retries === "number" && options.retries.retries > 0) {
        throw Object.assign(new Error("Cannot use retries with the sync api"), { code: "ESYNC" });
      }
      return options;
    }
    module2.exports = {
      toPromise,
      toSync,
      toSyncOptions
    };
  }
});

// node_modules/proper-lockfile/index.js
var require_proper_lockfile = __commonJS({
  "node_modules/proper-lockfile/index.js"(exports2, module2) {
    "use strict";
    var lockfile = require_lockfile();
    var { toPromise, toSync, toSyncOptions } = require_adapter();
    function lock(file, options) {
      return __async(this, null, function* () {
        const release = yield toPromise(lockfile.lock)(file, options);
        return toPromise(release);
      });
    }
    function lockSync(file, options) {
      const release = toSync(lockfile.lock)(file, toSyncOptions(options));
      return toSync(release);
    }
    function unlock(file, options) {
      return toPromise(lockfile.unlock)(file, options);
    }
    function unlockSync(file, options) {
      return toSync(lockfile.unlock)(file, toSyncOptions(options));
    }
    function check(file, options) {
      return toPromise(lockfile.check)(file, options);
    }
    function checkSync(file, options) {
      return toSync(lockfile.check)(file, toSyncOptions(options));
    }
    module2.exports = lock;
    module2.exports.lock = lock;
    module2.exports.unlock = unlock;
    module2.exports.lockSync = lockSync;
    module2.exports.unlockSync = unlockSync;
    module2.exports.check = check;
    module2.exports.checkSync = checkSync;
  }
});

// node_modules/playwright-core/lib/utils/nativeDeps.js
var require_nativeDeps = __commonJS({
  "node_modules/playwright-core/lib/utils/nativeDeps.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.deps = void 0;
    var deps = {
      "ubuntu18.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "ttf-unifont", "libfontconfig", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "ttf-ubuntu-font-family"],
        chromium: ["fonts-liberation", "libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libegl1", "libgbm1", "libglib2.0-0", "libgtk-3-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libx11-xcb1", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxrandr2", "libxshmfence1"],
        firefox: ["ffmpeg", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libglib2.0-0", "libgtk-3-0", "libpango-1.0-0", "libpangocairo-1.0-0", "libpangoft2-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrender1", "libxt6"],
        webkit: ["gstreamer1.0-libav", "gstreamer1.0-plugins-bad", "gstreamer1.0-plugins-base", "gstreamer1.0-plugins-good", "libatk-bridge2.0-0", "libatk1.0-0", "libbrotli1", "libcairo2", "libegl1", "libenchant1c2a", "libepoxy0", "libevdev2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libgl1", "libgles2", "libglib2.0-0", "libgstreamer-gl1.0-0", "libgstreamer1.0-0", "libgtk-3-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libicu60", "libjpeg-turbo8", "libnotify4", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libsecret-1-0", "libvpx5", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebp6", "libwebpdemux2", "libwoff1", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1"],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libbrotlidec.so.1": "libbrotli1",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libenchant.so.1": "libenchant1c2a",
          "libepoxy.so.0": "libepoxy0",
          "libevent-2.1.so.6": "libevent-2.1-6",
          "libevdev.so.2": "libevdev2",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgdk-x11-2.0.so.0": "libgtk2.0-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGL.so.1": "libgl1",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstapp-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstaudio-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstcodecparsers-1.0.so.0": "gstreamer1.0-plugins-bad",
          "libgstfft-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstvideo-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgthread-2.0.so.0": "libglib2.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgtk-x11-2.0.so.0": "libgtk2.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libicudata.so.60": "libicu60",
          "libicui18n.so.60": "libicu60",
          "libicuuc.so.60": "libicu60",
          "libjpeg.so.8": "libjpeg-turbo8",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libvpx.so.5": "libvpx5",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-dri3.so.0": "libxcb-dri3-0",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxslt.so.1": "libxslt1.1",
          "libXt.so.6": "libxt6",
          "libXtst.so.6": "libxtst6"
        }
      },
      "ubuntu20.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "ttf-unifont", "libfontconfig", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "ttf-ubuntu-font-family"],
        chromium: ["fonts-liberation", "libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libegl1", "libgbm1", "libglib2.0-0", "libgtk-3-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libx11-xcb1", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxrandr2", "libxshmfence1"],
        firefox: ["ffmpeg", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libglib2.0-0", "libgtk-3-0", "libpango-1.0-0", "libpangocairo-1.0-0", "libpangoft2-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrender1", "libxt6"],
        webkit: ["gstreamer1.0-libav", "gstreamer1.0-plugins-bad", "gstreamer1.0-plugins-base", "gstreamer1.0-plugins-good", "libatk-bridge2.0-0", "libatk1.0-0", "libcairo2", "libegl1", "libenchant1c2a", "libepoxy0", "libevdev2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libgl1", "libgles2", "libglib2.0-0", "libgstreamer-gl1.0-0", "libgstreamer1.0-0", "libgtk-3-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libicu66", "libjpeg-turbo8", "libnotify4", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libsecret-1-0", "libsoup2.4-1", "libvpx6", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebp6", "libwebpdemux2", "libwoff1", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1"],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libenchant.so.1": "libenchant1c2a",
          "libevdev.so.2": "libevdev2",
          "libepoxy.so.0": "libepoxy0",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgdk-x11-2.0.so.0": "libgtk2.0-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGL.so.1": "libgl1",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstapp-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstaudio-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstcodecparsers-1.0.so.0": "gstreamer1.0-plugins-bad",
          "libgstfft-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstvideo-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgthread-2.0.so.0": "libglib2.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgtk-x11-2.0.so.0": "libgtk2.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libicui18n.so.66": "libicu66",
          "libicuuc.so.66": "libicu66",
          "libjpeg.so.8": "libjpeg-turbo8",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libsoup-2.4.so.1": "libsoup2.4-1",
          "libvpx.so.6": "libvpx6",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-dri3.so.0": "libxcb-dri3-0",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxslt.so.1": "libxslt1.1",
          "libXt.so.6": "libxt6",
          "libXtst.so.6": "libxtst6",
          "libxshmfence.so.1": "libxshmfence1"
        }
      },
      "ubuntu21.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "ttf-unifont", "libfontconfig", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "ttf-ubuntu-font-family"],
        chromium: ["libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libgbm1", "libglib2.0-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxkbcommon0", "libxrandr2", "libxshmfence1"],
        firefox: ["ffmpeg", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf-2.0-0", "libglib2.0-0", "libgtk-3-0", "libgtk2.0-0", "libharfbuzz0b", "libpango-1.0-0", "libpangocairo-1.0-0", "libpangoft2-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrender1", "libxt6"],
        webkit: ["gstreamer1.0-libav", "gstreamer1.0-plugins-bad", "gstreamer1.0-plugins-base", "gstreamer1.0-plugins-good", "libatk-bridge2.0-0", "libatk1.0-0", "libcairo2", "libegl1", "libepoxy0", "libevdev2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf-2.0-0", "libgl1", "libgles2", "libglib2.0-0", "libgstreamer-gl1.0-0", "libgstreamer-plugins-bad1.0-0", "libgstreamer-plugins-base1.0-0", "libgstreamer1.0-0", "libgtk-3-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libjavascriptcoregtk-4.0-18", "libjpeg-turbo8", "liblcms2-2", "libnotify4", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libsecret-1-0", "libsoup2.4-1", "libvpx6", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebkit2gtk-4.0-37", "libwebp6", "libwebpdemux2", "libwoff1", "libwpe-1.0-1", "libwpebackend-fdo-1.0-1", "libwpewebkit-1.0-3", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1"],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libepoxy.so.0": "libepoxy0",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf-2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgdk-x11-2.0.so.0": "libgtk2.0-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGL.so.1": "libgl1",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstapp-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstaudio-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstcodecparsers-1.0.so.0": "libgstreamer-plugins-bad1.0-0",
          "libgstfft-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstvideo-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgthread-2.0.so.0": "libglib2.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgtk-x11-2.0.so.0": "libgtk2.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libjavascriptcoregtk-4.0.so.18": "libjavascriptcoregtk-4.0-18",
          "libjpeg.so.8": "libjpeg-turbo8",
          "liblcms2.so.2": "liblcms2-2",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libsoup-2.4.so.1": "libsoup2.4-1",
          "libvpx.so.6": "libvpx6",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebkit2gtk-4.0.so.37": "libwebkit2gtk-4.0-37",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libwpe-1.0.so.1": "libwpe-1.0-1",
          "libWPEBackend-fdo-1.0.so.1": "libwpebackend-fdo-1.0-1",
          "libWPEWebKit-1.0.so.3": "libwpewebkit-1.0-3",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxshmfence.so.1": "libxshmfence1",
          "libxslt.so.1": "libxslt1.1",
          "libXt.so.6": "libxt6"
        }
      }
    };
    exports2.deps = deps;
    deps["ubuntu20.04-arm64"] = {
      tools: [...deps["ubuntu20.04"].tools],
      chromium: [...deps["ubuntu20.04"].chromium],
      firefox: [...deps["ubuntu20.04"].firefox],
      webkit: [...deps["ubuntu20.04"].webkit, "libevent-2.1-7"],
      lib2package: __spreadProps(__spreadValues({}, deps["ubuntu20.04"].lib2package), {
        "libevent-2.1.so.7": "libevent-2.1.so.7"
      })
    };
  }
});

// node_modules/playwright-core/lib/utils/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/playwright-core/lib/utils/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.installDependenciesWindows = installDependenciesWindows;
    exports2.installDependenciesLinux = installDependenciesLinux;
    exports2.validateDependenciesWindows = validateDependenciesWindows;
    exports2.validateDependenciesLinux = validateDependenciesLinux;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _path2 = _interopRequireDefault2(require("path"));
    var os = _interopRequireWildcard2(require("os"));
    var _child_process2 = _interopRequireDefault2(require("child_process"));
    var utils = _interopRequireWildcard2(require_utils());
    var _registry2 = require_registry();
    var _nativeDeps = require_nativeDeps();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var BIN_DIRECTORY = _path2.default.join(__dirname, "..", "..", "bin");
    var checkExecutable = (filePath) => _fs2.default.promises.access(filePath, _fs2.default.constants.X_OK).then(() => true).catch((e) => false);
    function isSupportedWindowsVersion() {
      if (os.platform() !== "win32" || os.arch() !== "x64")
        return false;
      const [major, minor] = os.release().split(".").map((token) => parseInt(token, 10));
      return major > 6 || major === 6 && minor > 1;
    }
    function installDependenciesWindows(targets, dryRun) {
      return __async(this, null, function* () {
        if (targets.has("chromium")) {
          const command = "powershell.exe";
          const args = ["-ExecutionPolicy", "Bypass", "-File", _path2.default.join(BIN_DIRECTORY, "install_media_pack.ps1")];
          if (dryRun) {
            console.log(`${command} ${quoteProcessArgs(args).join(" ")}`);
            return;
          }
          const {
            code
          } = yield utils.spawnAsync(command, args, {
            cwd: BIN_DIRECTORY,
            stdio: "inherit"
          });
          if (code !== 0)
            throw new Error("Failed to install windows dependencies!");
        }
      });
    }
    function installDependenciesLinux(targets, dryRun) {
      return __async(this, null, function* () {
        const libraries = [];
        for (const target of targets) {
          const info = _nativeDeps.deps[utils.hostPlatform];
          if (!info) {
            console.warn("Cannot install dependencies for this linux distribution!");
            return;
          }
          libraries.push(...info[target]);
        }
        const uniqueLibraries = Array.from(new Set(libraries));
        if (!dryRun)
          console.log("Installing Ubuntu dependencies...");
        const commands = [];
        commands.push("apt-get update");
        commands.push(["apt-get", "install", "-y", "--no-install-recommends", ...uniqueLibraries].join(" "));
        const {
          command,
          args,
          elevatedPermissions
        } = yield utils.transformCommandsForRoot(commands);
        if (dryRun) {
          console.log(`${command} ${quoteProcessArgs(args).join(" ")}`);
          return;
        }
        if (elevatedPermissions)
          console.log("Switching to root user to install dependencies...");
        const child = _child_process2.default.spawn(command, args, {
          stdio: "inherit"
        });
        yield new Promise((resolve, reject) => {
          child.on("exit", resolve);
          child.on("error", reject);
        });
      });
    }
    function validateDependenciesWindows(windowsExeAndDllDirectories) {
      return __async(this, null, function* () {
        const directoryPaths = windowsExeAndDllDirectories;
        const lddPaths = [];
        for (const directoryPath of directoryPaths)
          lddPaths.push(...yield executablesOrSharedLibraries(directoryPath));
        const allMissingDeps = yield Promise.all(lddPaths.map((lddPath) => missingFileDependenciesWindows(lddPath)));
        const missingDeps = /* @__PURE__ */ new Set();
        for (const deps of allMissingDeps) {
          for (const dep of deps)
            missingDeps.add(dep);
        }
        if (!missingDeps.size)
          return;
        let isCrtMissing = false;
        let isMediaFoundationMissing = false;
        for (const dep of missingDeps) {
          if (dep.startsWith("api-ms-win-crt") || dep === "vcruntime140.dll" || dep === "vcruntime140_1.dll" || dep === "msvcp140.dll")
            isCrtMissing = true;
          else if (dep === "mf.dll" || dep === "mfplat.dll" || dep === "msmpeg2vdec.dll" || dep === "evr.dll" || dep === "avrt.dll")
            isMediaFoundationMissing = true;
        }
        const details = [];
        if (isCrtMissing) {
          details.push(`Some of the Universal C Runtime files cannot be found on the system. You can fix`, `that by installing Microsoft Visual C++ Redistributable for Visual Studio from:`, `https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads`, ``);
        }
        if (isMediaFoundationMissing) {
          details.push(`Some of the Media Foundation files cannot be found on the system. If you are`, `on Windows Server try fixing this by running the following command in PowerShell`, `as Administrator:`, ``, `    Install-WindowsFeature Server-Media-Foundation`, ``, `For Windows N editions visit:`, `https://support.microsoft.com/en-us/help/3145500/media-feature-pack-list-for-windows-n-editions`, ``);
        }
        details.push(`Full list of missing libraries:`, `    ${[...missingDeps].join("\n    ")}`, ``);
        const message = `Host system is missing dependencies!

${details.join("\n")}`;
        if (isSupportedWindowsVersion()) {
          throw new Error(message);
        } else {
          console.warn(`WARNING: running on unsupported windows version!`);
          console.warn(message);
        }
      });
    }
    function validateDependenciesLinux(sdkLanguage, linuxLddDirectories, dlOpenLibraries) {
      return __async(this, null, function* () {
        var _deps$utils$hostPlatf;
        const directoryPaths = linuxLddDirectories;
        const lddPaths = [];
        for (const directoryPath of directoryPaths)
          lddPaths.push(...yield executablesOrSharedLibraries(directoryPath));
        const allMissingDeps = yield Promise.all(lddPaths.map((lddPath) => missingFileDependencies(lddPath, directoryPaths)));
        const missingDeps = /* @__PURE__ */ new Set();
        for (const deps of allMissingDeps) {
          for (const dep of deps)
            missingDeps.add(dep);
        }
        for (const dep of yield missingDLOPENLibraries(dlOpenLibraries))
          missingDeps.add(dep);
        if (!missingDeps.size)
          return;
        const missingPackages = /* @__PURE__ */ new Set();
        const libraryToPackageNameMapping = __spreadValues(__spreadValues({}, ((_deps$utils$hostPlatf = _nativeDeps.deps[utils.hostPlatform]) === null || _deps$utils$hostPlatf === void 0 ? void 0 : _deps$utils$hostPlatf.lib2package) || {}), MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU);
        for (const missingDep of missingDeps) {
          const packageName = libraryToPackageNameMapping[missingDep];
          if (packageName) {
            missingPackages.add(packageName);
            missingDeps.delete(missingDep);
          }
        }
        const maybeSudo = process.getuid() !== 0 && os.platform() !== "win32" ? "sudo " : "";
        if (missingPackages.size && !missingDeps.size) {
          throw new Error("\n" + utils.wrapInASCIIBox([`Host system is missing a few dependencies to run browsers.`, `Please install them with the following command:`, ``, `    ${maybeSudo}${(0, _registry2.buildPlaywrightCLICommand)(sdkLanguage, "install-deps")}`, ``, `<3 Playwright Team`].join("\n"), 1));
        }
        let missingPackagesMessage = "";
        if (missingPackages.size) {
          missingPackagesMessage = [`  Install missing packages with:`, `      ${maybeSudo}apt-get install ${[...missingPackages].join("\\\n          ")}`, ``, ``].join("\n");
        }
        let missingDependenciesMessage = "";
        if (missingDeps.size) {
          const header = missingPackages.size ? `Missing libraries we didn't find packages for:` : `Missing libraries are:`;
          missingDependenciesMessage = [`  ${header}`, `      ${[...missingDeps].join("\n      ")}`, ``].join("\n");
        }
        throw new Error("Host system is missing dependencies!\n\n" + missingPackagesMessage + missingDependenciesMessage);
      });
    }
    function isSharedLib(basename) {
      switch (os.platform()) {
        case "linux":
          return basename.endsWith(".so") || basename.includes(".so.");
        case "win32":
          return basename.endsWith(".dll");
        default:
          return false;
      }
    }
    function executablesOrSharedLibraries(directoryPath) {
      return __async(this, null, function* () {
        const allPaths = (yield _fs2.default.promises.readdir(directoryPath)).map((file) => _path2.default.resolve(directoryPath, file));
        const allStats = yield Promise.all(allPaths.map((aPath) => _fs2.default.promises.stat(aPath)));
        const filePaths = allPaths.filter((aPath, index) => allStats[index].isFile());
        const executablersOrLibraries = (yield Promise.all(filePaths.map((filePath) => __async(this, null, function* () {
          const basename = _path2.default.basename(filePath).toLowerCase();
          if (isSharedLib(basename))
            return filePath;
          if (yield checkExecutable(filePath))
            return filePath;
          return false;
        })))).filter(Boolean);
        return executablersOrLibraries;
      });
    }
    function missingFileDependenciesWindows(filePath) {
      return __async(this, null, function* () {
        const executable = _path2.default.join(__dirname, "..", "..", "bin", "PrintDeps.exe");
        const dirname = _path2.default.dirname(filePath);
        const {
          stdout,
          code
        } = yield utils.spawnAsync(executable, [filePath], {
          cwd: dirname,
          env: __spreadProps(__spreadValues({}, process.env), {
            LD_LIBRARY_PATH: process.env.LD_LIBRARY_PATH ? `${process.env.LD_LIBRARY_PATH}:${dirname}` : dirname
          })
        });
        if (code !== 0)
          return [];
        const missingDeps = stdout.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim().toLowerCase());
        return missingDeps;
      });
    }
    function missingFileDependencies(filePath, extraLDPaths) {
      return __async(this, null, function* () {
        const dirname = _path2.default.dirname(filePath);
        let LD_LIBRARY_PATH = extraLDPaths.join(":");
        if (process.env.LD_LIBRARY_PATH)
          LD_LIBRARY_PATH = `${process.env.LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}`;
        const {
          stdout,
          code
        } = yield utils.spawnAsync("ldd", [filePath], {
          cwd: dirname,
          env: __spreadProps(__spreadValues({}, process.env), {
            LD_LIBRARY_PATH
          })
        });
        if (code !== 0)
          return [];
        const missingDeps = stdout.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim());
        return missingDeps;
      });
    }
    function missingDLOPENLibraries(libraries) {
      return __async(this, null, function* () {
        if (!libraries.length)
          return [];
        const {
          stdout,
          code,
          error
        } = yield utils.spawnAsync("/sbin/ldconfig", ["-p"], {});
        if (code !== 0 || error)
          return [];
        const isLibraryAvailable = (library) => stdout.toLowerCase().includes(library.toLowerCase());
        return libraries.filter((library) => !isLibraryAvailable(library));
      });
    }
    var MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU = {
      "libx264.so": "gstreamer1.0-libav"
    };
    function quoteProcessArgs(args) {
      return args.map((arg) => {
        if (arg.includes(" "))
          return `"${arg}"`;
        return arg;
      });
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports2, module2) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports2, module2) {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs = require("fs");
    var noop = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs)
        return false;
      return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop);
        if (isRequest(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module2.exports = pump;
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options) => {
      options = __spreadValues({}, options);
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var pump = require_pump();
    var bufferStream = require_buffer_stream();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    function getStream(inputStream, options) {
      return __async(this, null, function* () {
        if (!inputStream) {
          return Promise.reject(new Error("Expected a stream"));
        }
        options = __spreadValues({
          maxBuffer: Infinity
        }, options);
        const { maxBuffer } = options;
        let stream;
        yield new Promise((resolve, reject) => {
          const rejectPromise = (error) => {
            if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
              error.bufferedData = stream.getBufferedValue();
            }
            reject(error);
          };
          stream = pump(inputStream, bufferStream(options), (error) => {
            if (error) {
              rejectPromise(error);
              return;
            }
            resolve();
          });
          stream.on("data", () => {
            if (stream.getBufferedLength() > maxBuffer) {
              rejectPromise(new MaxBufferError());
            }
          });
        });
        return stream.getBufferedValue();
      });
    }
    module2.exports = getStream;
    module2.exports.default = getStream;
    module2.exports.buffer = (stream, options) => getStream(stream, __spreadProps(__spreadValues({}, options), { encoding: "buffer" }));
    module2.exports.array = (stream, options) => getStream(stream, __spreadProps(__spreadValues({}, options), { array: true }));
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/pend/index.js"(exports2, module2) {
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called)
          throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "node_modules/fd-slicer/index.js"(exports2) {
    var fs = require("fs");
    var util = require("util");
    var stream = require("stream");
    var Readable = stream.Readable;
    var Writable = stream.Writable;
    var PassThrough = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports2.createFromBuffer = createFromBuffer;
    exports2.createFromFd = createFromFd;
    exports2.BufferSlicer = BufferSlicer;
    exports2.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options) {
      options = options || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options) {
      return new ReadStream(this, options);
    };
    FdSlicer.prototype.createWriteStream = function(options) {
      return new WriteStream(this, options);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      if (self2.autoClose) {
        fs.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options) {
      options = options || {};
      Readable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed)
        return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        var buffer = new Buffer(toRead);
        fs.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options) {
      options = options || {};
      Writable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end == null ? Infinity : +options.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed)
        return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        fs.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options) {
      EventEmitter.call(this);
      options = options || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var end = position + length;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length;
      this.buffer.copy(buffer, offset, position, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options) {
      options = options || {};
      var readStream = new PassThrough(options);
      readStream.destroyed = false;
      readStream.start = options.start || 0;
      readStream.endOffset = options.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options) {
      var bufferSlicer = this;
      options = options || {};
      var writeStream = new Writable(options);
      writeStream.start = options.start || 0;
      writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed)
          return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options) {
      return new BufferSlicer(buffer, options);
    }
    function createFromFd(fd, options) {
      return new FdSlicer(fd, options);
    }
  }
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/yauzl/index.js"(exports2) {
    var fs = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable = require("stream").Writable;
    exports2.open = open2;
    exports2.fromFd = fromFd;
    exports2.fromBuffer = fromBuffer;
    exports2.fromRandomAccessReader = fromRandomAccessReader;
    exports2.dosDateTimeToDate = dosDateTimeToDate;
    exports2.validateFileName = validateFileName;
    exports2.ZipFile = ZipFile;
    exports2.Entry = Entry;
    exports2.RandomAccessReader = RandomAccessReader;
    function open2(path, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.open(path, "r", function(err, fd) {
        if (err)
          return callback(err);
        fromFd(fd, options, function(err2, zipfile) {
          if (err2)
            fs.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.fstat(fd, function(err, stats) {
        if (err)
          return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options, callback);
      });
    }
    function fromBuffer(buffer, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      var decodeStrings = !!options.decodeStrings;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      if (typeof totalSize !== "number")
        throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err)
          return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256)
            continue;
          var eocdrBuffer = buffer.slice(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2)
              return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3)
                return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries)
        self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose)
        self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError)
        return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries)
        throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose)
            self2.close();
          if (self2.emittedError)
            return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError)
        return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err)
          return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError)
          return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248)
          return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64)
          return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2)
            return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError)
            return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null)
              return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries)
            self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options;
        options = {};
      } else {
        if (options.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options.decrypt !== false)
            throw new Error("invalid options.decrypt value: " + options.decrypt);
          if (entry.isCompressed()) {
            if (options.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options.decompress === false || options.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options.decompress);
          }
        }
        if (options.start != null || options.end != null) {
          if (entry.isCompressed() && options.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options.start != null) {
          relativeStart = options.start;
          if (relativeStart < 0)
            throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize)
            throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
          relativeEnd = options.end;
          if (relativeEnd < 0)
            throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize)
            throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart)
            throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen)
        return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options.decrypt !== false)
          return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err)
            return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options.decompress != null ? options.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed)
                    endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream)
                inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err)
          return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err)
          return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options) {
      var start = options.start;
      var end = options.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet)
        return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i = start; i < end; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function defaultCallback(err) {
      if (err)
        throw err;
    }
  }
});

// node_modules/extract-zip/index.js
var require_extract_zip = __commonJS({
  "node_modules/extract-zip/index.js"(exports2, module2) {
    var debug = require_src()("extract-zip");
    var { createWriteStream, promises: fs } = require("fs");
    var getStream = require_get_stream();
    var path = require("path");
    var { promisify } = require("util");
    var stream = require("stream");
    var yauzl = require_yauzl();
    var openZip = promisify(yauzl.open);
    var pipeline = promisify(stream.pipeline);
    var Extractor = class {
      constructor(zipPath, opts) {
        this.zipPath = zipPath;
        this.opts = opts;
      }
      extract() {
        return __async(this, null, function* () {
          debug("opening", this.zipPath, "with opts", this.opts);
          this.zipfile = yield openZip(this.zipPath, { lazyEntries: true });
          this.canceled = false;
          return new Promise((resolve, reject) => {
            this.zipfile.on("error", (err) => {
              this.canceled = true;
              reject(err);
            });
            this.zipfile.readEntry();
            this.zipfile.on("close", () => {
              if (!this.canceled) {
                debug("zip extraction complete");
                resolve();
              }
            });
            this.zipfile.on("entry", (entry) => __async(this, null, function* () {
              if (this.canceled) {
                debug("skipping entry", entry.fileName, { cancelled: this.canceled });
                return;
              }
              debug("zipfile entry", entry.fileName);
              if (entry.fileName.startsWith("__MACOSX/")) {
                this.zipfile.readEntry();
                return;
              }
              const destDir = path.dirname(path.join(this.opts.dir, entry.fileName));
              try {
                yield fs.mkdir(destDir, { recursive: true });
                const canonicalDestDir = yield fs.realpath(destDir);
                const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir);
                if (relativeDestDir.split(path.sep).includes("..")) {
                  throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
                }
                yield this.extractEntry(entry);
                debug("finished processing", entry.fileName);
                this.zipfile.readEntry();
              } catch (err) {
                this.canceled = true;
                this.zipfile.close();
                reject(err);
              }
            }));
          });
        });
      }
      extractEntry(entry) {
        return __async(this, null, function* () {
          if (this.canceled) {
            debug("skipping entry extraction", entry.fileName, { cancelled: this.canceled });
            return;
          }
          if (this.opts.onEntry) {
            this.opts.onEntry(entry, this.zipfile);
          }
          const dest = path.join(this.opts.dir, entry.fileName);
          const mode = entry.externalFileAttributes >> 16 & 65535;
          const IFMT = 61440;
          const IFDIR = 16384;
          const IFLNK = 40960;
          const symlink = (mode & IFMT) === IFLNK;
          let isDir = (mode & IFMT) === IFDIR;
          if (!isDir && entry.fileName.endsWith("/")) {
            isDir = true;
          }
          const madeBy = entry.versionMadeBy >> 8;
          if (!isDir)
            isDir = madeBy === 0 && entry.externalFileAttributes === 16;
          debug("extracting entry", { filename: entry.fileName, isDir, isSymlink: symlink });
          const procMode = this.getExtractedMode(mode, isDir) & 511;
          const destDir = isDir ? dest : path.dirname(dest);
          const mkdirOptions = { recursive: true };
          if (isDir) {
            mkdirOptions.mode = procMode;
          }
          debug("mkdir", __spreadValues({ dir: destDir }, mkdirOptions));
          yield fs.mkdir(destDir, mkdirOptions);
          if (isDir)
            return;
          debug("opening read stream", dest);
          const readStream = yield promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);
          if (symlink) {
            const link = yield getStream(readStream);
            debug("creating symlink", link, dest);
            yield fs.symlink(link, dest);
          } else {
            yield pipeline(readStream, createWriteStream(dest, { mode: procMode }));
          }
        });
      }
      getExtractedMode(entryMode, isDir) {
        let mode = entryMode;
        if (mode === 0) {
          if (isDir) {
            if (this.opts.defaultDirMode) {
              mode = parseInt(this.opts.defaultDirMode, 10);
            }
            if (!mode) {
              mode = 493;
            }
          } else {
            if (this.opts.defaultFileMode) {
              mode = parseInt(this.opts.defaultFileMode, 10);
            }
            if (!mode) {
              mode = 420;
            }
          }
        }
        return mode;
      }
    };
    module2.exports = function(zipPath, opts) {
      return __async(this, null, function* () {
        debug("creating target directory", opts.dir);
        if (!path.isAbsolute(opts.dir)) {
          throw new Error("Target directory is expected to be absolute");
        }
        yield fs.mkdir(opts.dir, { recursive: true });
        opts.dir = yield fs.realpath(opts.dir);
        return new Extractor(zipPath, opts).extract();
      });
    };
  }
});

// node_modules/playwright-core/lib/utils/browserFetcher.js
var require_browserFetcher = __commonJS({
  "node_modules/playwright-core/lib/utils/browserFetcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.downloadBrowserWithProgressBar = downloadBrowserWithProgressBar;
    exports2.logPolitely = logPolitely;
    var _extractZip = _interopRequireDefault2(require_extract_zip());
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _os2 = _interopRequireDefault2(require("os"));
    var _path2 = _interopRequireDefault2(require("path"));
    var _utils2 = require_utils();
    var _debugLogger = require_debugLogger();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function downloadBrowserWithProgressBar(title, browserDirectory, executablePath, downloadURL, downloadFileName) {
      return __async(this, null, function* () {
        const progressBarName = `Playwright build of ${title}`;
        if (yield (0, _utils2.existsAsync)(browserDirectory)) {
          _debugLogger.debugLogger.log("install", `browser ${title} is already downloaded.`);
          return false;
        }
        const url = downloadURL;
        const zipPath = _path2.default.join(_os2.default.tmpdir(), downloadFileName);
        try {
          yield (0, _utils2.download)(url, zipPath, {
            progressBarName,
            log: _debugLogger.debugLogger.log.bind(_debugLogger.debugLogger, "install"),
            userAgent: (0, _utils2.getUserAgent)()
          });
          _debugLogger.debugLogger.log("install", `extracting archive`);
          _debugLogger.debugLogger.log("install", `-- zip: ${zipPath}`);
          _debugLogger.debugLogger.log("install", `-- location: ${browserDirectory}`);
          yield (0, _extractZip.default)(zipPath, {
            dir: browserDirectory
          });
          _debugLogger.debugLogger.log("install", `fixing permissions at ${executablePath}`);
          yield _fs2.default.promises.chmod(executablePath, 493);
        } catch (e) {
          _debugLogger.debugLogger.log("install", `FAILED installation ${progressBarName} with error: ${e}`);
          process.exitCode = 1;
          throw e;
        } finally {
          if (yield (0, _utils2.existsAsync)(zipPath))
            yield _fs2.default.promises.unlink(zipPath);
        }
        logPolitely(`${progressBarName} downloaded to ${browserDirectory}`);
        return true;
      });
    }
    function logPolitely(toBeLogged) {
      const logLevel = process.env.npm_config_loglevel;
      const logLevelDisplay = ["silent", "error", "warn"].indexOf(logLevel || "") > -1;
      if (!logLevelDisplay)
        console.log(toBeLogged);
    }
  }
});

// node_modules/playwright-core/browsers.json
var require_browsers = __commonJS({
  "node_modules/playwright-core/browsers.json"(exports2, module2) {
    module2.exports = {
      comment: "Do not edit this file, use utils/roll_browser.js",
      browsers: [
        {
          name: "chromium",
          revision: "956323",
          installByDefault: true
        },
        {
          name: "chromium-with-symbols",
          revision: "956323",
          installByDefault: false
        },
        {
          name: "firefox",
          revision: "1313",
          installByDefault: true
        },
        {
          name: "firefox-beta",
          revision: "1314",
          installByDefault: false
        },
        {
          name: "webkit",
          revision: "1596",
          installByDefault: true,
          revisionOverrides: {
            "mac10.14": "1446"
          }
        },
        {
          name: "ffmpeg",
          revision: "1007",
          installByDefault: true
        }
      ]
    };
  }
});

// node_modules/playwright-core/lib/utils/registry.js
var require_registry = __commonJS({
  "node_modules/playwright-core/lib/utils/registry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildPlaywrightCLICommand = buildPlaywrightCLICommand;
    exports2.installDefaultBrowsersForNpmInstall = installDefaultBrowsersForNpmInstall;
    exports2.installBrowsersForNpmInstall = installBrowsersForNpmInstall;
    exports2.findChromiumChannel = findChromiumChannel;
    exports2.registry = exports2.Registry = exports2.registryDirectory = void 0;
    var os = _interopRequireWildcard2(require("os"));
    var _path2 = _interopRequireDefault2(require("path"));
    var util = _interopRequireWildcard2(require("util"));
    var fs = _interopRequireWildcard2(require("fs"));
    var _properLockfile = _interopRequireDefault2(require_proper_lockfile());
    var _ubuntuVersion = require_ubuntuVersion();
    var _utils2 = require_utils();
    var _dependencies = require_dependencies();
    var _browserFetcher = require_browserFetcher();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var PACKAGE_PATH = _path2.default.join(__dirname, "..", "..");
    var BIN_PATH = _path2.default.join(__dirname, "..", "..", "bin");
    var EXECUTABLE_PATHS = {
      "chromium": {
        "linux": ["chrome-linux", "chrome"],
        "mac": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "win": ["chrome-win", "chrome.exe"]
      },
      "firefox": {
        "linux": ["firefox", "firefox"],
        "mac": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "win": ["firefox", "firefox.exe"]
      },
      "webkit": {
        "linux": ["pw_run.sh"],
        "mac": ["pw_run.sh"],
        "win": ["Playwright.exe"]
      },
      "ffmpeg": {
        "linux": ["ffmpeg-linux"],
        "mac": ["ffmpeg-mac"],
        "win": ["ffmpeg-win64.exe"]
      }
    };
    var DOWNLOAD_PATHS = {
      "chromium": {
        "ubuntu18.04": "builds/chromium/%s/chromium-linux.zip",
        "ubuntu20.04": "builds/chromium/%s/chromium-linux.zip",
        "ubuntu18.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
        "ubuntu20.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
        "mac10.13": "builds/chromium/%s/chromium-mac.zip",
        "mac10.14": "builds/chromium/%s/chromium-mac.zip",
        "mac10.15": "builds/chromium/%s/chromium-mac.zip",
        "mac11": "builds/chromium/%s/chromium-mac.zip",
        "mac11-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
        "mac12": "builds/chromium/%s/chromium-mac.zip",
        "mac12-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
        "win64": "builds/chromium/%s/chromium-win64.zip"
      },
      "chromium-with-symbols": {
        "ubuntu18.04": "builds/chromium/%s/chromium-with-symbols-linux.zip",
        "ubuntu20.04": "builds/chromium/%s/chromium-with-symbols-linux.zip",
        "ubuntu18.04-arm64": "builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "ubuntu20.04-arm64": "builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "mac10.13": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac10.14": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac10.15": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac11": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac11-arm64": "builds/chromium/%s/chromium-with-symbols-mac-arm64.zip",
        "mac12": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac12-arm64": "builds/chromium/%s/chromium-with-symbols-mac-arm64.zip",
        "win64": "builds/chromium/%s/chromium-with-symbols-win64.zip"
      },
      "firefox": {
        "ubuntu18.04": "builds/firefox/%s/firefox-ubuntu-18.04.zip",
        "ubuntu20.04": "builds/firefox/%s/firefox-ubuntu-20.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": "builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip",
        "mac10.13": "builds/firefox/%s/firefox-mac-11.zip",
        "mac10.14": "builds/firefox/%s/firefox-mac-11.zip",
        "mac10.15": "builds/firefox/%s/firefox-mac-11.zip",
        "mac11": "builds/firefox/%s/firefox-mac-11.zip",
        "mac11-arm64": "builds/firefox/%s/firefox-mac-11-arm64.zip",
        "mac12": "builds/firefox/%s/firefox-mac-11.zip",
        "mac12-arm64": "builds/firefox/%s/firefox-mac-11-arm64.zip",
        "win64": "builds/firefox/%s/firefox-win64.zip"
      },
      "firefox-beta": {
        "ubuntu18.04": "builds/firefox-beta/%s/firefox-beta-ubuntu-18.04.zip",
        "ubuntu20.04": "builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": void 0,
        "mac10.13": "builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac10.14": "builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac10.15": "builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac11": "builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac11-arm64": "builds/firefox-beta/%s/firefox-beta-mac-11-arm64.zip",
        "mac12": "builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac12-arm64": "builds/firefox-beta/%s/firefox-beta-mac-11-arm64.zip",
        "win64": "builds/firefox-beta/%s/firefox-beta-win64.zip"
      },
      "webkit": {
        "ubuntu18.04": "builds/webkit/%s/webkit-ubuntu-18.04.zip",
        "ubuntu20.04": "builds/webkit/%s/webkit-ubuntu-20.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": "builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip",
        "mac10.13": void 0,
        "mac10.14": "builds/deprecated-webkit-mac-10.14/%s/deprecated-webkit-mac-10.14.zip",
        "mac10.15": "builds/webkit/%s/webkit-mac-10.15.zip",
        "mac11": "builds/webkit/%s/webkit-mac-10.15.zip",
        "mac11-arm64": "builds/webkit/%s/webkit-mac-11-arm64.zip",
        "mac12": "builds/webkit/%s/webkit-mac-12.zip",
        "mac12-arm64": "builds/webkit/%s/webkit-mac-12-arm64.zip",
        "win64": "builds/webkit/%s/webkit-win64.zip"
      },
      "ffmpeg": {
        "ubuntu18.04": "builds/ffmpeg/%s/ffmpeg-linux.zip",
        "ubuntu20.04": "builds/ffmpeg/%s/ffmpeg-linux.zip",
        "ubuntu18.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "ubuntu20.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "mac10.13": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac10.14": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac10.15": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac11": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac11-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
        "mac12": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac12-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
        "win64": "builds/ffmpeg/%s/ffmpeg-win64.zip"
      }
    };
    var registryDirectory = (() => {
      let result;
      const envDefined = (0, _utils2.getFromENV)("PLAYWRIGHT_BROWSERS_PATH");
      if (envDefined === "0") {
        result = _path2.default.join(__dirname, "..", "..", ".local-browsers");
      } else if (envDefined) {
        result = envDefined;
      } else {
        let cacheDirectory;
        if (process.platform === "linux")
          cacheDirectory = process.env.XDG_CACHE_HOME || _path2.default.join(os.homedir(), ".cache");
        else if (process.platform === "darwin")
          cacheDirectory = _path2.default.join(os.homedir(), "Library", "Caches");
        else if (process.platform === "win32")
          cacheDirectory = process.env.LOCALAPPDATA || _path2.default.join(os.homedir(), "AppData", "Local");
        else
          throw new Error("Unsupported platform: " + process.platform);
        result = _path2.default.join(cacheDirectory, "ms-playwright");
      }
      if (!_path2.default.isAbsolute(result)) {
        result = _path2.default.resolve((0, _utils2.getFromENV)("INIT_CWD") || process.cwd(), result);
      }
      return result;
    })();
    exports2.registryDirectory = registryDirectory;
    function isBrowserDirectory(browserDirectory) {
      const baseName = _path2.default.basename(browserDirectory);
      for (const browserName of allDownloadable) {
        if (baseName.startsWith(browserName + "-"))
          return true;
      }
      return false;
    }
    function readDescriptors(browsersJSON) {
      return browsersJSON["browsers"].map((obj) => {
        const name = obj.name;
        const revisionOverride = (obj.revisionOverrides || {})[_utils2.hostPlatform];
        const revision = revisionOverride || obj.revision;
        const browserDirectoryPrefix = revisionOverride ? `${name}_${_utils2.hostPlatform}_special` : `${name}`;
        const descriptor = {
          name,
          revision,
          installByDefault: !!obj.installByDefault,
          dir: _path2.default.join(registryDirectory, browserDirectoryPrefix.replace(/-/g, "_") + "-" + revision)
        };
        return descriptor;
      });
    }
    var allDownloadable = ["chromium", "firefox", "webkit", "ffmpeg", "firefox-beta", "chromium-with-symbols"];
    var Registry = class {
      constructor(browsersJSON) {
        this._executables = void 0;
        const descriptors = readDescriptors(browsersJSON);
        const findExecutablePath = (dir, name) => {
          let tokens = void 0;
          if (_utils2.hostPlatform.startsWith("ubuntu"))
            tokens = EXECUTABLE_PATHS[name]["linux"];
          else if (_utils2.hostPlatform.startsWith("mac"))
            tokens = EXECUTABLE_PATHS[name]["mac"];
          else if (_utils2.hostPlatform.startsWith("win"))
            tokens = EXECUTABLE_PATHS[name]["win"];
          return tokens ? _path2.default.join(dir, ...tokens) : void 0;
        };
        const executablePathOrDie = (name, e, installByDefault, sdkLanguage) => {
          if (!e)
            throw new Error(`${name} is not supported on ${_utils2.hostPlatform}`);
          const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install${installByDefault ? "" : " " + name}`);
          if (!(0, _utils2.canAccessFile)(e)) {
            const prettyMessage = [`Looks like Playwright Test or Playwright was just installed or updated.`, `Please run the following command to download new browser${installByDefault ? "s" : ""}:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join("\n");
            throw new Error(`Executable doesn't exist at ${e}
${(0, _utils2.wrapInASCIIBox)(prettyMessage, 1)}`);
          }
          return e;
        };
        this._executables = [];
        const chromium = descriptors.find((d) => d.name === "chromium");
        const chromiumExecutable = findExecutablePath(chromium.dir, "chromium");
        this._executables.push({
          type: "browser",
          name: "chromium",
          browserName: "chromium",
          directory: chromium.dir,
          executablePath: () => chromiumExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("chromium", chromiumExecutable, chromium.installByDefault, sdkLanguage),
          installType: chromium.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "chromium", chromium.dir, ["chrome-linux"], [], ["chrome-win"]),
          _install: () => this._downloadExecutable(chromium, chromiumExecutable, DOWNLOAD_PATHS["chromium"][_utils2.hostPlatform], "PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST"),
          _dependencyGroup: "chromium"
        });
        const chromiumWithSymbols = descriptors.find((d) => d.name === "chromium-with-symbols");
        const chromiumWithSymbolsExecutable = findExecutablePath(chromiumWithSymbols.dir, "chromium");
        this._executables.push({
          type: "tool",
          name: "chromium-with-symbols",
          browserName: "chromium",
          directory: chromiumWithSymbols.dir,
          executablePath: () => chromiumWithSymbolsExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("chromium-with-symbols", chromiumWithSymbolsExecutable, chromiumWithSymbols.installByDefault, sdkLanguage),
          installType: chromiumWithSymbols.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "chromium", chromiumWithSymbols.dir, ["chrome-linux"], [], ["chrome-win"]),
          _install: () => this._downloadExecutable(chromiumWithSymbols, chromiumWithSymbolsExecutable, DOWNLOAD_PATHS["chromium-with-symbols"][_utils2.hostPlatform], "PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST"),
          _dependencyGroup: "chromium"
        });
        this._executables.push(this._createChromiumChannel("chrome", {
          "linux": "/opt/google/chrome/chrome",
          "darwin": "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
          "win32": `\\Google\\Chrome\\Application\\chrome.exe`
        }, () => this._installChromiumChannel("chrome", {
          "linux": "reinstall_chrome_stable_linux.sh",
          "darwin": "reinstall_chrome_stable_mac.sh",
          "win32": "reinstall_chrome_stable_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("chrome-beta", {
          "linux": "/opt/google/chrome-beta/chrome",
          "darwin": "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta",
          "win32": `\\Google\\Chrome Beta\\Application\\chrome.exe`
        }, () => this._installChromiumChannel("chrome-beta", {
          "linux": "reinstall_chrome_beta_linux.sh",
          "darwin": "reinstall_chrome_beta_mac.sh",
          "win32": "reinstall_chrome_beta_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("chrome-dev", {
          "linux": "/opt/google/chrome-unstable/chrome",
          "darwin": "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev",
          "win32": `\\Google\\Chrome Dev\\Application\\chrome.exe`
        }));
        this._executables.push(this._createChromiumChannel("chrome-canary", {
          "linux": "",
          "darwin": "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
          "win32": `\\Google\\Chrome SxS\\Application\\chrome.exe`
        }));
        this._executables.push(this._createChromiumChannel("msedge", {
          "linux": "/opt/microsoft/msedge/msedge",
          "darwin": "/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge",
          "win32": `\\Microsoft\\Edge\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge", {
          "linux": "reinstall_msedge_stable_linux.sh",
          "darwin": "reinstall_msedge_stable_mac.sh",
          "win32": "reinstall_msedge_stable_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-beta", {
          "linux": "/opt/microsoft/msedge-beta/msedge",
          "darwin": "/Applications/Microsoft Edge Beta.app/Contents/MacOS/Microsoft Edge Beta",
          "win32": `\\Microsoft\\Edge Beta\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge-beta", {
          "darwin": "reinstall_msedge_beta_mac.sh",
          "linux": "reinstall_msedge_beta_linux.sh",
          "win32": "reinstall_msedge_beta_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-dev", {
          "linux": "/opt/microsoft/msedge-dev/msedge",
          "darwin": "/Applications/Microsoft Edge Dev.app/Contents/MacOS/Microsoft Edge Dev",
          "win32": `\\Microsoft\\Edge Dev\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge-dev", {
          "darwin": "reinstall_msedge_dev_mac.sh",
          "linux": "reinstall_msedge_dev_linux.sh",
          "win32": "reinstall_msedge_dev_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-canary", {
          "linux": "",
          "darwin": "/Applications/Microsoft Edge Canary.app/Contents/MacOS/Microsoft Edge Canary",
          "win32": `\\Microsoft\\Edge SxS\\Application\\msedge.exe`
        }));
        const firefox = descriptors.find((d) => d.name === "firefox");
        const firefoxExecutable = findExecutablePath(firefox.dir, "firefox");
        this._executables.push({
          type: "browser",
          name: "firefox",
          browserName: "firefox",
          directory: firefox.dir,
          executablePath: () => firefoxExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("firefox", firefoxExecutable, firefox.installByDefault, sdkLanguage),
          installType: firefox.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "firefox", firefox.dir, ["firefox"], [], ["firefox"]),
          _install: () => this._downloadExecutable(firefox, firefoxExecutable, DOWNLOAD_PATHS["firefox"][_utils2.hostPlatform], "PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST"),
          _dependencyGroup: "firefox"
        });
        const firefoxBeta = descriptors.find((d) => d.name === "firefox-beta");
        const firefoxBetaExecutable = findExecutablePath(firefoxBeta.dir, "firefox");
        this._executables.push({
          type: "tool",
          name: "firefox-beta",
          browserName: "firefox",
          directory: firefoxBeta.dir,
          executablePath: () => firefoxBetaExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("firefox-beta", firefoxBetaExecutable, firefoxBeta.installByDefault, sdkLanguage),
          installType: firefoxBeta.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "firefox", firefoxBeta.dir, ["firefox"], [], ["firefox"]),
          _install: () => this._downloadExecutable(firefoxBeta, firefoxBetaExecutable, DOWNLOAD_PATHS["firefox-beta"][_utils2.hostPlatform], "PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST"),
          _dependencyGroup: "firefox"
        });
        const webkit = descriptors.find((d) => d.name === "webkit");
        const webkitExecutable = findExecutablePath(webkit.dir, "webkit");
        const webkitLinuxLddDirectories = [_path2.default.join("minibrowser-gtk"), _path2.default.join("minibrowser-gtk", "bin"), _path2.default.join("minibrowser-gtk", "lib"), _path2.default.join("minibrowser-wpe"), _path2.default.join("minibrowser-wpe", "bin"), _path2.default.join("minibrowser-wpe", "lib")];
        this._executables.push({
          type: "browser",
          name: "webkit",
          browserName: "webkit",
          directory: webkit.dir,
          executablePath: () => webkitExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("webkit", webkitExecutable, webkit.installByDefault, sdkLanguage),
          installType: webkit.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "webkit", webkit.dir, webkitLinuxLddDirectories, ["libGLESv2.so.2", "libx264.so"], [""]),
          _install: () => this._downloadExecutable(webkit, webkitExecutable, DOWNLOAD_PATHS["webkit"][_utils2.hostPlatform], "PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST"),
          _dependencyGroup: "webkit"
        });
        const ffmpeg = descriptors.find((d) => d.name === "ffmpeg");
        const ffmpegExecutable = findExecutablePath(ffmpeg.dir, "ffmpeg");
        this._executables.push({
          type: "tool",
          name: "ffmpeg",
          browserName: void 0,
          directory: ffmpeg.dir,
          executablePath: () => ffmpegExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("ffmpeg", ffmpegExecutable, ffmpeg.installByDefault, sdkLanguage),
          installType: ffmpeg.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: () => Promise.resolve(),
          _install: () => this._downloadExecutable(ffmpeg, ffmpegExecutable, DOWNLOAD_PATHS["ffmpeg"][_utils2.hostPlatform], "PLAYWRIGHT_FFMPEG_DOWNLOAD_HOST"),
          _dependencyGroup: "tools"
        });
      }
      _createChromiumChannel(name, lookAt, install) {
        const executablePath = (sdkLanguage, shouldThrow) => {
          const suffix = lookAt[process.platform];
          if (!suffix) {
            if (shouldThrow)
              throw new Error(`Chromium distribution '${name}' is not supported on ${process.platform}`);
            return void 0;
          }
          const prefixes = process.platform === "win32" ? [process.env.LOCALAPPDATA, process.env.PROGRAMFILES, process.env["PROGRAMFILES(X86)"]].filter(Boolean) : [""];
          for (const prefix of prefixes) {
            const executablePath2 = _path2.default.join(prefix, suffix);
            if ((0, _utils2.canAccessFile)(executablePath2))
              return executablePath2;
          }
          if (!shouldThrow)
            return void 0;
          const location2 = prefixes.length ? ` at ${_path2.default.join(prefixes[0], suffix)}` : ``;
          const installation = install ? `
Run "${buildPlaywrightCLICommand(sdkLanguage, "install " + name)}"` : "";
          throw new Error(`Chromium distribution '${name}' is not found${location2}${installation}`);
        };
        return {
          type: "channel",
          name,
          browserName: "chromium",
          directory: void 0,
          executablePath: (sdkLanguage) => executablePath(sdkLanguage, false),
          executablePathOrDie: (sdkLanguage) => executablePath(sdkLanguage, true),
          installType: install ? "install-script" : "none",
          validateHostRequirements: () => Promise.resolve(),
          _install: install
        };
      }
      executables() {
        return this._executables;
      }
      findExecutable(name) {
        return this._executables.find((b) => b.name === name);
      }
      defaultExecutables() {
        return this._executables.filter((e) => e.installType === "download-by-default");
      }
      _addRequirementsAndDedupe(executables) {
        const set = /* @__PURE__ */ new Set();
        for (const executable of executables) {
          set.add(executable);
          if (executable.browserName === "chromium")
            set.add(this.findExecutable("ffmpeg"));
        }
        return Array.from(set);
      }
      _validateHostRequirements(sdkLanguage, browserName, browserDirectory, linuxLddDirectories, dlOpenLibraries, windowsExeAndDllDirectories) {
        return __async(this, null, function* () {
          if ((0, _utils2.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS")) {
            process.stdout.write("Skipping host requirements validation logic because `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS` env variable is set.\n");
            return;
          }
          const ubuntuVersion = yield (0, _ubuntuVersion.getUbuntuVersion)();
          if (browserName === "firefox" && ubuntuVersion === "16.04")
            throw new Error(`Cannot launch Firefox on Ubuntu 16.04! Minimum required Ubuntu version for Firefox browser is 18.04`);
          if (os.platform() === "linux")
            return yield (0, _dependencies.validateDependenciesLinux)(sdkLanguage, linuxLddDirectories.map((d) => _path2.default.join(browserDirectory, d)), dlOpenLibraries);
          if (os.platform() === "win32" && os.arch() === "x64")
            return yield (0, _dependencies.validateDependenciesWindows)(windowsExeAndDllDirectories.map((d) => _path2.default.join(browserDirectory, d)));
        });
      }
      installDeps(executablesToInstallDeps, dryRun) {
        return __async(this, null, function* () {
          const executables = this._addRequirementsAndDedupe(executablesToInstallDeps);
          const targets = /* @__PURE__ */ new Set();
          for (const executable of executables) {
            if (executable._dependencyGroup)
              targets.add(executable._dependencyGroup);
          }
          targets.add("tools");
          if (os.platform() === "win32")
            return yield (0, _dependencies.installDependenciesWindows)(targets, dryRun);
          if (os.platform() === "linux")
            return yield (0, _dependencies.installDependenciesLinux)(targets, dryRun);
        });
      }
      install(executablesToInstall) {
        return __async(this, null, function* () {
          const executables = this._addRequirementsAndDedupe(executablesToInstall);
          yield fs.promises.mkdir(registryDirectory, {
            recursive: true
          });
          const lockfilePath = _path2.default.join(registryDirectory, "__dirlock");
          const linksDir = _path2.default.join(registryDirectory, ".links");
          let releaseLock;
          try {
            releaseLock = yield _properLockfile.default.lock(registryDirectory, {
              retries: {
                retries: 20,
                factor: 1.27579
              },
              onCompromised: (err) => {
                throw new Error(`${err.message} Path: ${lockfilePath}`);
              },
              lockfilePath
            });
            yield fs.promises.mkdir(linksDir, {
              recursive: true
            });
            yield fs.promises.writeFile(_path2.default.join(linksDir, (0, _utils2.calculateSha1)(PACKAGE_PATH)), PACKAGE_PATH);
            yield this._validateInstallationCache(linksDir);
            for (const executable of executables) {
              if (executable._install)
                yield executable._install();
              else
                throw new Error(`ERROR: Playwright does not support installing ${executable.name}`);
            }
          } catch (e) {
            if (e.code === "ELOCKED") {
              const rmCommand = process.platform === "win32" ? "rm -R" : "rm -rf";
              throw new Error("\n" + (0, _utils2.wrapInASCIIBox)([`An active lockfile is found at:`, ``, `  ${lockfilePath}`, ``, `Either:`, `- wait a few minutes if other Playwright is installing browsers in parallel`, `- remove lock manually with:`, ``, `    ${rmCommand} ${lockfilePath}`, ``, `<3 Playwright Team`].join("\n"), 1));
            } else {
              throw e;
            }
          } finally {
            if (releaseLock)
              yield releaseLock();
          }
        });
      }
      _downloadExecutable(descriptor, executablePath, downloadPathTemplate, downloadHostEnv) {
        return __async(this, null, function* () {
          if (!downloadPathTemplate || !executablePath)
            throw new Error(`ERROR: Playwright does not support ${descriptor.name} on ${_utils2.hostPlatform}`);
          const downloadHost = downloadHostEnv && (0, _utils2.getFromENV)(downloadHostEnv) || (0, _utils2.getFromENV)("PLAYWRIGHT_DOWNLOAD_HOST") || "https://playwright.azureedge.net";
          const downloadPath = util.format(downloadPathTemplate, descriptor.revision);
          const downloadURL = `${downloadHost}/${downloadPath}`;
          const title = `${descriptor.name} v${descriptor.revision}`;
          const downloadFileName = `playwright-download-${descriptor.name}-${_utils2.hostPlatform}-${descriptor.revision}.zip`;
          yield (0, _browserFetcher.downloadBrowserWithProgressBar)(title, descriptor.dir, executablePath, downloadURL, downloadFileName).catch((e) => {
            throw new Error(`Failed to download ${title}, caused by
${e.stack}`);
          });
          yield fs.promises.writeFile(markerFilePath(descriptor.dir), "");
        });
      }
      _installMSEdgeChannel(channel, scripts) {
        return __async(this, null, function* () {
          const scriptArgs = [];
          if (process.platform !== "linux") {
            const products = JSON.parse(yield (0, _utils2.fetchData)({
              url: "https://edgeupdates.microsoft.com/api/products"
            }));
            const productName = {
              "msedge": "Stable",
              "msedge-beta": "Beta",
              "msedge-dev": "Dev"
            }[channel];
            const product = products.find((product2) => product2.Product === productName);
            const searchConfig = {
              darwin: {
                platform: "MacOS",
                arch: "universal",
                artifact: "pkg"
              },
              win32: {
                platform: "Windows",
                arch: "x64",
                artifact: "msi"
              }
            }[process.platform];
            const release = searchConfig ? product.Releases.find((release2) => release2.Platform === searchConfig.platform && release2.Architecture === searchConfig.arch) : null;
            const artifact = release ? release.Artifacts.find((artifact2) => artifact2.ArtifactName === searchConfig.artifact) : null;
            if (artifact)
              scriptArgs.push(artifact.Location);
            else
              throw new Error(`Cannot install ${channel} on ${process.platform}`);
          }
          yield this._installChromiumChannel(channel, scripts, scriptArgs);
        });
      }
      _installChromiumChannel(_0, _1) {
        return __async(this, arguments, function* (channel, scripts, scriptArgs = []) {
          const scriptName = scripts[process.platform];
          if (!scriptName)
            throw new Error(`Cannot install ${channel} on ${process.platform}`);
          const cwd = BIN_PATH;
          const isPowerShell = scriptName.endsWith(".ps1");
          if (isPowerShell) {
            const args = ["-ExecutionPolicy", "Bypass", "-File", _path2.default.join(BIN_PATH, scriptName), ...scriptArgs];
            const {
              code
            } = yield (0, _utils2.spawnAsync)("powershell.exe", args, {
              cwd,
              stdio: "inherit"
            });
            if (code !== 0)
              throw new Error(`Failed to install ${channel}`);
          } else {
            const {
              command,
              args,
              elevatedPermissions
            } = yield (0, _utils2.transformCommandsForRoot)([`bash ${_path2.default.join(BIN_PATH, scriptName)} ${scriptArgs.join("")}`]);
            if (elevatedPermissions)
              console.log("Switching to root user to install dependencies...");
            const {
              code
            } = yield (0, _utils2.spawnAsync)(command, args, {
              cwd,
              stdio: "inherit"
            });
            if (code !== 0)
              throw new Error(`Failed to install ${channel}`);
          }
        });
      }
      _validateInstallationCache(linksDir) {
        return __async(this, null, function* () {
          const usedBrowserPaths = /* @__PURE__ */ new Set();
          for (const fileName of yield fs.promises.readdir(linksDir)) {
            const linkPath = _path2.default.join(linksDir, fileName);
            let linkTarget = "";
            try {
              linkTarget = (yield fs.promises.readFile(linkPath)).toString();
              const browsersJSON = require(_path2.default.join(linkTarget, "browsers.json"));
              const descriptors = readDescriptors(browsersJSON);
              for (const browserName of allDownloadable) {
                const descriptor = descriptors.find((d) => d.name === browserName);
                if (!descriptor)
                  continue;
                const usedBrowserPath = descriptor.dir;
                const browserRevision = parseInt(descriptor.revision, 10);
                const shouldHaveMarkerFile = browserName === "chromium" && browserRevision >= 786218 || browserName === "firefox" && browserRevision >= 1128 || browserName === "webkit" && browserRevision >= 1307 || browserName !== "firefox" && browserName !== "chromium" && browserName !== "webkit";
                if (!shouldHaveMarkerFile || (yield (0, _utils2.existsAsync)(markerFilePath(usedBrowserPath))))
                  usedBrowserPaths.add(usedBrowserPath);
              }
            } catch (e) {
              yield fs.promises.unlink(linkPath).catch((e2) => {
              });
            }
          }
          if (!(0, _utils2.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_BROWSER_GC")) {
            let downloadedBrowsers = (yield fs.promises.readdir(registryDirectory)).map((file) => _path2.default.join(registryDirectory, file));
            downloadedBrowsers = downloadedBrowsers.filter((file) => isBrowserDirectory(file));
            const directories = new Set(downloadedBrowsers);
            for (const browserDirectory of usedBrowserPaths)
              directories.delete(browserDirectory);
            for (const directory of directories)
              (0, _browserFetcher.logPolitely)("Removing unused browser at " + directory);
            yield (0, _utils2.removeFolders)([...directories]);
          }
        });
      }
    };
    exports2.Registry = Registry;
    function markerFilePath(browserDirectory) {
      return _path2.default.join(browserDirectory, "INSTALLATION_COMPLETE");
    }
    function buildPlaywrightCLICommand(sdkLanguage, parameters) {
      switch (sdkLanguage) {
        case "python":
          return `playwright ${parameters}`;
        case "java":
          return `mvn exec:java -e -Dexec.mainClass=com.microsoft.playwright.CLI -Dexec.args="${parameters}"`;
        case "csharp":
          return `playwright ${parameters}`;
        default:
          return `npx playwright ${parameters}`;
      }
    }
    function installDefaultBrowsersForNpmInstall() {
      return __async(this, null, function* () {
        const defaultBrowserNames = registry.defaultExecutables().map((e) => e.name);
        return installBrowsersForNpmInstall(defaultBrowserNames);
      });
    }
    function installBrowsersForNpmInstall(browsers2) {
      return __async(this, null, function* () {
        if ((0, _utils2.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD")) {
          (0, _browserFetcher.logPolitely)("Skipping browsers download because `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD` env variable is set");
          return false;
        }
        const executables = [];
        for (const browserName of browsers2) {
          const executable = registry.findExecutable(browserName);
          if (!executable || executable.installType === "none")
            throw new Error(`Cannot install ${browserName}`);
          executables.push(executable);
        }
        yield registry.install(executables);
      });
    }
    function findChromiumChannel(sdkLanguage) {
      let channel = null;
      for (const name of ["chromium", "chrome", "msedge"]) {
        try {
          registry.findExecutable(name).executablePathOrDie(sdkLanguage);
          channel = name === "chromium" ? void 0 : name;
          break;
        } catch (e) {
        }
      }
      if (channel === null) {
        const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install chromium`);
        const prettyMessage = [`No chromium-based browser found on the system.`, `Please run the following command to download one:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join("\n");
        throw new Error("\n" + (0, _utils2.wrapInASCIIBox)(prettyMessage, 1));
      }
      return channel;
    }
    var registry = new Registry(require_browsers());
    exports2.registry = registry;
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/recorderApp.js
var require_recorderApp = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/recorderApp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RecorderApp = void 0;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _path2 = _interopRequireDefault2(require("path"));
    var _progress = require_progress2();
    var _events = require("events");
    var _instrumentation = require_instrumentation();
    var _utils2 = require_utils();
    var mime = _interopRequireWildcard2(require_mime());
    var _crApp = require_crApp();
    var _registry2 = require_registry();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var RecorderApp = class extends _events.EventEmitter {
      constructor(page, wsEndpoint) {
        super();
        this._page = void 0;
        this.wsEndpoint = void 0;
        this.setMaxListeners(0);
        this._page = page;
        this.wsEndpoint = wsEndpoint;
      }
      close() {
        return __async(this, null, function* () {
          yield this._page.context().close((0, _instrumentation.internalCallMetadata)());
        });
      }
      _init() {
        return __async(this, null, function* () {
          yield (0, _crApp.installAppIcon)(this._page);
          yield this._page._setServerRequestInterceptor((route) => __async(this, null, function* () {
            if (route.request().url().startsWith("https://playwright/")) {
              const uri = route.request().url().substring("https://playwright/".length);
              const file = require.resolve("../../../webpack/recorder/" + uri);
              const buffer = yield _fs2.default.promises.readFile(file);
              yield route.fulfill({
                status: 200,
                headers: [{
                  name: "Content-Type",
                  value: mime.getType(_path2.default.extname(file)) || "application/octet-stream"
                }],
                body: buffer.toString("base64"),
                isBase64: true
              });
              return;
            }
            yield route.continue();
          }));
          yield this._page.exposeBinding("dispatch", false, (_, data) => this.emit("event", data));
          this._page.once("close", () => {
            this.emit("close");
            this._page.context().close((0, _instrumentation.internalCallMetadata)()).catch((e) => console.error(e));
          });
          const mainFrame = this._page.mainFrame();
          yield mainFrame.goto((0, _instrumentation.internalCallMetadata)(), "https://playwright/index.html");
        });
      }
      static open(sdkLanguage, headed) {
        return __async(this, null, function* () {
          const recorderPlaywright = require_playwright().createPlaywright("javascript", true);
          const args = ["--app=data:text/html,", "--window-size=600,600", "--window-position=1280,10", "--test-type="];
          if (process.env.PWTEST_RECORDER_PORT)
            args.push(`--remote-debugging-port=${process.env.PWTEST_RECORDER_PORT}`);
          const context = yield recorderPlaywright.chromium.launchPersistentContext((0, _instrumentation.internalCallMetadata)(), "", {
            channel: (0, _registry2.findChromiumChannel)(sdkLanguage),
            args,
            noDefaultViewport: true,
            ignoreDefaultArgs: ["--enable-automation"],
            headless: !!process.env.PWTEST_CLI_HEADLESS || (0, _utils2.isUnderTest)() && !headed,
            useWebSocket: !!process.env.PWTEST_RECORDER_PORT
          });
          const controller = new _progress.ProgressController((0, _instrumentation.internalCallMetadata)(), context._browser);
          yield controller.run((progress) => __async(this, null, function* () {
            yield context._browser._defaultContext._loadDefaultContextAsIs(progress);
          }));
          const [page] = context.pages();
          const result = new RecorderApp(page, context._browser.options.wsEndpoint);
          yield result._init();
          return result;
        });
      }
      setMode(mode) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((mode2) => {
            window.playwrightSetMode(mode2);
          }).toString(), true, mode, "main").catch(() => {
          });
        });
      }
      setFile(file) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((file2) => {
            window.playwrightSetFile(file2);
          }).toString(), true, file, "main").catch(() => {
          });
        });
      }
      setPaused(paused) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((paused2) => {
            window.playwrightSetPaused(paused2);
          }).toString(), true, paused, "main").catch(() => {
          });
        });
      }
      setSources(sources) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((sources2) => {
            window.playwrightSetSources(sources2);
          }).toString(), true, sources, "main").catch(() => {
          });
          {
            if (process.env.PWTEST_CLI_EXIT && sources.length) {
              process.stdout.write("\n-------------8<-------------\n");
              process.stdout.write(sources[0].text);
              process.stdout.write("\n-------------8<-------------\n");
            }
          }
        });
      }
      setSelector(selector, focus) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((arg) => {
            window.playwrightSetSelector(arg.selector, arg.focus);
          }).toString(), true, {
            selector,
            focus
          }, "main").catch(() => {
          });
        });
      }
      updateCallLogs(callLogs) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((callLogs2) => {
            window.playwrightUpdateLogs(callLogs2);
          }).toString(), true, callLogs, "main").catch(() => {
          });
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._page.bringToFront();
        });
      }
    };
    exports2.RecorderApp = RecorderApp;
  }
});

// node_modules/playwright-core/lib/server/supplements/recorder/recorderUtils.js
var require_recorderUtils = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorder/recorderUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.metadataToCallLog = metadataToCallLog;
    function metadataToCallLog(metadata, status) {
      var _metadata$params, _metadata$params2;
      let title = metadata.apiName || metadata.method;
      if (metadata.method === "waitForEventInfo")
        title += `(${metadata.params.info.event})`;
      title = title.replace("object.expect", "expect");
      if (metadata.error)
        status = "error";
      const params = {
        url: (_metadata$params = metadata.params) === null || _metadata$params === void 0 ? void 0 : _metadata$params.url,
        selector: (_metadata$params2 = metadata.params) === null || _metadata$params2 === void 0 ? void 0 : _metadata$params2.selector
      };
      let duration = metadata.endTime ? metadata.endTime - metadata.startTime : void 0;
      if (typeof duration === "number" && metadata.pauseStartTime && metadata.pauseEndTime) {
        duration -= metadata.pauseEndTime - metadata.pauseStartTime;
        duration = Math.max(duration, 0);
      }
      const callLog = {
        id: metadata.id,
        messages: metadata.log,
        title,
        status,
        error: metadata.error,
        params,
        duration
      };
      return callLog;
    }
  }
});

// node_modules/playwright-core/lib/server/supplements/recorderSupplement.js
var require_recorderSupplement = __commonJS({
  "node_modules/playwright-core/lib/server/supplements/recorderSupplement.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RecorderSupplement = void 0;
    var fs = _interopRequireWildcard2(require("fs"));
    var _codeGenerator = require_codeGenerator();
    var _utils2 = require_utils3();
    var _page = require_page();
    var _frames = require_frames();
    var _browserContext = require_browserContext();
    var _java = require_java();
    var _javascript = require_javascript2();
    var _csharp = require_csharp();
    var _python = require_python();
    var recorderSource = _interopRequireWildcard2(require_recorderSource());
    var consoleApiSource = _interopRequireWildcard2(require_consoleApiSource());
    var _recorderApp = require_recorderApp();
    var _utils22 = require_utils();
    var _recorderUtils = require_recorderUtils();
    var _debugger = require_debugger();
    var _events = require("events");
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var symbol = Symbol("RecorderSupplement");
    var RecorderSupplement = class {
      static showInspector(context) {
        RecorderSupplement.show(context, {}).catch(() => {
        });
      }
      static show(context, params = {}) {
        let recorderPromise = context[symbol];
        if (!recorderPromise) {
          const recorder = new RecorderSupplement(context, params);
          recorderPromise = recorder.install().then(() => recorder);
          context[symbol] = recorderPromise;
        }
        return recorderPromise;
      }
      constructor(context, params) {
        this._context = void 0;
        this._mode = void 0;
        this._highlightedSelector = "";
        this._recorderApp = null;
        this._currentCallsMetadata = /* @__PURE__ */ new Map();
        this._recorderSources = [];
        this._userSources = /* @__PURE__ */ new Map();
        this._allMetadatas = /* @__PURE__ */ new Map();
        this._debugger = void 0;
        this._contextRecorder = void 0;
        this._mode = params.startRecording ? "recording" : "none";
        this._contextRecorder = new ContextRecorder(context, params);
        this._context = context;
        this._debugger = _debugger.Debugger.lookup(context);
        context.instrumentation.addListener(this, context);
      }
      install() {
        return __async(this, null, function* () {
          const recorderApp = yield _recorderApp.RecorderApp.open(this._context._browser.options.sdkLanguage, !!this._context._browser.options.headful);
          this._recorderApp = recorderApp;
          recorderApp.once("close", () => {
            this._debugger.resume(false);
            this._recorderApp = null;
          });
          recorderApp.on("event", (data) => {
            if (data.event === "setMode") {
              this._setMode(data.params.mode);
              this._refreshOverlay();
              return;
            }
            if (data.event === "selectorUpdated") {
              this._highlightedSelector = data.params.selector;
              this._refreshOverlay();
              return;
            }
            if (data.event === "step") {
              this._debugger.resume(true);
              return;
            }
            if (data.event === "resume") {
              this._debugger.resume(false);
              return;
            }
            if (data.event === "pause") {
              this._debugger.pauseOnNextStatement();
              return;
            }
            if (data.event === "clear") {
              this._contextRecorder.clearScript();
              return;
            }
          });
          yield Promise.all([recorderApp.setMode(this._mode), recorderApp.setPaused(this._debugger.isPaused()), this._pushAllSources()]);
          this._context.once(_browserContext.BrowserContext.Events.Close, () => {
            this._contextRecorder.dispose();
            recorderApp.close().catch(() => {
            });
          });
          this._contextRecorder.on(ContextRecorder.Events.Change, (data) => {
            var _this$_recorderApp;
            this._recorderSources = data.sources;
            this._pushAllSources();
            (_this$_recorderApp = this._recorderApp) === null || _this$_recorderApp === void 0 ? void 0 : _this$_recorderApp.setFile(data.primaryFileName);
          });
          yield this._context.exposeBinding("_playwrightRecorderState", false, (source) => {
            let actionSelector = this._highlightedSelector;
            let actionPoint;
            for (const [metadata, sdkObject] of this._currentCallsMetadata) {
              if (source.page === sdkObject.attribution.page) {
                actionPoint = metadata.point || actionPoint;
                actionSelector = actionSelector || metadata.params.selector;
              }
            }
            const uiState = {
              mode: this._mode,
              actionPoint,
              actionSelector
            };
            return uiState;
          });
          yield this._context.exposeBinding("_playwrightRecorderSetSelector", false, (_, selector) => __async(this, null, function* () {
            var _this$_recorderApp2, _this$_recorderApp3;
            this._setMode("none");
            yield (_this$_recorderApp2 = this._recorderApp) === null || _this$_recorderApp2 === void 0 ? void 0 : _this$_recorderApp2.setSelector(selector, true);
            yield (_this$_recorderApp3 = this._recorderApp) === null || _this$_recorderApp3 === void 0 ? void 0 : _this$_recorderApp3.bringToFront();
          }));
          yield this._context.exposeBinding("_playwrightResume", false, () => {
            this._debugger.resume(false);
          });
          yield this._context.extendInjectedScript(consoleApiSource.source);
          yield this._contextRecorder.install();
          if (this._debugger.isPaused())
            this._pausedStateChanged();
          this._debugger.on(_debugger.Debugger.Events.PausedStateChanged, () => this._pausedStateChanged());
          this._context.recorderAppForTest = recorderApp;
        });
      }
      _pausedStateChanged() {
        var _this$_recorderApp4;
        for (const {
          metadata,
          sdkObject
        } of this._debugger.pausedDetails()) {
          if (!this._currentCallsMetadata.has(metadata))
            this.onBeforeCall(sdkObject, metadata);
        }
        (_this$_recorderApp4 = this._recorderApp) === null || _this$_recorderApp4 === void 0 ? void 0 : _this$_recorderApp4.setPaused(this._debugger.isPaused());
        this._updateUserSources();
        this.updateCallLog([...this._currentCallsMetadata.keys()]);
      }
      _setMode(mode) {
        var _this$_recorderApp5;
        this._mode = mode;
        (_this$_recorderApp5 = this._recorderApp) === null || _this$_recorderApp5 === void 0 ? void 0 : _this$_recorderApp5.setMode(this._mode);
        this._contextRecorder.setEnabled(this._mode === "recording");
        this._debugger.setMuted(this._mode === "recording");
        if (this._mode !== "none")
          this._context.pages()[0].bringToFront().catch(() => {
          });
      }
      _refreshOverlay() {
        for (const page of this._context.pages())
          page.mainFrame().evaluateExpression("window._playwrightRefreshOverlay()", false, void 0, "main").catch(() => {
          });
      }
      onBeforeCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._mode === "recording")
            return;
          this._currentCallsMetadata.set(metadata, sdkObject);
          this._allMetadatas.set(metadata.id, metadata);
          this._updateUserSources();
          this.updateCallLog([metadata]);
          if (metadata.params && metadata.params.selector) {
            var _this$_recorderApp6;
            this._highlightedSelector = metadata.params.selector;
            (_this$_recorderApp6 = this._recorderApp) === null || _this$_recorderApp6 === void 0 ? void 0 : _this$_recorderApp6.setSelector(this._highlightedSelector).catch(() => {
            });
          }
        });
      }
      onAfterCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._mode === "recording")
            return;
          if (!metadata.error)
            this._currentCallsMetadata.delete(metadata);
          this._updateUserSources();
          this.updateCallLog([metadata]);
        });
      }
      _updateUserSources() {
        var _this$_recorderApp7;
        for (const source of this._userSources.values()) {
          source.highlight = [];
          source.revealLine = void 0;
        }
        let fileToSelect = void 0;
        for (const metadata of this._currentCallsMetadata.keys()) {
          if (!metadata.stack || !metadata.stack[0])
            continue;
          const {
            file,
            line
          } = metadata.stack[0];
          let source = this._userSources.get(file);
          if (!source) {
            source = {
              file,
              text: this._readSource(file),
              highlight: [],
              language: languageForFile(file)
            };
            this._userSources.set(file, source);
          }
          if (line) {
            const paused = this._debugger.isPaused(metadata);
            source.highlight.push({
              line,
              type: metadata.error ? "error" : paused ? "paused" : "running"
            });
            source.revealLine = line;
            fileToSelect = source.file;
          }
        }
        this._pushAllSources();
        if (fileToSelect)
          (_this$_recorderApp7 = this._recorderApp) === null || _this$_recorderApp7 === void 0 ? void 0 : _this$_recorderApp7.setFile(fileToSelect);
      }
      _pushAllSources() {
        var _this$_recorderApp8;
        (_this$_recorderApp8 = this._recorderApp) === null || _this$_recorderApp8 === void 0 ? void 0 : _this$_recorderApp8.setSources([...this._recorderSources, ...this._userSources.values()]);
      }
      onBeforeInputAction(sdkObject, metadata) {
        return __async(this, null, function* () {
        });
      }
      onCallLog(sdkObject, metadata, logName, message) {
        return __async(this, null, function* () {
          this.updateCallLog([metadata]);
        });
      }
      updateCallLog(metadatas) {
        var _this$_recorderApp9;
        if (this._mode === "recording")
          return;
        const logs = [];
        for (const metadata of metadatas) {
          if (!metadata.method || metadata.internal)
            continue;
          let status = "done";
          if (this._currentCallsMetadata.has(metadata))
            status = "in-progress";
          if (this._debugger.isPaused(metadata))
            status = "paused";
          logs.push((0, _recorderUtils.metadataToCallLog)(metadata, status));
        }
        (_this$_recorderApp9 = this._recorderApp) === null || _this$_recorderApp9 === void 0 ? void 0 : _this$_recorderApp9.updateCallLogs(logs);
      }
      _readSource(fileName) {
        try {
          return fs.readFileSync(fileName, "utf-8");
        } catch (e) {
          return "// No source available";
        }
      }
    };
    exports2.RecorderSupplement = RecorderSupplement;
    var ContextRecorder = class extends _events.EventEmitter {
      constructor(context, params) {
        super();
        this._generator = void 0;
        this._pageAliases = /* @__PURE__ */ new Map();
        this._lastPopupOrdinal = 0;
        this._lastDialogOrdinal = 0;
        this._lastDownloadOrdinal = 0;
        this._timers = /* @__PURE__ */ new Set();
        this._context = void 0;
        this._params = void 0;
        this._recorderSources = void 0;
        this._context = context;
        this._params = params;
        const language2 = params.language || context._browser.options.sdkLanguage;
        const languages = /* @__PURE__ */ new Set([new _java.JavaLanguageGenerator(), new _javascript.JavaScriptLanguageGenerator(false), new _javascript.JavaScriptLanguageGenerator(true), new _python.PythonLanguageGenerator(false), new _python.PythonLanguageGenerator(true), new _csharp.CSharpLanguageGenerator()]);
        const primaryLanguage = [...languages].find((l) => l.id === language2);
        if (!primaryLanguage)
          throw new Error(`
===============================
Unsupported language: '${language2}'
===============================
`);
        languages.delete(primaryLanguage);
        const orderedLanguages = [primaryLanguage, ...languages];
        this._recorderSources = [];
        const generator = new _codeGenerator.CodeGenerator(context._browser.options.name, !!params.startRecording, params.launchOptions || {}, params.contextOptions || {}, params.device, params.saveStorage);
        let text = "";
        generator.on("change", () => {
          this._recorderSources = [];
          for (const languageGenerator of orderedLanguages) {
            const source = {
              file: languageGenerator.fileName,
              text: generator.generateText(languageGenerator),
              language: languageGenerator.highlighter,
              highlight: []
            };
            source.revealLine = source.text.split("\n").length - 1;
            this._recorderSources.push(source);
            if (languageGenerator === orderedLanguages[0])
              text = source.text;
          }
          this.emit(ContextRecorder.Events.Change, {
            sources: this._recorderSources,
            primaryFileName: primaryLanguage.fileName
          });
        });
        if (params.outputFile) {
          context.on(_browserContext.BrowserContext.Events.BeforeClose, () => {
            fs.writeFileSync(params.outputFile, text);
            text = "";
          });
          process.on("exit", () => {
            if (text)
              fs.writeFileSync(params.outputFile, text);
          });
        }
        this._generator = generator;
      }
      install() {
        return __async(this, null, function* () {
          this._context.on(_browserContext.BrowserContext.Events.Page, (page) => this._onPage(page));
          for (const page of this._context.pages())
            this._onPage(page);
          yield this._context.exposeBinding("_playwrightRecorderPerformAction", false, (source, action) => this._performAction(source.frame, action));
          yield this._context.exposeBinding("_playwrightRecorderRecordAction", false, (source, action) => this._recordAction(source.frame, action));
          yield this._context.extendInjectedScript(recorderSource.source, {
            isUnderTest: (0, _utils22.isUnderTest)()
          });
        });
      }
      setEnabled(enabled) {
        this._generator.setEnabled(enabled);
      }
      dispose() {
        for (const timer of this._timers)
          clearTimeout(timer);
        this._timers.clear();
      }
      _onPage(page) {
        return __async(this, null, function* () {
          const frame = page.mainFrame();
          page.on("close", () => {
            this._pageAliases.delete(page);
            this._generator.addAction(__spreadProps(__spreadValues({
              pageAlias
            }, (0, _utils2.describeFrame)(page.mainFrame())), {
              committed: true,
              action: {
                name: "closePage",
                signals: []
              }
            }));
          });
          frame.on(_frames.Frame.Events.Navigation, () => this._onFrameNavigated(frame, page));
          page.on(_page.Page.Events.Download, () => this._onDownload(page));
          page.on(_page.Page.Events.Dialog, () => this._onDialog(page));
          const suffix = this._pageAliases.size ? String(++this._lastPopupOrdinal) : "";
          const pageAlias = "page" + suffix;
          this._pageAliases.set(page, pageAlias);
          if (page.opener()) {
            this._onPopup(page.opener(), page);
          } else {
            this._generator.addAction(__spreadProps(__spreadValues({
              pageAlias
            }, (0, _utils2.describeFrame)(page.mainFrame())), {
              committed: true,
              action: {
                name: "openPage",
                url: page.mainFrame().url(),
                signals: []
              }
            }));
          }
        });
      }
      clearScript() {
        this._generator.restart();
        if (!!this._params.startRecording) {
          for (const page of this._context.pages())
            this._onFrameNavigated(page.mainFrame(), page);
        }
      }
      _performAction(frame, action) {
        return __async(this, null, function* () {
          this._generator.commitLastAction();
          const page = frame._page;
          const actionInContext = __spreadProps(__spreadValues({
            pageAlias: this._pageAliases.get(page)
          }, (0, _utils2.describeFrame)(frame)), {
            action
          });
          const perform = (action2, params, cb) => __async(this, null, function* () {
            const callMetadata = {
              id: `call@${(0, _utils22.createGuid)()}`,
              apiName: "frame." + action2,
              objectId: frame.guid,
              pageId: frame._page.guid,
              frameId: frame.guid,
              wallTime: Date.now(),
              startTime: (0, _utils22.monotonicTime)(),
              endTime: 0,
              type: "Frame",
              method: action2,
              params,
              log: [],
              snapshots: []
            };
            this._generator.willPerformAction(actionInContext);
            try {
              yield frame.instrumentation.onBeforeCall(frame, callMetadata);
              yield cb(callMetadata);
            } catch (e) {
              callMetadata.endTime = (0, _utils22.monotonicTime)();
              yield frame.instrumentation.onAfterCall(frame, callMetadata);
              this._generator.performedActionFailed(actionInContext);
              return;
            }
            callMetadata.endTime = (0, _utils22.monotonicTime)();
            yield frame.instrumentation.onAfterCall(frame, callMetadata);
            const timer = setTimeout(() => {
              actionInContext.committed = true;
              this._timers.delete(timer);
            }, 5e3);
            this._generator.didPerformAction(actionInContext);
            this._timers.add(timer);
          });
          const kActionTimeout = 5e3;
          if (action.name === "click") {
            const {
              options
            } = (0, _utils2.toClickOptions)(action);
            yield perform("click", {
              selector: action.selector
            }, (callMetadata) => frame.click(callMetadata, action.selector, __spreadProps(__spreadValues({}, options), {
              timeout: kActionTimeout
            })));
          }
          if (action.name === "press") {
            const modifiers = (0, _utils2.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            yield perform("press", {
              selector: action.selector,
              key: shortcut
            }, (callMetadata) => frame.press(callMetadata, action.selector, shortcut, {
              timeout: kActionTimeout
            }));
          }
          if (action.name === "check")
            yield perform("check", {
              selector: action.selector
            }, (callMetadata) => frame.check(callMetadata, action.selector, {
              timeout: kActionTimeout
            }));
          if (action.name === "uncheck")
            yield perform("uncheck", {
              selector: action.selector
            }, (callMetadata) => frame.uncheck(callMetadata, action.selector, {
              timeout: kActionTimeout
            }));
          if (action.name === "select") {
            const values = action.options.map((value) => ({
              value
            }));
            yield perform("selectOption", {
              selector: action.selector,
              values
            }, (callMetadata) => frame.selectOption(callMetadata, action.selector, [], values, {
              timeout: kActionTimeout
            }));
          }
        });
      }
      _recordAction(frame, action) {
        return __async(this, null, function* () {
          this._generator.commitLastAction();
          this._generator.addAction(__spreadProps(__spreadValues({
            pageAlias: this._pageAliases.get(frame._page)
          }, (0, _utils2.describeFrame)(frame)), {
            action
          }));
        });
      }
      _onFrameNavigated(frame, page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, frame, {
          name: "navigation",
          url: frame.url()
        });
      }
      _onPopup(page, popup) {
        const pageAlias = this._pageAliases.get(page);
        const popupAlias = this._pageAliases.get(popup);
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "popup",
          popupAlias
        });
      }
      _onDownload(page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "download",
          downloadAlias: String(++this._lastDownloadOrdinal)
        });
      }
      _onDialog(page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "dialog",
          dialogAlias: String(++this._lastDialogOrdinal)
        });
      }
    };
    ContextRecorder.Events = {
      Change: "change"
    };
    function languageForFile(file) {
      if (file.endsWith(".py"))
        return "python";
      if (file.endsWith(".java"))
        return "java";
      if (file.endsWith(".cs"))
        return "csharp";
      return "javascript";
    }
  }
});

// node_modules/playwright-core/lib/server/browserContext.js
var require_browserContext = __commonJS({
  "node_modules/playwright-core/lib/server/browserContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertBrowserContextIsNotOwned = assertBrowserContextIsNotOwned;
    exports2.validateBrowserContextOptions = validateBrowserContextOptions;
    exports2.verifyGeolocation = verifyGeolocation;
    exports2.normalizeProxySettings = normalizeProxySettings;
    exports2.BrowserContext = void 0;
    var os = _interopRequireWildcard2(require("os"));
    var _timeoutSettings = require_timeoutSettings();
    var _utils2 = require_utils();
    var _helper = require_helper();
    var network = _interopRequireWildcard2(require_network());
    var _page = require_page();
    var _path2 = _interopRequireDefault2(require("path"));
    var _instrumentation = require_instrumentation();
    var _debugger = require_debugger();
    var _tracing = require_tracing();
    var _harRecorder = require_harRecorder();
    var _recorderSupplement = require_recorderSupplement();
    var consoleApiSource = _interopRequireWildcard2(require_consoleApiSource());
    var _fetch = require_fetch();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var BrowserContext = class extends _instrumentation.SdkObject {
      constructor(browser, options, browserContextId) {
        super(browser, "browser-context");
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._pageBindings = /* @__PURE__ */ new Map();
        this._options = void 0;
        this._requestInterceptor = void 0;
        this._isPersistentContext = void 0;
        this._closedStatus = "open";
        this._closePromise = void 0;
        this._closePromiseFulfill = void 0;
        this._permissions = /* @__PURE__ */ new Map();
        this._downloads = /* @__PURE__ */ new Set();
        this._browser = void 0;
        this._browserContextId = void 0;
        this._selectors = void 0;
        this._origins = /* @__PURE__ */ new Set();
        this._harRecorder = void 0;
        this.tracing = void 0;
        this.fetchRequest = void 0;
        this._customCloseHandler = void 0;
        this.attribution.context = this;
        this._browser = browser;
        this._options = options;
        this._browserContextId = browserContextId;
        this._isPersistentContext = !browserContextId;
        this._closePromise = new Promise((fulfill) => this._closePromiseFulfill = fulfill);
        this.fetchRequest = new _fetch.BrowserContextAPIRequestContext(this);
        if (this._options.recordHar)
          this._harRecorder = new _harRecorder.HarRecorder(this, __spreadProps(__spreadValues({}, this._options.recordHar), {
            path: _path2.default.join(this._browser.options.artifactsDir, `${(0, _utils2.createGuid)()}.har`)
          }));
        this.tracing = new _tracing.Tracing(this);
      }
      isPersistentContext() {
        return this._isPersistentContext;
      }
      _setSelectors(selectors) {
        this._selectors = selectors;
      }
      selectors() {
        return this._selectors || this._browser.options.selectors;
      }
      _initialize() {
        return __async(this, null, function* () {
          if (this.attribution.isInternal)
            return;
          const contextDebugger = new _debugger.Debugger(this);
          this.instrumentation.addListener(contextDebugger, this);
          if ((0, _utils2.debugMode)() === "inspector")
            yield _recorderSupplement.RecorderSupplement.show(this, {
              pauseOnNextStatement: true
            });
          if (contextDebugger.isPaused())
            _recorderSupplement.RecorderSupplement.showInspector(this);
          contextDebugger.on(_debugger.Debugger.Events.PausedStateChanged, () => {
            _recorderSupplement.RecorderSupplement.showInspector(this);
          });
          if ((0, _utils2.debugMode)() === "console")
            yield this.extendInjectedScript(consoleApiSource.source);
        });
      }
      _ensureVideosPath() {
        return __async(this, null, function* () {
          if (this._options.recordVideo)
            yield (0, _utils2.mkdirIfNeeded)(_path2.default.join(this._options.recordVideo.dir, "dummy"));
        });
      }
      _browserClosed() {
        for (const page of this.pages())
          page._didClose();
        this._didCloseInternal();
      }
      _didCloseInternal() {
        if (this._closedStatus === "closed") {
          return;
        }
        this._closedStatus = "closed";
        this._deleteAllDownloads();
        this._downloads.clear();
        if (this._isPersistentContext)
          this._onClosePersistent();
        this._closePromiseFulfill(new Error("Context closed"));
        this.emit(BrowserContext.Events.Close);
      }
      cookies() {
        return __async(this, arguments, function* (urls = []) {
          if (urls && !Array.isArray(urls))
            urls = [urls];
          return yield this._doCookies(urls);
        });
      }
      setHTTPCredentials(httpCredentials) {
        return this._doSetHTTPCredentials(httpCredentials);
      }
      exposeBinding(name, needsHandle, playwrightBinding) {
        return __async(this, null, function* () {
          if (this._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
          for (const page of this.pages()) {
            if (page.getBinding(name))
              throw new Error(`Function "${name}" has been already registered in one of the pages`);
          }
          const binding = new _page.PageBinding(name, playwrightBinding, needsHandle);
          this._pageBindings.set(name, binding);
          yield this._doExposeBinding(binding);
        });
      }
      grantPermissions(permissions, origin) {
        return __async(this, null, function* () {
          let resolvedOrigin = "*";
          if (origin) {
            const url = new URL(origin);
            resolvedOrigin = url.origin;
          }
          const existing = new Set(this._permissions.get(resolvedOrigin) || []);
          permissions.forEach((p) => existing.add(p));
          const list = [...existing.values()];
          this._permissions.set(resolvedOrigin, list);
          yield this._doGrantPermissions(resolvedOrigin, list);
        });
      }
      clearPermissions() {
        return __async(this, null, function* () {
          this._permissions.clear();
          yield this._doClearPermissions();
        });
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      _loadDefaultContextAsIs(progress) {
        return __async(this, null, function* () {
          if (!this.pages().length) {
            const waitForEvent = _helper.helper.waitForEvent(progress, this, BrowserContext.Events.Page);
            progress.cleanupWhenAborted(() => waitForEvent.dispose);
            const page = yield waitForEvent.promise;
            if (page._pageIsError)
              throw page._pageIsError;
          }
          const pages = this.pages();
          if (pages[0]._pageIsError)
            throw pages[0]._pageIsError;
          yield pages[0].mainFrame()._waitForLoadState(progress, "load");
          return pages;
        });
      }
      _loadDefaultContext(progress) {
        return __async(this, null, function* () {
          const pages = yield this._loadDefaultContextAsIs(progress);
          if (this._options.isMobile || this._options.locale) {
            const oldPage = pages[0];
            yield this.newPage(progress.metadata);
            yield oldPage.close(progress.metadata);
          }
        });
      }
      _authenticateProxyViaHeader() {
        const proxy = this._options.proxy || this._browser.options.proxy || {
          username: void 0,
          password: void 0
        };
        const {
          username,
          password
        } = proxy;
        if (username) {
          this._options.httpCredentials = {
            username,
            password
          };
          const token = Buffer.from(`${username}:${password}`).toString("base64");
          this._options.extraHTTPHeaders = network.mergeHeaders([this._options.extraHTTPHeaders, network.singleHeader("Proxy-Authorization", `Basic ${token}`)]);
        }
      }
      _authenticateProxyViaCredentials() {
        const proxy = this._options.proxy || this._browser.options.proxy;
        if (!proxy)
          return;
        const {
          username,
          password
        } = proxy;
        if (username)
          this._options.httpCredentials = {
            username,
            password: password || ""
          };
      }
      _setRequestInterceptor(handler) {
        return __async(this, null, function* () {
          this._requestInterceptor = handler;
          yield this._doUpdateRequestInterception();
        });
      }
      isClosingOrClosed() {
        return this._closedStatus !== "open";
      }
      _deleteAllDownloads() {
        return __async(this, null, function* () {
          yield Promise.all(Array.from(this._downloads).map((download) => download.artifact.deleteOnContextClose()));
        });
      }
      setCustomCloseHandler(handler) {
        this._customCloseHandler = handler;
      }
      close(metadata) {
        return __async(this, null, function* () {
          if (this._closedStatus === "open") {
            var _this$_harRecorder;
            this.emit(BrowserContext.Events.BeforeClose);
            this._closedStatus = "closing";
            yield (_this$_harRecorder = this._harRecorder) === null || _this$_harRecorder === void 0 ? void 0 : _this$_harRecorder.flush();
            yield this.tracing.dispose();
            const promises = [];
            for (const {
              context,
              artifact
            } of this._browser._idToVideo.values()) {
              if (context === this)
                promises.push(artifact.finishedPromise());
            }
            if (this._customCloseHandler) {
              yield this._customCloseHandler();
            } else if (this._isPersistentContext) {
              yield Promise.all(this.pages().map((page) => page.close(metadata)));
            } else {
              yield this._doClose();
            }
            promises.push(this._deleteAllDownloads());
            yield Promise.all(promises);
            if (this._customCloseHandler)
              return;
            if (this._isPersistentContext)
              yield this._browser.close();
            this._didCloseInternal();
          }
          yield this._closePromise;
        });
      }
      newPage(metadata) {
        return __async(this, null, function* () {
          const pageDelegate = yield this.newPageDelegate();
          const pageOrError = yield pageDelegate.pageOrError();
          if (pageOrError instanceof _page.Page) {
            if (pageOrError.isClosed())
              throw new Error("Page has been closed.");
            return pageOrError;
          }
          throw pageOrError;
        });
      }
      addVisitedOrigin(origin) {
        this._origins.add(origin);
      }
      storageState() {
        return __async(this, null, function* () {
          const result = {
            cookies: yield this.cookies(),
            origins: []
          };
          if (this._origins.size) {
            const internalMetadata = (0, _instrumentation.internalCallMetadata)();
            const page = yield this.newPage(internalMetadata);
            yield page._setServerRequestInterceptor((handler) => {
              handler.fulfill({
                body: "<html></html>"
              }).catch(() => {
              });
            });
            for (const origin of this._origins) {
              const originStorage = {
                origin,
                localStorage: []
              };
              const frame = page.mainFrame();
              yield frame.goto(internalMetadata, origin);
              const storage = yield frame.evaluateExpression(`({
          localStorage: Object.keys(localStorage).map(name => ({ name, value: localStorage.getItem(name) })),
        })`, false, void 0, "utility");
              originStorage.localStorage = storage.localStorage;
              if (storage.localStorage.length)
                result.origins.push(originStorage);
            }
            yield page.close(internalMetadata);
          }
          return result;
        });
      }
      setStorageState(metadata, state) {
        return __async(this, null, function* () {
          if (state.cookies)
            yield this.addCookies(state.cookies);
          if (state.origins && state.origins.length) {
            const internalMetadata = (0, _instrumentation.internalCallMetadata)();
            const page = yield this.newPage(internalMetadata);
            yield page._setServerRequestInterceptor((handler) => {
              handler.fulfill({
                body: "<html></html>"
              }).catch(() => {
              });
            });
            for (const originState of state.origins) {
              const frame = page.mainFrame();
              yield frame.goto(metadata, originState.origin);
              yield frame.evaluateExpression(`
          originState => {
            for (const { name, value } of (originState.localStorage || []))
              localStorage.setItem(name, value);
          }`, true, originState, "utility");
            }
            yield page.close(internalMetadata);
          }
        });
      }
      extendInjectedScript(source, arg) {
        return __async(this, null, function* () {
          const installInFrame = (frame) => frame.extendInjectedScript(source, arg).catch(() => {
          });
          const installInPage = (page) => {
            page.on(_page.Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);
            return Promise.all(page.frames().map(installInFrame));
          };
          this.on(BrowserContext.Events.Page, installInPage);
          return Promise.all(this.pages().map(installInPage));
        });
      }
    };
    exports2.BrowserContext = BrowserContext;
    BrowserContext.Events = {
      Close: "close",
      Page: "page",
      Request: "request",
      Response: "response",
      RequestFailed: "requestfailed",
      RequestFinished: "requestfinished",
      BeforeClose: "beforeclose",
      VideoStarted: "videostarted"
    };
    function assertBrowserContextIsNotOwned(context) {
      for (const page of context.pages()) {
        if (page._ownedContext)
          throw new Error("Please use browser.newContext() for multi-page scripts that share the context.");
      }
    }
    function validateBrowserContextOptions(options, browserOptions) {
      if (options.noDefaultViewport && options.deviceScaleFactor !== void 0)
        throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
      if (options.noDefaultViewport && options.isMobile !== void 0)
        throw new Error(`"isMobile" option is not supported with null "viewport"`);
      if (options.acceptDownloads === void 0)
        options.acceptDownloads = true;
      if (!options.viewport && !options.noDefaultViewport)
        options.viewport = {
          width: 1280,
          height: 720
        };
      if (options.recordVideo) {
        if (!options.recordVideo.size) {
          if (options.noDefaultViewport) {
            options.recordVideo.size = {
              width: 800,
              height: 600
            };
          } else {
            const size = options.viewport;
            const scale = Math.min(1, 800 / Math.max(size.width, size.height));
            options.recordVideo.size = {
              width: Math.floor(size.width * scale),
              height: Math.floor(size.height * scale)
            };
          }
        }
        options.recordVideo.size.width &= ~1;
        options.recordVideo.size.height &= ~1;
      }
      if (options.proxy) {
        if (!browserOptions.proxy && browserOptions.isChromium && os.platform() === "win32")
          throw new Error(`Browser needs to be launched with the global proxy. If all contexts override the proxy, global proxy will be never used and can be any string, for example "launch({ proxy: { server: 'http://per-context' } })"`);
        options.proxy = normalizeProxySettings(options.proxy);
      }
      if ((0, _utils2.debugMode)() === "inspector")
        options.bypassCSP = true;
      verifyGeolocation(options.geolocation);
    }
    function verifyGeolocation(geolocation) {
      if (!geolocation)
        return;
      geolocation.accuracy = geolocation.accuracy || 0;
      const {
        longitude,
        latitude,
        accuracy
      } = geolocation;
      if (longitude < -180 || longitude > 180)
        throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);
      if (latitude < -90 || latitude > 90)
        throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);
      if (accuracy < 0)
        throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);
    }
    function normalizeProxySettings(proxy) {
      let {
        server,
        bypass
      } = proxy;
      let url;
      try {
        url = new URL(server);
        if (!url.host || !url.protocol)
          url = new URL("http://" + server);
      } catch (e) {
        url = new URL("http://" + server);
      }
      if (url.protocol === "socks4:" && (proxy.username || proxy.password))
        throw new Error(`Socks4 proxy protocol does not support authentication`);
      if (url.protocol === "socks5:" && (proxy.username || proxy.password))
        throw new Error(`Browser does not support socks5 proxy authentication`);
      server = url.protocol + "//" + url.host;
      if (bypass)
        bypass = bypass.split(",").map((t) => t.trim()).join(",");
      return __spreadProps(__spreadValues({}, proxy), {
        server,
        bypass
      });
    }
  }
});

// node_modules/playwright-core/lib/server/download.js
var require_download = __commonJS({
  "node_modules/playwright-core/lib/server/download.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Download = void 0;
    var _path2 = _interopRequireDefault2(require("path"));
    var _page = require_page();
    var _utils2 = require_utils();
    var _artifact = require_artifact();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Download = class {
      constructor(page, downloadsPath, uuid, url, suggestedFilename) {
        this.artifact = void 0;
        this.url = void 0;
        this._page = void 0;
        this._suggestedFilename = void 0;
        const unaccessibleErrorMessage = !page._browserContext._options.acceptDownloads ? "Pass { acceptDownloads: true } when you are creating your browser context." : void 0;
        this.artifact = new _artifact.Artifact(page, _path2.default.join(downloadsPath, uuid), unaccessibleErrorMessage, () => {
          return this._page._browserContext._doCancelDownload(uuid);
        });
        this._page = page;
        this.url = url;
        this._suggestedFilename = suggestedFilename;
        page._browserContext._downloads.add(this);
        if (suggestedFilename !== void 0)
          this._page.emit(_page.Page.Events.Download, this);
      }
      _filenameSuggested(suggestedFilename) {
        (0, _utils2.assert)(this._suggestedFilename === void 0);
        this._suggestedFilename = suggestedFilename;
        this._page.emit(_page.Page.Events.Download, this);
      }
      suggestedFilename() {
        return this._suggestedFilename;
      }
    };
    exports2.Download = Download;
  }
});

// node_modules/playwright-core/lib/server/browser.js
var require_browser2 = __commonJS({
  "node_modules/playwright-core/lib/server/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Browser = void 0;
    var _browserContext = require_browserContext();
    var _page = require_page();
    var _download = require_download();
    var _instrumentation = require_instrumentation();
    var _artifact = require_artifact();
    var Browser = class extends _instrumentation.SdkObject {
      constructor(options) {
        super(options.rootSdkObject, "browser");
        this.options = void 0;
        this._downloads = /* @__PURE__ */ new Map();
        this._defaultContext = null;
        this._startedClosing = false;
        this._idToVideo = /* @__PURE__ */ new Map();
        this.attribution.browser = this;
        this.options = options;
      }
      _downloadCreated(page, uuid, url, suggestedFilename) {
        const download = new _download.Download(page, this.options.downloadsPath || "", uuid, url, suggestedFilename);
        this._downloads.set(uuid, download);
      }
      _downloadFilenameSuggested(uuid, suggestedFilename) {
        const download = this._downloads.get(uuid);
        if (!download)
          return;
        download._filenameSuggested(suggestedFilename);
      }
      _downloadFinished(uuid, error) {
        const download = this._downloads.get(uuid);
        if (!download)
          return;
        download.artifact.reportFinished(error);
        this._downloads.delete(uuid);
      }
      _videoStarted(context, videoId, path, pageOrError) {
        const artifact = new _artifact.Artifact(context, path);
        this._idToVideo.set(videoId, {
          context,
          artifact
        });
        context.emit(_browserContext.BrowserContext.Events.VideoStarted, artifact);
        pageOrError.then((page) => {
          if (page instanceof _page.Page) {
            page._video = artifact;
            page.emit(_page.Page.Events.Video, artifact);
          }
        });
      }
      _takeVideo(videoId) {
        const video = this._idToVideo.get(videoId);
        this._idToVideo.delete(videoId);
        return video === null || video === void 0 ? void 0 : video.artifact;
      }
      _didClose() {
        for (const context of this.contexts())
          context._browserClosed();
        if (this._defaultContext)
          this._defaultContext._browserClosed();
        this.emit(Browser.Events.Disconnected);
      }
      close() {
        return __async(this, null, function* () {
          if (!this._startedClosing) {
            this._startedClosing = true;
            yield this.options.browserProcess.close();
          }
          if (this.isConnected())
            yield new Promise((x) => this.once(Browser.Events.Disconnected, x));
        });
      }
      killForTests() {
        return __async(this, null, function* () {
          yield this.options.browserProcess.kill();
        });
      }
    };
    exports2.Browser = Browser;
    Browser.Events = {
      Disconnected: "disconnected"
    };
  }
});

// node_modules/playwright-core/lib/server/chromium/crConnection.js
var require_crConnection = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRSession = exports2.CRSessionEvents = exports2.CRConnection = exports2.kBrowserCloseMessageId = exports2.ConnectionEvents = void 0;
    var _utils2 = require_utils();
    var _events = require("events");
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _protocolError = require_protocolError();
    var ConnectionEvents = {
      Disconnected: Symbol("ConnectionEvents.Disconnected")
    };
    exports2.ConnectionEvents = ConnectionEvents;
    var kBrowserCloseMessageId = -9999;
    exports2.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var CRConnection = class extends _events.EventEmitter {
      constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this._lastId = 0;
        this._transport = void 0;
        this._sessions = /* @__PURE__ */ new Map();
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this.rootSession = void 0;
        this._closed = false;
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this.rootSession = new CRSession(this, "", "browser", "");
        this._sessions.set("", this.rootSession);
      }
      static fromSession(session) {
        return session._connection;
      }
      session(sessionId) {
        return this._sessions.get(sessionId) || null;
      }
      _rawSend(sessionId, method, params) {
        const id = ++this._lastId;
        const message = {
          id,
          method,
          params
        };
        if (sessionId)
          message.sessionId = sessionId;
        this._protocolLogger("send", message);
        this._transport.send(message);
        return id;
      }
      _onMessage(message) {
        return __async(this, null, function* () {
          this._protocolLogger("receive", message);
          if (message.id === kBrowserCloseMessageId)
            return;
          if (message.method === "Target.attachedToTarget") {
            const sessionId = message.params.sessionId;
            const rootSessionId = message.sessionId || "";
            const session2 = new CRSession(this, rootSessionId, message.params.targetInfo.type, sessionId);
            this._sessions.set(sessionId, session2);
          } else if (message.method === "Target.detachedFromTarget") {
            const session2 = this._sessions.get(message.params.sessionId);
            if (session2) {
              session2._onClosed(void 0);
              this._sessions.delete(message.params.sessionId);
            }
          }
          const session = this._sessions.get(message.sessionId || "");
          if (session)
            session._onMessage(message);
        });
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        const browserDisconnectedLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
          session._onClosed(browserDisconnectedLogs);
        this._sessions.clear();
        Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
      createSession(targetInfo) {
        return __async(this, null, function* () {
          const {
            sessionId
          } = yield this.rootSession.send("Target.attachToTarget", {
            targetId: targetInfo.targetId,
            flatten: true
          });
          return this._sessions.get(sessionId);
        });
      }
      createBrowserSession() {
        return __async(this, null, function* () {
          const {
            sessionId
          } = yield this.rootSession.send("Target.attachToBrowserTarget");
          return this._sessions.get(sessionId);
        });
      }
    };
    exports2.CRConnection = CRConnection;
    var CRSessionEvents = {
      Disconnected: Symbol("Events.CDPSession.Disconnected")
    };
    exports2.CRSessionEvents = CRSessionEvents;
    var CRSession = class extends _events.EventEmitter {
      constructor(connection, rootSessionId, targetType, sessionId) {
        super();
        this._connection = void 0;
        this._eventListener = void 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._targetType = void 0;
        this._sessionId = void 0;
        this._rootSessionId = void 0;
        this._crashed = false;
        this._browserDisconnectedLogs = void 0;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.guid = void 0;
        this.guid = `cdp-session@${sessionId}`;
        this.setMaxListeners(0);
        this._connection = connection;
        this._rootSessionId = rootSessionId;
        this._targetType = targetType;
        this._sessionId = sessionId;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      _markAsCrashed() {
        this._crashed = true;
      }
      send(method, params) {
        return __async(this, null, function* () {
          if (this._crashed)
            throw new _protocolError.ProtocolError(true, "Target crashed");
          if (this._browserDisconnectedLogs !== void 0)
            throw new _protocolError.ProtocolError(true, `Browser closed.` + this._browserDisconnectedLogs);
          if (!this._connection)
            throw new _protocolError.ProtocolError(true, `Target closed`);
          const id = this._connection._rawSend(this._sessionId, method, params);
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      _sendMayFail(method, params) {
        return this.send(method, params).catch((error) => _debugLogger.debugLogger.log("error", error));
      }
      _onMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else {
          (0, _utils2.assert)(!object.id);
          Promise.resolve().then(() => {
            if (this._eventListener)
              this._eventListener(object.method, object.params);
            this.emit(object.method, object.params);
          });
        }
      }
      detach() {
        return __async(this, null, function* () {
          if (!this._connection)
            throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
          const rootSession = this._connection.session(this._rootSessionId);
          if (!rootSession)
            throw new Error("Root session has been closed");
          yield rootSession.send("Target.detachFromTarget", {
            sessionId: this._sessionId
          });
        });
      }
      _onClosed(browserDisconnectedLogs) {
        this._browserDisconnectedLogs = browserDisconnectedLogs;
        const errorMessage = browserDisconnectedLogs !== void 0 ? "Browser closed." + browserDisconnectedLogs : "Target closed";
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, errorMessage));
        }
        this._callbacks.clear();
        this._connection = null;
        Promise.resolve().then(() => this.emit(CRSessionEvents.Disconnected));
      }
    };
    exports2.CRSession = CRSession;
    function createProtocolError(error, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${protocolError.data}`;
      return (0, _stackTrace.rewriteErrorMessage)(error, message);
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crProtocolHelper.js
var require_crProtocolHelper = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crProtocolHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getExceptionMessage = getExceptionMessage;
    exports2.releaseObject = releaseObject;
    exports2.readProtocolStream = readProtocolStream;
    exports2.toConsoleMessageLocation = toConsoleMessageLocation;
    exports2.exceptionToError = exceptionToError;
    exports2.toModifiersMask = toModifiersMask;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _utils2 = require_utils();
    var _stackTrace = require_stackTrace();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getExceptionMessage(exceptionDetails) {
      if (exceptionDetails.exception)
        return exceptionDetails.exception.description || String(exceptionDetails.exception.value);
      let message = exceptionDetails.text;
      if (exceptionDetails.stackTrace) {
        for (const callframe of exceptionDetails.stackTrace.callFrames) {
          const location2 = callframe.url + ":" + callframe.lineNumber + ":" + callframe.columnNumber;
          const functionName = callframe.functionName || "<anonymous>";
          message += `
    at ${functionName} (${location2})`;
        }
      }
      return message;
    }
    function releaseObject(client, objectId) {
      return __async(this, null, function* () {
        yield client.send("Runtime.releaseObject", {
          objectId
        }).catch((error) => {
        });
      });
    }
    function readProtocolStream(client, handle, path) {
      return __async(this, null, function* () {
        let eof = false;
        let fd;
        if (path) {
          yield (0, _utils2.mkdirIfNeeded)(path);
          fd = yield _fs2.default.promises.open(path, "w");
        }
        const bufs = [];
        while (!eof) {
          const response = yield client.send("IO.read", {
            handle
          });
          eof = response.eof;
          const buf = Buffer.from(response.data, response.base64Encoded ? "base64" : void 0);
          bufs.push(buf);
          if (fd)
            yield fd.write(buf);
        }
        if (fd)
          yield fd.close();
        yield client.send("IO.close", {
          handle
        });
        return Buffer.concat(bufs);
      });
    }
    function toConsoleMessageLocation(stackTrace) {
      return stackTrace && stackTrace.callFrames.length ? {
        url: stackTrace.callFrames[0].url,
        lineNumber: stackTrace.callFrames[0].lineNumber,
        columnNumber: stackTrace.callFrames[0].columnNumber
      } : {
        url: "",
        lineNumber: 0,
        columnNumber: 0
      };
    }
    function exceptionToError(exceptionDetails) {
      const messageWithStack = getExceptionMessage(exceptionDetails);
      const lines = messageWithStack.split("\n");
      const firstStackTraceLine = lines.findIndex((line) => line.startsWith("    at"));
      let messageWithName = "";
      let stack = "";
      if (firstStackTraceLine === -1) {
        messageWithName = messageWithStack;
      } else {
        messageWithName = lines.slice(0, firstStackTraceLine).join("\n");
        stack = messageWithStack;
      }
      const {
        name,
        message
      } = (0, _stackTrace.splitErrorMessage)(messageWithName);
      const err = new Error(message);
      err.stack = stack;
      err.name = name;
      return err;
    }
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Alt"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Meta"))
        mask |= 4;
      if (modifiers.has("Shift"))
        mask |= 8;
      return mask;
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crExecutionContext.js
var require_crExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crExecutionContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRExecutionContext = void 0;
    var _crProtocolHelper = require_crProtocolHelper();
    var js = _interopRequireWildcard2(require_javascript());
    var _stackTrace = require_stackTrace();
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRExecutionContext = class {
      constructor(client, contextPayload) {
        this._client = void 0;
        this._contextId = void 0;
        this._client = client;
        this._contextId = contextPayload.id;
      }
      rawEvaluateJSON(expression) {
        return __async(this, null, function* () {
          const {
            exceptionDetails,
            result: remoteObject
          } = yield this._client.send("Runtime.evaluate", {
            expression,
            contextId: this._contextId,
            returnByValue: true
          }).catch(rewriteError);
          if (exceptionDetails)
            throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
          return remoteObject.value;
        });
      }
      rawEvaluateHandle(expression) {
        return __async(this, null, function* () {
          const {
            exceptionDetails,
            result: remoteObject
          } = yield this._client.send("Runtime.evaluate", {
            expression,
            contextId: this._contextId
          }).catch(rewriteError);
          if (exceptionDetails)
            throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
          return remoteObject.objectId;
        });
      }
      rawCallFunctionNoReply(func, ...args) {
        this._client.send("Runtime.callFunctionOn", {
          functionDeclaration: func.toString(),
          arguments: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          executionContextId: this._contextId,
          userGesture: true
        }).catch(() => {
        });
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return __async(this, null, function* () {
          const {
            exceptionDetails,
            result: remoteObject
          } = yield this._client.send("Runtime.callFunctionOn", {
            functionDeclaration: expression,
            objectId: utilityScript._objectId,
            arguments: [{
              objectId: utilityScript._objectId
            }, ...values.map((value) => ({
              value
            })), ...objectIds.map((objectId) => ({
              objectId
            }))],
            returnByValue,
            awaitPromise: true,
            userGesture: true
          }).catch(rewriteError);
          if (exceptionDetails)
            throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
          return returnByValue ? (0, _utilityScriptSerializers.parseEvaluationResultValue)(remoteObject.value) : utilityScript._context.createHandle(remoteObject);
        });
      }
      getProperties(context, objectId) {
        return __async(this, null, function* () {
          const response = yield this._client.send("Runtime.getProperties", {
            objectId,
            ownProperties: true
          });
          const result = /* @__PURE__ */ new Map();
          for (const property of response.result) {
            if (!property.enumerable || !property.value)
              continue;
            result.set(property.name, context.createHandle(property.value));
          }
          return result;
        });
      }
      createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      releaseHandle(objectId) {
        return __async(this, null, function* () {
          yield (0, _crProtocolHelper.releaseObject)(this._client, objectId);
        });
      }
    };
    exports2.CRExecutionContext = CRExecutionContext;
    function rewriteError(error) {
      if (error.message.includes("Object reference chain is too long"))
        return {
          result: {
            type: "undefined"
          }
        };
      if (error.message.includes("Object couldn't be returned by value"))
        return {
          result: {
            type: "undefined"
          }
        };
      if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON"))
        (0, _stackTrace.rewriteErrorMessage)(error, error.message + " Are you passing a nested JSHandle?");
      if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error))
        throw new Error("Execution context was destroyed, most likely because of a navigation.");
      throw error;
    }
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const unserializableValue = remoteObject.unserializableValue;
      return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if ("value" in object)
        return String(object.value);
      if (object.unserializableValue)
        return String(object.unserializableValue);
      if (object.description === "Object" && object.preview) {
        const tokens = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          tokens.push(`${name}: ${value}`);
        return `{${tokens.join(", ")}}`;
      }
      if (object.subtype === "array" && object.preview) {
        const result = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          result[+name] = value;
        return "[" + String(result) + "]";
      }
      return object.description;
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crNetworkManager.js
var require_crNetworkManager = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crNetworkManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRNetworkManager = void 0;
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard2(require_network());
    var _utils2 = require_utils();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRNetworkManager = class {
      constructor(client, page, parentManager) {
        this._client = void 0;
        this._page = void 0;
        this._parentManager = void 0;
        this._requestIdToRequest = /* @__PURE__ */ new Map();
        this._requestIdToRequestWillBeSentEvent = /* @__PURE__ */ new Map();
        this._credentials = null;
        this._attemptedAuthentications = /* @__PURE__ */ new Set();
        this._userRequestInterceptionEnabled = false;
        this._protocolRequestInterceptionEnabled = false;
        this._requestIdToRequestPausedEvent = /* @__PURE__ */ new Map();
        this._eventListeners = void 0;
        this._responseExtraInfoTracker = new ResponseExtraInfoTracker();
        this._client = client;
        this._page = page;
        this._parentManager = parentManager;
        this._eventListeners = this.instrumentNetworkEvents(client);
      }
      instrumentNetworkEvents(session, workerFrame) {
        return [_eventsHelper.eventsHelper.addEventListener(session, "Fetch.requestPaused", this._onRequestPaused.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, "Fetch.authRequired", this._onAuthRequired.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSentExtraInfo", this._onRequestWillBeSentExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceived", this._onResponseReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceivedExtraInfo", this._onResponseReceivedExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFinished", this._onLoadingFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFailed", this._onLoadingFailed.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))];
      }
      initialize() {
        return __async(this, null, function* () {
          yield this._client.send("Network.enable");
        });
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      authenticate(credentials) {
        return __async(this, null, function* () {
          this._credentials = credentials;
          yield this._updateProtocolRequestInterception();
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          yield this._client.send("Network.emulateNetworkConditions", {
            offline,
            latency: 0,
            downloadThroughput: -1,
            uploadThroughput: -1
          });
        });
      }
      setRequestInterception(value) {
        return __async(this, null, function* () {
          this._userRequestInterceptionEnabled = value;
          yield this._updateProtocolRequestInterception();
        });
      }
      _updateProtocolRequestInterception() {
        return __async(this, null, function* () {
          const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
          if (enabled === this._protocolRequestInterceptionEnabled)
            return;
          this._protocolRequestInterceptionEnabled = enabled;
          if (enabled) {
            yield Promise.all([this._client.send("Network.setCacheDisabled", {
              cacheDisabled: true
            }), this._client.send("Fetch.enable", {
              handleAuthRequests: true,
              patterns: [{
                urlPattern: "*",
                requestStage: "Request"
              }]
            })]);
          } else {
            yield Promise.all([this._client.send("Network.setCacheDisabled", {
              cacheDisabled: false
            }), this._client.send("Fetch.disable")]);
          }
        });
      }
      _onRequestWillBeSent(workerFrame, event) {
        this._responseExtraInfoTracker.requestWillBeSent(event);
        if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
          const requestId = event.requestId;
          const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);
          if (requestPausedEvent) {
            this._onRequest(workerFrame, event, requestPausedEvent);
            this._requestIdToRequestPausedEvent.delete(requestId);
          } else {
            this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
          }
        } else {
          this._onRequest(workerFrame, event, null);
        }
      }
      _onRequestWillBeSentExtraInfo(event) {
        this._responseExtraInfoTracker.requestWillBeSentExtraInfo(event);
      }
      _onAuthRequired(event) {
        let response = "Default";
        if (this._attemptedAuthentications.has(event.requestId)) {
          response = "CancelAuth";
        } else if (this._credentials) {
          response = "ProvideCredentials";
          this._attemptedAuthentications.add(event.requestId);
        }
        const {
          username,
          password
        } = this._credentials || {
          username: void 0,
          password: void 0
        };
        this._client._sendMayFail("Fetch.continueWithAuth", {
          requestId: event.requestId,
          authChallengeResponse: {
            response,
            username,
            password
          }
        });
      }
      _onRequestPaused(workerFrame, event) {
        if (!event.responseStatusCode && !event.responseErrorReason) {
          const request = this._requestIdToRequest.get(event.networkId);
          if (request)
            this._responseExtraInfoTracker.requestPaused(request.request, event);
        }
        if (!event.networkId) {
          this._client._sendMayFail("Fetch.failRequest", {
            requestId: event.requestId,
            errorReason: "Aborted"
          });
          return;
        }
        if (event.request.url.startsWith("data:"))
          return;
        const requestId = event.networkId;
        const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
        if (requestWillBeSentEvent) {
          this._onRequest(workerFrame, requestWillBeSentEvent, event);
          this._requestIdToRequestWillBeSentEvent.delete(requestId);
        } else {
          this._requestIdToRequestPausedEvent.set(requestId, event);
        }
      }
      _onRequest(workerFrame, requestWillBeSentEvent, requestPausedEvent) {
        if (requestWillBeSentEvent.request.url.startsWith("data:"))
          return;
        let redirectedFrom = null;
        if (requestWillBeSentEvent.redirectResponse) {
          const request2 = this._requestIdToRequest.get(requestWillBeSentEvent.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, requestWillBeSentEvent.redirectResponse, requestWillBeSentEvent.timestamp);
            redirectedFrom = request2;
          }
        }
        let frame = requestWillBeSentEvent.frameId ? this._page._frameManager.frame(requestWillBeSentEvent.frameId) : workerFrame;
        if (!frame && requestPausedEvent && requestPausedEvent.frameId)
          frame = this._page._frameManager.frame(requestPausedEvent.frameId);
        if (!frame && requestWillBeSentEvent.frameId === this._page._delegate._targetId) {
          frame = this._page._frameManager.frameAttached(requestWillBeSentEvent.frameId, null);
        }
        if (requestPausedEvent && requestPausedEvent.request.method === "OPTIONS" && this._page._needsRequestInterception()) {
          const requestHeaders = requestPausedEvent.request.headers;
          const responseHeaders = [{
            name: "Access-Control-Allow-Origin",
            value: requestHeaders["Origin"] || "*"
          }, {
            name: "Access-Control-Allow-Methods",
            value: requestHeaders["Access-Control-Request-Method"] || "GET, POST, OPTIONS, DELETE"
          }, {
            name: "Access-Control-Allow-Credentials",
            value: "true"
          }];
          if (requestHeaders["Access-Control-Request-Headers"])
            responseHeaders.push({
              name: "Access-Control-Allow-Headers",
              value: requestHeaders["Access-Control-Request-Headers"]
            });
          this._client._sendMayFail("Fetch.fulfillRequest", {
            requestId: requestPausedEvent.requestId,
            responseCode: 204,
            responsePhrase: network.STATUS_TEXTS["204"],
            responseHeaders,
            body: ""
          });
          return;
        }
        if (!frame) {
          if (requestPausedEvent)
            this._client._sendMayFail("Fetch.continueRequest", {
              requestId: requestPausedEvent.requestId
            });
          return;
        }
        let route = null;
        if (requestPausedEvent) {
          if (redirectedFrom || !this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled)
            this._client._sendMayFail("Fetch.continueRequest", {
              requestId: requestPausedEvent.requestId
            });
          else
            route = new RouteImpl(this._client, requestPausedEvent.requestId);
        }
        const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === "Document";
        const documentId = isNavigationRequest ? requestWillBeSentEvent.loaderId : void 0;
        const request = new InterceptableRequest({
          frame,
          documentId,
          route,
          requestWillBeSentEvent,
          requestPausedEvent,
          redirectedFrom
        });
        this._requestIdToRequest.set(requestWillBeSentEvent.requestId, request);
        this._page._frameManager.requestStarted(request.request, route || void 0);
      }
      _createResponse(request, responsePayload) {
        var _responsePayload$secu, _responsePayload$secu2, _responsePayload$secu3, _responsePayload$secu4, _responsePayload$secu5;
        const getResponseBody = () => __async(this, null, function* () {
          const response2 = yield this._client.send("Network.getResponseBody", {
            requestId: request._requestId
          });
          return Buffer.from(response2.body, response2.base64Encoded ? "base64" : "utf8");
        });
        const timingPayload = responsePayload.timing;
        let timing;
        if (timingPayload) {
          timing = {
            startTime: (timingPayload.requestTime - request._timestamp + request._wallTime) * 1e3,
            domainLookupStart: timingPayload.dnsStart,
            domainLookupEnd: timingPayload.dnsEnd,
            connectStart: timingPayload.connectStart,
            secureConnectionStart: timingPayload.sslStart,
            connectEnd: timingPayload.connectEnd,
            requestStart: timingPayload.sendStart,
            responseStart: timingPayload.receiveHeadersEnd
          };
        } else {
          timing = {
            startTime: request._wallTime * 1e3,
            domainLookupStart: -1,
            domainLookupEnd: -1,
            connectStart: -1,
            secureConnectionStart: -1,
            connectEnd: -1,
            requestStart: -1,
            responseStart: -1
          };
        }
        const response = new network.Response(request.request, responsePayload.status, responsePayload.statusText, (0, _utils2.headersObjectToArray)(responsePayload.headers), timing, getResponseBody, responsePayload.protocol);
        if (responsePayload !== null && responsePayload !== void 0 && responsePayload.remoteIPAddress && typeof (responsePayload === null || responsePayload === void 0 ? void 0 : responsePayload.remotePort) === "number") {
          response._serverAddrFinished({
            ipAddress: responsePayload.remoteIPAddress,
            port: responsePayload.remotePort
          });
        } else {
          response._serverAddrFinished();
        }
        response._securityDetailsFinished({
          protocol: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu = responsePayload.securityDetails) === null || _responsePayload$secu === void 0 ? void 0 : _responsePayload$secu.protocol,
          subjectName: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu2 = responsePayload.securityDetails) === null || _responsePayload$secu2 === void 0 ? void 0 : _responsePayload$secu2.subjectName,
          issuer: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu3 = responsePayload.securityDetails) === null || _responsePayload$secu3 === void 0 ? void 0 : _responsePayload$secu3.issuer,
          validFrom: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu4 = responsePayload.securityDetails) === null || _responsePayload$secu4 === void 0 ? void 0 : _responsePayload$secu4.validFrom,
          validTo: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu5 = responsePayload.securityDetails) === null || _responsePayload$secu5 === void 0 ? void 0 : _responsePayload$secu5.validTo
        });
        this._responseExtraInfoTracker.processResponse(request._requestId, response, request.wasFulfilled());
        return response;
      }
      _handleRequestRedirect(request, responsePayload, timestamp) {
        const response = this._createResponse(request, responsePayload);
        response._requestFinished((timestamp - request._timestamp) * 1e3);
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onResponseReceivedExtraInfo(event) {
        this._responseExtraInfoTracker.responseReceivedExtraInfo(event);
      }
      _onResponseReceived(event) {
        this._responseExtraInfoTracker.responseReceived(event);
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = this._createResponse(request, event.response);
        this._page._frameManager.requestReceivedResponse(response);
      }
      _onLoadingFinished(event) {
        this._responseExtraInfoTracker.loadingFinished(event);
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          request = this._maybeAdoptMainRequest(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          request.request.responseSize.transferSize = event.encodedDataLength;
          request.request.responseSize.encodedBodySize = event.encodedDataLength - request.request.responseSize.responseHeadersSize;
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        }
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onLoadingFailed(workerFrame, event) {
        this._responseExtraInfoTracker.loadingFailed(event);
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          request = this._maybeAdoptMainRequest(event.requestId);
        if (!request) {
          const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
          if (requestWillBeSentEvent) {
            this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
            this._onRequest(workerFrame, requestWillBeSentEvent, null);
            request = this._requestIdToRequest.get(event.requestId);
          }
        }
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response)
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, !!event.canceled);
      }
      _maybeAdoptMainRequest(requestId) {
        if (!this._parentManager)
          return;
        const request = this._parentManager._requestIdToRequest.get(requestId);
        if (!request || request._documentId !== requestId)
          return;
        this._requestIdToRequest.set(requestId, request);
        this._parentManager._requestIdToRequest.delete(requestId);
        if (request._interceptionId && this._parentManager._attemptedAuthentications.has(request._interceptionId)) {
          this._parentManager._attemptedAuthentications.delete(request._interceptionId);
          this._attemptedAuthentications.add(request._interceptionId);
        }
        return request;
      }
    };
    exports2.CRNetworkManager = CRNetworkManager;
    var InterceptableRequest = class {
      constructor(options) {
        this.request = void 0;
        this._requestId = void 0;
        this._interceptionId = void 0;
        this._documentId = void 0;
        this._timestamp = void 0;
        this._wallTime = void 0;
        this._route = void 0;
        this._redirectedFrom = void 0;
        const {
          frame,
          documentId,
          route,
          requestWillBeSentEvent,
          requestPausedEvent,
          redirectedFrom
        } = options;
        this._timestamp = requestWillBeSentEvent.timestamp;
        this._wallTime = requestWillBeSentEvent.wallTime;
        this._requestId = requestWillBeSentEvent.requestId;
        this._interceptionId = requestPausedEvent && requestPausedEvent.requestId;
        this._documentId = documentId;
        this._route = route;
        this._redirectedFrom = redirectedFrom;
        const {
          headers,
          method,
          url,
          postDataEntries = null
        } = requestPausedEvent ? requestPausedEvent.request : requestWillBeSentEvent.request;
        const type = (requestWillBeSentEvent.type || "").toLowerCase();
        let postDataBuffer = null;
        if (postDataEntries && postDataEntries.length && postDataEntries[0].bytes)
          postDataBuffer = Buffer.from(postDataEntries[0].bytes, "base64");
        this.request = new network.Request(frame, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, url, type, method, postDataBuffer, (0, _utils2.headersObjectToArray)(headers));
      }
      _routeForRedirectChain() {
        let request = this;
        while (request._redirectedFrom)
          request = request._redirectedFrom;
        return request._route;
      }
      wasFulfilled() {
        var _this$_routeForRedire;
        return ((_this$_routeForRedire = this._routeForRedirectChain()) === null || _this$_routeForRedire === void 0 ? void 0 : _this$_routeForRedire._wasFulfilled) || false;
      }
    };
    var RouteImpl = class {
      constructor(client, interceptionId) {
        this._client = void 0;
        this._interceptionId = void 0;
        this._wasFulfilled = false;
        this._client = client;
        this._interceptionId = interceptionId;
      }
      continue(request, overrides) {
        return __async(this, null, function* () {
          yield this._client._sendMayFail("Fetch.continueRequest", {
            requestId: this._interceptionId,
            url: overrides.url,
            headers: overrides.headers,
            method: overrides.method,
            postData: overrides.postData ? overrides.postData.toString("base64") : void 0
          });
        });
      }
      fulfill(response) {
        return __async(this, null, function* () {
          this._wasFulfilled = true;
          const body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
          const responseHeaders = splitSetCookieHeader(response.headers);
          yield this._client._sendMayFail("Fetch.fulfillRequest", {
            requestId: this._interceptionId,
            responseCode: response.status,
            responsePhrase: network.STATUS_TEXTS[String(response.status)],
            responseHeaders,
            body
          });
        });
      }
      abort(errorCode = "failed") {
        return __async(this, null, function* () {
          const errorReason = errorReasons[errorCode];
          (0, _utils2.assert)(errorReason, "Unknown error code: " + errorCode);
          yield this._client._sendMayFail("Fetch.failRequest", {
            requestId: this._interceptionId,
            errorReason
          });
        });
      }
    };
    function splitSetCookieHeader(headers) {
      const index = headers.findIndex(({
        name
      }) => name.toLowerCase() === "set-cookie");
      if (index === -1)
        return headers;
      const header = headers[index];
      const values = header.value.split("\n");
      if (values.length === 1)
        return headers;
      const result = headers.slice();
      result.splice(index, 1, ...values.map((value) => ({
        name: header.name,
        value
      })));
      return result;
    }
    var errorReasons = {
      "aborted": "Aborted",
      "accessdenied": "AccessDenied",
      "addressunreachable": "AddressUnreachable",
      "blockedbyclient": "BlockedByClient",
      "blockedbyresponse": "BlockedByResponse",
      "connectionaborted": "ConnectionAborted",
      "connectionclosed": "ConnectionClosed",
      "connectionfailed": "ConnectionFailed",
      "connectionrefused": "ConnectionRefused",
      "connectionreset": "ConnectionReset",
      "internetdisconnected": "InternetDisconnected",
      "namenotresolved": "NameNotResolved",
      "timedout": "TimedOut",
      "failed": "Failed"
    };
    var ResponseExtraInfoTracker = class {
      constructor() {
        this._requests = /* @__PURE__ */ new Map();
      }
      requestWillBeSent(event) {
        const info = this._requests.get(event.requestId);
        if (info && event.redirectResponse)
          this._innerResponseReceived(info, event.redirectResponse);
        else
          this._getOrCreateEntry(event.requestId);
      }
      requestWillBeSentExtraInfo(event) {
        const info = this._getOrCreateEntry(event.requestId);
        if (!info)
          return;
        info.requestWillBeSentExtraInfo.push(event);
        this._patchHeaders(info, info.requestWillBeSentExtraInfo.length - 1);
      }
      responseReceived(event) {
        const info = this._requests.get(event.requestId);
        if (!info)
          return;
        this._innerResponseReceived(info, event.response);
      }
      requestPaused(request, event) {
        request.setRawRequestHeaders((0, _utils2.headersObjectToArray)(event.request.headers, "\n"));
      }
      _innerResponseReceived(info, response) {
        if (!response.connectionId) {
          info.sawResponseWithoutConnectionId = true;
        }
      }
      responseReceivedExtraInfo(event) {
        const info = this._getOrCreateEntry(event.requestId);
        info.responseReceivedExtraInfo.push(event);
        this._patchHeaders(info, info.responseReceivedExtraInfo.length - 1);
        this._checkFinished(info);
      }
      processResponse(requestId, response, wasFulfilled) {
        if (wasFulfilled) {
          this._stopTracking(requestId);
          return;
        }
        const info = this._requests.get(requestId);
        if (!info || info.sawResponseWithoutConnectionId)
          return;
        response.setWillReceiveExtraHeaders();
        info.responses.push(response);
        this._patchHeaders(info, info.responses.length - 1);
      }
      loadingFinished(event) {
        const info = this._requests.get(event.requestId);
        if (!info)
          return;
        info.loadingFinished = event;
        this._checkFinished(info);
      }
      loadingFailed(event) {
        const info = this._requests.get(event.requestId);
        if (!info)
          return;
        info.loadingFailed = event;
        this._checkFinished(info);
      }
      _getOrCreateEntry(requestId) {
        let info = this._requests.get(requestId);
        if (!info) {
          info = {
            requestId,
            requestWillBeSentExtraInfo: [],
            responseReceivedExtraInfo: [],
            responses: [],
            sawResponseWithoutConnectionId: false
          };
          this._requests.set(requestId, info);
        }
        return info;
      }
      _patchHeaders(info, index) {
        const response = info.responses[index];
        const requestExtraInfo = info.requestWillBeSentExtraInfo[index];
        if (response && requestExtraInfo)
          response.request().setRawRequestHeaders((0, _utils2.headersObjectToArray)(requestExtraInfo.headers, "\n"));
        const responseExtraInfo = info.responseReceivedExtraInfo[index];
        if (response && responseExtraInfo) {
          var _responseExtraInfo$he;
          response.setRawResponseHeaders((0, _utils2.headersObjectToArray)(responseExtraInfo.headers, "\n"));
          response.request().responseSize.responseHeadersSize = ((_responseExtraInfo$he = responseExtraInfo.headersText) === null || _responseExtraInfo$he === void 0 ? void 0 : _responseExtraInfo$he.length) || 0;
        }
      }
      _checkFinished(info) {
        if (!info.loadingFinished && !info.loadingFailed)
          return;
        if (info.responses.length <= info.responseReceivedExtraInfo.length) {
          this._stopTracking(info.requestId);
          return;
        }
      }
      _stopTracking(requestId) {
        this._requests.delete(requestId);
      }
    };
  }
});

// node_modules/playwright-core/lib/server/dialog.js
var require_dialog = __commonJS({
  "node_modules/playwright-core/lib/server/dialog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Dialog = void 0;
    var _utils2 = require_utils();
    var _instrumentation = require_instrumentation();
    var Dialog = class extends _instrumentation.SdkObject {
      constructor(page, type, message, onHandle, defaultValue) {
        super(page, "dialog");
        this._page = void 0;
        this._type = void 0;
        this._message = void 0;
        this._onHandle = void 0;
        this._handled = false;
        this._defaultValue = void 0;
        this._page = page;
        this._type = type;
        this._message = message;
        this._onHandle = onHandle;
        this._defaultValue = defaultValue || "";
        this._page._frameManager.dialogDidOpen();
      }
      type() {
        return this._type;
      }
      message() {
        return this._message;
      }
      defaultValue() {
        return this._defaultValue;
      }
      accept(promptText) {
        return __async(this, null, function* () {
          (0, _utils2.assert)(!this._handled, "Cannot accept dialog which is already handled!");
          this._handled = true;
          this._page._frameManager.dialogWillClose();
          yield this._onHandle(true, promptText);
        });
      }
      dismiss() {
        return __async(this, null, function* () {
          (0, _utils2.assert)(!this._handled, "Cannot dismiss dialog which is already handled!");
          this._handled = true;
          this._page._frameManager.dialogWillClose();
          yield this._onHandle(false);
        });
      }
    };
    exports2.Dialog = Dialog;
  }
});

// node_modules/playwright-core/lib/server/macEditingCommands.js
var require_macEditingCommands = __commonJS({
  "node_modules/playwright-core/lib/server/macEditingCommands.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.macEditingCommands = void 0;
    var macEditingCommands = {
      "Backspace": "deleteBackward:",
      "Enter": "insertNewline:",
      "NumpadEnter": "insertNewline:",
      "Escape": "cancelOperation:",
      "ArrowUp": "moveUp:",
      "ArrowDown": "moveDown:",
      "ArrowLeft": "moveLeft:",
      "ArrowRight": "moveRight:",
      "F5": "complete:",
      "Delete": "deleteForward:",
      "Home": "scrollToBeginningOfDocument:",
      "End": "scrollToEndOfDocument:",
      "PageUp": "scrollPageUp:",
      "PageDown": "scrollPageDown:",
      "Shift+Backspace": "deleteBackward:",
      "Shift+Enter": "insertNewline:",
      "Shift+NumpadEnter": "insertNewline:",
      "Shift+Escape": "cancelOperation:",
      "Shift+ArrowUp": "moveUpAndModifySelection:",
      "Shift+ArrowDown": "moveDownAndModifySelection:",
      "Shift+ArrowLeft": "moveLeftAndModifySelection:",
      "Shift+ArrowRight": "moveRightAndModifySelection:",
      "Shift+F5": "complete:",
      "Shift+Delete": "deleteForward:",
      "Shift+Home": "moveToBeginningOfDocumentAndModifySelection:",
      "Shift+End": "moveToEndOfDocumentAndModifySelection:",
      "Shift+PageUp": "pageUpAndModifySelection:",
      "Shift+PageDown": "pageDownAndModifySelection:",
      "Shift+Numpad5": "delete:",
      "Control+Tab": "selectNextKeyView:",
      "Control+Enter": "insertLineBreak:",
      "Control+NumpadEnter": "insertLineBreak:",
      "Control+Quote": "insertSingleQuoteIgnoringSubstitution:",
      "Control+KeyA": "moveToBeginningOfParagraph:",
      "Control+KeyB": "moveBackward:",
      "Control+KeyD": "deleteForward:",
      "Control+KeyE": "moveToEndOfParagraph:",
      "Control+KeyF": "moveForward:",
      "Control+KeyH": "deleteBackward:",
      "Control+KeyK": "deleteToEndOfParagraph:",
      "Control+KeyL": "centerSelectionInVisibleArea:",
      "Control+KeyN": "moveDown:",
      "Control+KeyO": ["insertNewlineIgnoringFieldEditor:", "moveBackward:"],
      "Control+KeyP": "moveUp:",
      "Control+KeyT": "transpose:",
      "Control+KeyV": "pageDown:",
      "Control+KeyY": "yank:",
      "Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
      "Control+ArrowUp": "scrollPageUp:",
      "Control+ArrowDown": "scrollPageDown:",
      "Control+ArrowLeft": "moveToLeftEndOfLine:",
      "Control+ArrowRight": "moveToRightEndOfLine:",
      "Shift+Control+Enter": "insertLineBreak:",
      "Shift+Control+NumpadEnter": "insertLineBreak:",
      "Shift+Control+Tab": "selectPreviousKeyView:",
      "Shift+Control+Quote": "insertDoubleQuoteIgnoringSubstitution:",
      "Shift+Control+KeyA": "moveToBeginningOfParagraphAndModifySelection:",
      "Shift+Control+KeyB": "moveBackwardAndModifySelection:",
      "Shift+Control+KeyE": "moveToEndOfParagraphAndModifySelection:",
      "Shift+Control+KeyF": "moveForwardAndModifySelection:",
      "Shift+Control+KeyN": "moveDownAndModifySelection:",
      "Shift+Control+KeyP": "moveUpAndModifySelection:",
      "Shift+Control+KeyV": "pageDownAndModifySelection:",
      "Shift+Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
      "Shift+Control+ArrowUp": "scrollPageUp:",
      "Shift+Control+ArrowDown": "scrollPageDown:",
      "Shift+Control+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
      "Shift+Control+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
      "Alt+Backspace": "deleteWordBackward:",
      "Alt+Enter": "insertNewlineIgnoringFieldEditor:",
      "Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
      "Alt+Escape": "complete:",
      "Alt+ArrowUp": ["moveBackward:", "moveToBeginningOfParagraph:"],
      "Alt+ArrowDown": ["moveForward:", "moveToEndOfParagraph:"],
      "Alt+ArrowLeft": "moveWordLeft:",
      "Alt+ArrowRight": "moveWordRight:",
      "Alt+Delete": "deleteWordForward:",
      "Alt+PageUp": "pageUp:",
      "Alt+PageDown": "pageDown:",
      "Shift+Alt+Backspace": "deleteWordBackward:",
      "Shift+Alt+Enter": "insertNewlineIgnoringFieldEditor:",
      "Shift+Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
      "Shift+Alt+Escape": "complete:",
      "Shift+Alt+ArrowUp": "moveParagraphBackwardAndModifySelection:",
      "Shift+Alt+ArrowDown": "moveParagraphForwardAndModifySelection:",
      "Shift+Alt+ArrowLeft": "moveWordLeftAndModifySelection:",
      "Shift+Alt+ArrowRight": "moveWordRightAndModifySelection:",
      "Shift+Alt+Delete": "deleteWordForward:",
      "Shift+Alt+PageUp": "pageUp:",
      "Shift+Alt+PageDown": "pageDown:",
      "Control+Alt+KeyB": "moveWordBackward:",
      "Control+Alt+KeyF": "moveWordForward:",
      "Control+Alt+Backspace": "deleteWordBackward:",
      "Shift+Control+Alt+KeyB": "moveWordBackwardAndModifySelection:",
      "Shift+Control+Alt+KeyF": "moveWordForwardAndModifySelection:",
      "Shift+Control+Alt+Backspace": "deleteWordBackward:",
      "Meta+NumpadSubtract": "cancel:",
      "Meta+Backspace": "deleteToBeginningOfLine:",
      "Meta+ArrowUp": "moveToBeginningOfDocument:",
      "Meta+ArrowDown": "moveToEndOfDocument:",
      "Meta+ArrowLeft": "moveToLeftEndOfLine:",
      "Meta+ArrowRight": "moveToRightEndOfLine:",
      "Shift+Meta+NumpadSubtract": "cancel:",
      "Shift+Meta+Backspace": "deleteToBeginningOfLine:",
      "Shift+Meta+ArrowUp": "moveToBeginningOfDocumentAndModifySelection:",
      "Shift+Meta+ArrowDown": "moveToEndOfDocumentAndModifySelection:",
      "Shift+Meta+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
      "Shift+Meta+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
      "Meta+KeyA": "selectAll:"
    };
    exports2.macEditingCommands = macEditingCommands;
  }
});

// node_modules/playwright-core/lib/server/chromium/crInput.js
var require_crInput = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crInput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    var input = _interopRequireWildcard2(require_input());
    var _macEditingCommands = require_macEditingCommands();
    var _utils2 = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var RawKeyboardImpl = class {
      constructor(_client, _isMac, _dragManger) {
        this._client = _client;
        this._isMac = _isMac;
        this._dragManger = _dragManger;
      }
      _commandsForCode(code, modifiers) {
        if (!this._isMac)
          return [];
        const parts = [];
        for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
          if (modifiers.has(modifier))
            parts.push(modifier);
        }
        parts.push(code);
        const shortcut = parts.join("+");
        let commands = _macEditingCommands.macEditingCommands[shortcut] || [];
        if ((0, _utils2.isString)(commands))
          commands = [commands];
        commands = commands.filter((x) => !x.startsWith("insert"));
        return commands.map((c) => c.substring(0, c.length - 1));
      }
      keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        return __async(this, null, function* () {
          if (code === "Escape" && (yield this._dragManger.cancelDrag()))
            return;
          const commands = this._commandsForCode(code, modifiers);
          yield this._client.send("Input.dispatchKeyEvent", {
            type: text ? "keyDown" : "rawKeyDown",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            windowsVirtualKeyCode: keyCodeWithoutLocation,
            code,
            commands,
            key,
            text,
            unmodifiedText: text,
            autoRepeat,
            location: location2,
            isKeypad: location2 === input.keypadLocation
          });
        });
      }
      keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        return __async(this, null, function* () {
          yield this._client.send("Input.dispatchKeyEvent", {
            type: "keyUp",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            key,
            windowsVirtualKeyCode: keyCodeWithoutLocation,
            code,
            location: location2
          });
        });
      }
      sendText(text) {
        return __async(this, null, function* () {
          yield this._client.send("Input.insertText", {
            text
          });
        });
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(page, client, dragManager) {
        this._client = void 0;
        this._page = void 0;
        this._dragManager = void 0;
        this._page = page;
        this._client = client;
        this._dragManager = dragManager;
      }
      move(x, y, button, buttons, modifiers, forClick) {
        return __async(this, null, function* () {
          const actualMove = () => __async(this, null, function* () {
            yield this._client.send("Input.dispatchMouseEvent", {
              type: "mouseMoved",
              button,
              x,
              y,
              modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
            });
          });
          if (forClick) {
            return actualMove();
          }
          yield this._dragManager.interceptDragCausedByMove(x, y, button, buttons, modifiers, actualMove);
        });
      }
      down(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          if (this._dragManager.isDragging())
            return;
          yield this._client.send("Input.dispatchMouseEvent", {
            type: "mousePressed",
            button,
            x,
            y,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            clickCount
          });
        });
      }
      up(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          if (this._dragManager.isDragging()) {
            yield this._dragManager.drop(x, y, modifiers);
            return;
          }
          yield this._client.send("Input.dispatchMouseEvent", {
            type: "mouseReleased",
            button,
            x,
            y,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            clickCount
          });
        });
      }
      wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._client.send("Input.dispatchMouseEvent", {
            type: "mouseWheel",
            x,
            y,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            deltaX,
            deltaY
          });
        });
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      tap(x, y, modifiers) {
        return __async(this, null, function* () {
          yield Promise.all([this._client.send("Input.dispatchTouchEvent", {
            type: "touchStart",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            touchPoints: [{
              x,
              y
            }]
          }), this._client.send("Input.dispatchTouchEvent", {
            type: "touchEnd",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            touchPoints: []
          })]);
        });
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/chromium/crAccessibility.js
var require_crAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAccessibilityTree = getAccessibilityTree;
    function getAccessibilityTree(client, needle) {
      return __async(this, null, function* () {
        const {
          nodes
        } = yield client.send("Accessibility.getFullAXTree");
        const tree = CRAXNode.createTree(client, nodes);
        return {
          tree,
          needle: needle ? yield tree._findElement(needle) : null
        };
      });
    }
    var CRAXNode = class {
      constructor(client, payload) {
        this._payload = void 0;
        this._children = [];
        this._richlyEditable = false;
        this._editable = false;
        this._focusable = false;
        this._expanded = false;
        this._hidden = false;
        this._name = void 0;
        this._role = void 0;
        this._cachedHasFocusableChild = void 0;
        this._client = void 0;
        this._client = client;
        this._payload = payload;
        this._name = this._payload.name ? this._payload.name.value : "";
        this._role = this._payload.role ? this._payload.role.value : "Unknown";
        for (const property of this._payload.properties || []) {
          if (property.name === "editable") {
            this._richlyEditable = property.value.value === "richtext";
            this._editable = true;
          }
          if (property.name === "focusable")
            this._focusable = property.value.value;
          if (property.name === "expanded")
            this._expanded = property.value.value;
          if (property.name === "hidden")
            this._hidden = property.value.value;
        }
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "textbox" || this._role === "ComboBox" || this._role === "searchbox";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      children() {
        return this._children;
      }
      _findElement(element) {
        return __async(this, null, function* () {
          const objectId = element._objectId;
          const {
            node: {
              backendNodeId
            }
          } = yield this._client.send("DOM.describeNode", {
            objectId
          });
          const needle = this.find((node) => node._payload.backendDOMNodeId === backendNodeId);
          return needle || null;
        });
      }
      find(predicate) {
        if (predicate(this))
          return this;
        for (const child of this._children) {
          const result = child.find(predicate);
          if (result)
            return result;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "doc-cover":
          case "graphics-symbol":
          case "img":
          case "Meter":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._role !== "WebArea" && this._role !== "RootWebArea" && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        const role = this._role;
        if (role === "Ignored" || this._hidden)
          return false;
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name;
      }
      normalizedRole() {
        switch (this._role) {
          case "RootWebArea":
            return "WebArea";
          case "StaticText":
            return "text";
          default:
            return this._role;
        }
      }
      serialize() {
        const properties = /* @__PURE__ */ new Map();
        for (const property of this._payload.properties || [])
          properties.set(property.name.toLowerCase(), property.value.value);
        if (this._payload.description)
          properties.set("description", this._payload.description.value);
        const node = {
          role: this.normalizedRole(),
          name: this._payload.name ? this._payload.name.value || "" : ""
        };
        const userStringProperties = ["description", "keyshortcuts", "roledescription", "valuetext"];
        for (const userStringProperty of userStringProperties) {
          if (!properties.has(userStringProperty))
            continue;
          node[userStringProperty] = properties.get(userStringProperty);
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && (this._role === "WebArea" || this._role === "RootWebArea"))
            continue;
          const value = properties.get(booleanProperty);
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level", "valuemax", "valuemin"];
        for (const numericalProperty of numericalProperties) {
          if (!properties.has(numericalProperty))
            continue;
          node[numericalProperty] = properties.get(numericalProperty);
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid", "orientation"];
        for (const tokenProperty of tokenProperties) {
          const value = properties.get(tokenProperty);
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const axNode = node;
        if (this._payload.value) {
          if (typeof this._payload.value.value === "string")
            axNode.valueString = this._payload.value.value;
          if (typeof this._payload.value.value === "number")
            axNode.valueNumber = this._payload.value.value;
        }
        if (properties.has("checked"))
          axNode.checked = properties.get("checked") === "true" ? "checked" : properties.get("checked") === "false" ? "unchecked" : "mixed";
        if (properties.has("pressed"))
          axNode.pressed = properties.get("pressed") === "true" ? "pressed" : properties.get("pressed") === "false" ? "released" : "mixed";
        return axNode;
      }
      static createTree(client, payloads) {
        const nodeById = /* @__PURE__ */ new Map();
        for (const payload of payloads)
          nodeById.set(payload.nodeId, new CRAXNode(client, payload));
        for (const node of nodeById.values()) {
          for (const childId of node._payload.childIds || [])
            node._children.push(nodeById.get(childId));
        }
        return nodeById.values().next().value;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/chromium/crCoverage.js
var require_crCoverage = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crCoverage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRCoverage = void 0;
    var _eventsHelper = require_eventsHelper();
    var _utils2 = require_utils();
    var CRCoverage = class {
      constructor(client) {
        this._jsCoverage = void 0;
        this._cssCoverage = void 0;
        this._jsCoverage = new JSCoverage(client);
        this._cssCoverage = new CSSCoverage(client);
      }
      startJSCoverage(options) {
        return __async(this, null, function* () {
          return yield this._jsCoverage.start(options);
        });
      }
      stopJSCoverage() {
        return __async(this, null, function* () {
          return yield this._jsCoverage.stop();
        });
      }
      startCSSCoverage(options) {
        return __async(this, null, function* () {
          return yield this._cssCoverage.start(options);
        });
      }
      stopCSSCoverage() {
        return __async(this, null, function* () {
          return yield this._cssCoverage.stop();
        });
      }
    };
    exports2.CRCoverage = CRCoverage;
    var JSCoverage = class {
      constructor(client) {
        this._client = void 0;
        this._enabled = void 0;
        this._scriptIds = void 0;
        this._scriptSources = void 0;
        this._eventListeners = void 0;
        this._resetOnNavigation = void 0;
        this._reportAnonymousScripts = false;
        this._client = client;
        this._enabled = false;
        this._scriptIds = /* @__PURE__ */ new Set();
        this._scriptSources = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      start() {
        return __async(this, arguments, function* (options = {}) {
          (0, _utils2.assert)(!this._enabled, "JSCoverage is already enabled");
          const {
            resetOnNavigation = true,
            reportAnonymousScripts = false
          } = options;
          this._resetOnNavigation = resetOnNavigation;
          this._reportAnonymousScripts = reportAnonymousScripts;
          this._enabled = true;
          this._scriptIds.clear();
          this._scriptSources.clear();
          this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, "Debugger.scriptParsed", this._onScriptParsed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Debugger.paused", this._onDebuggerPaused.bind(this))];
          yield Promise.all([this._client.send("Profiler.enable"), this._client.send("Profiler.startPreciseCoverage", {
            callCount: true,
            detailed: true
          }), this._client.send("Debugger.enable"), this._client.send("Debugger.setSkipAllPauses", {
            skip: true
          })]);
        });
      }
      _onDebuggerPaused() {
        this._client.send("Debugger.resume");
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._scriptIds.clear();
        this._scriptSources.clear();
      }
      _onScriptParsed(event) {
        return __async(this, null, function* () {
          this._scriptIds.add(event.scriptId);
          if (!event.url && !this._reportAnonymousScripts)
            return;
          const response = yield this._client._sendMayFail("Debugger.getScriptSource", {
            scriptId: event.scriptId
          });
          if (response)
            this._scriptSources.set(event.scriptId, response.scriptSource);
        });
      }
      stop() {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this._enabled, "JSCoverage is not enabled");
          this._enabled = false;
          const [profileResponse] = yield Promise.all([this._client.send("Profiler.takePreciseCoverage"), this._client.send("Profiler.stopPreciseCoverage"), this._client.send("Profiler.disable"), this._client.send("Debugger.disable")]);
          _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
          const coverage = [];
          for (const entry of profileResponse.result) {
            if (!this._scriptIds.has(entry.scriptId))
              continue;
            if (!entry.url && !this._reportAnonymousScripts)
              continue;
            const source = this._scriptSources.get(entry.scriptId);
            if (source)
              coverage.push(__spreadProps(__spreadValues({}, entry), {
                source
              }));
            else
              coverage.push(entry);
          }
          return coverage;
        });
      }
    };
    var CSSCoverage = class {
      constructor(client) {
        this._client = void 0;
        this._enabled = void 0;
        this._stylesheetURLs = void 0;
        this._stylesheetSources = void 0;
        this._eventListeners = void 0;
        this._resetOnNavigation = void 0;
        this._client = client;
        this._enabled = false;
        this._stylesheetURLs = /* @__PURE__ */ new Map();
        this._stylesheetSources = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      start() {
        return __async(this, arguments, function* (options = {}) {
          (0, _utils2.assert)(!this._enabled, "CSSCoverage is already enabled");
          const {
            resetOnNavigation = true
          } = options;
          this._resetOnNavigation = resetOnNavigation;
          this._enabled = true;
          this._stylesheetURLs.clear();
          this._stylesheetSources.clear();
          this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, "CSS.styleSheetAdded", this._onStyleSheet.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this))];
          yield Promise.all([this._client.send("DOM.enable"), this._client.send("CSS.enable"), this._client.send("CSS.startRuleUsageTracking")]);
        });
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
      }
      _onStyleSheet(event) {
        return __async(this, null, function* () {
          const header = event.header;
          if (!header.sourceURL)
            return;
          const response = yield this._client._sendMayFail("CSS.getStyleSheetText", {
            styleSheetId: header.styleSheetId
          });
          if (response) {
            this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
            this._stylesheetSources.set(header.styleSheetId, response.text);
          }
        });
      }
      stop() {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this._enabled, "CSSCoverage is not enabled");
          this._enabled = false;
          const ruleTrackingResponse = yield this._client.send("CSS.stopRuleUsageTracking");
          yield Promise.all([this._client.send("CSS.disable"), this._client.send("DOM.disable")]);
          _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
          const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
          for (const entry of ruleTrackingResponse.ruleUsage) {
            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
            if (!ranges) {
              ranges = [];
              styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
            }
            ranges.push({
              startOffset: entry.startOffset,
              endOffset: entry.endOffset,
              count: entry.used ? 1 : 0
            });
          }
          const coverage = [];
          for (const styleSheetId of this._stylesheetURLs.keys()) {
            const url = this._stylesheetURLs.get(styleSheetId);
            const text = this._stylesheetSources.get(styleSheetId);
            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
            coverage.push({
              url,
              ranges,
              text
            });
          }
          return coverage;
        });
      }
    };
    function convertToDisjointRanges(nestedRanges) {
      const points = [];
      for (const range of nestedRanges) {
        points.push({
          offset: range.startOffset,
          type: 0,
          range
        });
        points.push({
          offset: range.endOffset,
          type: 1,
          range
        });
      }
      points.sort((a, b) => {
        if (a.offset !== b.offset)
          return a.offset - b.offset;
        if (a.type !== b.type)
          return b.type - a.type;
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        if (a.type === 0)
          return bLength - aLength;
        return aLength - bLength;
      });
      const hitCountStack = [];
      const results = [];
      let lastOffset = 0;
      for (const point of points) {
        if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
          const lastResult = results.length ? results[results.length - 1] : null;
          if (lastResult && lastResult.end === lastOffset)
            lastResult.end = point.offset;
          else
            results.push({
              start: lastOffset,
              end: point.offset
            });
        }
        lastOffset = point.offset;
        if (point.type === 0)
          hitCountStack.push(point.range.count);
        else
          hitCountStack.pop();
      }
      return results.filter((range) => range.end - range.start > 1);
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crPdf.js
var require_crPdf = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crPdf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRPDF = void 0;
    var _utils2 = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    var PagePaperFormats = {
      letter: {
        width: 8.5,
        height: 11
      },
      legal: {
        width: 8.5,
        height: 14
      },
      tabloid: {
        width: 11,
        height: 17
      },
      ledger: {
        width: 17,
        height: 11
      },
      a0: {
        width: 33.1,
        height: 46.8
      },
      a1: {
        width: 23.4,
        height: 33.1
      },
      a2: {
        width: 16.54,
        height: 23.4
      },
      a3: {
        width: 11.7,
        height: 16.54
      },
      a4: {
        width: 8.27,
        height: 11.7
      },
      a5: {
        width: 5.83,
        height: 8.27
      },
      a6: {
        width: 4.13,
        height: 5.83
      }
    };
    var unitToPixels = {
      "px": 1,
      "in": 96,
      "cm": 37.8,
      "mm": 3.78
    };
    function convertPrintParameterToInches(text) {
      if (text === void 0)
        return void 0;
      let unit = text.substring(text.length - 2).toLowerCase();
      let valueText = "";
      if (unitToPixels.hasOwnProperty(unit)) {
        valueText = text.substring(0, text.length - 2);
      } else {
        unit = "px";
        valueText = text;
      }
      const value = Number(valueText);
      (0, _utils2.assert)(!isNaN(value), "Failed to parse parameter value: " + text);
      const pixels = value * unitToPixels[unit];
      return pixels / 96;
    }
    var CRPDF = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      generate() {
        return __async(this, arguments, function* (options = {}) {
          const {
            scale = 1,
            displayHeaderFooter = false,
            headerTemplate = "",
            footerTemplate = "",
            printBackground = false,
            landscape = false,
            pageRanges = "",
            preferCSSPageSize = false,
            margin = {}
          } = options;
          let paperWidth = 8.5;
          let paperHeight = 11;
          if (options.format) {
            const format = PagePaperFormats[options.format.toLowerCase()];
            (0, _utils2.assert)(format, "Unknown paper format: " + options.format);
            paperWidth = format.width;
            paperHeight = format.height;
          } else {
            paperWidth = convertPrintParameterToInches(options.width) || paperWidth;
            paperHeight = convertPrintParameterToInches(options.height) || paperHeight;
          }
          const marginTop = convertPrintParameterToInches(margin.top) || 0;
          const marginLeft = convertPrintParameterToInches(margin.left) || 0;
          const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
          const marginRight = convertPrintParameterToInches(margin.right) || 0;
          const result = yield this._client.send("Page.printToPDF", {
            transferMode: "ReturnAsStream",
            landscape,
            displayHeaderFooter,
            headerTemplate,
            footerTemplate,
            printBackground,
            scale,
            paperWidth,
            paperHeight,
            marginTop,
            marginBottom,
            marginLeft,
            marginRight,
            pageRanges,
            preferCSSPageSize
          });
          return yield (0, _crProtocolHelper.readProtocolStream)(this._client, result.stream, null);
        });
      }
    };
    exports2.CRPDF = CRPDF;
  }
});

// node_modules/playwright-core/lib/utils/processLauncher.js
var require_processLauncher = __commonJS({
  "node_modules/playwright-core/lib/utils/processLauncher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.gracefullyCloseAll = gracefullyCloseAll;
    exports2.launchProcess = launchProcess;
    exports2.envArrayToObject = envArrayToObject;
    exports2.gracefullyCloseSet = void 0;
    var childProcess = _interopRequireWildcard2(require("child_process"));
    var readline = _interopRequireWildcard2(require("readline"));
    var _eventsHelper = require_eventsHelper();
    var _utils2 = require_utils();
    var _rimraf = _interopRequireDefault2(require_rimraf());
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var gracefullyCloseSet = /* @__PURE__ */ new Set();
    exports2.gracefullyCloseSet = gracefullyCloseSet;
    function gracefullyCloseAll() {
      return __async(this, null, function* () {
        yield Promise.all(Array.from(gracefullyCloseSet).map((gracefullyClose) => gracefullyClose().catch((e) => {
        })));
      });
    }
    var maxListeners = process.getMaxListeners();
    if (maxListeners !== 0)
      process.setMaxListeners(Math.max(maxListeners || 0, 100));
    function launchProcess(options) {
      return __async(this, null, function* () {
        const stdio = options.stdio === "pipe" ? ["ignore", "pipe", "pipe", "pipe", "pipe"] : ["pipe", "pipe", "pipe"];
        options.log(`<launching> ${options.command} ${options.args ? options.args.join(" ") : ""}`);
        const spawnOptions = {
          detached: process.platform !== "win32",
          env: options.env,
          cwd: options.cwd,
          shell: options.shell,
          stdio
        };
        const spawnedProcess = childProcess.spawn(options.command, options.args || [], spawnOptions);
        const cleanup = () => __async(this, null, function* () {
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
          const errors = yield (0, _utils2.removeFolders)(options.tempDirectories);
          for (let i = 0; i < options.tempDirectories.length; ++i) {
            if (errors[i])
              options.log(`[pid=${spawnedProcess.pid || "N/A"}] exception while removing ${options.tempDirectories[i]}: ${errors[i]}`);
          }
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
        });
        spawnedProcess.on("error", () => {
        });
        if (!spawnedProcess.pid) {
          let failed;
          const failedPromise = new Promise((f, r) => failed = f);
          spawnedProcess.once("error", (error) => {
            failed(new Error("Failed to launch: " + error));
          });
          return cleanup().then(() => failedPromise).then((e) => Promise.reject(e));
        }
        options.log(`<launched> pid=${spawnedProcess.pid}`);
        const stdout = readline.createInterface({
          input: spawnedProcess.stdout
        });
        stdout.on("line", (data) => {
          options.log(`[pid=${spawnedProcess.pid}][out] ` + data);
        });
        const stderr = readline.createInterface({
          input: spawnedProcess.stderr
        });
        stderr.on("line", (data) => {
          options.log(`[pid=${spawnedProcess.pid}][err] ` + data);
        });
        let processClosed = false;
        let fulfillClose = () => {
        };
        const waitForClose = new Promise((f) => fulfillClose = f);
        let fulfillCleanup = () => {
        };
        const waitForCleanup = new Promise((f) => fulfillCleanup = f);
        spawnedProcess.once("exit", (exitCode, signal) => {
          options.log(`[pid=${spawnedProcess.pid}] <process did exit: exitCode=${exitCode}, signal=${signal}>`);
          processClosed = true;
          _eventsHelper.eventsHelper.removeEventListeners(listeners);
          gracefullyCloseSet.delete(gracefullyClose);
          options.onExit(exitCode, signal);
          fulfillClose();
          cleanup().then(fulfillCleanup);
        });
        const listeners = [_eventsHelper.eventsHelper.addEventListener(process, "exit", killProcessAndCleanup)];
        if (options.handleSIGINT) {
          listeners.push(_eventsHelper.eventsHelper.addEventListener(process, "SIGINT", () => {
            gracefullyClose().then(() => {
              if ((0, _utils2.isUnderTest)())
                setTimeout(() => process.exit(130), 0);
              else
                process.exit(130);
            });
          }));
        }
        if (options.handleSIGTERM)
          listeners.push(_eventsHelper.eventsHelper.addEventListener(process, "SIGTERM", gracefullyClose));
        if (options.handleSIGHUP)
          listeners.push(_eventsHelper.eventsHelper.addEventListener(process, "SIGHUP", gracefullyClose));
        gracefullyCloseSet.add(gracefullyClose);
        let gracefullyClosing = false;
        function gracefullyClose() {
          return __async(this, null, function* () {
            gracefullyCloseSet.delete(gracefullyClose);
            if (gracefullyClosing) {
              options.log(`[pid=${spawnedProcess.pid}] <forecefully close>`);
              killProcess();
              yield waitForClose;
              return;
            }
            gracefullyClosing = true;
            options.log(`[pid=${spawnedProcess.pid}] <gracefully close start>`);
            yield options.attemptToGracefullyClose().catch(() => killProcess());
            yield waitForCleanup;
            options.log(`[pid=${spawnedProcess.pid}] <gracefully close end>`);
          });
        }
        function killProcess() {
          options.log(`[pid=${spawnedProcess.pid}] <kill>`);
          _eventsHelper.eventsHelper.removeEventListeners(listeners);
          if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {
            options.log(`[pid=${spawnedProcess.pid}] <will force kill>`);
            try {
              if (process.platform === "win32") {
                const taskkillProcess = childProcess.spawnSync(`taskkill /pid ${spawnedProcess.pid} /T /F /FI "MEMUSAGE gt 0"`, {
                  shell: true
                });
                const [stderr2, stdout2] = [taskkillProcess.stdout.toString(), taskkillProcess.stderr.toString()];
                if (stdout2)
                  options.log(`[pid=${spawnedProcess.pid}] taskkill stdout: ${stdout2}`);
                if (stderr2)
                  options.log(`[pid=${spawnedProcess.pid}] taskkill stderr: ${stderr2}`);
              } else {
                process.kill(-spawnedProcess.pid, "SIGKILL");
              }
            } catch (e) {
              options.log(`[pid=${spawnedProcess.pid}] exception while trying to kill process: ${e}`);
            }
          } else {
            options.log(`[pid=${spawnedProcess.pid}] <skipped force kill spawnedProcess.killed=${spawnedProcess.killed} processClosed=${processClosed}>`);
          }
        }
        function killProcessAndCleanup() {
          killProcess();
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
          for (const dir of options.tempDirectories) {
            try {
              _rimraf.default.sync(dir, {
                maxBusyTries: 10
              });
            } catch (e) {
              options.log(`[pid=${spawnedProcess.pid || "N/A"}] exception while removing ${dir}: ${e}`);
            }
          }
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
        }
        function killAndWait() {
          killProcess();
          return waitForCleanup;
        }
        return {
          launchedProcess: spawnedProcess,
          gracefullyClose,
          kill: killAndWait
        };
      });
    }
    function envArrayToObject(env) {
      const result = {};
      for (const {
        name,
        value
      } of env)
        result[name] = value;
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/videoRecorder.js
var require_videoRecorder = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/videoRecorder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VideoRecorder = void 0;
    var _utils2 = require_utils();
    var _page = require_page();
    var _processLauncher = require_processLauncher();
    var _progress = require_progress2();
    var _instrumentation = require_instrumentation();
    var fps = 25;
    var VideoRecorder = class {
      static launch(page, ffmpegPath, options) {
        return __async(this, null, function* () {
          if (!options.outputFile.endsWith(".webm"))
            throw new Error("File must have .webm extension");
          const controller = new _progress.ProgressController((0, _instrumentation.internalCallMetadata)(), page);
          controller.setLogName("browser");
          return yield controller.run((progress) => __async(this, null, function* () {
            const recorder = new VideoRecorder(page, ffmpegPath, progress);
            yield recorder._launch(options);
            return recorder;
          }));
        });
      }
      constructor(page, ffmpegPath, progress) {
        this._process = null;
        this._gracefullyClose = null;
        this._lastWritePromise = Promise.resolve();
        this._lastFrameTimestamp = 0;
        this._lastFrameBuffer = null;
        this._lastWriteTimestamp = 0;
        this._progress = void 0;
        this._frameQueue = [];
        this._isStopped = false;
        this._ffmpegPath = void 0;
        this._progress = progress;
        this._ffmpegPath = ffmpegPath;
        page.on(_page.Page.Events.ScreencastFrame, (frame) => this.writeFrame(frame.buffer, frame.timestamp));
      }
      _launch(options) {
        return __async(this, null, function* () {
          const w = options.width;
          const h = options.height;
          const args = `-loglevel error -f image2pipe -avioflags direct -fpsprobesize 0 -probesize 32 -analyzeduration 0 -c:v mjpeg -i - -y -an -r ${fps} -c:v vp8 -qmin 0 -qmax 50 -crf 8 -deadline realtime -speed 8 -b:v 1M -threads 1 -vf pad=${w}:${h}:0:0:gray,crop=${w}:${h}:0:0`.split(" ");
          args.push(options.outputFile);
          const progress = this._progress;
          const {
            launchedProcess,
            gracefullyClose
          } = yield (0, _processLauncher.launchProcess)({
            command: this._ffmpegPath,
            args,
            stdio: "stdin",
            log: (message) => progress.log(message),
            tempDirectories: [],
            attemptToGracefullyClose: () => __async(this, null, function* () {
              progress.log("Closing stdin...");
              launchedProcess.stdin.end();
            }),
            onExit: (exitCode, signal) => {
              progress.log(`ffmpeg onkill exitCode=${exitCode} signal=${signal}`);
            }
          });
          launchedProcess.stdin.on("finish", () => {
            progress.log("ffmpeg finished input.");
          });
          launchedProcess.stdin.on("error", () => {
            progress.log("ffmpeg error.");
          });
          this._process = launchedProcess;
          this._gracefullyClose = gracefullyClose;
        });
      }
      writeFrame(frame, timestamp) {
        (0, _utils2.assert)(this._process);
        if (this._isStopped)
          return;
        this._progress.log(`writing frame ` + timestamp);
        if (this._lastFrameBuffer) {
          const durationSec = timestamp - this._lastFrameTimestamp;
          const repeatCount = Math.max(1, Math.round(fps * durationSec));
          for (let i = 0; i < repeatCount; ++i)
            this._frameQueue.push(this._lastFrameBuffer);
          this._lastWritePromise = this._lastWritePromise.then(() => this._sendFrames());
        }
        this._lastFrameBuffer = frame;
        this._lastFrameTimestamp = timestamp;
        this._lastWriteTimestamp = (0, _utils2.monotonicTime)();
      }
      _sendFrames() {
        return __async(this, null, function* () {
          while (this._frameQueue.length)
            yield this._sendFrame(this._frameQueue.shift());
        });
      }
      _sendFrame(frame) {
        return __async(this, null, function* () {
          return new Promise((f) => this._process.stdin.write(frame, f)).then((error) => {
            if (error)
              this._progress.log(`ffmpeg failed to write: ${error}`);
          });
        });
      }
      stop() {
        return __async(this, null, function* () {
          if (this._isStopped)
            return;
          this.writeFrame(Buffer.from([]), this._lastFrameTimestamp + ((0, _utils2.monotonicTime)() - this._lastWriteTimestamp) / 1e3);
          this._isStopped = true;
          yield this._lastWritePromise;
          yield this._gracefullyClose();
        });
      }
    };
    exports2.VideoRecorder = VideoRecorder;
  }
});

// node_modules/playwright-core/lib/server/chromium/crDragDrop.js
var require_crDragDrop = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crDragDrop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DragManager = void 0;
    var _utils2 = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    var DragManager = class {
      constructor(page) {
        this._crPage = void 0;
        this._dragState = null;
        this._lastPosition = {
          x: 0,
          y: 0
        };
        this._crPage = page;
      }
      cancelDrag() {
        return __async(this, null, function* () {
          if (!this._dragState)
            return false;
          yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
            type: "dragCancel",
            x: this._lastPosition.x,
            y: this._lastPosition.y,
            data: {
              items: [],
              dragOperationsMask: 65535
            }
          });
          this._dragState = null;
          return true;
        });
      }
      interceptDragCausedByMove(x, y, button, buttons, modifiers, moveCallback) {
        return __async(this, null, function* () {
          this._lastPosition = {
            x,
            y
          };
          if (this._dragState) {
            yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
              type: "dragOver",
              x,
              y,
              data: this._dragState,
              modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
            });
            return;
          }
          if (button !== "left")
            return moveCallback();
          const client = this._crPage._mainFrameSession._client;
          let onDragIntercepted;
          const dragInterceptedPromise = new Promise((x2) => onDragIntercepted = x2);
          yield Promise.all(this._crPage._page.frames().map((frame) => __async(this, null, function* () {
            yield frame.nonStallingEvaluateInExistingContext(function() {
              let didStartDrag = Promise.resolve(false);
              let dragEvent = null;
              const dragListener = (event) => dragEvent = event;
              const mouseListener = () => {
                didStartDrag = new Promise((callback) => {
                  window.addEventListener("dragstart", dragListener, {
                    once: true,
                    capture: true
                  });
                  setTimeout(() => callback(dragEvent ? !dragEvent.defaultPrevented : false), 0);
                });
              };
              window.addEventListener("mousemove", mouseListener, {
                once: true,
                capture: true
              });
              window.__cleanupDrag = () => __async(this, null, function* () {
                const val = yield didStartDrag;
                window.removeEventListener("mousemove", mouseListener, {
                  capture: true
                });
                window.removeEventListener("dragstart", dragListener, {
                  capture: true
                });
                return val;
              });
            }.toString(), true, "utility").catch(() => {
            });
          })));
          client.on("Input.dragIntercepted", onDragIntercepted);
          try {
            yield client.send("Input.setInterceptDrags", {
              enabled: true
            });
          } catch (e) {
            client.off("Input.dragIntercepted", onDragIntercepted);
            return moveCallback();
          }
          yield moveCallback();
          const expectingDrag = (yield Promise.all(this._crPage._page.frames().map((frame) => __async(this, null, function* () {
            return frame.nonStallingEvaluateInExistingContext("window.__cleanupDrag && window.__cleanupDrag()", false, "utility").catch(() => false);
          })))).some((x2) => x2);
          this._dragState = expectingDrag ? (yield dragInterceptedPromise).data : null;
          client.off("Input.dragIntercepted", onDragIntercepted);
          yield client.send("Input.setInterceptDrags", {
            enabled: false
          });
          if (this._dragState) {
            yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
              type: "dragEnter",
              x,
              y,
              data: this._dragState,
              modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
            });
          }
        });
      }
      isDragging() {
        return !!this._dragState;
      }
      drop(x, y, modifiers) {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this._dragState, "missing drag state");
          yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
            type: "drop",
            x,
            y,
            data: this._dragState,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
          });
          this._dragState = null;
        });
      }
    };
    exports2.DragManager = DragManager;
  }
});

// node_modules/playwright-core/lib/server/chromium/crPage.js
var require_crPage = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRPage = void 0;
    var dom = _interopRequireWildcard2(require_dom());
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard2(require_network());
    var _crConnection = require_crConnection();
    var _crExecutionContext = require_crExecutionContext();
    var _crNetworkManager = require_crNetworkManager();
    var _page = require_page();
    var _crProtocolHelper = require_crProtocolHelper();
    var dialog = _interopRequireWildcard2(require_dialog());
    var _path2 = _interopRequireDefault2(require("path"));
    var _crInput = require_crInput();
    var _crAccessibility = require_crAccessibility();
    var _crCoverage = require_crCoverage();
    var _crPdf = require_crPdf();
    var _crBrowser = require_crBrowser();
    var _stackTrace = require_stackTrace();
    var _utils2 = require_utils();
    var _videoRecorder = require_videoRecorder();
    var _crDragDrop = require_crDragDrop();
    var _registry2 = require_registry();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    var CRPage = class {
      static mainFrameSession(page) {
        const crPage = page._delegate;
        return crPage._mainFrameSession;
      }
      constructor(client, targetId, browserContext, opener, hasUIWindow, isBackgroundPage) {
        this._mainFrameSession = void 0;
        this._sessions = /* @__PURE__ */ new Map();
        this._page = void 0;
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._targetId = void 0;
        this._opener = void 0;
        this._pdf = void 0;
        this._coverage = void 0;
        this._browserContext = void 0;
        this._pagePromise = void 0;
        this._initializedPage = null;
        this._isBackgroundPage = void 0;
        this._nextWindowOpenPopupFeatures = [];
        this._targetId = targetId;
        this._opener = opener;
        this._isBackgroundPage = isBackgroundPage;
        const dragManager = new _crDragDrop.DragManager(this);
        this.rawKeyboard = new _crInput.RawKeyboardImpl(client, browserContext._browser._isMac, dragManager);
        this.rawMouse = new _crInput.RawMouseImpl(this, client, dragManager);
        this.rawTouchscreen = new _crInput.RawTouchscreenImpl(client);
        this._pdf = new _crPdf.CRPDF(client);
        this._coverage = new _crCoverage.CRCoverage(client);
        this._browserContext = browserContext;
        this._page = new _page.Page(this, browserContext);
        this._mainFrameSession = new FrameSession(this, client, targetId, null);
        this._sessions.set(targetId, this._mainFrameSession);
        client.once(_crConnection.CRSessionEvents.Disconnected, () => this._page._didDisconnect());
        if (opener && !browserContext._options.noDefaultViewport) {
          const features = opener._nextWindowOpenPopupFeatures.shift() || [];
          const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(features);
          if (viewportSize)
            this._page._state.emulatedSize = {
              viewport: viewportSize,
              screen: viewportSize
            };
        }
        this._pagePromise = this._mainFrameSession._initialize(hasUIWindow).then((r) => __async(this, null, function* () {
          yield this._page.initOpener(this._opener);
          return r;
        })).catch((e) => __async(this, null, function* () {
          yield this._page.initOpener(this._opener);
          throw e;
        })).then(() => {
          this._initializedPage = this._page;
          this._reportAsNew();
          return this._page;
        }).catch((e) => {
          this._reportAsNew(e);
          return e;
        });
      }
      _reportAsNew(error) {
        if (this._isBackgroundPage) {
          if (!error)
            this._browserContext.emit(_crBrowser.CRBrowserContext.CREvents.BackgroundPage, this._page);
        } else {
          this._page.reportAsNew(error);
        }
      }
      _forAllFrameSessions(cb) {
        return __async(this, null, function* () {
          const frameSessions = Array.from(this._sessions.values());
          yield Promise.all(frameSessions.map((frameSession) => {
            if (frameSession._isMainFrame())
              return cb(frameSession);
            return cb(frameSession).catch((e) => {
              if (e.message && (e.message.includes("Target closed.") || e.message.includes("Session closed.")))
                return;
              throw e;
            });
          }));
        });
      }
      _sessionForFrame(frame) {
        while (!this._sessions.has(frame._id)) {
          const parent = frame.parentFrame();
          if (!parent)
            throw new Error(`Frame has been detached.`);
          frame = parent;
        }
        return this._sessions.get(frame._id);
      }
      _sessionForHandle(handle) {
        const frame = handle._context.frame;
        return this._sessionForFrame(frame);
      }
      willBeginDownload() {
        this._mainFrameSession._willBeginDownload();
      }
      pageOrError() {
        return __async(this, null, function* () {
          return this._pagePromise;
        });
      }
      didClose() {
        for (const session of this._sessions.values())
          session.dispose();
        this._page._didClose();
      }
      navigateFrame(frame, url, referrer) {
        return __async(this, null, function* () {
          return this._sessionForFrame(frame)._navigate(frame, url, referrer);
        });
      }
      exposeBinding(binding) {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._initBinding(binding));
          yield Promise.all(this._page.frames().map((frame) => frame.evaluateExpression(binding.source, false, {}).catch((e) => {
          })));
        });
      }
      updateExtraHTTPHeaders() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateExtraHTTPHeaders(false));
        });
      }
      updateGeolocation() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateGeolocation(false));
        });
      }
      updateOffline() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateOffline(false));
        });
      }
      updateHttpCredentials() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateHttpCredentials(false));
        });
      }
      setEmulatedSize(emulatedSize) {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this._page._state.emulatedSize === emulatedSize);
          yield this._mainFrameSession._updateViewport();
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Page.bringToFront");
        });
      }
      updateEmulateMedia() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateEmulateMedia(false));
        });
      }
      updateRequestInterception() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateRequestInterception());
        });
      }
      setFileChooserIntercepted(enabled) {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._setFileChooserIntercepted(enabled));
        });
      }
      reload() {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Page.reload");
        });
      }
      _go(delta) {
        return __async(this, null, function* () {
          const history = yield this._mainFrameSession._client.send("Page.getNavigationHistory");
          const entry = history.entries[history.currentIndex + delta];
          if (!entry)
            return false;
          yield this._mainFrameSession._client.send("Page.navigateToHistoryEntry", {
            entryId: entry.id
          });
          return true;
        });
      }
      goBack() {
        return this._go(-1);
      }
      goForward() {
        return this._go(1);
      }
      evaluateOnNewDocument(source, world = "main") {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._evaluateOnNewDocument(source, world));
        });
      }
      closePage(runBeforeUnload) {
        return __async(this, null, function* () {
          if (runBeforeUnload)
            yield this._mainFrameSession._client.send("Page.close");
          else
            yield this._browserContext._browser._closePage(this);
        });
      }
      setBackgroundColor(color) {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Emulation.setDefaultBackgroundColorOverride", {
            color
          });
        });
      }
      takeScreenshot(progress, format, documentRect, viewportRect, quality, fitsViewport) {
        return __async(this, null, function* () {
          const {
            visualViewport
          } = yield this._mainFrameSession._client.send("Page.getLayoutMetrics");
          if (!documentRect) {
            documentRect = __spreadValues({
              x: visualViewport.pageX + viewportRect.x,
              y: visualViewport.pageY + viewportRect.y
            }, _helper.helper.enclosingIntSize({
              width: viewportRect.width / visualViewport.scale,
              height: viewportRect.height / visualViewport.scale
            }));
          }
          const clip = __spreadProps(__spreadValues({}, documentRect), {
            scale: viewportRect ? visualViewport.scale : 1
          });
          progress.throwIfAborted();
          const result = yield this._mainFrameSession._client.send("Page.captureScreenshot", {
            format,
            quality,
            clip,
            captureBeyondViewport: !fitsViewport
          });
          return Buffer.from(result.data, "base64");
        });
      }
      getContentFrame(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getContentFrame(handle);
        });
      }
      getOwnerFrame(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getOwnerFrame(handle);
        });
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      getBoundingBox(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getBoundingBox(handle);
        });
      }
      scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._scrollRectIntoViewIfNeeded(handle, rect);
        });
      }
      setScreencastOptions(options) {
        return __async(this, null, function* () {
          if (options) {
            yield this._mainFrameSession._startScreencast(this, {
              format: "jpeg",
              quality: options.quality,
              maxWidth: options.width,
              maxHeight: options.height
            });
          } else {
            yield this._mainFrameSession._stopScreencast(this);
          }
        });
      }
      rafCountForStablePosition() {
        return 1;
      }
      getContentQuads(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getContentQuads(handle);
        });
      }
      setInputFiles(handle, files) {
        return __async(this, null, function* () {
          yield handle.evaluateInUtility(([injected, node, files2]) => injected.setInputFiles(node, files2), files);
        });
      }
      adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._adoptElementHandle(handle, to);
        });
      }
      getAccessibilityTree(needle) {
        return __async(this, null, function* () {
          return (0, _crAccessibility.getAccessibilityTree)(this._mainFrameSession._client, needle);
        });
      }
      inputActionEpilogue() {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Page.enable").catch((e) => {
          });
        });
      }
      pdf(options) {
        return __async(this, null, function* () {
          return this._pdf.generate(options);
        });
      }
      coverage() {
        return this._coverage;
      }
      getFrameElement(frame) {
        return __async(this, null, function* () {
          let parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          const parentSession = this._sessionForFrame(parent);
          const {
            backendNodeId
          } = yield parentSession._client.send("DOM.getFrameOwner", {
            frameId: frame._id
          }).catch((e) => {
            if (e instanceof Error && e.message.includes("Frame with the given id was not found."))
              (0, _stackTrace.rewriteErrorMessage)(e, "Frame has been detached.");
            throw e;
          });
          parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          return parentSession._adoptBackendNodeId(backendNodeId, yield parent._mainContext());
        });
      }
    };
    exports2.CRPage = CRPage;
    var FrameSession = class {
      constructor(crPage, client, targetId, parentSession) {
        this._client = void 0;
        this._crPage = void 0;
        this._page = void 0;
        this._networkManager = void 0;
        this._contextIdToContext = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._targetId = void 0;
        this._firstNonInitialNavigationCommittedPromise = void 0;
        this._firstNonInitialNavigationCommittedFulfill = () => {
        };
        this._firstNonInitialNavigationCommittedReject = (e) => {
        };
        this._windowId = void 0;
        this._swappedIn = false;
        this._videoRecorder = null;
        this._screencastId = null;
        this._screencastClients = /* @__PURE__ */ new Set();
        this._client = client;
        this._crPage = crPage;
        this._page = crPage._page;
        this._targetId = targetId;
        this._networkManager = new _crNetworkManager.CRNetworkManager(client, this._page, parentSession ? parentSession._networkManager : null);
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
          this._firstNonInitialNavigationCommittedFulfill = f;
          this._firstNonInitialNavigationCommittedReject = r;
        });
        client.once(_crConnection.CRSessionEvents.Disconnected, () => {
          this._firstNonInitialNavigationCommittedReject(new Error("Page closed"));
        });
      }
      _isMainFrame() {
        return this._targetId === this._crPage._targetId;
      }
      _addRendererListeners() {
        this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, "Log.entryAdded", (event) => this._onLogEntryAdded(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId, event.reason)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameRequestedNavigation", (event) => this._onFrameRequestedNavigation(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameStoppedLoading", (event) => this._onFrameStoppedLoading(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.javascriptDialogOpening", (event) => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.bindingCalled", (event) => this._onBindingCalled(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.consoleAPICalled", (event) => this._onConsoleAPI(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.exceptionThrown", (exception) => this._handleException(exception.exceptionDetails)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextDestroyed", (event) => this._onExecutionContextDestroyed(event.executionContextId)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", (event) => this._onExecutionContextsCleared()), _eventsHelper.eventsHelper.addEventListener(this._client, "Target.attachedToTarget", (event) => this._onAttachedToTarget(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Target.detachedFromTarget", (event) => this._onDetachedFromTarget(event))]);
      }
      _addBrowserListeners() {
        this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, "Inspector.targetCrashed", (event) => this._onTargetCrashed()), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.screencastFrame", (event) => this._onScreencastFrame(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.windowOpen", (event) => this._onWindowOpen(event))]);
      }
      _initialize(hasUIWindow) {
        return __async(this, null, function* () {
          if (hasUIWindow && !this._crPage._browserContext._browser.isClank() && !this._crPage._browserContext._options.noDefaultViewport) {
            const {
              windowId
            } = yield this._client.send("Browser.getWindowForTarget");
            this._windowId = windowId;
          }
          let screencastOptions;
          if (this._isMainFrame() && this._crPage._browserContext._options.recordVideo && hasUIWindow) {
            const screencastId = (0, _utils2.createGuid)();
            const outputFile = _path2.default.join(this._crPage._browserContext._options.recordVideo.dir, screencastId + ".webm");
            screencastOptions = __spreadProps(__spreadValues({}, this._crPage._browserContext._options.recordVideo.size), {
              outputFile
            });
            yield this._crPage._browserContext._ensureVideosPath();
            yield this._createVideoRecorder(screencastId, screencastOptions);
            this._crPage.pageOrError().then((p) => {
              if (p instanceof Error)
                this._stopVideoRecording().catch(() => {
                });
            });
          }
          let lifecycleEventsEnabled;
          if (!this._isMainFrame())
            this._addRendererListeners();
          this._addBrowserListeners();
          const promises = [this._client.send("Page.enable"), this._client.send("Page.getFrameTree").then(({
            frameTree
          }) => {
            if (this._isMainFrame()) {
              this._handleFrameTree(frameTree);
              this._addRendererListeners();
            }
            const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)];
            for (const frame of localFrames) {
              this._client._sendMayFail("Page.createIsolatedWorld", {
                frameId: frame._id,
                grantUniveralAccess: true,
                worldName: UTILITY_WORLD_NAME
              });
              for (const binding of this._crPage._browserContext._pageBindings.values())
                frame.evaluateExpression(binding.source, false, void 0).catch((e) => {
                });
              for (const source of this._crPage._browserContext._evaluateOnNewDocumentSources)
                frame.evaluateExpression(source, false, void 0, "main").catch((e) => {
                });
            }
            const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ":";
            if (isInitialEmptyPage) {
              lifecycleEventsEnabled.catch((e) => {
              }).then(() => {
                this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
              });
            } else {
              this._firstNonInitialNavigationCommittedFulfill();
              this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
            }
          }), this._client.send("Log.enable", {}), lifecycleEventsEnabled = this._client.send("Page.setLifecycleEventsEnabled", {
            enabled: true
          }), this._client.send("Runtime.enable", {}), this._client.send("Page.addScriptToEvaluateOnNewDocument", {
            source: "",
            worldName: UTILITY_WORLD_NAME
          }), this._networkManager.initialize(), this._client.send("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true
          })];
          if (this._isMainFrame())
            promises.push(this._client.send("Emulation.setFocusEmulationEnabled", {
              enabled: true
            }));
          const options = this._crPage._browserContext._options;
          if (options.bypassCSP)
            promises.push(this._client.send("Page.setBypassCSP", {
              enabled: true
            }));
          if (options.ignoreHTTPSErrors)
            promises.push(this._client.send("Security.setIgnoreCertificateErrors", {
              ignore: true
            }));
          if (this._isMainFrame())
            promises.push(this._updateViewport());
          if (options.hasTouch)
            promises.push(this._client.send("Emulation.setTouchEmulationEnabled", {
              enabled: true
            }));
          if (options.javaScriptEnabled === false)
            promises.push(this._client.send("Emulation.setScriptExecutionDisabled", {
              value: true
            }));
          if (options.userAgent || options.locale)
            promises.push(this._client.send("Emulation.setUserAgentOverride", {
              userAgent: options.userAgent || "",
              acceptLanguage: options.locale
            }));
          if (options.locale)
            promises.push(emulateLocale(this._client, options.locale));
          if (options.timezoneId)
            promises.push(emulateTimezone(this._client, options.timezoneId));
          promises.push(this._updateGeolocation(true));
          promises.push(this._updateExtraHTTPHeaders(true));
          promises.push(this._updateRequestInterception());
          promises.push(this._updateOffline(true));
          promises.push(this._updateHttpCredentials(true));
          promises.push(this._updateEmulateMedia(true));
          for (const binding of this._crPage._page.allBindings())
            promises.push(this._initBinding(binding));
          for (const source of this._crPage._browserContext._evaluateOnNewDocumentSources)
            promises.push(this._evaluateOnNewDocument(source, "main"));
          for (const source of this._crPage._page._evaluateOnNewDocumentSources)
            promises.push(this._evaluateOnNewDocument(source, "main"));
          if (screencastOptions)
            promises.push(this._startVideoRecording(screencastOptions));
          promises.push(this._client.send("Runtime.runIfWaitingForDebugger"));
          promises.push(this._firstNonInitialNavigationCommittedPromise);
          yield Promise.all(promises);
        });
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._crPage._sessions.delete(this._targetId);
      }
      _navigate(frame, url, referrer) {
        return __async(this, null, function* () {
          const response = yield this._client.send("Page.navigate", {
            url,
            referrer,
            frameId: frame._id
          });
          if (response.errorText)
            throw new Error(`${response.errorText} at ${url}`);
          return {
            newDocumentId: response.loaderId
          };
        });
      }
      _onLifecycleEvent(event) {
        if (this._eventBelongsToStaleFrame(event.frameId))
          return;
        if (event.name === "load")
          this._page._frameManager.frameLifecycleEvent(event.frameId, "load");
        else if (event.name === "DOMContentLoaded")
          this._page._frameManager.frameLifecycleEvent(event.frameId, "domcontentloaded");
      }
      _onFrameStoppedLoading(frameId) {
        if (this._eventBelongsToStaleFrame(frameId))
          return;
        this._page._frameManager.frameStoppedLoading(frameId);
      }
      _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      _eventBelongsToStaleFrame(frameId) {
        const frame = this._page._frameManager.frame(frameId);
        if (!frame)
          return true;
        const session = this._crPage._sessionForFrame(frame);
        return session && session !== this && !session._swappedIn;
      }
      _onFrameAttached(frameId, parentFrameId) {
        const frameSession = this._crPage._sessions.get(frameId);
        if (frameSession && frameId !== this._targetId) {
          frameSession._swappedIn = true;
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            this._page._frameManager.removeChildFramesRecursively(frame);
          return;
        }
        if (parentFrameId && !this._page._frameManager.frame(parentFrameId)) {
          return;
        }
        this._page._frameManager.frameAttached(frameId, parentFrameId);
      }
      _onFrameNavigated(framePayload, initial) {
        if (this._eventBelongsToStaleFrame(framePayload.id))
          return;
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ""), framePayload.name || "", framePayload.loaderId, initial);
        if (!initial)
          this._firstNonInitialNavigationCommittedFulfill();
      }
      _onFrameRequestedNavigation(payload) {
        if (this._eventBelongsToStaleFrame(payload.frameId))
          return;
        if (payload.disposition === "currentTab")
          this._page._frameManager.frameRequestedNavigation(payload.frameId);
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        if (this._eventBelongsToStaleFrame(frameId))
          return;
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
      }
      _onFrameDetached(frameId, reason) {
        if (this._crPage._sessions.has(frameId)) {
          return;
        }
        if (reason === "swap") {
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            this._page._frameManager.removeChildFramesRecursively(frame);
          return;
        }
        this._page._frameManager.frameDetached(frameId);
      }
      _onExecutionContextCreated(contextPayload) {
        const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
        if (!frame || this._eventBelongsToStaleFrame(frame._id))
          return;
        const delegate = new _crExecutionContext.CRExecutionContext(this._client, contextPayload);
        let worldName = null;
        if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
          worldName = "main";
        else if (contextPayload.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        this._contextIdToContext.set(contextPayload.id, context);
      }
      _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
      }
      _onExecutionContextsCleared() {
        for (const contextId of Array.from(this._contextIdToContext.keys()))
          this._onExecutionContextDestroyed(contextId);
      }
      _onAttachedToTarget(event) {
        const session = _crConnection.CRConnection.fromSession(this._client).session(event.sessionId);
        if (event.targetInfo.type === "iframe") {
          const targetId = event.targetInfo.targetId;
          const frame = this._page._frameManager.frame(targetId);
          if (!frame)
            return;
          this._page._frameManager.removeChildFramesRecursively(frame);
          const frameSession = new FrameSession(this._crPage, session, targetId, this);
          this._crPage._sessions.set(targetId, frameSession);
          frameSession._initialize(false).catch((e) => e);
          return;
        }
        if (event.targetInfo.type !== "worker") {
          session._sendMayFail("Runtime.runIfWaitingForDebugger").then(() => {
            this._client._sendMayFail("Target.detachFromTarget", {
              sessionId: event.sessionId
            });
          });
          return;
        }
        const url = event.targetInfo.url;
        const worker = new _page.Worker(this._page, url);
        this._page._addWorker(event.sessionId, worker);
        session.once("Runtime.executionContextCreated", (event2) => __async(this, null, function* () {
          worker._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event2.context));
        }));
        session._sendMayFail("Runtime.enable");
        session._sendMayFail("Network.enable");
        session._sendMayFail("Runtime.runIfWaitingForDebugger");
        session.on("Runtime.consoleAPICalled", (event2) => {
          const args = event2.args.map((o) => worker._existingExecutionContext.createHandle(o));
          this._page._addConsoleMessage(event2.type, args, (0, _crProtocolHelper.toConsoleMessageLocation)(event2.stackTrace));
        });
        session.on("Runtime.exceptionThrown", (exception) => this._page.emit(_page.Page.Events.PageError, (0, _crProtocolHelper.exceptionToError)(exception.exceptionDetails)));
        this._networkManager.instrumentNetworkEvents(session, this._page._frameManager.frame(this._targetId));
      }
      _onDetachedFromTarget(event) {
        this._page._removeWorker(event.sessionId);
        const childFrameSession = this._crPage._sessions.get(event.targetId);
        if (!childFrameSession)
          return;
        if (childFrameSession._swappedIn) {
          childFrameSession.dispose();
          return;
        }
        this._client.send("Page.enable").catch((e) => null).then(() => {
          if (!childFrameSession._swappedIn)
            this._page._frameManager.frameDetached(event.targetId);
          childFrameSession.dispose();
        });
      }
      _onWindowOpen(event) {
        this._crPage._nextWindowOpenPopupFeatures.push(event.windowFeatures);
      }
      _onConsoleAPI(event) {
        return __async(this, null, function* () {
          if (event.executionContextId === 0) {
            return;
          }
          const context = this._contextIdToContext.get(event.executionContextId);
          if (!context)
            return;
          const values = event.args.map((arg) => context.createHandle(arg));
          this._page._addConsoleMessage(event.type, values, (0, _crProtocolHelper.toConsoleMessageLocation)(event.stackTrace));
        });
      }
      _initBinding(binding) {
        return __async(this, null, function* () {
          yield Promise.all([this._client.send("Runtime.addBinding", {
            name: binding.name
          }), this._client.send("Page.addScriptToEvaluateOnNewDocument", {
            source: binding.source
          })]);
        });
      }
      _onBindingCalled(event) {
        return __async(this, null, function* () {
          const pageOrError = yield this._crPage.pageOrError();
          if (!(pageOrError instanceof Error)) {
            const context = this._contextIdToContext.get(event.executionContextId);
            if (context)
              yield this._page._onBindingCalled(event.payload, context);
          }
        });
      }
      _onDialog(event) {
        if (!this._page._frameManager.frame(this._targetId))
          return;
        this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, (accept, promptText) => __async(this, null, function* () {
          yield this._client.send("Page.handleJavaScriptDialog", {
            accept,
            promptText
          });
        }), event.defaultPrompt));
      }
      _handleException(exceptionDetails) {
        this._page.firePageError((0, _crProtocolHelper.exceptionToError)(exceptionDetails));
      }
      _onTargetCrashed() {
        return __async(this, null, function* () {
          this._client._markAsCrashed();
          this._page._didCrash();
        });
      }
      _onLogEntryAdded(event) {
        const {
          level,
          text,
          args,
          source,
          url,
          lineNumber
        } = event.entry;
        if (args)
          args.map((arg) => (0, _crProtocolHelper.releaseObject)(this._client, arg.objectId));
        if (source !== "worker") {
          const location2 = {
            url: url || "",
            lineNumber: lineNumber || 0,
            columnNumber: 0
          };
          this._page._addConsoleMessage(level, [], location2, text);
        }
      }
      _onFileChooserOpened(event) {
        return __async(this, null, function* () {
          const frame = this._page._frameManager.frame(event.frameId);
          if (!frame)
            return;
          let handle;
          try {
            const utilityContext = yield frame._utilityContext();
            handle = yield this._adoptBackendNodeId(event.backendNodeId, utilityContext);
          } catch (e) {
            return;
          }
          yield this._page._onFileChooserOpened(handle);
        });
      }
      _willBeginDownload() {
        const originPage = this._crPage._initializedPage;
        if (!originPage) {
          this._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
        }
      }
      _onScreencastFrame(payload) {
        this._page.throttleScreencastFrameAck(() => {
          this._client.send("Page.screencastFrameAck", {
            sessionId: payload.sessionId
          }).catch(() => {
          });
        });
        const buffer = Buffer.from(payload.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          timestamp: payload.metadata.timestamp,
          width: payload.metadata.deviceWidth,
          height: payload.metadata.deviceHeight
        });
      }
      _createVideoRecorder(screencastId, options) {
        return __async(this, null, function* () {
          (0, _utils2.assert)(!this._screencastId);
          const ffmpegPath = _registry2.registry.findExecutable("ffmpeg").executablePathOrDie(this._page._browserContext._browser.options.sdkLanguage);
          this._videoRecorder = yield _videoRecorder.VideoRecorder.launch(this._crPage._page, ffmpegPath, options);
          this._screencastId = screencastId;
        });
      }
      _startVideoRecording(options) {
        return __async(this, null, function* () {
          const screencastId = this._screencastId;
          (0, _utils2.assert)(screencastId);
          this._page.once(_page.Page.Events.Close, () => this._stopVideoRecording().catch(() => {
          }));
          const gotFirstFrame = new Promise((f) => this._client.once("Page.screencastFrame", f));
          yield this._startScreencast(this._videoRecorder, {
            format: "jpeg",
            quality: 90,
            maxWidth: options.width,
            maxHeight: options.height
          });
          gotFirstFrame.then(() => {
            this._crPage._browserContext._browser._videoStarted(this._crPage._browserContext, screencastId, options.outputFile, this._crPage.pageOrError());
          });
        });
      }
      _stopVideoRecording() {
        return __async(this, null, function* () {
          if (!this._screencastId)
            return;
          const screencastId = this._screencastId;
          this._screencastId = null;
          const recorder = this._videoRecorder;
          this._videoRecorder = null;
          yield this._stopScreencast(recorder);
          yield recorder.stop().catch(() => {
          });
          const video = this._crPage._browserContext._browser._takeVideo(screencastId);
          video === null || video === void 0 ? void 0 : video.reportFinished();
        });
      }
      _startScreencast(_0) {
        return __async(this, arguments, function* (client, options = {}) {
          this._screencastClients.add(client);
          if (this._screencastClients.size === 1)
            yield this._client.send("Page.startScreencast", options);
        });
      }
      _stopScreencast(client) {
        return __async(this, null, function* () {
          this._screencastClients.delete(client);
          if (!this._screencastClients.size)
            yield this._client._sendMayFail("Page.stopScreencast");
        });
      }
      _updateExtraHTTPHeaders(initial) {
        return __async(this, null, function* () {
          const headers = network.mergeHeaders([this._crPage._browserContext._options.extraHTTPHeaders, this._page._state.extraHTTPHeaders]);
          if (!initial || headers.length)
            yield this._client.send("Network.setExtraHTTPHeaders", {
              headers: (0, _utils2.headersArrayToObject)(headers, false)
            });
        });
      }
      _updateGeolocation(initial) {
        return __async(this, null, function* () {
          const geolocation = this._crPage._browserContext._options.geolocation;
          if (!initial || geolocation)
            yield this._client.send("Emulation.setGeolocationOverride", geolocation || {});
        });
      }
      _updateOffline(initial) {
        return __async(this, null, function* () {
          const offline = !!this._crPage._browserContext._options.offline;
          if (!initial || offline)
            yield this._networkManager.setOffline(offline);
        });
      }
      _updateHttpCredentials(initial) {
        return __async(this, null, function* () {
          const credentials = this._crPage._browserContext._options.httpCredentials || null;
          if (!initial || credentials)
            yield this._networkManager.authenticate(credentials);
        });
      }
      _updateViewport() {
        return __async(this, null, function* () {
          if (this._crPage._browserContext._browser.isClank())
            return;
          (0, _utils2.assert)(this._isMainFrame());
          const options = this._crPage._browserContext._options;
          const emulatedSize = this._page._state.emulatedSize;
          if (emulatedSize === null)
            return;
          const viewportSize = emulatedSize.viewport;
          const screenSize = emulatedSize.screen;
          const isLandscape = viewportSize.width > viewportSize.height;
          const promises = [this._client.send("Emulation.setDeviceMetricsOverride", {
            mobile: !!options.isMobile,
            width: viewportSize.width,
            height: viewportSize.height,
            screenWidth: screenSize.width,
            screenHeight: screenSize.height,
            deviceScaleFactor: options.deviceScaleFactor || 1,
            screenOrientation: isLandscape ? {
              angle: 90,
              type: "landscapePrimary"
            } : {
              angle: 0,
              type: "portraitPrimary"
            }
          })];
          if (this._windowId) {
            let insets = {
              width: 0,
              height: 0
            };
            if (this._crPage._browserContext._browser.options.headful) {
              insets = {
                width: 24,
                height: 88
              };
              if (process.platform === "win32")
                insets = {
                  width: 16,
                  height: 88
                };
              else if (process.platform === "linux")
                insets = {
                  width: 8,
                  height: 85
                };
              else if (process.platform === "darwin")
                insets = {
                  width: 2,
                  height: 80
                };
              if (this._crPage._browserContext.isPersistentContext()) {
                insets.height += 46;
              }
            }
            promises.push(this.setWindowBounds({
              width: viewportSize.width + insets.width,
              height: viewportSize.height + insets.height
            }));
          }
          yield Promise.all(promises);
        });
      }
      windowBounds() {
        return __async(this, null, function* () {
          const {
            bounds
          } = yield this._client.send("Browser.getWindowBounds", {
            windowId: this._windowId
          });
          return bounds;
        });
      }
      setWindowBounds(bounds) {
        return __async(this, null, function* () {
          return yield this._client.send("Browser.setWindowBounds", {
            windowId: this._windowId,
            bounds
          });
        });
      }
      _updateEmulateMedia(initial) {
        return __async(this, null, function* () {
          if (this._crPage._browserContext._browser.isClank())
            return;
          const colorScheme = this._page._state.colorScheme === null ? "" : this._page._state.colorScheme;
          const reducedMotion = this._page._state.reducedMotion === null ? "" : this._page._state.reducedMotion;
          const forcedColors = this._page._state.forcedColors === null ? "" : this._page._state.forcedColors;
          const features = [{
            name: "prefers-color-scheme",
            value: colorScheme
          }, {
            name: "prefers-reduced-motion",
            value: reducedMotion
          }, {
            name: "forced-colors",
            value: forcedColors
          }];
          yield this._client.send("Emulation.setEmulatedMedia", {
            media: this._page._state.mediaType || "",
            features
          });
        });
      }
      _updateRequestInterception() {
        return __async(this, null, function* () {
          yield this._networkManager.setRequestInterception(this._page._needsRequestInterception());
        });
      }
      _setFileChooserIntercepted(enabled) {
        return __async(this, null, function* () {
          yield this._client.send("Page.setInterceptFileChooserDialog", {
            enabled
          }).catch((e) => {
          });
        });
      }
      _evaluateOnNewDocument(source, world) {
        return __async(this, null, function* () {
          const worldName = world === "utility" ? UTILITY_WORLD_NAME : void 0;
          yield this._client.send("Page.addScriptToEvaluateOnNewDocument", {
            source,
            worldName
          });
        });
      }
      _getContentFrame(handle) {
        return __async(this, null, function* () {
          const nodeInfo = yield this._client.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          if (!nodeInfo || typeof nodeInfo.node.frameId !== "string")
            return null;
          return this._page._frameManager.frame(nodeInfo.node.frameId);
        });
      }
      _getOwnerFrame(handle) {
        return __async(this, null, function* () {
          const documentElement = yield handle.evaluateHandle((node) => {
            const doc = node;
            if (doc.documentElement && doc.documentElement.ownerDocument === doc)
              return doc.documentElement;
            return node.ownerDocument ? node.ownerDocument.documentElement : null;
          });
          if (!documentElement)
            return null;
          if (!documentElement._objectId)
            return null;
          const nodeInfo = yield this._client.send("DOM.describeNode", {
            objectId: documentElement._objectId
          });
          const frameId = nodeInfo && typeof nodeInfo.node.frameId === "string" ? nodeInfo.node.frameId : null;
          documentElement.dispose();
          return frameId;
        });
      }
      _getBoundingBox(handle) {
        return __async(this, null, function* () {
          const result = yield this._client._sendMayFail("DOM.getBoxModel", {
            objectId: handle._objectId
          });
          if (!result)
            return null;
          const quad = result.model.border;
          const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
          const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
          const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
          const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
          const position = yield this._framePosition();
          if (!position)
            return null;
          return {
            x: x + position.x,
            y: y + position.y,
            width,
            height
          };
        });
      }
      _framePosition() {
        return __async(this, null, function* () {
          const frame = this._page._frameManager.frame(this._targetId);
          if (!frame)
            return null;
          if (frame === this._page.mainFrame())
            return {
              x: 0,
              y: 0
            };
          const element = yield frame.frameElement();
          const box = yield element.boundingBox();
          return box;
        });
      }
      _scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return yield this._client.send("DOM.scrollIntoViewIfNeeded", {
            objectId: handle._objectId,
            rect
          }).then(() => "done").catch((e) => {
            if (e instanceof Error && e.message.includes("Node does not have a layout object"))
              return "error:notvisible";
            if (e instanceof Error && e.message.includes("Node is detached from document"))
              return "error:notconnected";
            throw e;
          });
        });
      }
      _getContentQuads(handle) {
        return __async(this, null, function* () {
          const result = yield this._client._sendMayFail("DOM.getContentQuads", {
            objectId: handle._objectId
          });
          if (!result)
            return null;
          const position = yield this._framePosition();
          if (!position)
            return null;
          return result.quads.map((quad) => [{
            x: quad[0] + position.x,
            y: quad[1] + position.y
          }, {
            x: quad[2] + position.x,
            y: quad[3] + position.y
          }, {
            x: quad[4] + position.x,
            y: quad[5] + position.y
          }, {
            x: quad[6] + position.x,
            y: quad[7] + position.y
          }]);
        });
      }
      _adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          const nodeInfo = yield this._client.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          return this._adoptBackendNodeId(nodeInfo.node.backendNodeId, to);
        });
      }
      _adoptBackendNodeId(backendNodeId, to) {
        return __async(this, null, function* () {
          const result = yield this._client._sendMayFail("DOM.resolveNode", {
            backendNodeId,
            executionContextId: to[contextDelegateSymbol]._contextId
          });
          if (!result || result.object.subtype === "null")
            throw new Error(dom.kUnableToAdoptErrorMessage);
          return to.createHandle(result.object).asElement();
        });
      }
    };
    function emulateLocale(session, locale) {
      return __async(this, null, function* () {
        try {
          yield session.send("Emulation.setLocaleOverride", {
            locale
          });
        } catch (exception) {
          if (exception.message.includes("Another locale override is already in effect"))
            return;
          throw exception;
        }
      });
    }
    function emulateTimezone(session, timezoneId) {
      return __async(this, null, function* () {
        try {
          yield session.send("Emulation.setTimezoneOverride", {
            timezoneId
          });
        } catch (exception) {
          if (exception.message.includes("Timezone override is already in effect"))
            return;
          if (exception.message.includes("Invalid timezone"))
            throw new Error(`Invalid timezone ID: ${timezoneId}`);
          throw exception;
        }
      });
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/chromium/crBrowser.js
var require_crBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crBrowser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRBrowserContext = exports2.CRBrowser = void 0;
    var _browser = require_browser2();
    var _browserContext = require_browserContext();
    var _utils2 = require_utils();
    var network = _interopRequireWildcard2(require_network());
    var _page = require_page();
    var _frames = require_frames();
    var _crConnection = require_crConnection();
    var _crPage = require_crPage();
    var _crProtocolHelper = require_crProtocolHelper();
    var _crExecutionContext = require_crExecutionContext();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRBrowser = class extends _browser.Browser {
      static connect(transport, options, devtools) {
        return __async(this, null, function* () {
          const connection = new _crConnection.CRConnection(transport, options.protocolLogger, options.browserLogsCollector);
          const browser = new CRBrowser(connection, options);
          browser._devtools = devtools;
          const session = connection.rootSession;
          if (options.__testHookOnConnectToBrowser)
            yield options.__testHookOnConnectToBrowser();
          const version = yield session.send("Browser.getVersion");
          browser._isMac = version.userAgent.includes("Macintosh");
          browser._version = version.product.substring(version.product.indexOf("/") + 1);
          browser._userAgent = version.userAgent;
          if (!options.persistent) {
            yield session.send("Target.setAutoAttach", {
              autoAttach: true,
              waitForDebuggerOnStart: true,
              flatten: true
            });
            return browser;
          }
          browser._defaultContext = new CRBrowserContext(browser, void 0, options.persistent);
          yield Promise.all([session.send("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true
          }).then(() => __async(this, null, function* () {
            yield session.send("Target.getTargetInfo");
          })), browser._defaultContext._initialize()]);
          yield browser._waitForAllPagesToBeInitialized();
          return browser;
        });
      }
      constructor(connection, options) {
        super(options);
        this._connection = void 0;
        this._session = void 0;
        this._clientRootSessionPromise = null;
        this._contexts = /* @__PURE__ */ new Map();
        this._crPages = /* @__PURE__ */ new Map();
        this._backgroundPages = /* @__PURE__ */ new Map();
        this._serviceWorkers = /* @__PURE__ */ new Map();
        this._devtools = void 0;
        this._isMac = false;
        this._version = "";
        this._tracingRecording = false;
        this._tracingPath = "";
        this._tracingClient = void 0;
        this._userAgent = "";
        this._connection = connection;
        this._session = this._connection.rootSession;
        this._connection.on(_crConnection.ConnectionEvents.Disconnected, () => this._didClose());
        this._session.on("Target.attachedToTarget", this._onAttachedToTarget.bind(this));
        this._session.on("Target.detachedFromTarget", this._onDetachedFromTarget.bind(this));
        this._session.on("Browser.downloadWillBegin", this._onDownloadWillBegin.bind(this));
        this._session.on("Browser.downloadProgress", this._onDownloadProgress.bind(this));
      }
      newContext(options) {
        return __async(this, null, function* () {
          (0, _browserContext.validateBrowserContextOptions)(options, this.options);
          let proxyBypassList = void 0;
          if (options.proxy) {
            if (process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK)
              proxyBypassList = options.proxy.bypass;
            else
              proxyBypassList = "<-loopback>" + (options.proxy.bypass ? `,${options.proxy.bypass}` : "");
          }
          const {
            browserContextId
          } = yield this._session.send("Target.createBrowserContext", {
            disposeOnDetach: true,
            proxyServer: options.proxy ? options.proxy.server : void 0,
            proxyBypassList
          });
          const context = new CRBrowserContext(this, browserContextId, options);
          yield context._initialize();
          this._contexts.set(browserContextId, context);
          return context;
        });
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return this._version;
      }
      userAgent() {
        return this._userAgent;
      }
      isClank() {
        return this.options.name === "clank";
      }
      _waitForAllPagesToBeInitialized() {
        return __async(this, null, function* () {
          yield Promise.all([...this._crPages.values()].map((page) => page.pageOrError()));
        });
      }
      _onAttachedToTarget({
        targetInfo,
        sessionId,
        waitingForDebugger
      }) {
        if (targetInfo.type === "browser")
          return;
        const session = this._connection.session(sessionId);
        (0, _utils2.assert)(targetInfo.browserContextId, "targetInfo: " + JSON.stringify(targetInfo, null, 2));
        let context = this._contexts.get(targetInfo.browserContextId) || null;
        if (!context) {
          context = this._defaultContext;
        }
        if (targetInfo.type === "other" && targetInfo.url.startsWith("devtools://devtools") && this._devtools) {
          this._devtools.install(session);
          return;
        }
        if (targetInfo.type === "other" || !context) {
          if (waitingForDebugger) {
            session._sendMayFail("Runtime.runIfWaitingForDebugger").then(() => {
              this._session._sendMayFail("Target.detachFromTarget", {
                sessionId
              });
            });
          }
          return;
        }
        (0, _utils2.assert)(!this._crPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        (0, _utils2.assert)(!this._backgroundPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        (0, _utils2.assert)(!this._serviceWorkers.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        if (targetInfo.type === "background_page") {
          const backgroundPage = new _crPage.CRPage(session, targetInfo.targetId, context, null, false, true);
          this._backgroundPages.set(targetInfo.targetId, backgroundPage);
          return;
        }
        if (targetInfo.type === "page") {
          const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;
          const crPage = new _crPage.CRPage(session, targetInfo.targetId, context, opener, true, false);
          this._crPages.set(targetInfo.targetId, crPage);
          return;
        }
        if (targetInfo.type === "service_worker") {
          const serviceWorker = new CRServiceWorker(context, session, targetInfo.url);
          this._serviceWorkers.set(targetInfo.targetId, serviceWorker);
          context.emit(CRBrowserContext.CREvents.ServiceWorker, serviceWorker);
          return;
        }
        (0, _utils2.assert)(false, "Unknown target type: " + targetInfo.type);
      }
      _onDetachedFromTarget(payload) {
        const targetId = payload.targetId;
        const crPage = this._crPages.get(targetId);
        if (crPage) {
          this._crPages.delete(targetId);
          crPage.didClose();
          return;
        }
        const backgroundPage = this._backgroundPages.get(targetId);
        if (backgroundPage) {
          this._backgroundPages.delete(targetId);
          backgroundPage.didClose();
          return;
        }
        const serviceWorker = this._serviceWorkers.get(targetId);
        if (serviceWorker) {
          this._serviceWorkers.delete(targetId);
          serviceWorker.didClose();
          return;
        }
      }
      _findOwningPage(frameId) {
        for (const crPage of this._crPages.values()) {
          const frame = crPage._page._frameManager.frame(frameId);
          if (frame)
            return crPage;
        }
        return null;
      }
      _onDownloadWillBegin(payload) {
        const page = this._findOwningPage(payload.frameId);
        (0, _utils2.assert)(page, "Download started in unknown page: " + JSON.stringify(payload));
        page.willBeginDownload();
        let originPage = page._initializedPage;
        if (!originPage && page._opener)
          originPage = page._opener._initializedPage;
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.guid, payload.url, payload.suggestedFilename);
      }
      _onDownloadProgress(payload) {
        if (payload.state === "completed")
          this._downloadFinished(payload.guid, "");
        if (payload.state === "canceled")
          this._downloadFinished(payload.guid, "canceled");
      }
      _closePage(crPage) {
        return __async(this, null, function* () {
          yield this._session.send("Target.closeTarget", {
            targetId: crPage._targetId
          });
        });
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          return yield this._connection.createBrowserSession();
        });
      }
      startTracing(_0) {
        return __async(this, arguments, function* (page, options = {}) {
          (0, _utils2.assert)(!this._tracingRecording, "Cannot start recording trace while already recording trace.");
          this._tracingClient = page ? page._delegate._mainFrameSession._client : this._session;
          const defaultCategories = ["-*", "devtools.timeline", "v8.execute", "disabled-by-default-devtools.timeline", "disabled-by-default-devtools.timeline.frame", "toplevel", "blink.console", "blink.user_timing", "latencyInfo", "disabled-by-default-devtools.timeline.stack", "disabled-by-default-v8.cpu_profiler", "disabled-by-default-v8.cpu_profiler.hires"];
          const {
            path = null,
            screenshots = false,
            categories = defaultCategories
          } = options;
          if (screenshots)
            categories.push("disabled-by-default-devtools.screenshot");
          this._tracingPath = path;
          this._tracingRecording = true;
          yield this._tracingClient.send("Tracing.start", {
            transferMode: "ReturnAsStream",
            categories: categories.join(",")
          });
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this._tracingClient, "Tracing was not started.");
          const [event] = yield Promise.all([new Promise((f) => this._tracingClient.once("Tracing.tracingComplete", f)), this._tracingClient.send("Tracing.end")]);
          const result = yield (0, _crProtocolHelper.readProtocolStream)(this._tracingClient, event.stream, this._tracingPath);
          this._tracingRecording = false;
          return result;
        });
      }
      isConnected() {
        return !this._connection._closed;
      }
      _clientRootSession() {
        return __async(this, null, function* () {
          if (!this._clientRootSessionPromise)
            this._clientRootSessionPromise = this._connection.createBrowserSession();
          return this._clientRootSessionPromise;
        });
      }
    };
    exports2.CRBrowser = CRBrowser;
    var CRServiceWorker = class extends _page.Worker {
      constructor(browserContext, session, url) {
        super(browserContext, url);
        this._browserContext = void 0;
        this._browserContext = browserContext;
        session.once("Runtime.executionContextCreated", (event) => {
          this._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event.context));
        });
        session.send("Runtime.enable", {}).catch((e) => {
        });
        session.send("Runtime.runIfWaitingForDebugger").catch((e) => {
        });
      }
    };
    var CRBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
        this._evaluateOnNewDocumentSources = void 0;
        this._evaluateOnNewDocumentSources = [];
        this._authenticateProxyViaCredentials();
      }
      _initialize() {
        var __superGet = (key) => super[key];
        return __async(this, null, function* () {
          (0, _utils2.assert)(!Array.from(this._browser._crPages.values()).some((page) => page._browserContext === this));
          const promises = [__superGet("_initialize").call(this)];
          if (this._browser.options.name !== "electron" && this._browser.options.name !== "clank") {
            promises.push(this._browser._session.send("Browser.setDownloadBehavior", {
              behavior: this._options.acceptDownloads ? "allowAndName" : "deny",
              browserContextId: this._browserContextId,
              downloadPath: this._browser.options.downloadsPath,
              eventsEnabled: true
            }));
          }
          if (this._options.permissions)
            promises.push(this.grantPermissions(this._options.permissions));
          yield Promise.all(promises);
        });
      }
      pages() {
        const result = [];
        for (const crPage of this._browser._crPages.values()) {
          if (crPage._browserContext === this && crPage._initializedPage)
            result.push(crPage._initializedPage);
        }
        return result;
      }
      newPageDelegate() {
        return __async(this, null, function* () {
          (0, _browserContext.assertBrowserContextIsNotOwned)(this);
          const oldKeys = this._browser.isClank() ? new Set(this._browser._crPages.keys()) : void 0;
          let {
            targetId
          } = yield this._browser._session.send("Target.createTarget", {
            url: "about:blank",
            browserContextId: this._browserContextId
          });
          if (oldKeys) {
            const newKeys = new Set(this._browser._crPages.keys());
            for (const key of oldKeys)
              newKeys.delete(key);
            for (const key of newKeys) {
              const page = this._browser._crPages.get(key);
              if (page._opener)
                newKeys.delete(key);
            }
            (0, _utils2.assert)(newKeys.size === 1);
            [targetId] = [...newKeys];
          }
          return this._browser._crPages.get(targetId);
        });
      }
      _doCookies(urls) {
        return __async(this, null, function* () {
          const {
            cookies
          } = yield this._browser._session.send("Storage.getCookies", {
            browserContextId: this._browserContextId
          });
          return network.filterCookies(cookies.map((c) => {
            const copy = __spreadValues({
              sameSite: "Lax"
            }, c);
            delete copy.size;
            delete copy.priority;
            delete copy.session;
            delete copy.sameParty;
            delete copy.sourceScheme;
            delete copy.sourcePort;
            return copy;
          }), urls);
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          yield this._browser._session.send("Storage.setCookies", {
            cookies: network.rewriteCookies(cookies),
            browserContextId: this._browserContextId
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._browser._session.send("Storage.clearCookies", {
            browserContextId: this._browserContextId
          });
        });
      }
      _doGrantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          const webPermissionToProtocol = /* @__PURE__ */ new Map([
            ["geolocation", "geolocation"],
            ["midi", "midi"],
            ["notifications", "notifications"],
            ["camera", "videoCapture"],
            ["microphone", "audioCapture"],
            ["background-sync", "backgroundSync"],
            ["ambient-light-sensor", "sensors"],
            ["accelerometer", "sensors"],
            ["gyroscope", "sensors"],
            ["magnetometer", "sensors"],
            ["accessibility-events", "accessibilityEvents"],
            ["clipboard-read", "clipboardReadWrite"],
            ["clipboard-write", "clipboardSanitizedWrite"],
            ["payment-handler", "paymentHandler"],
            ["midi-sysex", "midiSysex"]
          ]);
          const filtered = permissions.map((permission) => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
              throw new Error("Unknown permission: " + permission);
            return protocolPermission;
          });
          yield this._browser._session.send("Browser.grantPermissions", {
            origin: origin === "*" ? void 0 : origin,
            browserContextId: this._browserContextId,
            permissions: filtered
          });
        });
      }
      _doClearPermissions() {
        return __async(this, null, function* () {
          yield this._browser._session.send("Browser.resetPermissions", {
            browserContextId: this._browserContextId
          });
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          (0, _browserContext.verifyGeolocation)(geolocation);
          this._options.geolocation = geolocation;
          for (const page of this.pages())
            yield page._delegate.updateGeolocation();
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          this._options.extraHTTPHeaders = headers;
          for (const page of this.pages())
            yield page._delegate.updateExtraHTTPHeaders();
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          this._options.offline = offline;
          for (const page of this.pages())
            yield page._delegate.updateOffline();
        });
      }
      _doSetHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          this._options.httpCredentials = httpCredentials;
          for (const page of this.pages())
            yield page._delegate.updateHttpCredentials();
        });
      }
      _doAddInitScript(source) {
        return __async(this, null, function* () {
          this._evaluateOnNewDocumentSources.push(source);
          for (const page of this.pages())
            yield page._delegate.evaluateOnNewDocument(source);
        });
      }
      _doExposeBinding(binding) {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.exposeBinding(binding);
        });
      }
      _doUpdateRequestInterception() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.updateRequestInterception();
        });
      }
      _doClose() {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this._browserContextId);
          yield this._browser._session.send("Target.disposeBrowserContext", {
            browserContextId: this._browserContextId
          });
          this._browser._contexts.delete(this._browserContextId);
          for (const [targetId, serviceWorker] of this._browser._serviceWorkers) {
            if (serviceWorker._browserContext !== this)
              continue;
            serviceWorker.didClose();
            this._browser._serviceWorkers.delete(targetId);
          }
        });
      }
      _onClosePersistent() {
        for (const [targetId, backgroundPage] of this._browser._backgroundPages.entries()) {
          if (backgroundPage._browserContext === this && backgroundPage._initializedPage) {
            backgroundPage.didClose();
            this._browser._backgroundPages.delete(targetId);
          }
        }
      }
      _doCancelDownload(guid) {
        return __async(this, null, function* () {
          yield this._browser._session.send("Browser.cancelDownload", {
            guid,
            browserContextId: this._browserContextId
          });
        });
      }
      backgroundPages() {
        const result = [];
        for (const backgroundPage of this._browser._backgroundPages.values()) {
          if (backgroundPage._browserContext === this && backgroundPage._initializedPage)
            result.push(backgroundPage._initializedPage);
        }
        return result;
      }
      serviceWorkers() {
        return Array.from(this._browser._serviceWorkers.values()).filter((serviceWorker) => serviceWorker._browserContext === this);
      }
      newCDPSession(page) {
        return __async(this, null, function* () {
          let targetId = null;
          if (page instanceof _page.Page) {
            targetId = page._delegate._targetId;
          } else if (page instanceof _frames.Frame) {
            const session = page._page._delegate._sessions.get(page._id);
            if (!session)
              throw new Error(`This frame does not have a separate CDP session, it is a part of the parent frame's session`);
            targetId = session._targetId;
          } else {
            throw new Error("page: expected Page or Frame");
          }
          const rootSession = yield this._browser._clientRootSession();
          const {
            sessionId
          } = yield rootSession.send("Target.attachToTarget", {
            targetId,
            flatten: true
          });
          return this._browser._connection.session(sessionId);
        });
      }
    };
    exports2.CRBrowserContext = CRBrowserContext;
    CRBrowserContext.CREvents = {
      BackgroundPage: "backgroundpage",
      ServiceWorker: "serviceworker"
    };
  }
});

// node_modules/playwright-core/lib/protocol/transport.js
var require_transport = __commonJS({
  "node_modules/playwright-core/lib/protocol/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Transport = void 0;
    var _utils2 = require_utils();
    var Transport = class {
      constructor(pipeWrite, pipeRead, closeable, endian = "le") {
        this._pipeWrite = void 0;
        this._data = Buffer.from([]);
        this._waitForNextTask = (0, _utils2.makeWaitForNextTask)();
        this._closed = false;
        this._bytesLeft = 0;
        this.onmessage = void 0;
        this.onclose = void 0;
        this._endian = void 0;
        this._closeableStream = void 0;
        this._pipeWrite = pipeWrite;
        this._endian = endian;
        this._closeableStream = closeable;
        pipeRead.on("data", (buffer) => this._dispatch(buffer));
        pipeRead.on("close", () => {
          this._closed = true;
          if (this.onclose)
            this.onclose();
        });
        this.onmessage = void 0;
        this.onclose = void 0;
      }
      send(message) {
        if (this._closed)
          throw new Error("Pipe has been closed");
        const data = Buffer.from(message, "utf-8");
        const dataLength = Buffer.alloc(4);
        if (this._endian === "be")
          dataLength.writeUInt32BE(data.length, 0);
        else
          dataLength.writeUInt32LE(data.length, 0);
        this._pipeWrite.write(dataLength);
        this._pipeWrite.write(data);
      }
      close() {
        this._closeableStream.close();
      }
      _dispatch(buffer) {
        this._data = Buffer.concat([this._data, buffer]);
        while (true) {
          if (!this._bytesLeft && this._data.length < 4) {
            break;
          }
          if (!this._bytesLeft) {
            this._bytesLeft = this._endian === "be" ? this._data.readUInt32BE(0) : this._data.readUInt32LE(0);
            this._data = this._data.slice(4);
          }
          if (!this._bytesLeft || this._data.length < this._bytesLeft) {
            break;
          }
          const message = this._data.slice(0, this._bytesLeft);
          this._data = this._data.slice(this._bytesLeft);
          this._bytesLeft = 0;
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage(message.toString("utf-8"));
          });
        }
      }
    };
    exports2.Transport = Transport;
  }
});

// node_modules/playwright-core/lib/server/android/android.js
var require_android = __commonJS({
  "node_modules/playwright-core/lib/server/android/android.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AndroidDevice = exports2.Android = void 0;
    var _debug = _interopRequireDefault2(require_src());
    var _events = require("events");
    var _fs2 = _interopRequireDefault2(require("fs"));
    var ws = _interopRequireWildcard2(require("ws"));
    var _utils2 = require_utils();
    var _browserContext = require_browserContext();
    var _progress = require_progress2();
    var _crBrowser = require_crBrowser();
    var _helper = require_helper();
    var _transport = require_transport();
    var _debugLogger = require_debugLogger();
    var _timeoutSettings = require_timeoutSettings();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Android = class extends _instrumentation.SdkObject {
      constructor(backend, playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "android");
        this._backend = void 0;
        this._devices = /* @__PURE__ */ new Map();
        this._timeoutSettings = void 0;
        this._playwrightOptions = void 0;
        this._backend = backend;
        this._playwrightOptions = playwrightOptions;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      devices() {
        return __async(this, null, function* () {
          const devices = (yield this._backend.devices()).filter((d) => d.status === "device");
          const newSerials = /* @__PURE__ */ new Set();
          for (const d of devices) {
            newSerials.add(d.serial);
            if (this._devices.has(d.serial))
              continue;
            const device = yield AndroidDevice.create(this, d);
            this._devices.set(d.serial, device);
          }
          for (const d of this._devices.keys()) {
            if (!newSerials.has(d))
              this._devices.delete(d);
          }
          return [...this._devices.values()];
        });
      }
      _deviceClosed(device) {
        this._devices.delete(device.serial);
      }
    };
    exports2.Android = Android;
    var AndroidDevice = class extends _instrumentation.SdkObject {
      constructor(android, backend, model) {
        super(android, "android-device");
        this._backend = void 0;
        this.model = void 0;
        this.serial = void 0;
        this._driverPromise = void 0;
        this._lastId = 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._pollingWebViews = void 0;
        this._timeoutSettings = void 0;
        this._webViews = /* @__PURE__ */ new Map();
        this._browserConnections = /* @__PURE__ */ new Set();
        this._android = void 0;
        this._isClosed = false;
        this._android = android;
        this._backend = backend;
        this.model = model;
        this.serial = backend.serial;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(android._timeoutSettings);
      }
      static create(android, backend) {
        return __async(this, null, function* () {
          yield backend.init();
          const model = yield backend.runCommand("shell:getprop ro.product.model");
          const device = new AndroidDevice(android, backend, model.toString().trim());
          yield device._init();
          return device;
        });
      }
      _init() {
        return __async(this, null, function* () {
          yield this._refreshWebViews();
          const poll = () => {
            this._pollingWebViews = setTimeout(() => this._refreshWebViews().then(poll).catch(() => {
            }), 500);
          };
          poll();
        });
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      shell(command) {
        return __async(this, null, function* () {
          const result = yield this._backend.runCommand(`shell:${command}`);
          yield this._refreshWebViews();
          return result;
        });
      }
      open(command) {
        return __async(this, null, function* () {
          return yield this._backend.open(`${command}`);
        });
      }
      screenshot() {
        return __async(this, null, function* () {
          return yield this._backend.runCommand(`shell:screencap -p`);
        });
      }
      _driver() {
        return __async(this, null, function* () {
          if (!this._driverPromise)
            this._driverPromise = this._installDriver();
          return this._driverPromise;
        });
      }
      _installDriver() {
        return __async(this, null, function* () {
          (0, _debug.default)("pw:android")("Stopping the old driver");
          yield this.shell(`am force-stop com.microsoft.playwright.androiddriver`);
          (0, _debug.default)("pw:android")("Uninstalling the old driver");
          yield this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver`);
          yield this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver.test`);
          (0, _debug.default)("pw:android")("Installing the new driver");
          for (const file of ["android-driver.apk", "android-driver-target.apk"])
            yield this.installApk(yield _fs2.default.promises.readFile(require.resolve(`../../../bin/${file}`)));
          (0, _debug.default)("pw:android")("Starting the new driver");
          this.shell("am instrument -w com.microsoft.playwright.androiddriver.test/androidx.test.runner.AndroidJUnitRunner").catch((e) => (0, _debug.default)("pw:android")(e));
          const socket = yield this._waitForLocalAbstract("playwright_android_driver_socket");
          const transport = new _transport.Transport(socket, socket, socket, "be");
          transport.onmessage = (message) => {
            const response = JSON.parse(message);
            const {
              id,
              result,
              error
            } = response;
            const callback = this._callbacks.get(id);
            if (!callback)
              return;
            if (error)
              callback.reject(new Error(error));
            else
              callback.fulfill(result);
            this._callbacks.delete(id);
          };
          return transport;
        });
      }
      _waitForLocalAbstract(socketName) {
        return __async(this, null, function* () {
          let socket;
          (0, _debug.default)("pw:android")(`Polling the socket localabstract:${socketName}`);
          while (!socket) {
            try {
              socket = yield this._backend.open(`localabstract:${socketName}`);
            } catch (e) {
              yield new Promise((f) => setTimeout(f, 250));
            }
          }
          (0, _debug.default)("pw:android")(`Connected to localabstract:${socketName}`);
          return socket;
        });
      }
      send(_0) {
        return __async(this, arguments, function* (method, params = {}) {
          params.timeout = this._timeoutSettings.timeout(params);
          const driver = yield this._driver();
          const id = ++this._lastId;
          const result = new Promise((fulfill, reject) => this._callbacks.set(id, {
            fulfill,
            reject
          }));
          driver.send(JSON.stringify({
            id,
            method,
            params
          }));
          return result;
        });
      }
      close() {
        return __async(this, null, function* () {
          this._isClosed = true;
          if (this._pollingWebViews)
            clearTimeout(this._pollingWebViews);
          for (const connection of this._browserConnections)
            yield connection.close();
          if (this._driverPromise) {
            const driver = yield this._driver();
            driver.close();
          }
          yield this._backend.close();
          this._android._deviceClosed(this);
          this.emit(AndroidDevice.Events.Closed);
        });
      }
      launchBrowser(pkg = "com.android.chrome", options) {
        return __async(this, null, function* () {
          (0, _debug.default)("pw:android")("Force-stopping", pkg);
          yield this._backend.runCommand(`shell:am force-stop ${pkg}`);
          const socketName = "playwright-" + (0, _utils2.createGuid)();
          const commandLine = `_ --disable-fre --no-default-browser-check --no-first-run --remote-debugging-socket-name=${socketName}`;
          (0, _debug.default)("pw:android")("Starting", pkg, commandLine);
          yield this._backend.runCommand(`shell:echo "${commandLine}" > /data/local/tmp/chrome-command-line`);
          yield this._backend.runCommand(`shell:am start -n ${pkg}/com.google.android.apps.chrome.Main about:blank`);
          return yield this._connectToBrowser(socketName, options);
        });
      }
      connectToWebView(pid) {
        return __async(this, null, function* () {
          const webView = this._webViews.get(pid);
          if (!webView)
            throw new Error("WebView has been closed");
          return yield this._connectToBrowser(`webview_devtools_remote_${pid}`);
        });
      }
      _connectToBrowser(_0) {
        return __async(this, arguments, function* (socketName, options = {}) {
          const socket = yield this._waitForLocalAbstract(socketName);
          const androidBrowser = new AndroidBrowser(this, socket);
          yield androidBrowser._init();
          this._browserConnections.add(androidBrowser);
          const browserOptions = __spreadProps(__spreadValues({}, this._android._playwrightOptions), {
            name: "clank",
            isChromium: true,
            slowMo: 0,
            persistent: __spreadProps(__spreadValues({}, options), {
              noDefaultViewport: true
            }),
            artifactsDir: "",
            downloadsPath: "",
            tracesDir: "",
            browserProcess: new ClankBrowserProcess(androidBrowser),
            proxy: options.proxy,
            protocolLogger: _helper.helper.debugProtocolLogger(),
            browserLogsCollector: new _debugLogger.RecentLogsCollector()
          });
          (0, _browserContext.validateBrowserContextOptions)(options, browserOptions);
          const browser = yield _crBrowser.CRBrowser.connect(androidBrowser, browserOptions);
          const controller = new _progress.ProgressController((0, _instrumentation.internalCallMetadata)(), this);
          const defaultContext = browser._defaultContext;
          yield controller.run((progress) => __async(this, null, function* () {
            yield defaultContext._loadDefaultContextAsIs(progress);
          }));
          {
            const page = defaultContext.pages()[0];
            const crPage = page._delegate;
            yield crPage._mainFrameSession._client.send("Emulation.setDeviceMetricsOverride", {
              mobile: false,
              width: 0,
              height: 0,
              deviceScaleFactor: 0
            });
            yield crPage._mainFrameSession._client.send("Emulation.clearDeviceMetricsOverride", {});
          }
          return defaultContext;
        });
      }
      webViews() {
        return [...this._webViews.values()];
      }
      installApk(content, options) {
        return __async(this, null, function* () {
          const args = options && options.args ? options.args : ["-r", "-t", "-S"];
          (0, _debug.default)("pw:android")("Opening install socket");
          const installSocket = yield this._backend.open(`shell:cmd package install ${args.join(" ")} ${content.length}`);
          (0, _debug.default)("pw:android")("Writing driver bytes: " + content.length);
          yield installSocket.write(content);
          const success = yield new Promise((f) => installSocket.on("data", f));
          (0, _debug.default)("pw:android")("Written driver bytes: " + success);
          installSocket.close();
        });
      }
      push(content, path, mode = 420) {
        return __async(this, null, function* () {
          const socket = yield this._backend.open(`sync:`);
          const sendHeader = (command, length) => __async(this, null, function* () {
            const buffer = Buffer.alloc(command.length + 4);
            buffer.write(command, 0);
            buffer.writeUInt32LE(length, command.length);
            yield socket.write(buffer);
          });
          const send = (command, data) => __async(this, null, function* () {
            yield sendHeader(command, data.length);
            yield socket.write(data);
          });
          yield send("SEND", Buffer.from(`${path},${mode}`));
          const maxChunk = 65535;
          for (let i = 0; i < content.length; i += maxChunk)
            yield send("DATA", content.slice(i, i + maxChunk));
          yield sendHeader("DONE", Date.now() / 1e3 | 0);
          const result = yield new Promise((f) => socket.once("data", f));
          const code = result.slice(0, 4).toString();
          if (code !== "OKAY")
            throw new Error("Could not push: " + code);
          socket.close();
        });
      }
      _refreshWebViews() {
        return __async(this, null, function* () {
          const sockets = (yield this._backend.runCommand(`shell:cat /proc/net/unix | grep webview_devtools_remote`)).toString().split("\n");
          if (this._isClosed)
            return;
          const newPids = /* @__PURE__ */ new Set();
          for (const line of sockets) {
            const match = line.match(/[^@]+@webview_devtools_remote_(\d+)/);
            if (!match)
              continue;
            const pid = +match[1];
            newPids.add(pid);
          }
          for (const pid of newPids) {
            if (this._webViews.has(pid))
              continue;
            const procs = (yield this._backend.runCommand(`shell:ps -A | grep ${pid}`)).toString().split("\n");
            if (this._isClosed)
              return;
            let pkg = "";
            for (const proc of procs) {
              const match = proc.match(/[^\s]+\s+(\d+).*$/);
              if (!match)
                continue;
              const p = match[1];
              if (+p !== pid)
                continue;
              pkg = proc.substring(proc.lastIndexOf(" ") + 1);
            }
            const webView = {
              pid,
              pkg
            };
            this._webViews.set(pid, webView);
            this.emit(AndroidDevice.Events.WebViewAdded, webView);
          }
          for (const p of this._webViews.keys()) {
            if (!newPids.has(p)) {
              this._webViews.delete(p);
              this.emit(AndroidDevice.Events.WebViewRemoved, p);
            }
          }
        });
      }
    };
    exports2.AndroidDevice = AndroidDevice;
    AndroidDevice.Events = {
      WebViewAdded: "webViewAdded",
      WebViewRemoved: "webViewRemoved",
      Closed: "closed"
    };
    var AndroidBrowser = class extends _events.EventEmitter {
      constructor(device, socket) {
        super();
        this.device = void 0;
        this._socket = void 0;
        this._receiver = void 0;
        this._waitForNextTask = (0, _utils2.makeWaitForNextTask)();
        this.onmessage = void 0;
        this.onclose = void 0;
        this.setMaxListeners(0);
        this.device = device;
        this._socket = socket;
        this._socket.on("close", () => {
          this._waitForNextTask(() => {
            if (this.onclose)
              this.onclose();
          });
        });
        this._receiver = new ws.Receiver();
        this._receiver.on("message", (message) => {
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage(JSON.parse(message));
          });
        });
      }
      _init() {
        return __async(this, null, function* () {
          yield this._socket.write(Buffer.from(`GET /devtools/browser HTTP/1.1\r
Upgrade: WebSocket\r
Connection: Upgrade\r
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r
Sec-WebSocket-Version: 13\r
\r
`));
          yield new Promise((f) => this._socket.once("data", f));
          this._socket.on("data", (data) => this._receiver._write(data, "binary", () => {
          }));
        });
      }
      send(s) {
        return __async(this, null, function* () {
          yield this._socket.write(encodeWebFrame(JSON.stringify(s)));
        });
      }
      close() {
        return __async(this, null, function* () {
          this._socket.close();
        });
      }
    };
    function encodeWebFrame(data) {
      return ws.Sender.frame(Buffer.from(data), {
        opcode: 1,
        mask: true,
        fin: true,
        readOnly: true
      })[0];
    }
    var ClankBrowserProcess = class {
      constructor(browser) {
        this._browser = void 0;
        this.onclose = void 0;
        this._browser = browser;
      }
      kill() {
        return __async(this, null, function* () {
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._browser.close();
        });
      }
    };
  }
});

// node_modules/playwright-core/lib/server/android/backendAdb.js
var require_backendAdb = __commonJS({
  "node_modules/playwright-core/lib/server/android/backendAdb.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AdbBackend = void 0;
    var _assert = _interopRequireDefault2(require("assert"));
    var _debug = _interopRequireDefault2(require_src());
    var net = _interopRequireWildcard2(require("net"));
    var _events = require("events");
    var _utils2 = require_utils();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var AdbBackend = class {
      devices() {
        return __async(this, null, function* () {
          const result = yield runCommand("host:devices");
          const lines = result.toString().trim().split("\n");
          return lines.map((line) => {
            const [serial, status] = line.trim().split("	");
            return new AdbDevice(serial, status);
          });
        });
      }
    };
    exports2.AdbBackend = AdbBackend;
    var AdbDevice = class {
      constructor(serial, status) {
        this.serial = void 0;
        this.status = void 0;
        this.serial = serial;
        this.status = status;
      }
      init() {
        return __async(this, null, function* () {
        });
      }
      close() {
        return __async(this, null, function* () {
        });
      }
      runCommand(command) {
        return runCommand(command, this.serial);
      }
      open(command) {
        return __async(this, null, function* () {
          const result = yield open2(command, this.serial);
          result.becomeSocket();
          return result;
        });
      }
    };
    function runCommand(command, serial) {
      return __async(this, null, function* () {
        (0, _debug.default)("pw:adb:runCommand")(command, serial);
        const socket = new BufferedSocketWrapper(command, net.createConnection({
          port: 5037
        }));
        if (serial) {
          yield socket.write(encodeMessage(`host:transport:${serial}`));
          const status2 = yield socket.read(4);
          (0, _assert.default)(status2.toString() === "OKAY", status2.toString());
        }
        yield socket.write(encodeMessage(command));
        const status = yield socket.read(4);
        (0, _assert.default)(status.toString() === "OKAY", status.toString());
        let commandOutput;
        if (!command.startsWith("shell:")) {
          const remainingLength = parseInt((yield socket.read(4)).toString(), 16);
          commandOutput = yield socket.read(remainingLength);
        } else {
          commandOutput = yield socket.readAll();
        }
        socket.close();
        return commandOutput;
      });
    }
    function open2(command, serial) {
      return __async(this, null, function* () {
        const socket = new BufferedSocketWrapper(command, net.createConnection({
          port: 5037
        }));
        if (serial) {
          yield socket.write(encodeMessage(`host:transport:${serial}`));
          const status2 = yield socket.read(4);
          (0, _assert.default)(status2.toString() === "OKAY", status2.toString());
        }
        yield socket.write(encodeMessage(command));
        const status = yield socket.read(4);
        (0, _assert.default)(status.toString() === "OKAY", status.toString());
        return socket;
      });
    }
    function encodeMessage(message) {
      let lenHex = message.length.toString(16);
      lenHex = "0".repeat(4 - lenHex.length) + lenHex;
      return Buffer.from(lenHex + message);
    }
    var BufferedSocketWrapper = class extends _events.EventEmitter {
      constructor(command, socket) {
        super();
        this.guid = (0, _utils2.createGuid)();
        this._socket = void 0;
        this._buffer = Buffer.from([]);
        this._isSocket = false;
        this._notifyReader = void 0;
        this._connectPromise = void 0;
        this._isClosed = false;
        this._command = void 0;
        this._command = command;
        this._socket = socket;
        this._connectPromise = new Promise((f) => this._socket.on("connect", f));
        this._socket.on("data", (data) => {
          (0, _debug.default)("pw:adb:data")(data.toString());
          if (this._isSocket) {
            this.emit("data", data);
            return;
          }
          this._buffer = Buffer.concat([this._buffer, data]);
          if (this._notifyReader)
            this._notifyReader();
        });
        this._socket.on("close", () => {
          this._isClosed = true;
          if (this._notifyReader)
            this._notifyReader();
          this.close();
          this.emit("close");
        });
        this._socket.on("error", (error) => this.emit("error", error));
      }
      write(data) {
        return __async(this, null, function* () {
          (0, _debug.default)("pw:adb:send")(data.toString().substring(0, 100) + "...");
          yield this._connectPromise;
          yield new Promise((f) => this._socket.write(data, f));
        });
      }
      close() {
        if (this._isClosed)
          return;
        (0, _debug.default)("pw:adb")("Close " + this._command);
        this._socket.destroy();
      }
      read(length) {
        return __async(this, null, function* () {
          yield this._connectPromise;
          (0, _assert.default)(!this._isSocket, "Can not read by length in socket mode");
          while (this._buffer.length < length)
            yield new Promise((f) => this._notifyReader = f);
          const result = this._buffer.slice(0, length);
          this._buffer = this._buffer.slice(length);
          (0, _debug.default)("pw:adb:recv")(result.toString().substring(0, 100) + "...");
          return result;
        });
      }
      readAll() {
        return __async(this, null, function* () {
          while (!this._isClosed)
            yield new Promise((f) => this._notifyReader = f);
          return this._buffer;
        });
      }
      becomeSocket() {
        (0, _assert.default)(!this._buffer.length);
        this._isSocket = true;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/transport.js
var require_transport2 = __commonJS({
  "node_modules/playwright-core/lib/server/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebSocketTransport = void 0;
    var _ws = _interopRequireDefault2(require("ws"));
    var _utils2 = require_utils();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var WebSocketTransport = class {
      static connect(progress, url, headers) {
        return __async(this, null, function* () {
          progress.log(`<ws connecting> ${url}`);
          const transport = new WebSocketTransport(progress, url, headers);
          let success = false;
          progress.cleanupWhenAborted(() => __async(this, null, function* () {
            if (!success)
              yield transport.closeAndWait().catch((e) => null);
          }));
          yield new Promise((fulfill, reject) => {
            transport._ws.addEventListener("open", () => __async(this, null, function* () {
              progress.log(`<ws connected> ${url}`);
              fulfill(transport);
            }));
            transport._ws.addEventListener("error", (event) => {
              progress.log(`<ws connect error> ${url} ${event.message}`);
              reject(new Error("WebSocket error: " + event.message));
              transport._ws.close();
            });
          });
          success = true;
          return transport;
        });
      }
      constructor(progress, url, headers) {
        this._ws = void 0;
        this._progress = void 0;
        this.onmessage = void 0;
        this.onclose = void 0;
        this.wsEndpoint = void 0;
        this.wsEndpoint = url;
        this._ws = new _ws.default(url, [], {
          perMessageDeflate: false,
          maxPayload: 256 * 1024 * 1024,
          handshakeTimeout: progress.timeUntilDeadline(),
          headers
        });
        this._progress = progress;
        const messageWrap = (0, _utils2.makeWaitForNextTask)();
        this._ws.addEventListener("message", (event) => {
          messageWrap(() => {
            try {
              if (this.onmessage)
                this.onmessage.call(null, JSON.parse(event.data));
            } catch (e) {
              this._ws.close();
            }
          });
        });
        this._ws.addEventListener("close", (event) => {
          this._progress && this._progress.log(`<ws disconnected> ${url}`);
          if (this.onclose)
            this.onclose.call(null);
        });
        this._ws.addEventListener("error", () => {
        });
      }
      send(message) {
        this._ws.send(JSON.stringify(message));
      }
      close() {
        this._progress && this._progress.log(`<ws disconnecting> ${this._ws.url}`);
        this._ws.close();
      }
      closeAndWait() {
        return __async(this, null, function* () {
          const promise = new Promise((f) => this._ws.once("close", f));
          this.close();
          yield promise;
        });
      }
    };
    exports2.WebSocketTransport = WebSocketTransport;
  }
});

// node_modules/playwright-core/lib/server/pipeTransport.js
var require_pipeTransport = __commonJS({
  "node_modules/playwright-core/lib/server/pipeTransport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PipeTransport = void 0;
    var _utils2 = require_utils();
    var _debugLogger = require_debugLogger();
    var PipeTransport = class {
      constructor(pipeWrite, pipeRead) {
        this._pipeWrite = void 0;
        this._pendingMessage = "";
        this._waitForNextTask = (0, _utils2.makeWaitForNextTask)();
        this._closed = false;
        this.onmessage = void 0;
        this.onclose = void 0;
        this._pipeWrite = pipeWrite;
        pipeRead.on("data", (buffer) => this._dispatch(buffer));
        pipeRead.on("close", () => {
          this._closed = true;
          if (this.onclose)
            this.onclose.call(null);
        });
        pipeRead.on("error", (e) => _debugLogger.debugLogger.log("error", e));
        pipeWrite.on("error", (e) => _debugLogger.debugLogger.log("error", e));
        this.onmessage = void 0;
        this.onclose = void 0;
      }
      send(message) {
        if (this._closed)
          throw new Error("Pipe has been closed");
        this._pipeWrite.write(JSON.stringify(message));
        this._pipeWrite.write("\0");
      }
      close() {
        throw new Error("unimplemented");
      }
      _dispatch(buffer) {
        let end = buffer.indexOf("\0");
        if (end === -1) {
          this._pendingMessage += buffer.toString();
          return;
        }
        const message = this._pendingMessage + buffer.toString(void 0, 0, end);
        this._waitForNextTask(() => {
          if (this.onmessage)
            this.onmessage.call(null, JSON.parse(message));
        });
        let start = end + 1;
        end = buffer.indexOf("\0", start);
        while (end !== -1) {
          const message2 = buffer.toString(void 0, start, end);
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage.call(null, JSON.parse(message2));
          });
          start = end + 1;
          end = buffer.indexOf("\0", start);
        }
        this._pendingMessage = buffer.toString(void 0, start);
      }
    };
    exports2.PipeTransport = PipeTransport;
  }
});

// node_modules/playwright-core/lib/server/browserType.js
var require_browserType = __commonJS({
  "node_modules/playwright-core/lib/server/browserType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserType = void 0;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var os = _interopRequireWildcard2(require("os"));
    var _path2 = _interopRequireDefault2(require("path"));
    var _browserContext = require_browserContext();
    var _registry2 = require_registry();
    var _transport = require_transport2();
    var _processLauncher = require_processLauncher();
    var _pipeTransport = require_pipeTransport();
    var _progress = require_progress2();
    var _timeoutSettings = require_timeoutSettings();
    var _utils2 = require_utils();
    var _helper = require_helper();
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path2.default.join(os.tmpdir(), "playwright-artifacts-");
    var BrowserType = class extends _instrumentation.SdkObject {
      constructor(browserName, playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "browser-type");
        this._name = void 0;
        this._playwrightOptions = void 0;
        this.attribution.browserType = this;
        this._playwrightOptions = playwrightOptions;
        this._name = browserName;
      }
      executablePath() {
        return _registry2.registry.findExecutable(this._name).executablePath(this._playwrightOptions.sdkLanguage) || "";
      }
      name() {
        return this._name;
      }
      launch(metadata, options, protocolLogger) {
        return __async(this, null, function* () {
          options = this._validateLaunchOptions(options);
          const controller = new _progress.ProgressController(metadata, this);
          controller.setLogName("browser");
          const browser = yield controller.run((progress) => {
            const seleniumHubUrl = options.__testHookSeleniumRemoteURL || process.env.SELENIUM_REMOTE_URL;
            if (seleniumHubUrl)
              return this._launchWithSeleniumHub(progress, seleniumHubUrl, options);
            return this._innerLaunchWithRetries(progress, options, void 0, _helper.helper.debugProtocolLogger(protocolLogger)).catch((e) => {
              throw this._rewriteStartupError(e);
            });
          }, _timeoutSettings.TimeoutSettings.timeout(options));
          return browser;
        });
      }
      launchPersistentContext(metadata, userDataDir, options) {
        return __async(this, null, function* () {
          options = this._validateLaunchOptions(options);
          const controller = new _progress.ProgressController(metadata, this);
          const persistent = options;
          controller.setLogName("browser");
          const browser = yield controller.run((progress) => {
            return this._innerLaunchWithRetries(progress, options, persistent, _helper.helper.debugProtocolLogger(), userDataDir).catch((e) => {
              throw this._rewriteStartupError(e);
            });
          }, _timeoutSettings.TimeoutSettings.timeout(options));
          return browser._defaultContext;
        });
      }
      _innerLaunchWithRetries(progress, options, persistent, protocolLogger, userDataDir) {
        return __async(this, null, function* () {
          try {
            return this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);
          } catch (error) {
            const errorMessage = typeof error === "object" && typeof error.message === "string" ? error.message : "";
            if (errorMessage.includes("Inconsistency detected by ld.so")) {
              progress.log(`<restarting browser due to hitting race condition in glibc>`);
              return this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);
            }
            throw error;
          }
        });
      }
      _innerLaunch(progress, options, persistent, protocolLogger, userDataDir) {
        return __async(this, null, function* () {
          options.proxy = options.proxy ? (0, _browserContext.normalizeProxySettings)(options.proxy) : void 0;
          const browserLogsCollector = new _debugLogger.RecentLogsCollector();
          const {
            browserProcess,
            artifactsDir,
            transport
          } = yield this._launchProcess(progress, options, !!persistent, browserLogsCollector, userDataDir);
          if (options.__testHookBeforeCreateBrowser)
            yield options.__testHookBeforeCreateBrowser();
          const browserOptions = __spreadProps(__spreadValues({}, this._playwrightOptions), {
            name: this._name,
            isChromium: this._name === "chromium",
            channel: options.channel,
            slowMo: options.slowMo,
            persistent,
            headful: !options.headless,
            artifactsDir,
            downloadsPath: options.downloadsPath || artifactsDir,
            tracesDir: options.tracesDir || artifactsDir,
            browserProcess,
            customExecutablePath: options.executablePath,
            proxy: options.proxy,
            protocolLogger,
            browserLogsCollector,
            wsEndpoint: options.useWebSocket ? transport.wsEndpoint : void 0
          });
          if (persistent)
            (0, _browserContext.validateBrowserContextOptions)(persistent, browserOptions);
          copyTestHooks(options, browserOptions);
          const browser = yield this._connectToTransport(transport, browserOptions);
          if (persistent && !options.ignoreAllDefaultArgs)
            yield browser._defaultContext._loadDefaultContext(progress);
          return browser;
        });
      }
      _launchProcess(progress, options, isPersistent, browserLogsCollector, userDataDir) {
        return __async(this, null, function* () {
          var _options$args;
          const {
            ignoreDefaultArgs,
            ignoreAllDefaultArgs,
            args = [],
            executablePath = null,
            handleSIGINT = true,
            handleSIGTERM = true,
            handleSIGHUP = true
          } = options;
          const env = options.env ? (0, _processLauncher.envArrayToObject)(options.env) : process.env;
          const tempDirectories = [];
          if (options.downloadsPath)
            yield _fs2.default.promises.mkdir(options.downloadsPath, {
              recursive: true
            });
          if (options.tracesDir)
            yield _fs2.default.promises.mkdir(options.tracesDir, {
              recursive: true
            });
          const artifactsDir = yield _fs2.default.promises.mkdtemp(ARTIFACTS_FOLDER);
          tempDirectories.push(artifactsDir);
          if (userDataDir) {
            if (!(yield (0, _utils2.existsAsync)(userDataDir)))
              yield _fs2.default.promises.mkdir(userDataDir, {
                recursive: true,
                mode: 448
              });
          } else {
            userDataDir = yield _fs2.default.promises.mkdtemp(_path2.default.join(os.tmpdir(), `playwright_${this._name}dev_profile-`));
            tempDirectories.push(userDataDir);
          }
          const browserArguments = [];
          if (ignoreAllDefaultArgs)
            browserArguments.push(...args);
          else if (ignoreDefaultArgs)
            browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir).filter((arg) => ignoreDefaultArgs.indexOf(arg) === -1));
          else
            browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir));
          let executable;
          if (executablePath) {
            if (!(yield (0, _utils2.existsAsync)(executablePath)))
              throw new Error(`Failed to launch ${this._name} because executable doesn't exist at ${executablePath}`);
            executable = executablePath;
          } else {
            const registryExecutable = _registry2.registry.findExecutable(options.channel || this._name);
            if (!registryExecutable || registryExecutable.browserName !== this._name)
              throw new Error(`Unsupported ${this._name} channel "${options.channel}"`);
            executable = registryExecutable.executablePathOrDie(this._playwrightOptions.sdkLanguage);
            yield registryExecutable.validateHostRequirements(this._playwrightOptions.sdkLanguage);
          }
          let wsEndpointCallback;
          const shouldWaitForWSListening = options.useWebSocket || ((_options$args = options.args) === null || _options$args === void 0 ? void 0 : _options$args.some((a) => a.startsWith("--remote-debugging-port")));
          const waitForWSEndpoint = shouldWaitForWSListening ? new Promise((f) => wsEndpointCallback = f) : void 0;
          let transport = void 0;
          let browserProcess = void 0;
          const {
            launchedProcess,
            gracefullyClose,
            kill
          } = yield (0, _processLauncher.launchProcess)({
            command: executable,
            args: browserArguments,
            env: this._amendEnvironment(env, userDataDir, executable, browserArguments),
            handleSIGINT,
            handleSIGTERM,
            handleSIGHUP,
            log: (message) => {
              if (wsEndpointCallback) {
                const match = message.match(/DevTools listening on (.*)/);
                if (match)
                  wsEndpointCallback(match[1]);
              }
              progress.log(message);
              browserLogsCollector.log(message);
            },
            stdio: "pipe",
            tempDirectories,
            attemptToGracefullyClose: () => __async(this, null, function* () {
              if (options.__testHookGracefullyClose)
                yield options.__testHookGracefullyClose();
              this._attemptToGracefullyCloseBrowser(transport);
            }),
            onExit: (exitCode, signal) => {
              if (browserProcess && browserProcess.onclose)
                browserProcess.onclose(exitCode, signal);
            }
          });
          function closeOrKill(timeout) {
            return __async(this, null, function* () {
              let timer;
              try {
                yield Promise.race([gracefullyClose(), new Promise((resolve, reject) => timer = setTimeout(reject, timeout))]);
              } catch (ignored) {
                yield kill().catch((ignored2) => {
                });
              } finally {
                clearTimeout(timer);
              }
            });
          }
          browserProcess = {
            onclose: void 0,
            process: launchedProcess,
            close: () => closeOrKill(options.__testHookBrowserCloseTimeout || _timeoutSettings.DEFAULT_TIMEOUT),
            kill
          };
          progress.cleanupWhenAborted(() => closeOrKill(progress.timeUntilDeadline()));
          let wsEndpoint;
          if (shouldWaitForWSListening)
            wsEndpoint = yield waitForWSEndpoint;
          if (options.useWebSocket) {
            transport = yield _transport.WebSocketTransport.connect(progress, wsEndpoint);
          } else {
            const stdio = launchedProcess.stdio;
            transport = new _pipeTransport.PipeTransport(stdio[3], stdio[4]);
          }
          return {
            browserProcess,
            artifactsDir,
            transport
          };
        });
      }
      connectOverCDP(metadata, endpointURL, options, timeout) {
        return __async(this, null, function* () {
          throw new Error("CDP connections are only supported by Chromium");
        });
      }
      _launchWithSeleniumHub(progress, hubUrl, options) {
        return __async(this, null, function* () {
          throw new Error("Connecting to SELENIUM_REMOTE_URL is only supported by Chromium");
        });
      }
      _validateLaunchOptions(options) {
        const {
          devtools = false
        } = options;
        let {
          headless = !devtools,
          downloadsPath,
          proxy
        } = options;
        if ((0, _utils2.debugMode)())
          headless = false;
        if (downloadsPath && !_path2.default.isAbsolute(downloadsPath))
          downloadsPath = _path2.default.join(process.cwd(), downloadsPath);
        if (this._playwrightOptions.socksProxyPort)
          proxy = {
            server: `socks5://127.0.0.1:${this._playwrightOptions.socksProxyPort}`
          };
        return __spreadProps(__spreadValues({}, options), {
          devtools,
          headless,
          downloadsPath,
          proxy
        });
      }
    };
    exports2.BrowserType = BrowserType;
    function copyTestHooks(from, to) {
      for (const [key, value] of Object.entries(from)) {
        if (key.startsWith("__testHook"))
          to[key] = value;
      }
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crDevTools.js
var require_crDevTools = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crDevTools.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRDevTools = void 0;
    var _fs2 = _interopRequireDefault2(require("fs"));
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var kBindingName = "__pw_devtools__";
    var CRDevTools = class {
      constructor(preferencesPath) {
        this._preferencesPath = void 0;
        this._prefs = void 0;
        this._savePromise = void 0;
        this.__testHookOnBinding = void 0;
        this._preferencesPath = preferencesPath;
        this._savePromise = Promise.resolve();
      }
      install(session) {
        session.on("Runtime.bindingCalled", (event) => __async(this, null, function* () {
          if (event.name !== kBindingName)
            return;
          const parsed = JSON.parse(event.payload);
          let result = void 0;
          if (this.__testHookOnBinding)
            this.__testHookOnBinding(parsed);
          if (parsed.method === "getPreferences") {
            if (this._prefs === void 0) {
              try {
                const json = yield _fs2.default.promises.readFile(this._preferencesPath, "utf8");
                this._prefs = JSON.parse(json);
              } catch (e) {
                this._prefs = {};
              }
            }
            result = this._prefs;
          } else if (parsed.method === "setPreference") {
            this._prefs[parsed.params[0]] = parsed.params[1];
            this._save();
          } else if (parsed.method === "removePreference") {
            delete this._prefs[parsed.params[0]];
            this._save();
          } else if (parsed.method === "clearPreferences") {
            this._prefs = {};
            this._save();
          }
          session.send("Runtime.evaluate", {
            expression: `window.DevToolsAPI.embedderMessageAck(${parsed.id}, ${JSON.stringify(result)})`,
            contextId: event.executionContextId
          }).catch((e) => null);
        }));
        Promise.all([session.send("Runtime.enable"), session.send("Runtime.addBinding", {
          name: kBindingName
        }), session.send("Page.enable"), session.send("Page.addScriptToEvaluateOnNewDocument", {
          source: `
        (() => {
          const init = () => {
            // Lazy init happens when InspectorFrontendHost is initialized.
            // At this point DevToolsHost is ready to be used.
            const host = window.DevToolsHost;
            const old = host.sendMessageToEmbedder.bind(host);
            host.sendMessageToEmbedder = message => {
              if (['getPreferences', 'setPreference', 'removePreference', 'clearPreferences'].includes(JSON.parse(message).method))
                window.${kBindingName}(message);
              else
                old(message);
            };
          };
          let value;
          Object.defineProperty(window, 'InspectorFrontendHost', {
            configurable: true,
            enumerable: true,
            get() { return value; },
            set(v) { value = v; init(); },
          });
        })()
      `
        }), session.send("Runtime.runIfWaitingForDebugger")]).catch((e) => null);
      }
      _save() {
        this._savePromise = this._savePromise.then(() => __async(this, null, function* () {
          yield _fs2.default.promises.writeFile(this._preferencesPath, JSON.stringify(this._prefs)).catch((e) => null);
        }));
      }
    };
    exports2.CRDevTools = CRDevTools;
  }
});

// node_modules/playwright-core/lib/server/chromium/chromium.js
var require_chromium = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/chromium.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Chromium = void 0;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _os2 = _interopRequireDefault2(require("os"));
    var _path2 = _interopRequireDefault2(require("path"));
    var _crBrowser = require_crBrowser();
    var _processLauncher = require_processLauncher();
    var _crConnection = require_crConnection();
    var _stackTrace = require_stackTrace();
    var _browserType = require_browserType();
    var _transport = require_transport2();
    var _crDevTools = require_crDevTools();
    var _browser = require_browser2();
    var _utils2 = require_utils();
    var _debugLogger = require_debugLogger();
    var _progress = require_progress2();
    var _timeoutSettings = require_timeoutSettings();
    var _helper = require_helper();
    var _http = _interopRequireDefault2(require("http"));
    var _https = _interopRequireDefault2(require("https"));
    var _registry2 = require_registry();
    var _async = require_async();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path2.default.join(_os2.default.tmpdir(), "playwright-artifacts-");
    var Chromium = class extends _browserType.BrowserType {
      constructor(playwrightOptions) {
        super("chromium", playwrightOptions);
        this._devtools = void 0;
        if ((0, _utils2.debugMode)())
          this._devtools = this._createDevTools();
      }
      connectOverCDP(metadata, endpointURL, options, timeout) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          controller.setLogName("browser");
          return controller.run((progress) => __async(this, null, function* () {
            return yield this._connectOverCDPInternal(progress, endpointURL, options);
          }), _timeoutSettings.TimeoutSettings.timeout({
            timeout
          }));
        });
      }
      _connectOverCDPInternal(progress, endpointURL, options, onClose) {
        return __async(this, null, function* () {
          let headersMap;
          if (options.headers)
            headersMap = (0, _utils2.headersArrayToObject)(options.headers, false);
          if (!headersMap)
            headersMap = {
              "User-Agent": (0, _utils2.getUserAgent)()
            };
          else if (headersMap && !Object.keys(headersMap).some((key) => key.toLowerCase() === "user-agent"))
            headersMap["User-Agent"] = (0, _utils2.getUserAgent)();
          const artifactsDir = yield _fs2.default.promises.mkdtemp(ARTIFACTS_FOLDER);
          const wsEndpoint = yield urlToWSEndpoint(progress, endpointURL);
          progress.throwIfAborted();
          const chromeTransport = yield _transport.WebSocketTransport.connect(progress, wsEndpoint, headersMap);
          const cleanedUp = new _async.ManualPromise();
          const doCleanup = () => __async(this, null, function* () {
            yield (0, _utils2.removeFolders)([artifactsDir]);
            yield onClose === null || onClose === void 0 ? void 0 : onClose();
            cleanedUp.resolve();
          });
          const doClose = () => __async(this, null, function* () {
            yield chromeTransport.closeAndWait();
            yield cleanedUp;
          });
          const browserProcess = {
            close: doClose,
            kill: doClose
          };
          const browserOptions = __spreadProps(__spreadValues({}, this._playwrightOptions), {
            slowMo: options.slowMo,
            name: "chromium",
            isChromium: true,
            persistent: {
              noDefaultViewport: true
            },
            browserProcess,
            protocolLogger: _helper.helper.debugProtocolLogger(),
            browserLogsCollector: new _debugLogger.RecentLogsCollector(),
            artifactsDir,
            downloadsPath: artifactsDir,
            tracesDir: artifactsDir,
            proxy: {
              server: "per-context"
            }
          });
          progress.throwIfAborted();
          const browser = yield _crBrowser.CRBrowser.connect(chromeTransport, browserOptions);
          browser.on(_browser.Browser.Events.Disconnected, doCleanup);
          return browser;
        });
      }
      _createDevTools() {
        const directory = _registry2.registry.findExecutable("chromium").directory;
        return directory ? new _crDevTools.CRDevTools(_path2.default.join(directory, "devtools-preferences.json")) : void 0;
      }
      _connectToTransport(transport, options) {
        return __async(this, null, function* () {
          let devtools = this._devtools;
          if (options.__testHookForDevTools) {
            devtools = this._createDevTools();
            yield options.__testHookForDevTools(devtools);
          }
          return _crBrowser.CRBrowser.connect(transport, options, devtools);
        });
      }
      _rewriteStartupError(error) {
        if (!error.message.includes("crbug.com/357670") && !error.message.includes("No usable sandbox!") && !error.message.includes("crbug.com/638180"))
          return error;
        return (0, _stackTrace.rewriteErrorMessage)(error, [`Chromium sandboxing failed!`, `================================`, `To workaround sandboxing issues, do either of the following:`, `  - (preferred): Configure environment to support sandboxing: https://playwright.dev/docs/troubleshooting`, `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`, `================================`, ``].join("\n"));
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        return env;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        const message = {
          method: "Browser.close",
          id: _crConnection.kBrowserCloseMessageId,
          params: {}
        };
        transport.send(message);
      }
      _launchWithSeleniumHub(progress, hubUrl, options) {
        return __async(this, null, function* () {
          if (!hubUrl.endsWith("/"))
            hubUrl = hubUrl + "/";
          const args = this._innerDefaultArgs(options);
          args.push("--remote-debugging-port=0");
          let desiredCapabilities = {
            "browserName": "chrome",
            "goog:chromeOptions": {
              args
            }
          };
          try {
            if (process.env.SELENIUM_REMOTE_CAPABILITIES) {
              const parsed = JSON.parse(process.env.SELENIUM_REMOTE_CAPABILITIES);
              desiredCapabilities = __spreadValues(__spreadValues({}, desiredCapabilities), parsed);
              progress.log(`<selenium> using additional capabilities "${process.env.SELENIUM_REMOTE_CAPABILITIES}"`);
            }
          } catch (e) {
            progress.log(`<selenium> ignoring additional capabilities "${process.env.SELENIUM_REMOTE_CAPABILITIES}": ${e}`);
          }
          progress.log(`<selenium> connecting to ${hubUrl}`);
          const response = yield (0, _utils2.fetchData)({
            url: hubUrl + "session",
            method: "POST",
            data: JSON.stringify({
              desiredCapabilities,
              capabilities: {
                alwaysMatch: desiredCapabilities
              }
            }),
            timeout: progress.timeUntilDeadline()
          }, seleniumErrorHandler);
          const value = JSON.parse(response).value;
          const sessionId = value.sessionId;
          progress.log(`<selenium> connected to sessionId=${sessionId}`);
          const disconnectFromSelenium = () => __async(this, null, function* () {
            progress.log(`<selenium> disconnecting from sessionId=${sessionId}`);
            yield (0, _utils2.fetchData)({
              url: hubUrl + "session/" + sessionId,
              method: "DELETE"
            }).catch((error) => progress.log(`<error disconnecting from selenium>: ${error}`));
            progress.log(`<selenium> disconnected from sessionId=${sessionId}`);
            _processLauncher.gracefullyCloseSet.delete(disconnectFromSelenium);
          });
          _processLauncher.gracefullyCloseSet.add(disconnectFromSelenium);
          try {
            const capabilities = value.capabilities;
            let endpointURL;
            if (capabilities["se:cdp"]) {
              progress.log(`<selenium> using selenium v4`);
              const endpointURLString = addProtocol(capabilities["se:cdp"]);
              endpointURL = new URL(endpointURLString);
              if (endpointURL.hostname === "localhost" || endpointURL.hostname === "127.0.0.1")
                endpointURL.hostname = new URL(hubUrl).hostname;
              progress.log(`<selenium> retrieved endpoint ${endpointURL.toString()} for sessionId=${sessionId}`);
            } else {
              progress.log(`<selenium> using selenium v3`);
              const maybeChromeOptions = capabilities["goog:chromeOptions"];
              const chromeOptions = maybeChromeOptions && typeof maybeChromeOptions === "object" ? maybeChromeOptions : void 0;
              const debuggerAddress = chromeOptions && typeof chromeOptions.debuggerAddress === "string" ? chromeOptions.debuggerAddress : void 0;
              const chromeOptionsURL = typeof maybeChromeOptions === "string" ? maybeChromeOptions : void 0;
              const endpointURLString = addProtocol(debuggerAddress || chromeOptionsURL);
              progress.log(`<selenium> retrieved endpoint ${endpointURLString} for sessionId=${sessionId}`);
              endpointURL = new URL(endpointURLString);
              if (endpointURL.hostname === "localhost" || endpointURL.hostname === "127.0.0.1") {
                const sessionInfoUrl = new URL(hubUrl).origin + "/grid/api/testsession?session=" + sessionId;
                try {
                  const sessionResponse = yield (0, _utils2.fetchData)({
                    url: sessionInfoUrl,
                    method: "GET",
                    timeout: progress.timeUntilDeadline()
                  }, seleniumErrorHandler);
                  const proxyId = JSON.parse(sessionResponse).proxyId;
                  endpointURL.hostname = new URL(proxyId).hostname;
                  progress.log(`<selenium> resolved endpoint ip ${endpointURL.toString()} for sessionId=${sessionId}`);
                } catch (e) {
                  progress.log(`<selenium> unable to resolve endpoint ip for sessionId=${sessionId}, running in standalone?`);
                }
              }
            }
            return yield this._connectOverCDPInternal(progress, endpointURL.toString(), {
              slowMo: options.slowMo
            }, disconnectFromSelenium);
          } catch (e) {
            yield disconnectFromSelenium();
            throw e;
          }
        });
      }
      _defaultArgs(options, isPersistent, userDataDir) {
        const chromeArguments = this._innerDefaultArgs(options);
        chromeArguments.push(`--user-data-dir=${userDataDir}`);
        if (options.useWebSocket)
          chromeArguments.push("--remote-debugging-port=0");
        else
          chromeArguments.push("--remote-debugging-pipe");
        if (isPersistent)
          chromeArguments.push("about:blank");
        else
          chromeArguments.push("--no-startup-window");
        return chromeArguments;
      }
      _innerDefaultArgs(options) {
        const {
          args = [],
          proxy
        } = options;
        const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument");
        if (args.find((arg) => arg.startsWith("--remote-debugging-pipe")))
          throw new Error("Playwright manages remote debugging connection itself.");
        if (args.find((arg) => !arg.startsWith("-")))
          throw new Error("Arguments can not specify page to be opened");
        const chromeArguments = [...DEFAULT_ARGS];
        if (_os2.default.platform() === "darwin")
          chromeArguments.push("--enable-use-zoom-for-dsf=false");
        if (options.devtools)
          chromeArguments.push("--auto-open-devtools-for-tabs");
        if (options.headless) {
          chromeArguments.push("--headless", "--hide-scrollbars", "--mute-audio", "--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4");
        }
        if (options.chromiumSandbox !== true)
          chromeArguments.push("--no-sandbox");
        if (proxy) {
          const proxyURL = new URL(proxy.server);
          const isSocks = proxyURL.protocol === "socks5:";
          if (isSocks && !this._playwrightOptions.socksProxyPort) {
            chromeArguments.push(`--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`);
          }
          chromeArguments.push(`--proxy-server=${proxy.server}`);
          const proxyBypassRules = [];
          if (this._playwrightOptions.socksProxyPort)
            proxyBypassRules.push("<-loopback>");
          if (proxy.bypass)
            proxyBypassRules.push(...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t));
          if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes("<-loopback>"))
            proxyBypassRules.push("<-loopback>");
          if (proxyBypassRules.length > 0)
            chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
        }
        chromeArguments.push(...args);
        return chromeArguments;
      }
    };
    exports2.Chromium = Chromium;
    var DEFAULT_ARGS = [
      "--disable-background-networking",
      "--enable-features=NetworkService,NetworkServiceInProcess",
      "--disable-background-timer-throttling",
      "--disable-backgrounding-occluded-windows",
      "--disable-breakpad",
      "--disable-client-side-phishing-detection",
      "--disable-component-extensions-with-background-pages",
      "--disable-default-apps",
      "--disable-dev-shm-usage",
      "--disable-extensions",
      "--disable-features=ImprovedCookieControls,LazyFrameLoading,GlobalMediaControls,DestroyProfileOnBrowserClose,MediaRouter,AcceptCHFrame,AutoExpandDetailsElement",
      "--allow-pre-commit-input",
      "--disable-hang-monitor",
      "--disable-ipc-flooding-protection",
      "--disable-popup-blocking",
      "--disable-prompt-on-repost",
      "--disable-renderer-backgrounding",
      "--disable-sync",
      "--force-color-profile=srgb",
      "--metrics-recording-only",
      "--no-first-run",
      "--enable-automation",
      "--password-store=basic",
      "--use-mock-keychain",
      "--no-service-autorun",
      "--export-tagged-pdf"
    ];
    function urlToWSEndpoint(progress, endpointURL) {
      return __async(this, null, function* () {
        if (endpointURL.startsWith("ws"))
          return endpointURL;
        progress.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);
        const httpURL = endpointURL.endsWith("/") ? `${endpointURL}json/version/` : `${endpointURL}/json/version/`;
        const request = endpointURL.startsWith("https") ? _https.default : _http.default;
        const json = yield new Promise((resolve, reject) => {
          request.get(httpURL, (resp) => {
            if (resp.statusCode < 200 || resp.statusCode >= 400) {
              reject(new Error(`Unexpected status ${resp.statusCode} when connecting to ${httpURL}.
This does not look like a DevTools server, try connecting via ws://.`));
            }
            let data = "";
            resp.on("data", (chunk) => data += chunk);
            resp.on("end", () => resolve(data));
          }).on("error", reject);
        });
        return JSON.parse(json).webSocketDebuggerUrl;
      });
    }
    function seleniumErrorHandler(params, response) {
      return __async(this, null, function* () {
        const body = yield (0, _utils2.streamToString)(response);
        let message = body;
        try {
          const json = JSON.parse(body);
          message = json.value.localizedMessage || json.value.message;
        } catch (e) {
        }
        return new Error(`Error connecting to Selenium at ${params.url}: ${message}`);
      });
    }
    function addProtocol(url) {
      if (!["ws://", "wss://", "http://", "https://"].some((protocol) => url.startsWith(protocol)))
        return "http://" + url;
      return url;
    }
  }
});

// node_modules/electron/index.js
var require_electron = __commonJS({
  "node_modules/electron/index.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var pathFile = path.join(__dirname, "path.txt");
    function getElectronPath() {
      let executablePath;
      if (fs.existsSync(pathFile)) {
        executablePath = fs.readFileSync(pathFile, "utf-8");
      }
      if (process.env.ELECTRON_OVERRIDE_DIST_PATH) {
        return path.join(process.env.ELECTRON_OVERRIDE_DIST_PATH, executablePath || "electron");
      }
      if (executablePath) {
        return path.join(__dirname, "dist", executablePath);
      } else {
        throw new Error("Electron failed to install correctly, please delete node_modules/electron and try installing again");
      }
    }
    module2.exports = getElectronPath();
  }
});

// node_modules/playwright-core/lib/server/electron/electron.js
var require_electron2 = __commonJS({
  "node_modules/playwright-core/lib/server/electron/electron.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Electron = exports2.ElectronApplication = void 0;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _os2 = _interopRequireDefault2(require("os"));
    var _path2 = _interopRequireDefault2(require("path"));
    var _crBrowser = require_crBrowser();
    var _crConnection = require_crConnection();
    var _crExecutionContext = require_crExecutionContext();
    var js = _interopRequireWildcard2(require_javascript());
    var _timeoutSettings = require_timeoutSettings();
    var _transport = require_transport2();
    var _processLauncher = require_processLauncher();
    var _browserContext = require_browserContext();
    var _progress = require_progress2();
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var readline = _interopRequireWildcard2(require("readline"));
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path2.default.join(_os2.default.tmpdir(), "playwright-artifacts-");
    var ElectronApplication = class extends _instrumentation.SdkObject {
      constructor(parent, browser, nodeConnection) {
        super(parent, "electron-app");
        this._browserContext = void 0;
        this._nodeConnection = void 0;
        this._nodeSession = void 0;
        this._nodeExecutionContext = void 0;
        this._nodeElectronHandlePromise = void 0;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._browserContext = browser._defaultContext;
        this._browserContext.on(_browserContext.BrowserContext.Events.Close, () => {
          Promise.resolve().then(() => this.emit(ElectronApplication.Events.Close));
        });
        this._nodeConnection = nodeConnection;
        this._nodeSession = nodeConnection.rootSession;
        this._nodeElectronHandlePromise = new Promise((f) => {
          this._nodeSession.on("Runtime.executionContextCreated", (event) => __async(this, null, function* () {
            if (event.context.auxData && event.context.auxData.isDefault) {
              this._nodeExecutionContext = new js.ExecutionContext(this, new _crExecutionContext.CRExecutionContext(this._nodeSession, event.context));
              f(yield js.evaluate(this._nodeExecutionContext, false, `process.mainModule.require('electron')`));
            }
          }));
        });
        this._browserContext.setCustomCloseHandler(() => __async(this, null, function* () {
          const electronHandle = yield this._nodeElectronHandlePromise;
          yield electronHandle.evaluate(({
            app
          }) => app.quit());
        }));
        this._nodeSession.send("Runtime.enable", {}).catch((e) => {
        });
      }
      context() {
        return this._browserContext;
      }
      close() {
        return __async(this, null, function* () {
          const progressController = new _progress.ProgressController((0, _instrumentation.internalCallMetadata)(), this);
          const closed = progressController.run((progress) => _helper.helper.waitForEvent(progress, this, ElectronApplication.Events.Close).promise);
          yield this._browserContext.close((0, _instrumentation.internalCallMetadata)());
          this._nodeConnection.close();
          yield closed;
        });
      }
      browserWindow(page) {
        return __async(this, null, function* () {
          const targetId = page._delegate._targetId;
          const electronHandle = yield this._nodeElectronHandlePromise;
          return yield electronHandle.evaluateHandle(({
            BrowserWindow,
            webContents
          }, targetId2) => {
            const wc = webContents.fromDevToolsTargetId(targetId2);
            return BrowserWindow.fromWebContents(wc);
          }, targetId);
        });
      }
    };
    exports2.ElectronApplication = ElectronApplication;
    ElectronApplication.Events = {
      Close: "close"
    };
    var Electron = class extends _instrumentation.SdkObject {
      constructor(playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "electron");
        this._playwrightOptions = void 0;
        this._playwrightOptions = playwrightOptions;
      }
      launch(options) {
        return __async(this, null, function* () {
          const {
            args = []
          } = options;
          const controller = new _progress.ProgressController((0, _instrumentation.internalCallMetadata)(), this);
          controller.setLogName("browser");
          return controller.run((progress) => __async(this, null, function* () {
            let app = void 0;
            const electronArguments = ["--inspect=0", "--remote-debugging-port=0", ...args];
            if (_os2.default.platform() === "linux") {
              const runningAsRoot = process.geteuid && process.geteuid() === 0;
              if (runningAsRoot && electronArguments.indexOf("--no-sandbox") === -1)
                electronArguments.push("--no-sandbox");
            }
            const artifactsDir = yield _fs2.default.promises.mkdtemp(ARTIFACTS_FOLDER);
            const browserLogsCollector = new _debugLogger.RecentLogsCollector();
            const {
              launchedProcess,
              gracefullyClose,
              kill
            } = yield (0, _processLauncher.launchProcess)({
              command: options.executablePath || require_electron(),
              args: electronArguments,
              env: options.env ? (0, _processLauncher.envArrayToObject)(options.env) : process.env,
              log: (message) => {
                progress.log(message);
                browserLogsCollector.log(message);
              },
              stdio: "pipe",
              cwd: options.cwd,
              tempDirectories: [artifactsDir],
              attemptToGracefullyClose: () => app.close(),
              handleSIGINT: true,
              handleSIGTERM: true,
              handleSIGHUP: true,
              onExit: () => {
              }
            });
            const waitForXserverError = new Promise((resolve, reject) => __async(this, null, function* () {
              waitForLine(progress, launchedProcess, /Unable to open X display/).then(() => reject(new Error(["Unable to open X display!", `================================`, "Most likely this is because there is no X server available.", "Use 'xvfb-run' on Linux to launch your tests with an emulated display server.", "For example: 'xvfb-run npm run test:e2e'", `================================`, progress.metadata.log].join("\n")))).catch(() => {
              });
            }));
            const nodeMatch = yield waitForLine(progress, launchedProcess, /^Debugger listening on (ws:\/\/.*)$/);
            const nodeTransport = yield _transport.WebSocketTransport.connect(progress, nodeMatch[1]);
            const nodeConnection = new _crConnection.CRConnection(nodeTransport, _helper.helper.debugProtocolLogger(), browserLogsCollector);
            const chromeMatch = yield Promise.race([waitForLine(progress, launchedProcess, /^DevTools listening on (ws:\/\/.*)$/), waitForXserverError]);
            const chromeTransport = yield _transport.WebSocketTransport.connect(progress, chromeMatch[1]);
            const browserProcess = {
              onclose: void 0,
              process: launchedProcess,
              close: gracefullyClose,
              kill
            };
            const contextOptions = __spreadProps(__spreadValues({}, options), {
              noDefaultViewport: true
            });
            const browserOptions = __spreadProps(__spreadValues({}, this._playwrightOptions), {
              name: "electron",
              isChromium: true,
              headful: true,
              persistent: contextOptions,
              browserProcess,
              protocolLogger: _helper.helper.debugProtocolLogger(),
              browserLogsCollector,
              artifactsDir,
              downloadsPath: artifactsDir,
              tracesDir: artifactsDir
            });
            (0, _browserContext.validateBrowserContextOptions)(contextOptions, browserOptions);
            const browser = yield _crBrowser.CRBrowser.connect(chromeTransport, browserOptions);
            app = new ElectronApplication(this, browser, nodeConnection);
            return app;
          }), _timeoutSettings.TimeoutSettings.timeout(options));
        });
      }
    };
    exports2.Electron = Electron;
    function waitForLine(progress, process2, regex) {
      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process2.stderr
        });
        const failError = new Error("Process failed to launch!");
        const listeners = [
          _eventsHelper.eventsHelper.addEventListener(rl, "line", onLine),
          _eventsHelper.eventsHelper.addEventListener(rl, "close", reject.bind(null, failError)),
          _eventsHelper.eventsHelper.addEventListener(process2, "exit", reject.bind(null, failError)),
          _eventsHelper.eventsHelper.addEventListener(process2, "error", reject.bind(null, failError))
        ];
        progress.cleanupWhenAborted(cleanup);
        function onLine(line) {
          const match = line.match(regex);
          if (!match)
            return;
          cleanup();
          resolve(match);
        }
        function cleanup() {
          _eventsHelper.eventsHelper.removeEventListeners(listeners);
        }
      });
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffConnection.js
var require_ffConnection = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FFSession = exports2.FFSessionEvents = exports2.FFConnection = exports2.kBrowserCloseMessageId = exports2.ConnectionEvents = void 0;
    var _events = require("events");
    var _utils2 = require_utils();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _protocolError = require_protocolError();
    var ConnectionEvents = {
      Disconnected: Symbol("Disconnected")
    };
    exports2.ConnectionEvents = ConnectionEvents;
    var kBrowserCloseMessageId = -9999;
    exports2.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var FFConnection = class extends _events.EventEmitter {
      constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this._lastId = void 0;
        this._callbacks = void 0;
        this._transport = void 0;
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this._sessions = void 0;
        this._closed = void 0;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this._lastId = 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._sessions = /* @__PURE__ */ new Map();
        this._closed = false;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      send(method, params) {
        return __async(this, null, function* () {
          this._checkClosed(method);
          const id = this.nextMessageId();
          this._rawSend({
            id,
            method,
            params
          });
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      nextMessageId() {
        return ++this._lastId;
      }
      _checkClosed(method) {
        if (this._closed)
          throw new _protocolError.ProtocolError(true, `${method}): Browser closed.` + _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs()));
      }
      _rawSend(message) {
        this._protocolLogger("send", message);
        this._transport.send(message);
      }
      _onMessage(message) {
        return __async(this, null, function* () {
          this._protocolLogger("receive", message);
          if (message.id === kBrowserCloseMessageId)
            return;
          if (message.sessionId) {
            const session = this._sessions.get(message.sessionId);
            if (session)
              session.dispatchMessage(message);
          } else if (message.id) {
            const callback = this._callbacks.get(message.id);
            if (callback) {
              this._callbacks.delete(message.id);
              if (message.error)
                callback.reject(createProtocolError(callback.error, callback.method, message.error));
              else
                callback.resolve(message.result);
            }
          } else {
            Promise.resolve().then(() => this.emit(message.method, message.params));
          }
        });
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        const formattedBrowserLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
          session.dispose();
        this._sessions.clear();
        for (const callback of this._callbacks.values()) {
          const error = (0, _stackTrace.rewriteErrorMessage)(callback.error, `Protocol error (${callback.method}): Browser closed.` + formattedBrowserLogs);
          error.sessionClosed = true;
          callback.reject(error);
        }
        this._callbacks.clear();
        Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
      createSession(sessionId) {
        const session = new FFSession(this, sessionId, (message) => this._rawSend(__spreadProps(__spreadValues({}, message), {
          sessionId
        })));
        this._sessions.set(sessionId, session);
        return session;
      }
    };
    exports2.FFConnection = FFConnection;
    var FFSessionEvents = {
      Disconnected: Symbol("Disconnected")
    };
    exports2.FFSessionEvents = FFSessionEvents;
    var FFSession = class extends _events.EventEmitter {
      constructor(connection, sessionId, rawSend) {
        super();
        this._connection = void 0;
        this._disposed = false;
        this._callbacks = void 0;
        this._sessionId = void 0;
        this._rawSend = void 0;
        this._crashed = false;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this._callbacks = /* @__PURE__ */ new Map();
        this._connection = connection;
        this._sessionId = sessionId;
        this._rawSend = rawSend;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      markAsCrashed() {
        this._crashed = true;
      }
      send(method, params) {
        return __async(this, null, function* () {
          if (this._crashed)
            throw new _protocolError.ProtocolError(true, "Target crashed");
          this._connection._checkClosed(method);
          if (this._disposed)
            throw new _protocolError.ProtocolError(true, "Target closed");
          const id = this._connection.nextMessageId();
          this._rawSend({
            method,
            params,
            id
          });
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      sendMayFail(method, params) {
        return this.send(method, params).catch((error) => _debugLogger.debugLogger.log("error", error));
      }
      dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else {
          (0, _utils2.assert)(!object.id);
          Promise.resolve().then(() => this.emit(object.method, object.params));
        }
      }
      dispose() {
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, "Target closed"));
        }
        this._callbacks.clear();
        this._disposed = true;
        this._connection._sessions.delete(this._sessionId);
        Promise.resolve().then(() => this.emit(FFSessionEvents.Disconnected));
      }
    };
    exports2.FFSession = FFSession;
    function createProtocolError(error, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${protocolError.data}`;
      return (0, _stackTrace.rewriteErrorMessage)(error, message);
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffAccessibility.js
var require_ffAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAccessibilityTree = getAccessibilityTree;
    function getAccessibilityTree(session, needle) {
      return __async(this, null, function* () {
        const objectId = needle ? needle._objectId : void 0;
        const {
          tree
        } = yield session.send("Accessibility.getFullAXTree", {
          objectId
        });
        const axNode = new FFAXNode(tree);
        return {
          tree: axNode,
          needle: needle ? axNode._findNeedle() : null
        };
      });
    }
    var FFRoleToARIARole = new Map(Object.entries({
      "pushbutton": "button",
      "checkbutton": "checkbox",
      "editcombobox": "combobox",
      "content deletion": "deletion",
      "footnote": "doc-footnote",
      "non-native document": "document",
      "grouping": "group",
      "graphic": "img",
      "content insertion": "insertion",
      "animation": "marquee",
      "flat equation": "math",
      "menupopup": "menu",
      "check menu item": "menuitemcheckbox",
      "radio menu item": "menuitemradio",
      "listbox option": "option",
      "radiobutton": "radio",
      "statusbar": "status",
      "pagetab": "tab",
      "pagetablist": "tablist",
      "propertypage": "tabpanel",
      "entry": "textbox",
      "outline": "tree",
      "tree table": "treegrid",
      "outlineitem": "treeitem"
    }));
    var FFAXNode = class {
      constructor(payload) {
        this._children = void 0;
        this._payload = void 0;
        this._editable = void 0;
        this._richlyEditable = void 0;
        this._focusable = void 0;
        this._expanded = void 0;
        this._name = void 0;
        this._role = void 0;
        this._cachedHasFocusableChild = void 0;
        this._payload = payload;
        this._children = (payload.children || []).map((x) => new FFAXNode(x));
        this._editable = !!payload.editable;
        this._richlyEditable = this._editable && payload.tag !== "textarea" && payload.tag !== "input";
        this._focusable = !!payload.focusable;
        this._expanded = !!payload.expanded;
        this._name = this._payload.name;
        this._role = this._payload.role;
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "entry";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "text leaf" || role === "text" || role === "statictext";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      children() {
        return this._children;
      }
      _findNeedle() {
        if (this._payload.foundObject)
          return this;
        for (const child of this._children) {
          const found = child._findNeedle();
          if (found)
            return found;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "graphic":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._role !== "document" && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "checkbutton":
          case "check menu item":
          case "check rich option":
          case "combobox":
          case "combobox option":
          case "color chooser":
          case "listbox":
          case "listbox option":
          case "listbox rich option":
          case "popup menu":
          case "menupopup":
          case "menuitem":
          case "menubar":
          case "button":
          case "pushbutton":
          case "radiobutton":
          case "radio menuitem":
          case "scrollbar":
          case "slider":
          case "spinbutton":
          case "switch":
          case "pagetab":
          case "entry":
          case "tree table":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name.trim();
      }
      serialize() {
        const node = {
          role: FFRoleToARIARole.get(this._role) || this._role,
          name: this._name || ""
        };
        const userStringProperties = ["name", "description", "roledescription", "valuetext", "keyshortcuts"];
        for (const userStringProperty of userStringProperties) {
          if (!(userStringProperty in this._payload))
            continue;
          node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (this._role === "document" && booleanProperty === "focused")
            continue;
          const value = this._payload[booleanProperty];
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level"];
        for (const numericalProperty of numericalProperties) {
          if (!(numericalProperty in this._payload))
            continue;
          node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid", "orientation"];
        for (const tokenProperty of tokenProperties) {
          const value = this._payload[tokenProperty];
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const axNode = node;
        axNode.valueString = this._payload.value;
        if ("checked" in this._payload)
          axNode.checked = this._payload.checked === true ? "checked" : this._payload.checked === "mixed" ? "mixed" : "unchecked";
        if ("pressed" in this._payload)
          axNode.pressed = this._payload.pressed === true ? "pressed" : "released";
        return axNode;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/firefox/ffExecutionContext.js
var require_ffExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffExecutionContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FFExecutionContext = void 0;
    var js = _interopRequireWildcard2(require_javascript());
    var _stackTrace = require_stackTrace();
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFExecutionContext = class {
      constructor(session, executionContextId) {
        this._session = void 0;
        this._executionContextId = void 0;
        this._session = session;
        this._executionContextId = executionContextId;
      }
      rawEvaluateJSON(expression) {
        return __async(this, null, function* () {
          const payload = yield this._session.send("Runtime.evaluate", {
            expression,
            returnByValue: true,
            executionContextId: this._executionContextId
          }).catch(rewriteError);
          checkException(payload.exceptionDetails);
          return payload.result.value;
        });
      }
      rawEvaluateHandle(expression) {
        return __async(this, null, function* () {
          const payload = yield this._session.send("Runtime.evaluate", {
            expression,
            returnByValue: false,
            executionContextId: this._executionContextId
          }).catch(rewriteError);
          checkException(payload.exceptionDetails);
          return payload.result.objectId;
        });
      }
      rawCallFunctionNoReply(func, ...args) {
        this._session.send("Runtime.callFunction", {
          functionDeclaration: func.toString(),
          args: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          executionContextId: this._executionContextId
        }).catch(() => {
        });
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return __async(this, null, function* () {
          const payload = yield this._session.send("Runtime.callFunction", {
            functionDeclaration: expression,
            args: [{
              objectId: utilityScript._objectId,
              value: void 0
            }, ...values.map((value) => ({
              value
            })), ...objectIds.map((objectId) => ({
              objectId,
              value: void 0
            }))],
            returnByValue,
            executionContextId: this._executionContextId
          }).catch(rewriteError);
          checkException(payload.exceptionDetails);
          if (returnByValue)
            return (0, _utilityScriptSerializers.parseEvaluationResultValue)(payload.result.value);
          return utilityScript._context.createHandle(payload.result);
        });
      }
      getProperties(context, objectId) {
        return __async(this, null, function* () {
          const response = yield this._session.send("Runtime.getObjectProperties", {
            executionContextId: this._executionContextId,
            objectId
          });
          const result = /* @__PURE__ */ new Map();
          for (const property of response.properties)
            result.set(property.name, context.createHandle(property.value));
          return result;
        });
      }
      createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type || "", renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      releaseHandle(objectId) {
        return __async(this, null, function* () {
          yield this._session.send("Runtime.disposeObject", {
            executionContextId: this._executionContextId,
            objectId
          });
        });
      }
    };
    exports2.FFExecutionContext = FFExecutionContext;
    function checkException(exceptionDetails) {
      if (!exceptionDetails)
        return;
      if (exceptionDetails.value)
        throw new js.JavaScriptErrorInEvaluate(JSON.stringify(exceptionDetails.value));
      else
        throw new js.JavaScriptErrorInEvaluate(exceptionDetails.text + (exceptionDetails.stack ? "\n" + exceptionDetails.stack : ""));
    }
    function rewriteError(error) {
      if (error.message.includes("cyclic object value") || error.message.includes("Object is not serializable"))
        return {
          result: {
            type: "undefined",
            value: void 0
          }
        };
      if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON"))
        (0, _stackTrace.rewriteErrorMessage)(error, error.message + " Are you passing a nested JSHandle?");
      if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error))
        throw new Error("Execution context was destroyed, most likely because of a navigation.");
      throw error;
    }
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const unserializableValue = remoteObject.unserializableValue;
      return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if (object.unserializableValue)
        return String(object.unserializableValue);
      if (object.type === "symbol")
        return "Symbol()";
      if (object.subtype === "regexp")
        return "RegExp";
      if (object.subtype === "weakmap")
        return "WeakMap";
      if (object.subtype === "weakset")
        return "WeakSet";
      if (object.subtype)
        return object.subtype[0].toUpperCase() + object.subtype.slice(1);
      if ("value" in object)
        return String(object.value);
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffInput.js
var require_ffInput = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffInput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Alt"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Shift"))
        mask |= 4;
      if (modifiers.has("Meta"))
        mask |= 8;
      return mask;
    }
    function toButtonNumber(button) {
      if (button === "left")
        return 0;
      if (button === "middle")
        return 1;
      if (button === "right")
        return 2;
      return 0;
    }
    function toButtonsMask(buttons) {
      let mask = 0;
      if (buttons.has("left"))
        mask |= 1;
      if (buttons.has("right"))
        mask |= 2;
      if (buttons.has("middle"))
        mask |= 4;
      return mask;
    }
    var RawKeyboardImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        return __async(this, null, function* () {
          if (code === "MetaLeft")
            code = "OSLeft";
          if (code === "MetaRight")
            code = "OSRight";
          if (text === "\r")
            text = "";
          yield this._client.send("Page.dispatchKeyEvent", {
            type: "keydown",
            keyCode: keyCodeWithoutLocation,
            code,
            key,
            repeat: autoRepeat,
            location: location2,
            text
          });
        });
      }
      keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        return __async(this, null, function* () {
          if (code === "MetaLeft")
            code = "OSLeft";
          if (code === "MetaRight")
            code = "OSRight";
          yield this._client.send("Page.dispatchKeyEvent", {
            type: "keyup",
            key,
            keyCode: keyCodeWithoutLocation,
            code,
            location: location2,
            repeat: false
          });
        });
      }
      sendText(text) {
        return __async(this, null, function* () {
          yield this._client.send("Page.insertText", {
            text
          });
        });
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(client) {
        this._client = void 0;
        this._page = void 0;
        this._client = client;
      }
      move(x, y, button, buttons, modifiers, forClick) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchMouseEvent", {
            type: "mousemove",
            button: 0,
            buttons: toButtonsMask(buttons),
            x: Math.floor(x),
            y: Math.floor(y),
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      down(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchMouseEvent", {
            type: "mousedown",
            button: toButtonNumber(button),
            buttons: toButtonsMask(buttons),
            x: Math.floor(x),
            y: Math.floor(y),
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      up(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchMouseEvent", {
            type: "mouseup",
            button: toButtonNumber(button),
            buttons: toButtonsMask(buttons),
            x: Math.floor(x),
            y: Math.floor(y),
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, false, false, "utility");
          yield this._client.send("Page.dispatchWheelEvent", {
            deltaX,
            deltaY,
            x: Math.floor(x),
            y: Math.floor(y),
            deltaZ: 0,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      setPage(page) {
        this._page = page;
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      tap(x, y, modifiers) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchTapEvent", {
            x,
            y,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/firefox/ffNetworkManager.js
var require_ffNetworkManager = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffNetworkManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FFNetworkManager = void 0;
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard2(require_network());
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFNetworkManager = class {
      constructor(session, page) {
        this._session = void 0;
        this._requests = void 0;
        this._page = void 0;
        this._eventListeners = void 0;
        this._session = session;
        this._requests = /* @__PURE__ */ new Map();
        this._page = page;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceived", this._onResponseReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestFinished", this._onRequestFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestFailed", this._onRequestFailed.bind(this))];
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      setRequestInterception(enabled) {
        return __async(this, null, function* () {
          yield this._session.send("Network.setRequestInterception", {
            enabled
          });
        });
      }
      _onRequestWillBeSent(event) {
        const redirectedFrom = event.redirectedFrom ? this._requests.get(event.redirectedFrom) || null : null;
        const frame = redirectedFrom ? redirectedFrom.request.frame() : event.frameId ? this._page._frameManager.frame(event.frameId) : null;
        if (!frame)
          return;
        if (redirectedFrom)
          this._requests.delete(redirectedFrom._id);
        const request = new InterceptableRequest(frame, redirectedFrom, event);
        let route;
        if (event.isIntercepted)
          route = new FFRouteImpl(this._session, request);
        this._requests.set(request._id, request);
        this._page._frameManager.requestStarted(request.request, route);
      }
      _onResponseReceived(event) {
        var _event$securityDetail, _event$securityDetail2, _event$securityDetail3, _event$securityDetail4, _event$securityDetail5;
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        const getResponseBody = () => __async(this, null, function* () {
          const response2 = yield this._session.send("Network.getResponseBody", {
            requestId: request._id
          });
          if (response2.evicted)
            throw new Error(`Response body for ${request.request.method()} ${request.request.url()} was evicted!`);
          return Buffer.from(response2.base64body, "base64");
        });
        const startTime = event.timing.startTime;
        function relativeToStart(time) {
          if (!time)
            return -1;
          return (time - startTime) / 1e3;
        }
        const timing = {
          startTime: startTime / 1e3,
          domainLookupStart: relativeToStart(event.timing.domainLookupStart),
          domainLookupEnd: relativeToStart(event.timing.domainLookupEnd),
          connectStart: relativeToStart(event.timing.connectStart),
          secureConnectionStart: relativeToStart(event.timing.secureConnectionStart),
          connectEnd: relativeToStart(event.timing.connectEnd),
          requestStart: relativeToStart(event.timing.requestStart),
          responseStart: relativeToStart(event.timing.responseStart)
        };
        const response = new network.Response(request.request, event.status, event.statusText, parseMultivalueHeaders(event.headers), timing, getResponseBody);
        if (event !== null && event !== void 0 && event.remoteIPAddress && typeof (event === null || event === void 0 ? void 0 : event.remotePort) === "number") {
          response._serverAddrFinished({
            ipAddress: event.remoteIPAddress,
            port: event.remotePort
          });
        } else {
          response._serverAddrFinished();
        }
        response._securityDetailsFinished({
          protocol: event === null || event === void 0 ? void 0 : (_event$securityDetail = event.securityDetails) === null || _event$securityDetail === void 0 ? void 0 : _event$securityDetail.protocol,
          subjectName: event === null || event === void 0 ? void 0 : (_event$securityDetail2 = event.securityDetails) === null || _event$securityDetail2 === void 0 ? void 0 : _event$securityDetail2.subjectName,
          issuer: event === null || event === void 0 ? void 0 : (_event$securityDetail3 = event.securityDetails) === null || _event$securityDetail3 === void 0 ? void 0 : _event$securityDetail3.issuer,
          validFrom: event === null || event === void 0 ? void 0 : (_event$securityDetail4 = event.securityDetails) === null || _event$securityDetail4 === void 0 ? void 0 : _event$securityDetail4.validFrom,
          validTo: event === null || event === void 0 ? void 0 : (_event$securityDetail5 = event.securityDetails) === null || _event$securityDetail5 === void 0 ? void 0 : _event$securityDetail5.validTo
        });
        this._page._frameManager.requestReceivedResponse(response);
      }
      _onRequestFinished(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        request.request.responseSize.transferSize = event.transferSize;
        const isRedirected = response.status() >= 300 && response.status() <= 399;
        const responseEndTime = event.responseEndTime ? event.responseEndTime / 1e3 - response.timing().startTime : -1;
        if (isRedirected) {
          response._requestFinished(responseEndTime);
        } else {
          this._requests.delete(request._id);
          response._requestFinished(responseEndTime);
        }
        if (event.protocolVersion)
          response._setHttpVersion(event.protocolVersion);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onRequestFailed(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        this._requests.delete(request._id);
        const response = request.request._existingResponse();
        if (response)
          response._requestFinished(-1);
        request.request._setFailureText(event.errorCode);
        this._page._frameManager.requestFailed(request.request, event.errorCode === "NS_BINDING_ABORTED");
      }
    };
    exports2.FFNetworkManager = FFNetworkManager;
    var causeToResourceType = {
      TYPE_INVALID: "other",
      TYPE_OTHER: "other",
      TYPE_SCRIPT: "script",
      TYPE_IMAGE: "image",
      TYPE_STYLESHEET: "stylesheet",
      TYPE_OBJECT: "other",
      TYPE_DOCUMENT: "document",
      TYPE_SUBDOCUMENT: "document",
      TYPE_REFRESH: "document",
      TYPE_XBL: "other",
      TYPE_PING: "other",
      TYPE_XMLHTTPREQUEST: "xhr",
      TYPE_OBJECT_SUBREQUEST: "other",
      TYPE_DTD: "other",
      TYPE_FONT: "font",
      TYPE_MEDIA: "media",
      TYPE_WEBSOCKET: "websocket",
      TYPE_CSP_REPORT: "other",
      TYPE_XSLT: "other",
      TYPE_BEACON: "other",
      TYPE_FETCH: "fetch",
      TYPE_IMAGESET: "images",
      TYPE_WEB_MANIFEST: "manifest"
    };
    var internalCauseToResourceType = {
      TYPE_INTERNAL_EVENTSOURCE: "eventsource"
    };
    var InterceptableRequest = class {
      constructor(frame, redirectedFrom, payload) {
        this.request = void 0;
        this._id = void 0;
        this._redirectedTo = void 0;
        this._id = payload.requestId;
        if (redirectedFrom)
          redirectedFrom._redirectedTo = this;
        let postDataBuffer = null;
        if (payload.postData)
          postDataBuffer = Buffer.from(payload.postData, "base64");
        this.request = new network.Request(frame, redirectedFrom ? redirectedFrom.request : null, payload.navigationId, payload.url, internalCauseToResourceType[payload.internalCause] || causeToResourceType[payload.cause] || "other", payload.method, postDataBuffer, payload.headers);
      }
      _finalRequest() {
        let request = this;
        while (request._redirectedTo)
          request = request._redirectedTo;
        return request;
      }
    };
    var FFRouteImpl = class {
      constructor(session, request) {
        this._request = void 0;
        this._session = void 0;
        this._session = session;
        this._request = request;
      }
      continue(request, overrides) {
        return __async(this, null, function* () {
          yield this._session.sendMayFail("Network.resumeInterceptedRequest", {
            requestId: this._request._id,
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers,
            postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
          });
        });
      }
      fulfill(response) {
        return __async(this, null, function* () {
          const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
          yield this._session.sendMayFail("Network.fulfillInterceptedRequest", {
            requestId: this._request._id,
            status: response.status,
            statusText: network.STATUS_TEXTS[String(response.status)] || "",
            headers: response.headers,
            base64body
          });
        });
      }
      abort(errorCode) {
        return __async(this, null, function* () {
          yield this._session.sendMayFail("Network.abortInterceptedRequest", {
            requestId: this._request._id,
            errorCode
          });
        });
      }
    };
    function parseMultivalueHeaders(headers) {
      const result = [];
      for (const header of headers) {
        const separator = header.name.toLowerCase() === "set-cookie" ? "\n" : ",";
        const tokens = header.value.split(separator).map((s) => s.trim());
        for (const token of tokens)
          result.push({
            name: header.name,
            value: token
          });
      }
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffPage.js
var require_ffPage = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FFPage = exports2.UTILITY_WORLD_NAME = void 0;
    var dialog = _interopRequireWildcard2(require_dialog());
    var dom = _interopRequireWildcard2(require_dom());
    var _eventsHelper = require_eventsHelper();
    var _utils2 = require_utils();
    var _page = require_page();
    var _ffAccessibility = require_ffAccessibility();
    var _ffConnection = require_ffConnection();
    var _ffExecutionContext = require_ffExecutionContext();
    var _ffInput = require_ffInput();
    var _ffNetworkManager = require_ffNetworkManager();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _async = require_async();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    exports2.UTILITY_WORLD_NAME = UTILITY_WORLD_NAME;
    var FFPage = class {
      constructor(session, browserContext, opener) {
        this.cspErrorsAsynchronousForInlineScipts = true;
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._session = void 0;
        this._page = void 0;
        this._networkManager = void 0;
        this._browserContext = void 0;
        this._pagePromise = new _async.ManualPromise();
        this._initializedPage = null;
        this._initializationFailed = false;
        this._opener = void 0;
        this._contextIdToContext = void 0;
        this._eventListeners = void 0;
        this._workers = /* @__PURE__ */ new Map();
        this._screencastId = void 0;
        this._session = session;
        this._opener = opener;
        this.rawKeyboard = new _ffInput.RawKeyboardImpl(session);
        this.rawMouse = new _ffInput.RawMouseImpl(session);
        this.rawTouchscreen = new _ffInput.RawTouchscreenImpl(session);
        this._contextIdToContext = /* @__PURE__ */ new Map();
        this._browserContext = browserContext;
        this._page = new _page.Page(this, browserContext);
        this.rawMouse.setPage(this._page);
        this._networkManager = new _ffNetworkManager.FFNetworkManager(session, this._page);
        this._page.on(_page.Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame));
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, "Page.eventFired", this._onEventFired.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameAttached", this._onFrameAttached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameDetached", this._onFrameDetached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationAborted", this._onNavigationAborted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationCommitted", this._onNavigationCommitted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationStarted", this._onNavigationStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.sameDocumentNavigation", this._onSameDocumentNavigation.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", this._onExecutionContextCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextDestroyed", this._onExecutionContextDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.linkClicked", (event) => this._onLinkClicked(event.phase)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.uncaughtError", this._onUncaughtError.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.console", this._onConsole.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.dialogOpened", this._onDialogOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.bindingCalled", this._onBindingCalled.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", this._onFileChooserOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.workerCreated", this._onWorkerCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.workerDestroyed", this._onWorkerDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.dispatchMessageFromWorker", this._onDispatchMessageFromWorker.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.crashed", this._onCrashed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.videoRecordingStarted", this._onVideoRecordingStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketCreated", this._onWebSocketCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketClosed", this._onWebSocketClosed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketFrameReceived", this._onWebSocketFrameReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketFrameSent", this._onWebSocketFrameSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.screencastFrame", this._onScreencastFrame.bind(this))];
        session.once(_ffConnection.FFSessionEvents.Disconnected, () => {
          this._markAsError(new Error("Page closed"));
          this._page._didDisconnect();
        });
        this._session.once("Page.ready", () => __async(this, null, function* () {
          yield this._page.initOpener(this._opener);
          if (this._initializationFailed)
            return;
          this._initializedPage = this._page;
          this._page.reportAsNew();
          this._pagePromise.resolve(this._page);
        }));
        this._session.send("Page.addScriptToEvaluateOnNewDocument", {
          script: "",
          worldName: UTILITY_WORLD_NAME
        }).catch((e) => this._markAsError(e));
      }
      _markAsError(error) {
        return __async(this, null, function* () {
          if (this._initializationFailed)
            return;
          this._initializationFailed = true;
          if (!this._initializedPage) {
            yield this._page.initOpener(this._opener);
            this._page.reportAsNew(error);
            this._pagePromise.resolve(error);
          }
        });
      }
      pageOrError() {
        return __async(this, null, function* () {
          return this._pagePromise;
        });
      }
      _onWebSocketCreated(event) {
        this._page._frameManager.onWebSocketCreated(webSocketId(event.frameId, event.wsid), event.requestURL);
        this._page._frameManager.onWebSocketRequest(webSocketId(event.frameId, event.wsid));
      }
      _onWebSocketClosed(event) {
        if (event.error)
          this._page._frameManager.webSocketError(webSocketId(event.frameId, event.wsid), event.error);
        this._page._frameManager.webSocketClosed(webSocketId(event.frameId, event.wsid));
      }
      _onWebSocketFrameReceived(event) {
        this._page._frameManager.webSocketFrameReceived(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
      }
      _onWebSocketFrameSent(event) {
        this._page._frameManager.onWebSocketFrameSent(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
      }
      _onExecutionContextCreated(payload) {
        const {
          executionContextId,
          auxData
        } = payload;
        const frame = this._page._frameManager.frame(auxData.frameId);
        if (!frame)
          return;
        const delegate = new _ffExecutionContext.FFExecutionContext(this._session, executionContextId);
        let worldName = null;
        if (auxData.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        else if (!auxData.name)
          worldName = "main";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        this._contextIdToContext.set(executionContextId, context);
      }
      _onExecutionContextDestroyed(payload) {
        const {
          executionContextId
        } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
      }
      _removeContextsForFrame(frame) {
        for (const [contextId, context] of this._contextIdToContext) {
          if (context.frame === frame)
            this._contextIdToContext.delete(contextId);
        }
      }
      _onLinkClicked(phase) {
        if (phase === "before")
          this._page._frameManager.frameWillPotentiallyRequestNavigation();
        else
          this._page._frameManager.frameDidPotentiallyRequestNavigation();
      }
      _onNavigationStarted(params) {
        this._page._frameManager.frameRequestedNavigation(params.frameId, params.navigationId);
      }
      _onNavigationAborted(params) {
        this._page._frameManager.frameAbortedNavigation(params.frameId, params.errorText, params.navigationId);
      }
      _onNavigationCommitted(params) {
        for (const [workerId, worker] of this._workers) {
          if (worker.frameId === params.frameId)
            this._onWorkerDestroyed({
              workerId
            });
        }
        this._page._frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || "", params.navigationId || "", false);
      }
      _onSameDocumentNavigation(params) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);
      }
      _onFrameAttached(params) {
        this._page._frameManager.frameAttached(params.frameId, params.parentFrameId);
      }
      _onFrameDetached(params) {
        this._page._frameManager.frameDetached(params.frameId);
      }
      _onEventFired(payload) {
        const {
          frameId,
          name
        } = payload;
        if (name === "load")
          this._page._frameManager.frameLifecycleEvent(frameId, "load");
        if (name === "DOMContentLoaded")
          this._page._frameManager.frameLifecycleEvent(frameId, "domcontentloaded");
      }
      _onUncaughtError(params) {
        const {
          name,
          message
        } = (0, _stackTrace.splitErrorMessage)(params.message);
        const error = new Error(message);
        error.stack = params.message + "\n" + params.stack.split("\n").filter(Boolean).map((a) => a.replace(/([^@]*)@(.*)/, "    at $1 ($2)")).join("\n");
        error.name = name;
        this._page.firePageError(error);
      }
      _onConsole(payload) {
        const {
          type,
          args,
          executionContextId,
          location: location2
        } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._page._addConsoleMessage(type, args.map((arg) => context.createHandle(arg)), location2);
      }
      _onDialogOpened(params) {
        this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, params.type, params.message, (accept, promptText) => __async(this, null, function* () {
          yield this._session.sendMayFail("Page.handleDialog", {
            dialogId: params.dialogId,
            accept,
            promptText
          });
        }), params.defaultValue));
      }
      _onBindingCalled(event) {
        return __async(this, null, function* () {
          const pageOrError = yield this.pageOrError();
          if (!(pageOrError instanceof Error)) {
            const context = this._contextIdToContext.get(event.executionContextId);
            if (context)
              yield this._page._onBindingCalled(event.payload, context);
          }
        });
      }
      _onFileChooserOpened(payload) {
        return __async(this, null, function* () {
          const {
            executionContextId,
            element
          } = payload;
          const context = this._contextIdToContext.get(executionContextId);
          if (!context)
            return;
          const handle = context.createHandle(element).asElement();
          yield this._page._onFileChooserOpened(handle);
        });
      }
      _onWorkerCreated(event) {
        return __async(this, null, function* () {
          const workerId = event.workerId;
          const worker = new _page.Worker(this._page, event.url);
          const workerSession = new _ffConnection.FFSession(this._session._connection, workerId, (message) => {
            this._session.send("Page.sendMessageToWorker", {
              frameId: event.frameId,
              workerId,
              message: JSON.stringify(message)
            }).catch((e) => {
              workerSession.dispatchMessage({
                id: message.id,
                method: "",
                params: {},
                error: {
                  message: e.message,
                  data: void 0
                }
              });
            });
          });
          this._workers.set(workerId, {
            session: workerSession,
            frameId: event.frameId
          });
          this._page._addWorker(workerId, worker);
          workerSession.once("Runtime.executionContextCreated", (event2) => {
            worker._createExecutionContext(new _ffExecutionContext.FFExecutionContext(workerSession, event2.executionContextId));
          });
          workerSession.on("Runtime.console", (event2) => {
            const {
              type,
              args,
              location: location2
            } = event2;
            const context = worker._existingExecutionContext;
            this._page._addConsoleMessage(type, args.map((arg) => context.createHandle(arg)), location2);
          });
        });
      }
      _onWorkerDestroyed(event) {
        const workerId = event.workerId;
        const worker = this._workers.get(workerId);
        if (!worker)
          return;
        worker.session.dispose();
        this._workers.delete(workerId);
        this._page._removeWorker(workerId);
      }
      _onDispatchMessageFromWorker(event) {
        return __async(this, null, function* () {
          const worker = this._workers.get(event.workerId);
          if (!worker)
            return;
          worker.session.dispatchMessage(JSON.parse(event.message));
        });
      }
      _onCrashed(event) {
        return __async(this, null, function* () {
          this._session.markAsCrashed();
          this._page._didCrash();
        });
      }
      _onVideoRecordingStarted(event) {
        this._browserContext._browser._videoStarted(this._browserContext, event.screencastId, event.file, this.pageOrError());
      }
      exposeBinding(binding) {
        return __async(this, null, function* () {
          yield this._session.send("Page.addBinding", {
            name: binding.name,
            script: binding.source
          });
        });
      }
      didClose() {
        this._session.dispose();
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._page._didClose();
      }
      navigateFrame(frame, url, referer) {
        return __async(this, null, function* () {
          const response = yield this._session.send("Page.navigate", {
            url,
            referer,
            frameId: frame._id
          });
          return {
            newDocumentId: response.navigationId || void 0
          };
        });
      }
      updateExtraHTTPHeaders() {
        return __async(this, null, function* () {
          yield this._session.send("Network.setExtraHTTPHeaders", {
            headers: this._page._state.extraHTTPHeaders || []
          });
        });
      }
      setEmulatedSize(emulatedSize) {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this._page._state.emulatedSize === emulatedSize);
          yield this._session.send("Page.setViewportSize", {
            viewportSize: {
              width: emulatedSize.viewport.width,
              height: emulatedSize.viewport.height
            }
          });
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._session.send("Page.bringToFront", {});
        });
      }
      updateEmulateMedia() {
        return __async(this, null, function* () {
          const colorScheme = this._page._state.colorScheme === null ? void 0 : this._page._state.colorScheme;
          const reducedMotion = this._page._state.reducedMotion === null ? void 0 : this._page._state.reducedMotion;
          const forcedColors = this._page._state.forcedColors === null ? void 0 : this._page._state.forcedColors;
          yield this._session.send("Page.setEmulatedMedia", {
            type: this._page._state.mediaType === null ? "" : this._page._state.mediaType,
            colorScheme,
            reducedMotion,
            forcedColors
          });
        });
      }
      updateRequestInterception() {
        return __async(this, null, function* () {
          yield this._networkManager.setRequestInterception(this._page._needsRequestInterception());
        });
      }
      setFileChooserIntercepted(enabled) {
        return __async(this, null, function* () {
          yield this._session.send("Page.setInterceptFileChooserDialog", {
            enabled
          }).catch((e) => {
          });
        });
      }
      reload() {
        return __async(this, null, function* () {
          yield this._session.send("Page.reload", {
            frameId: this._page.mainFrame()._id
          });
        });
      }
      goBack() {
        return __async(this, null, function* () {
          const {
            success
          } = yield this._session.send("Page.goBack", {
            frameId: this._page.mainFrame()._id
          });
          return success;
        });
      }
      goForward() {
        return __async(this, null, function* () {
          const {
            success
          } = yield this._session.send("Page.goForward", {
            frameId: this._page.mainFrame()._id
          });
          return success;
        });
      }
      evaluateOnNewDocument(source) {
        return __async(this, null, function* () {
          yield this._session.send("Page.addScriptToEvaluateOnNewDocument", {
            script: source
          });
        });
      }
      closePage(runBeforeUnload) {
        return __async(this, null, function* () {
          yield this._session.send("Page.close", {
            runBeforeUnload
          });
        });
      }
      setBackgroundColor(color) {
        return __async(this, null, function* () {
          if (color)
            throw new Error("Not implemented");
        });
      }
      takeScreenshot(progress, format, documentRect, viewportRect, quality) {
        return __async(this, null, function* () {
          if (!documentRect) {
            const scrollOffset = yield this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
              x: window.scrollX,
              y: window.scrollY
            }));
            documentRect = {
              x: viewportRect.x + scrollOffset.x,
              y: viewportRect.y + scrollOffset.y,
              width: viewportRect.width,
              height: viewportRect.height
            };
          }
          progress.throwIfAborted();
          const {
            data
          } = yield this._session.send("Page.screenshot", {
            mimeType: "image/" + format,
            clip: documentRect
          });
          return Buffer.from(data, "base64");
        });
      }
      getContentFrame(handle) {
        return __async(this, null, function* () {
          const {
            contentFrameId
          } = yield this._session.send("Page.describeNode", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId
          });
          if (!contentFrameId)
            return null;
          return this._page._frameManager.frame(contentFrameId);
        });
      }
      getOwnerFrame(handle) {
        return __async(this, null, function* () {
          const {
            ownerFrameId
          } = yield this._session.send("Page.describeNode", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId
          });
          return ownerFrameId || null;
        });
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      getBoundingBox(handle) {
        return __async(this, null, function* () {
          const quads = yield this.getContentQuads(handle);
          if (!quads || !quads.length)
            return null;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (const quad of quads) {
            for (const point of quad) {
              minX = Math.min(minX, point.x);
              maxX = Math.max(maxX, point.x);
              minY = Math.min(minY, point.y);
              maxY = Math.max(maxY, point.y);
            }
          }
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        });
      }
      scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return yield this._session.send("Page.scrollIntoViewIfNeeded", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
            rect
          }).then(() => "done").catch((e) => {
            if (e instanceof Error && e.message.includes("Node is detached from document"))
              return "error:notconnected";
            if (e instanceof Error && e.message.includes("Node does not have a layout object"))
              return "error:notvisible";
            throw e;
          });
        });
      }
      setScreencastOptions(options) {
        return __async(this, null, function* () {
          if (options) {
            const {
              screencastId
            } = yield this._session.send("Page.startScreencast", options);
            this._screencastId = screencastId;
          } else {
            yield this._session.send("Page.stopScreencast");
          }
        });
      }
      _onScreencastFrame(event) {
        if (!this._screencastId)
          return;
        const screencastId = this._screencastId;
        this._page.throttleScreencastFrameAck(() => {
          this._session.send("Page.screencastFrameAck", {
            screencastId
          }).catch((e) => _debugLogger.debugLogger.log("error", e));
        });
        const buffer = Buffer.from(event.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          width: event.deviceWidth,
          height: event.deviceHeight
        });
      }
      rafCountForStablePosition() {
        return 1;
      }
      getContentQuads(handle) {
        return __async(this, null, function* () {
          const result = yield this._session.sendMayFail("Page.getContentQuads", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId
          });
          if (!result)
            return null;
          return result.quads.map((quad) => [quad.p1, quad.p2, quad.p3, quad.p4]);
        });
      }
      setInputFiles(handle, files) {
        return __async(this, null, function* () {
          yield handle.evaluateInUtility(([injected, node, files2]) => injected.setInputFiles(node, files2), files);
        });
      }
      adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          const result = yield this._session.send("Page.adoptNode", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
            executionContextId: to[contextDelegateSymbol]._executionContextId
          });
          if (!result.remoteObject)
            throw new Error(dom.kUnableToAdoptErrorMessage);
          return to.createHandle(result.remoteObject);
        });
      }
      getAccessibilityTree(needle) {
        return __async(this, null, function* () {
          return (0, _ffAccessibility.getAccessibilityTree)(this._session, needle);
        });
      }
      inputActionEpilogue() {
        return __async(this, null, function* () {
        });
      }
      getFrameElement(frame) {
        return __async(this, null, function* () {
          const parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          const info = this._page.parseSelector("frame,iframe");
          const handles = yield this._page.selectors._queryAll(parent, info);
          const items = yield Promise.all(handles.map((handle) => __async(this, null, function* () {
            const frame2 = yield handle.contentFrame().catch((e) => null);
            return {
              handle,
              frame: frame2
            };
          })));
          const result = items.find((item) => item.frame === frame);
          items.map((item) => item === result ? Promise.resolve() : item.handle.dispose());
          if (!result)
            throw new Error("Frame has been detached.");
          return result.handle;
        });
      }
    };
    exports2.FFPage = FFPage;
    function webSocketId(frameId, wsid) {
      return `${frameId}---${wsid}`;
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/firefox/ffBrowser.js
var require_ffBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffBrowser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FFBrowserContext = exports2.FFBrowser = void 0;
    var _errors = require_errors();
    var _utils2 = require_utils();
    var _browser = require_browser2();
    var _browserContext = require_browserContext();
    var network = _interopRequireWildcard2(require_network());
    var _ffConnection = require_ffConnection();
    var _ffPage = require_ffPage();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFBrowser = class extends _browser.Browser {
      static connect(transport, options) {
        return __async(this, null, function* () {
          const connection = new _ffConnection.FFConnection(transport, options.protocolLogger, options.browserLogsCollector);
          const browser = new FFBrowser(connection, options);
          if (options.__testHookOnConnectToBrowser)
            yield options.__testHookOnConnectToBrowser();
          const promises = [connection.send("Browser.enable", {
            attachToDefaultContext: !!options.persistent
          }), browser._initVersion()];
          if (options.persistent) {
            browser._defaultContext = new FFBrowserContext(browser, void 0, options.persistent);
            promises.push(browser._defaultContext._initialize());
          }
          if (options.proxy)
            promises.push(browser._connection.send("Browser.setBrowserProxy", toJugglerProxyOptions(options.proxy)));
          yield Promise.all(promises);
          return browser;
        });
      }
      constructor(connection, options) {
        super(options);
        this._connection = void 0;
        this._ffPages = void 0;
        this._contexts = void 0;
        this._version = "";
        this._userAgent = "";
        this._connection = connection;
        this._ffPages = /* @__PURE__ */ new Map();
        this._contexts = /* @__PURE__ */ new Map();
        this._connection.on(_ffConnection.ConnectionEvents.Disconnected, () => this._onDisconnect());
        this._connection.on("Browser.attachedToTarget", this._onAttachedToTarget.bind(this));
        this._connection.on("Browser.detachedFromTarget", this._onDetachedFromTarget.bind(this));
        this._connection.on("Browser.downloadCreated", this._onDownloadCreated.bind(this));
        this._connection.on("Browser.downloadFinished", this._onDownloadFinished.bind(this));
        this._connection.on("Browser.videoRecordingFinished", this._onVideoRecordingFinished.bind(this));
      }
      _initVersion() {
        return __async(this, null, function* () {
          const result = yield this._connection.send("Browser.getInfo");
          this._version = result.version.substring(result.version.indexOf("/") + 1);
          this._userAgent = result.userAgent;
        });
      }
      isConnected() {
        return !this._connection._closed;
      }
      newContext(options) {
        return __async(this, null, function* () {
          (0, _browserContext.validateBrowserContextOptions)(options, this.options);
          if (options.isMobile)
            throw new Error("options.isMobile is not supported in Firefox");
          const {
            browserContextId
          } = yield this._connection.send("Browser.createBrowserContext", {
            removeOnDetach: true
          });
          const context = new FFBrowserContext(this, browserContextId, options);
          yield context._initialize();
          this._contexts.set(browserContextId, context);
          return context;
        });
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return this._version;
      }
      userAgent() {
        return this._userAgent;
      }
      _onDetachedFromTarget(payload) {
        const ffPage = this._ffPages.get(payload.targetId);
        this._ffPages.delete(payload.targetId);
        ffPage.didClose();
      }
      _onAttachedToTarget(payload) {
        const {
          targetId,
          browserContextId,
          openerId,
          type
        } = payload.targetInfo;
        (0, _utils2.assert)(type === "page");
        const context = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
        (0, _utils2.assert)(context, `Unknown context id:${browserContextId}, _defaultContext: ${this._defaultContext}`);
        const session = this._connection.createSession(payload.sessionId);
        const opener = openerId ? this._ffPages.get(openerId) : null;
        const ffPage = new _ffPage.FFPage(session, context, opener);
        this._ffPages.set(targetId, ffPage);
      }
      _onDownloadCreated(payload) {
        const ffPage = this._ffPages.get(payload.pageTargetId);
        (0, _utils2.assert)(ffPage);
        if (!ffPage)
          return;
        let originPage = ffPage._initializedPage;
        if (!originPage) {
          ffPage._markAsError(new Error("Starting new page download"));
          if (ffPage._opener)
            originPage = ffPage._opener._initializedPage;
        }
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.uuid, payload.url, payload.suggestedFileName);
      }
      _onDownloadFinished(payload) {
        const error = payload.canceled ? "canceled" : payload.error;
        this._downloadFinished(payload.uuid, error);
      }
      _onVideoRecordingFinished(payload) {
        var _this$_takeVideo;
        (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();
      }
      _onDisconnect() {
        for (const video of this._idToVideo.values())
          video.artifact.reportFinished(_errors.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
      }
    };
    exports2.FFBrowser = FFBrowser;
    var FFBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
      }
      _initialize() {
        var __superGet = (key) => super[key];
        return __async(this, null, function* () {
          (0, _utils2.assert)(!this._ffPages().length);
          const browserContextId = this._browserContextId;
          const promises = [__superGet("_initialize").call(this)];
          promises.push(this._browser._connection.send("Browser.setDownloadOptions", {
            browserContextId,
            downloadOptions: {
              behavior: this._options.acceptDownloads ? "saveToDisk" : "cancel",
              downloadsDir: this._browser.options.downloadsPath
            }
          }));
          if (this._options.viewport) {
            const viewport = {
              viewportSize: {
                width: this._options.viewport.width,
                height: this._options.viewport.height
              },
              deviceScaleFactor: this._options.deviceScaleFactor || 1
            };
            promises.push(this._browser._connection.send("Browser.setDefaultViewport", {
              browserContextId,
              viewport
            }));
          }
          if (this._options.hasTouch)
            promises.push(this._browser._connection.send("Browser.setTouchOverride", {
              browserContextId,
              hasTouch: true
            }));
          if (this._options.userAgent)
            promises.push(this._browser._connection.send("Browser.setUserAgentOverride", {
              browserContextId,
              userAgent: this._options.userAgent
            }));
          if (this._options.bypassCSP)
            promises.push(this._browser._connection.send("Browser.setBypassCSP", {
              browserContextId,
              bypassCSP: true
            }));
          if (this._options.ignoreHTTPSErrors)
            promises.push(this._browser._connection.send("Browser.setIgnoreHTTPSErrors", {
              browserContextId,
              ignoreHTTPSErrors: true
            }));
          if (this._options.javaScriptEnabled === false)
            promises.push(this._browser._connection.send("Browser.setJavaScriptDisabled", {
              browserContextId,
              javaScriptDisabled: true
            }));
          if (this._options.locale)
            promises.push(this._browser._connection.send("Browser.setLocaleOverride", {
              browserContextId,
              locale: this._options.locale
            }));
          if (this._options.timezoneId)
            promises.push(this._browser._connection.send("Browser.setTimezoneOverride", {
              browserContextId,
              timezoneId: this._options.timezoneId
            }));
          if (this._options.permissions)
            promises.push(this.grantPermissions(this._options.permissions));
          if (this._options.extraHTTPHeaders || this._options.locale)
            promises.push(this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []));
          if (this._options.httpCredentials)
            promises.push(this.setHTTPCredentials(this._options.httpCredentials));
          if (this._options.geolocation)
            promises.push(this.setGeolocation(this._options.geolocation));
          if (this._options.offline)
            promises.push(this.setOffline(this._options.offline));
          promises.push(this._browser._connection.send("Browser.setColorScheme", {
            browserContextId,
            colorScheme: this._options.colorScheme !== void 0 ? this._options.colorScheme : "light"
          }));
          promises.push(this._browser._connection.send("Browser.setReducedMotion", {
            browserContextId,
            reducedMotion: this._options.reducedMotion !== void 0 ? this._options.reducedMotion : "no-preference"
          }));
          promises.push(this._browser._connection.send("Browser.setForcedColors", {
            browserContextId,
            forcedColors: this._options.forcedColors !== void 0 ? this._options.forcedColors : "none"
          }));
          if (this._options.recordVideo) {
            promises.push(this._ensureVideosPath().then(() => {
              return this._browser._connection.send("Browser.setVideoRecordingOptions", {
                options: __spreadProps(__spreadValues({}, this._options.recordVideo.size), {
                  dir: this._options.recordVideo.dir
                }),
                browserContextId: this._browserContextId
              });
            }));
          }
          if (this._options.proxy) {
            promises.push(this._browser._connection.send("Browser.setContextProxy", __spreadValues({
              browserContextId: this._browserContextId
            }, toJugglerProxyOptions(this._options.proxy))));
          }
          yield Promise.all(promises);
        });
      }
      _ffPages() {
        return Array.from(this._browser._ffPages.values()).filter((ffPage) => ffPage._browserContext === this);
      }
      pages() {
        return this._ffPages().map((ffPage) => ffPage._initializedPage).filter((pageOrNull) => !!pageOrNull);
      }
      newPageDelegate() {
        return __async(this, null, function* () {
          (0, _browserContext.assertBrowserContextIsNotOwned)(this);
          const {
            targetId
          } = yield this._browser._connection.send("Browser.newPage", {
            browserContextId: this._browserContextId
          }).catch((e) => {
            if (e.message.includes("Failed to override timezone"))
              throw new Error(`Invalid timezone ID: ${this._options.timezoneId}`);
            throw e;
          });
          return this._browser._ffPages.get(targetId);
        });
      }
      _doCookies(urls) {
        return __async(this, null, function* () {
          const {
            cookies
          } = yield this._browser._connection.send("Browser.getCookies", {
            browserContextId: this._browserContextId
          });
          return network.filterCookies(cookies.map((c) => {
            const copy = __spreadValues({}, c);
            delete copy.size;
            delete copy.session;
            return copy;
          }), urls);
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          const cc = network.rewriteCookies(cookies).map((c) => __spreadProps(__spreadValues({}, c), {
            expires: c.expires && c.expires !== -1 ? c.expires : void 0
          }));
          yield this._browser._connection.send("Browser.setCookies", {
            browserContextId: this._browserContextId,
            cookies: cc
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.clearCookies", {
            browserContextId: this._browserContextId
          });
        });
      }
      _doGrantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          const webPermissionToProtocol = /* @__PURE__ */ new Map([["geolocation", "geo"], ["persistent-storage", "persistent-storage"], ["push", "push"], ["notifications", "desktop-notification"]]);
          const filtered = permissions.map((permission) => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
              throw new Error("Unknown permission: " + permission);
            return protocolPermission;
          });
          yield this._browser._connection.send("Browser.grantPermissions", {
            origin,
            browserContextId: this._browserContextId,
            permissions: filtered
          });
        });
      }
      _doClearPermissions() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.resetPermissions", {
            browserContextId: this._browserContextId
          });
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          (0, _browserContext.verifyGeolocation)(geolocation);
          this._options.geolocation = geolocation;
          yield this._browser._connection.send("Browser.setGeolocationOverride", {
            browserContextId: this._browserContextId,
            geolocation: geolocation || null
          });
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          this._options.extraHTTPHeaders = headers;
          let allHeaders = this._options.extraHTTPHeaders;
          if (this._options.locale)
            allHeaders = network.mergeHeaders([allHeaders, network.singleHeader("Accept-Language", this._options.locale)]);
          yield this._browser._connection.send("Browser.setExtraHTTPHeaders", {
            browserContextId: this._browserContextId,
            headers: allHeaders
          });
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          this._options.offline = offline;
          yield this._browser._connection.send("Browser.setOnlineOverride", {
            browserContextId: this._browserContextId,
            override: offline ? "offline" : "online"
          });
        });
      }
      _doSetHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          this._options.httpCredentials = httpCredentials;
          yield this._browser._connection.send("Browser.setHTTPCredentials", {
            browserContextId: this._browserContextId,
            credentials: httpCredentials || null
          });
        });
      }
      _doAddInitScript(source) {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.addScriptToEvaluateOnNewDocument", {
            browserContextId: this._browserContextId,
            script: source
          });
        });
      }
      _doExposeBinding(binding) {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.addBinding", {
            browserContextId: this._browserContextId,
            name: binding.name,
            script: binding.source
          });
        });
      }
      _doUpdateRequestInterception() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.setRequestInterception", {
            browserContextId: this._browserContextId,
            enabled: !!this._requestInterceptor
          });
        });
      }
      _onClosePersistent() {
      }
      _doClose() {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this._browserContextId);
          yield this._browser._connection.send("Browser.removeBrowserContext", {
            browserContextId: this._browserContextId
          });
          this._browser._contexts.delete(this._browserContextId);
        });
      }
      _doCancelDownload(uuid) {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.cancelDownload", {
            uuid
          });
        });
      }
    };
    exports2.FFBrowserContext = FFBrowserContext;
    function toJugglerProxyOptions(proxy) {
      const proxyServer = new URL(proxy.server);
      let port = parseInt(proxyServer.port, 10);
      let type = "http";
      if (proxyServer.protocol === "socks5:")
        type = "socks";
      else if (proxyServer.protocol === "socks4:")
        type = "socks4";
      else if (proxyServer.protocol === "https:")
        type = "https";
      if (proxyServer.port === "") {
        if (proxyServer.protocol === "http:")
          port = 80;
        else if (proxyServer.protocol === "https:")
          port = 443;
      }
      return {
        type,
        bypass: proxy.bypass ? proxy.bypass.split(",").map((domain) => domain.trim()) : [],
        host: proxyServer.hostname,
        port,
        username: proxy.username,
        password: proxy.password
      };
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/firefox.js
var require_firefox = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/firefox.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Firefox = void 0;
    var os = _interopRequireWildcard2(require("os"));
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _path2 = _interopRequireDefault2(require("path"));
    var _ffBrowser = require_ffBrowser();
    var _ffConnection = require_ffConnection();
    var _browserType = require_browserType();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Firefox = class extends _browserType.BrowserType {
      constructor(playwrightOptions) {
        super("firefox", playwrightOptions);
      }
      _connectToTransport(transport, options) {
        return _ffBrowser.FFBrowser.connect(transport, options);
      }
      _rewriteStartupError(error) {
        return error;
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        if (!_path2.default.isAbsolute(os.homedir()))
          throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os.platform() === "win32" ? "USERPROFILE" : "HOME"} to a relative path?`);
        if (os.platform() === "linux") {
          return __spreadProps(__spreadValues({}, env), {
            LD_LIBRARY_PATH: `${_path2.default.dirname(executable)}:${process.env.LD_LIBRARY_PATH}`
          });
        }
        return env;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        const message = {
          method: "Browser.close",
          params: {},
          id: _ffConnection.kBrowserCloseMessageId
        };
        transport.send(message);
      }
      _defaultArgs(options, isPersistent, userDataDir) {
        const {
          args = [],
          devtools,
          headless
        } = options;
        if (devtools)
          console.warn("devtools parameter is not supported as a launch argument in Firefox. You can launch the devtools window manually.");
        const userDataDirArg = args.find((arg) => arg.startsWith("-profile") || arg.startsWith("--profile"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --profile argument");
        if (args.find((arg) => arg.startsWith("-juggler")))
          throw new Error("Use the port parameter instead of -juggler argument");
        const firefoxUserPrefs = isPersistent ? void 0 : options.firefoxUserPrefs;
        if (firefoxUserPrefs) {
          const lines = [];
          for (const [name, value] of Object.entries(firefoxUserPrefs))
            lines.push(`user_pref(${JSON.stringify(name)}, ${JSON.stringify(value)});`);
          _fs2.default.writeFileSync(_path2.default.join(userDataDir, "user.js"), lines.join("\n"));
        }
        const firefoxArguments = ["-no-remote"];
        if (headless) {
          firefoxArguments.push("-headless");
        } else {
          firefoxArguments.push("-wait-for-browser");
          firefoxArguments.push("-foreground");
        }
        firefoxArguments.push(`-profile`, userDataDir);
        firefoxArguments.push("-juggler-pipe");
        firefoxArguments.push(...args);
        if (isPersistent)
          firefoxArguments.push("about:blank");
        else
          firefoxArguments.push("-silent");
        return firefoxArguments;
      }
    };
    exports2.Firefox = Firefox;
  }
});

// node_modules/playwright-core/lib/server/selectors.js
var require_selectors = __commonJS({
  "node_modules/playwright-core/lib/server/selectors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Selectors = void 0;
    var _selectorParser = require_selectorParser();
    var _selectorErrors = require_selectorErrors();
    var _utils2 = require_utils();
    var Selectors = class {
      constructor() {
        this._builtinEngines = void 0;
        this._builtinEnginesInMainWorld = void 0;
        this._engines = void 0;
        this.guid = `selectors@${(0, _utils2.createGuid)()}`;
        this._builtinEngines = /* @__PURE__ */ new Set(["css", "css:light", "xpath", "xpath:light", "_react", "_vue", "text", "text:light", "id", "id:light", "data-testid", "data-testid:light", "data-test-id", "data-test-id:light", "data-test", "data-test:light", "nth", "visible", "control"]);
        this._builtinEnginesInMainWorld = /* @__PURE__ */ new Set(["_react", "_vue"]);
        this._engines = /* @__PURE__ */ new Map();
      }
      register(name, source, contentScript = false) {
        return __async(this, null, function* () {
          if (!name.match(/^[a-zA-Z_0-9-]+$/))
            throw new Error("Selector engine name may only contain [a-zA-Z0-9_] characters");
          if (this._builtinEngines.has(name) || name === "zs" || name === "zs:light")
            throw new Error(`"${name}" is a predefined selector engine`);
          if (this._engines.has(name))
            throw new Error(`"${name}" selector engine has been already registered`);
          this._engines.set(name, {
            source,
            contentScript
          });
        });
      }
      unregisterAll() {
        this._engines.clear();
      }
      query(frame, info, scope) {
        return __async(this, null, function* () {
          const context = yield frame._context(info.world);
          const injectedScript = yield context.injectedScript();
          const handle = yield injectedScript.evaluateHandle((injected, {
            parsed,
            scope: scope2,
            strict
          }) => {
            return injected.querySelector(parsed, scope2 || document, strict);
          }, {
            parsed: info.parsed,
            scope,
            strict: info.strict
          });
          const elementHandle = handle.asElement();
          if (!elementHandle) {
            handle.dispose();
            return null;
          }
          const mainContext = yield frame._mainContext();
          return this._adoptIfNeeded(elementHandle, mainContext);
        });
      }
      _queryArrayInMainWorld(frame, info, scope) {
        return __async(this, null, function* () {
          const context = yield frame._mainContext();
          const injectedScript = yield context.injectedScript();
          const arrayHandle = yield injectedScript.evaluateHandle((injected, {
            parsed,
            scope: scope2
          }) => {
            return injected.querySelectorAll(parsed, scope2 || document);
          }, {
            parsed: info.parsed,
            scope
          });
          return arrayHandle;
        });
      }
      _queryCount(frame, info, scope) {
        return __async(this, null, function* () {
          const context = yield frame._utilityContext();
          const injectedScript = yield context.injectedScript();
          return yield injectedScript.evaluate((injected, {
            parsed,
            scope: scope2
          }) => {
            return injected.querySelectorAll(parsed, scope2 || document).length;
          }, {
            parsed: info.parsed,
            scope
          });
        });
      }
      _queryAll(frame, selector, scope, adoptToMain) {
        return __async(this, null, function* () {
          const info = typeof selector === "string" ? frame._page.parseSelector(selector) : selector;
          const context = yield frame._context(info.world);
          const injectedScript = yield context.injectedScript();
          const arrayHandle = yield injectedScript.evaluateHandle((injected, {
            parsed,
            scope: scope2
          }) => {
            return injected.querySelectorAll(parsed, scope2 || document);
          }, {
            parsed: info.parsed,
            scope
          });
          const properties = yield arrayHandle.getProperties();
          arrayHandle.dispose();
          const targetContext = adoptToMain ? yield frame._mainContext() : context;
          const result = [];
          for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
              result.push(this._adoptIfNeeded(elementHandle, targetContext));
            else
              property.dispose();
          }
          return Promise.all(result);
        });
      }
      _adoptIfNeeded(handle, context) {
        return __async(this, null, function* () {
          if (handle._context === context)
            return handle;
          const adopted = handle._page._delegate.adoptElementHandle(handle, context);
          handle.dispose();
          return adopted;
        });
      }
      parseSelector(selector, strict) {
        const parsed = typeof selector === "string" ? (0, _selectorParser.parseSelector)(selector) : selector;
        let needsMainWorld = false;
        for (const part of parsed.parts) {
          const custom = this._engines.get(part.name);
          if (!custom && !this._builtinEngines.has(part.name))
            throw new _selectorErrors.InvalidSelectorError(`Unknown engine "${part.name}" while parsing selector ${(0, _selectorParser.stringifySelector)(parsed)}`);
          if (custom && !custom.contentScript)
            needsMainWorld = true;
          if (this._builtinEnginesInMainWorld.has(part.name))
            needsMainWorld = true;
        }
        return {
          parsed,
          world: needsMainWorld ? "main" : "utility",
          strict
        };
      }
    };
    exports2.Selectors = Selectors;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkConnection.js
var require_wkConnection = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createProtocolError = createProtocolError;
    exports2.WKSession = exports2.WKConnection = exports2.kPageProxyMessageReceived = exports2.kBrowserCloseMessageId = void 0;
    var _events = require("events");
    var _utils2 = require_utils();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _errors = require_errors();
    var _protocolError = require_protocolError();
    var kBrowserCloseMessageId = -9999;
    exports2.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var kPageProxyMessageReceived = "kPageProxyMessageReceived";
    exports2.kPageProxyMessageReceived = kPageProxyMessageReceived;
    var WKConnection = class {
      constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {
        this._transport = void 0;
        this._onDisconnect = void 0;
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this._lastId = 0;
        this._closed = false;
        this.browserSession = void 0;
        this._transport = transport;
        this._transport.onmessage = this._dispatchMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._onDisconnect = onDisconnect;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this.browserSession = new WKSession(this, "", _errors.kBrowserClosedError, (message) => {
          this.rawSend(message);
        });
      }
      nextMessageId() {
        return ++this._lastId;
      }
      rawSend(message) {
        this._protocolLogger("send", message);
        this._transport.send(message);
      }
      _dispatchMessage(message) {
        this._protocolLogger("receive", message);
        if (message.id === kBrowserCloseMessageId)
          return;
        if (message.pageProxyId) {
          const payload = {
            message,
            pageProxyId: message.pageProxyId
          };
          this.browserSession.dispatchMessage({
            method: kPageProxyMessageReceived,
            params: payload
          });
          return;
        }
        this.browserSession.dispatchMessage(message);
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        this.browserSession.dispose(true);
        this._onDisconnect();
      }
      isClosed() {
        return this._closed;
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
    };
    exports2.WKConnection = WKConnection;
    var WKSession = class extends _events.EventEmitter {
      constructor(connection, sessionId, errorText, rawSend) {
        super();
        this.connection = void 0;
        this.errorText = void 0;
        this.sessionId = void 0;
        this._disposed = false;
        this._rawSend = void 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._crashed = false;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this.connection = connection;
        this.sessionId = sessionId;
        this._rawSend = rawSend;
        this.errorText = errorText;
        this.on = super.on;
        this.off = super.removeListener;
        this.addListener = super.addListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      send(method, params) {
        return __async(this, null, function* () {
          if (this._crashed)
            throw new _protocolError.ProtocolError(true, "Target crashed");
          if (this._disposed)
            throw new _protocolError.ProtocolError(true, `Target closed`);
          const id = this.connection.nextMessageId();
          const messageObj = {
            id,
            method,
            params
          };
          this._rawSend(messageObj);
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      sendMayFail(method, params) {
        return this.send(method, params).catch((error) => _debugLogger.debugLogger.log("error", error));
      }
      markAsCrashed() {
        this._crashed = true;
      }
      isDisposed() {
        return this._disposed;
      }
      dispose(disconnected) {
        if (disconnected)
          this.errorText = "Browser closed." + _helper.helper.formatBrowserLogs(this.connection._browserLogsCollector.recentLogs());
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, this.errorText));
        }
        this._callbacks.clear();
        this._disposed = true;
      }
      dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else if (object.id && !object.error) {
          (0, _utils2.assert)(this.isDisposed());
        } else {
          Promise.resolve().then(() => this.emit(object.method, object.params));
        }
      }
    };
    exports2.WKSession = WKSession;
    function createProtocolError(error, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${JSON.stringify(protocolError.data)}`;
      return (0, _stackTrace.rewriteErrorMessage)(error, message);
    }
  }
});

// node_modules/jpeg-js/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/jpeg-js/lib/encoder.js"(exports2, module2) {
    var btoa = btoa || function(buf) {
      return Buffer.from(buf).toString("base64");
    };
    function JPEGEncoder(quality) {
      var self2 = this;
      var fround = Math.round;
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value) {
        byteout.push(value);
      }
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        var I8 = 8;
        var I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeAPP1(exifBuffer) {
        if (!exifBuffer)
          return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i = 0; i < exifBuffer.length; i++) {
          writeByte(exifBuffer[i]);
        }
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        ;
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      this.encode = function(image, quality2) {
        var time_start = new Date().getTime();
        if (quality2)
          setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeAPP1(image.exifBuffer);
        writeDQT();
        writeSOF0(image.width, image.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image.data;
        var width = image.width;
        var height = image.height;
        var quadWidth = width * 4;
        var tripleWidth = width * 3;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        if (typeof module2 === "undefined")
          return new Uint8Array(byteout);
        return Buffer.from(byteout);
        var jpegDataUri = "data:image/jpeg;base64," + btoa(byteout.join(""));
        byteout = [];
        var duration = new Date().getTime() - time_start;
        return jpegDataUri;
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2)
          return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      function init() {
        var time_start = new Date().getTime();
        if (!quality)
          quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        var duration = new Date().getTime() - time_start;
      }
      init();
    }
    if (typeof module2 !== "undefined") {
      module2.exports = encode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].encode = encode;
    }
    function encode(imgData, qu) {
      if (typeof qu === "undefined")
        qu = 50;
      var encoder = new JPEGEncoder(qu);
      var data = encoder.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
  }
});

// node_modules/jpeg-js/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/jpeg-js/lib/decoder.js"(exports2, module2) {
    var JpegImage = function jpegImage() {
      "use strict";
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q = { children: [], index: 0 });
              p.children[p.index] = q.children;
              p = q;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
        }
        return code[0].children;
      }
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null)
              return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s);
            k2++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s) * (1 << successive);
            k2++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode2, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode2, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval)
          resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected)
                break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data[offset] === 255) {
                if (data[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data.length - 2);
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      constructor.prototype = {
        load: function load(path) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        },
        parse: function parse(data) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0, length = data.length;
          function readUint16() {
            var value = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length2 = readUint16();
            var array = data.subarray(offset, offset + length2 - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame2) {
            var maxH2 = 0, maxV2 = 0;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH2 < component2.h)
                  maxH2 = component2.h;
                if (maxV2 < component2.v)
                  maxV2 = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH2;
            frame2.maxV = maxV2;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var pixels = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          var malformedDataOffset = -1;
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j, l;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data[offset++], componentId;
                var maxH = 0, maxV = 0;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++) {
                    codeLengthSum += codeLengths[j] = data[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                var scanLength = readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, this.opts);
                offset += processed;
                break;
              case 65535:
                if (data[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                } else if (fileMarker === 224 || fileMarker == 225) {
                  if (malformedDataOffset !== -1) {
                    throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                  }
                  malformedDataOffset = offset - 1;
                  const nextOffset = readUint16();
                  if (data[offset + nextOffset - 2] === 255) {
                    offset += nextOffset - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i = 0; i < frames.length; i++) {
            var cp = frames[i].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = 255 - C;
                  data[offset++] = 255 - M;
                  data[offset++] = 255 - Ye;
                  data[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data;
        },
        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i++];
                  G = data[i++];
                  B = data[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i++];
                  M = data[i++];
                  Y = data[i++];
                  K = data[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    }();
    if (typeof module2 !== "undefined") {
      module2.exports = decode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].decode = decode;
    }
    function decode(jpegData, userOpts = {}) {
      var defaultOpts = {
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        maxMemoryUsageInMB: 512
      };
      var opts = __spreadValues(__spreadValues({}, defaultOpts), userOpts);
      var arr = new Uint8Array(jpegData);
      var decoder = new JpegImage();
      decoder.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder.width * decoder.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image = {
          width: decoder.width,
          height: decoder.height,
          exifBuffer: decoder.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder.comments.length > 0) {
          image["comments"] = decoder.comments;
        }
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        } else {
          throw err;
        }
      }
      decoder.copyToImageData(image, opts.formatAsRGBA);
      return image;
    }
  }
});

// node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS({
  "node_modules/jpeg-js/index.js"(exports2, module2) {
    var encode = require_encoder();
    var decode = require_decoder();
    module2.exports = {
      encode,
      decode
    };
  }
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "node_modules/pngjs/lib/chunkstream.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var ChunkStream = module2.exports = function() {
      Stream.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(function() {
        this._process();
        if (this._paused && this._reads && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this));
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      let dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = Buffer.from(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read) {
      this._reads.shift();
      let smallerBuf = this._buffers[0];
      if (smallerBuf.length > read.length) {
        this._buffered -= read.length;
        this._buffers[0] = smallerBuf.slice(read.length);
        read.func.call(this, smallerBuf.slice(0, read.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read) {
      this._reads.shift();
      let pos = 0;
      let count = 0;
      let data = Buffer.alloc(read.length);
      while (pos < read.length) {
        let buf = this._buffers[count++];
        let len = Math.min(buf.length, read.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read.length;
      read.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          let read = this._reads[0];
          if (read.allowLess) {
            this._processReadAllowingLess(read);
          } else if (this._buffered >= read.length) {
            this._processRead(read);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS({
  "node_modules/pngjs/lib/interlace.js"(exports2) {
    "use strict";
    var imagePasses = [
      {
        x: [0],
        y: [0]
      },
      {
        x: [4],
        y: [0]
      },
      {
        x: [0, 4],
        y: [4]
      },
      {
        x: [2, 6],
        y: [0, 4]
      },
      {
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports2.getImagePasses = function(width, height) {
      let images = [];
      let xLeftOver = width % 8;
      let yLeftOver = height % 8;
      let xRepeats = (width - xLeftOver) / 8;
      let yRepeats = (height - yLeftOver) / 8;
      for (let i = 0; i < imagePasses.length; i++) {
        let pass = imagePasses[i];
        let passWidth = xRepeats * pass.x.length;
        let passHeight = yRepeats * pass.y.length;
        for (let j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (let j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i });
        }
      }
      return images;
    };
    exports2.getInterlaceIterator = function(width) {
      return function(x, y, pass) {
        let outerXLeftOver = x % imagePasses[pass].x.length;
        let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        let outerYLeftOver = y % imagePasses[pass].y.length;
        let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "node_modules/pngjs/lib/paeth-predictor.js"(exports2, module2) {
    "use strict";
    module2.exports = function paethPredictor(left, above, upLeft) {
      let paeth = left + above - upLeft;
      let pLeft = Math.abs(paeth - left);
      let pAbove = Math.abs(paeth - above);
      let pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "node_modules/pngjs/lib/filter-parse.js"(exports2, module2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      let byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module2.exports = function(bitmapInfo, dependencies) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let interlace = bitmapInfo.interlace;
      let bpp = bitmapInfo.bpp;
      let depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        let passes = interlaceUtils.getImagePasses(width, height);
        for (let i = 0; i < passes.length; i++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i].width, bpp, depth),
            height: passes[i].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f3Up = lastLine ? lastLine[x] : 0;
        let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f4Up = lastLine ? lastLine[x] : 0;
        let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
        let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      let filter = rawData[0];
      let unfilteredLine;
      let currentImage = this._images[this._imageIndex];
      let byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = Buffer.alloc(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "node_modules/pngjs/lib/filter-parse-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module2.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      let buffers = [];
      let that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
  }
});

// node_modules/pngjs/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/pngjs/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS({
  "node_modules/pngjs/lib/crc.js"(exports2, module2) {
    "use strict";
    var crcTable = [];
    (function() {
      for (let i = 0; i < 256; i++) {
        let currentCrc = i;
        for (let j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i] = currentCrc;
      }
    })();
    var CrcCalculator = module2.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (let i = 0; i < data.length; i++) {
        this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      let crc = -1;
      for (let i = 0; i < buf.length; i++) {
        crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// node_modules/pngjs/lib/parser.js
var require_parser = __commonJS({
  "node_modules/pngjs/lib/parser.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var CrcCalculator = require_crc();
    var Parser = module2.exports = function(options, dependencies) {
      this._options = options;
      options.checkCRC = options.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      let signature = constants.PNG_SIGNATURE;
      for (let i = 0; i < signature.length; i++) {
        if (data[i] !== signature[i]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      let length = data.readUInt32BE(0);
      let type = data.readUInt32BE(4);
      let name = "";
      for (let i = 4; i < 8; i++) {
        name += String.fromCharCode(data[i]);
      }
      let ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(Buffer.from(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      let fileCrc = data.readInt32BE(0);
      let calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      let width = data.readUInt32BE(0);
      let height = data.readUInt32BE(4);
      let depth = data[8];
      let colorType = data[9];
      let compr = data[10];
      let filter = data[11];
      let interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      let entries = Math.floor(data.length / 3);
      for (let i = 0; i < entries; i++) {
        this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 255]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (let i = 0; i < data.length; i++) {
          this._palette[i][3] = data[i];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([
          data.readUInt16BE(0),
          data.readUInt16BE(2),
          data.readUInt16BE(4)
        ]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      let leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "node_modules/pngjs/lib/bitmapper.js"(exports2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMapper = [
      function() {
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      function() {
      },
      function(pxData, pixelData, pxPos, maxBit) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      let leftOver = [];
      let i = 0;
      function split() {
        if (i === data.length) {
          throw new Error("Ran out of data");
        }
        let byte = data[i];
        i++;
        let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i];
            i++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          let returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pixelData = bits.get(bpp);
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports2.dataToBitMap = function(data, bitmapInfo) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let depth = bitmapInfo.depth;
      let bpp = bitmapInfo.bpp;
      let interlace = bitmapInfo.interlace;
      let bits;
      if (depth !== 8) {
        bits = bitRetriever(data, depth);
      }
      let pxData;
      if (depth <= 8) {
        pxData = Buffer.alloc(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      let maxBit = Math.pow(2, depth) - 1;
      let rawPos = 0;
      let images;
      let getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        let nonInterlacedPxPos = 0;
        getPxPos = function() {
          let returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        } else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "node_modules/pngjs/lib/format-normaliser.js"(exports2, module2) {
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let color = palette[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = color[i];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (let i = 0; i < 4; i++) {
              outdata[pxPos + i] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      let maxOutSample = 255;
      let maxInSample = Math.pow(2, depth) - 1;
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    module2.exports = function(indata, imageData) {
      let depth = imageData.depth;
      let width = imageData.width;
      let height = imageData.height;
      let colorType = imageData.colorType;
      let transColor = imageData.transColor;
      let palette = imageData.palette;
      let outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8) {
          if (depth === 16) {
            outdata = Buffer.alloc(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS({
  "node_modules/pngjs/lib/parser-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var zlib = require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module2.exports = function(options) {
      ChunkStream.call(this);
      this._parser = new Parser(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options;
      this.writable = true;
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          let imageSize = rowSize * this._bitmapInfo.height;
          let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
          this._inflate = zlib.createInflate({ chunkSize });
          let leftToInflate = imageSize;
          let emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err) {
            if (!leftToInflate) {
              return;
            }
            emitError(err);
          });
          this._filter.on("complete", this._complete.bind(this));
          let filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk) {
            if (!leftToInflate) {
              return;
            }
            if (chunk.length > leftToInflate) {
              chunk = chunk.slice(0, leftToInflate);
            }
            leftToInflate -= chunk.length;
            filterWrite(chunk);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      let normalisedBitmapData;
      try {
        let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "node_modules/pngjs/lib/bitpacker.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    module2.exports = function(dataIn, width, height, options) {
      let outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
      if (options.colorType === options.inputColorType) {
        let bigEndian = function() {
          let buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] !== 256;
        }();
        if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      let maxValue = 255;
      let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
      if (inBpp === 4 && !options.inputHasAlpha) {
        inBpp = 3;
      }
      let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
      if (options.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      let outData = Buffer.alloc(width * height * outBpp);
      let inIndex = 0;
      let outIndex = 0;
      let bgColor = options.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        let red;
        let green;
        let blue;
        let alpha = maxValue;
        switch (options.inputColorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error("input color type:" + options.inputColorType + " is not supported at present");
        }
        if (options.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
            green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
            blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
          }
        }
        return { red, green, blue, alpha };
      }
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let rgba = getRGBA(data, inIndex);
          switch (options.colorType) {
            case constants.COLORTYPE_COLOR_ALPHA:
            case constants.COLORTYPE_COLOR:
              if (options.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants.COLORTYPE_ALPHA:
            case constants.COLORTYPE_GRAYSCALE: {
              let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            }
            default:
              throw new Error("unrecognised color Type " + options.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "node_modules/pngjs/lib/filter-pack.js"(exports2, module2) {
    "use strict";
    var paethPredictor = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        rawData[rawPos + x] = pxData[pxPos + x];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let i = pxPos; i < length; i++) {
        sum += Math.abs(pxData[i]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - up;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let x = pxPos; x < length; x++) {
        let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
        let val = pxData[x] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module2.exports = function(pxData, width, height, options, bpp) {
      let filterTypes;
      if (!("filterType" in options) || options.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options.filterType === "number") {
        filterTypes = [options.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options.bitDepth === 16) {
        bpp *= 2;
      }
      let byteWidth = width * bpp;
      let rawPos = 0;
      let pxPos = 0;
      let rawData = Buffer.alloc((byteWidth + 1) * height);
      let sel = filterTypes[0];
      for (let y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          let min = Infinity;
          for (let i = 0; i < filterTypes.length; i++) {
            let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS({
  "node_modules/pngjs/lib/packer.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib = require("zlib");
    var Packer = module2.exports = function(options) {
      this._options = options;
      options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
      options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
      options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
      options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
      options.deflateFactory = options.deflateFactory || zlib.createDeflate;
      options.bitDepth = options.bitDepth || 8;
      options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
      options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.colorType) === -1) {
        throw new Error("option color type:" + options.colorType + " is not supported at present");
      }
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.inputColorType) === -1) {
        throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.bitDepth !== 8 && options.bitDepth !== 16) {
        throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      let packedData = bitPacker(data, width, height, this._options);
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      let filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      let len = data ? data.length : 0;
      let buf = Buffer.alloc(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      let buf = Buffer.alloc(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      let buf = Buffer.alloc(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
  }
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS({
  "node_modules/pngjs/lib/packer-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var constants = require_constants2();
    var Packer = require_packer();
    var PackerAsync = module2.exports = function(opt) {
      Stream.call(this);
      let options = opt || {};
      this._packer = new Packer(options);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util.inherits(PackerAsync, Stream);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      let filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this));
      this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this));
      this._deflate.end(filteredData);
    };
  }
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "node_modules/pngjs/lib/sync-inflate.js"(exports2, module2) {
    "use strict";
    var assert = require("assert").ok;
    var zlib = require("zlib");
    var util = require("util");
    var kMaxLength = require("buffer").kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
        opts.chunkSize = zlib.Z_MIN_CHUNK;
      }
      zlib.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk && chunk.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error;
      this.on("error", function(err) {
        error = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util.inherits(Inflate, zlib.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module2.exports = exports2 = inflateSync;
    exports2.Inflate = Inflate;
    exports2.createInflate = createInflate;
    exports2.inflateSync = inflateSync;
  }
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "node_modules/pngjs/lib/sync-reader.js"(exports2, module2) {
    "use strict";
    var SyncReader = module2.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        let read = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
          this._reads.shift();
          let buf = this._buffer;
          this._buffer = buf.slice(read.length);
          read.func.call(this, buf.slice(0, read.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        return new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        return new Error("unrecognised content at end of stream");
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "node_modules/pngjs/lib/filter-parse-sync.js"(exports2) {
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports2.process = function(inBuffer, bitmapInfo) {
      let outBuffers = [];
      let reader = new SyncReader(inBuffer);
      let filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "node_modules/pngjs/lib/parser-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib = require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module2.exports = function(buffer, options) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let err;
      function handleError(_err_) {
        err = _err_;
      }
      let metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      let gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      let inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      let reader = new SyncReader(buffer);
      let parser = new Parser(options, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      let inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      let inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib.inflateSync(inflateData);
      } else {
        let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        let imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, {
          chunkSize: imageSize,
          maxLength: imageSize
        });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      let unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      let normalisedBitmapData = formatNormaliser(bitmapData, metaData);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "node_modules/pngjs/lib/packer-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib = require("zlib");
    if (!zlib.deflateSync) {
      hasSyncZlib = false;
    }
    var constants = require_constants2();
    var Packer = require_packer();
    module2.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let options = opt || {};
      let packer = new Packer(options);
      let chunks = [];
      chunks.push(Buffer.from(constants.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
      let compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS({
  "node_modules/pngjs/lib/png-sync.js"(exports2) {
    "use strict";
    var parse = require_parser_sync();
    var pack = require_packer_sync();
    exports2.read = function(buffer, options) {
      return parse(buffer, options || {});
    };
    exports2.write = function(png, options) {
      return pack(png, options);
    };
  }
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS({
  "node_modules/pngjs/lib/png.js"(exports2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var Parser = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG = exports2.PNG = function(options) {
      Stream.call(this);
      options = options || {};
      this.width = options.width | 0;
      this.height = options.height | 0;
      this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
      if (options.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on("parsed", function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this));
      this._packer = new Packer(options);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util.inherits(PNG, Stream);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        let onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (let y = 0; y < height; y++) {
        src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src) {
      if (src.gamma) {
        for (let y = 0; y < src.height; y++) {
          for (let x = 0; x < src.width; x++) {
            let idx = src.width * y + x << 2;
            for (let i = 0; i < 3; i++) {
              let sample = src.data[idx + i] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              src.data[idx + i] = Math.round(sample * 255);
            }
          }
        }
        src.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// node_modules/playwright-core/lib/server/webkit/wkAccessibility.js
var require_wkAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAccessibilityTree = getAccessibilityTree;
    function getAccessibilityTree(session, needle) {
      return __async(this, null, function* () {
        const objectId = needle ? needle._objectId : void 0;
        const {
          axNode
        } = yield session.send("Page.accessibilitySnapshot", {
          objectId
        });
        const tree = new WKAXNode(axNode);
        return {
          tree,
          needle: needle ? tree._findNeedle() : null
        };
      });
    }
    var WKRoleToARIARole = new Map(Object.entries({
      "TextField": "textbox"
    }));
    var WKUnhelpfulRoleDescriptions = new Map(Object.entries({
      "WebArea": "HTML content",
      "Summary": "summary",
      "DescriptionList": "description list",
      "ImageMap": "image map",
      "ListMarker": "list marker",
      "Video": "video playback",
      "Mark": "highlighted",
      "contentinfo": "content information",
      "Details": "details",
      "DescriptionListDetail": "description",
      "DescriptionListTerm": "term",
      "alertdialog": "web alert dialog",
      "dialog": "web dialog",
      "status": "application status",
      "tabpanel": "tab panel",
      "application": "web application"
    }));
    var WKAXNode = class {
      constructor(payload) {
        this._payload = void 0;
        this._children = void 0;
        this._payload = payload;
        this._children = [];
        for (const payload2 of this._payload.children || [])
          this._children.push(new WKAXNode(payload2));
      }
      children() {
        return this._children;
      }
      _findNeedle() {
        if (this._payload.found)
          return this;
        for (const child of this._children) {
          const found = child._findNeedle();
          if (found)
            return found;
        }
        return null;
      }
      isControl() {
        switch (this._payload.role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "TextField":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      _isTextControl() {
        switch (this._payload.role) {
          case "combobox":
          case "searchfield":
          case "textbox":
          case "TextField":
            return true;
        }
        return false;
      }
      _name() {
        if (this._payload.role === "text")
          return this._payload.value || "";
        return this._payload.name || "";
      }
      isInteresting(insideControl) {
        const {
          role,
          focusable
        } = this._payload;
        const name = this._name();
        if (role === "ScrollArea")
          return false;
        if (role === "WebArea")
          return true;
        if (focusable || role === "MenuListOption")
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!name;
      }
      _hasRendundantTextChild() {
        if (this._children.length !== 1)
          return false;
        const child = this._children[0];
        return child._payload.role === "text" && this._payload.name === child._payload.value;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isTextControl())
          return true;
        if (this._hasRendundantTextChild())
          return true;
        return false;
      }
      serialize() {
        const node = {
          role: WKRoleToARIARole.get(this._payload.role) || this._payload.role,
          name: this._name()
        };
        if ("description" in this._payload && this._payload.description !== node.name)
          node.description = this._payload.description;
        if ("roledescription" in this._payload) {
          const roledescription = this._payload.roledescription;
          if (roledescription !== this._payload.role && WKUnhelpfulRoleDescriptions.get(this._payload.role) !== roledescription)
            node.roledescription = roledescription;
        }
        if ("value" in this._payload && this._payload.role !== "text") {
          if (typeof this._payload.value === "string")
            node.valueString = this._payload.value;
          else if (typeof this._payload.value === "number")
            node.valueNumber = this._payload.value;
        }
        if ("checked" in this._payload)
          node.checked = this._payload.checked === "true" ? "checked" : this._payload.checked === "false" ? "unchecked" : "mixed";
        if ("pressed" in this._payload)
          node.pressed = this._payload.pressed === "true" ? "pressed" : this._payload.pressed === "false" ? "released" : "mixed";
        const userStringProperties = ["keyshortcuts", "valuetext"];
        for (const userStringProperty of userStringProperties) {
          if (!(userStringProperty in this._payload))
            continue;
          node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && (this._payload.role === "WebArea" || this._payload.role === "ScrollArea"))
            continue;
          const value = this._payload[booleanProperty];
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level", "valuemax", "valuemin"];
        for (const numericalProperty of numericalProperties) {
          if (!(numericalProperty in this._payload))
            continue;
          node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid"];
        for (const tokenProperty of tokenProperties) {
          const value = this._payload[tokenProperty];
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const orientationIsApplicable = /* @__PURE__ */ new Set(["ScrollArea", "scrollbar", "listbox", "combobox", "menu", "tree", "separator", "slider", "tablist", "toolbar"]);
        if (this._payload.orientation && orientationIsApplicable.has(this._payload.role))
          node.orientation = this._payload.orientation;
        return node;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/webkit/wkExecutionContext.js
var require_wkExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkExecutionContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKExecutionContext = void 0;
    var js = _interopRequireWildcard2(require_javascript());
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var WKExecutionContext = class {
      constructor(session, contextId) {
        this._session = void 0;
        this._contextId = void 0;
        this._session = session;
        this._contextId = contextId;
      }
      rawEvaluateJSON(expression) {
        return __async(this, null, function* () {
          try {
            const response = yield this._session.send("Runtime.evaluate", {
              expression,
              contextId: this._contextId,
              returnByValue: true
            });
            if (response.wasThrown)
              throw new js.JavaScriptErrorInEvaluate(response.result.description);
            return response.result.value;
          } catch (error) {
            throw rewriteError(error);
          }
        });
      }
      rawEvaluateHandle(expression) {
        return __async(this, null, function* () {
          try {
            const response = yield this._session.send("Runtime.evaluate", {
              expression,
              contextId: this._contextId,
              returnByValue: false
            });
            if (response.wasThrown)
              throw new js.JavaScriptErrorInEvaluate(response.result.description);
            return response.result.objectId;
          } catch (error) {
            throw rewriteError(error);
          }
        });
      }
      rawCallFunctionNoReply(func, ...args) {
        this._session.send("Runtime.callFunctionOn", {
          functionDeclaration: func.toString(),
          objectId: args.find((a) => a instanceof js.JSHandle)._objectId,
          arguments: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          emulateUserGesture: true
        }).catch(() => {
        });
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return __async(this, null, function* () {
          try {
            const response = yield this._session.send("Runtime.callFunctionOn", {
              functionDeclaration: expression,
              objectId: utilityScript._objectId,
              arguments: [{
                objectId: utilityScript._objectId
              }, ...values.map((value) => ({
                value
              })), ...objectIds.map((objectId) => ({
                objectId
              }))],
              returnByValue,
              emulateUserGesture: true,
              awaitPromise: true
            });
            if (response.wasThrown)
              throw new js.JavaScriptErrorInEvaluate(response.result.description);
            if (returnByValue)
              return (0, _utilityScriptSerializers.parseEvaluationResultValue)(response.result.value);
            return utilityScript._context.createHandle(response.result);
          } catch (error) {
            throw rewriteError(error);
          }
        });
      }
      getProperties(context, objectId) {
        return __async(this, null, function* () {
          const response = yield this._session.send("Runtime.getProperties", {
            objectId,
            ownProperties: true
          });
          const result = /* @__PURE__ */ new Map();
          for (const property of response.properties) {
            if (!property.enumerable || !property.value)
              continue;
            result.set(property.name, context.createHandle(property.value));
          }
          return result;
        });
      }
      createHandle(context, remoteObject) {
        const isPromise = remoteObject.className === "Promise";
        return new js.JSHandle(context, isPromise ? "promise" : remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      releaseHandle(objectId) {
        return __async(this, null, function* () {
          yield this._session.send("Runtime.releaseObject", {
            objectId
          });
        });
      }
    };
    exports2.WKExecutionContext = WKExecutionContext;
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const isUnserializable = remoteObject.type === "number" && ["NaN", "-Infinity", "Infinity", "-0"].includes(remoteObject.description);
      return isUnserializable ? js.parseUnserializableValue(remoteObject.description) : value;
    }
    function rewriteError(error) {
      if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error))
        return new Error("Execution context was destroyed, most likely because of a navigation.");
      return error;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if ("value" in object)
        return String(object.value);
      if (object.description === "Object" && object.preview) {
        const tokens = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          tokens.push(`${name}: ${value}`);
        return `{${tokens.join(", ")}}`;
      }
      if (object.subtype === "array" && object.preview) {
        const result = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          result[+name] = value;
        return "[" + String(result) + "]";
      }
      return object.description;
    }
  }
});

// node_modules/playwright-core/lib/server/webkit/wkInput.js
var require_wkInput = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkInput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    var input = _interopRequireWildcard2(require_input());
    var _macEditingCommands = require_macEditingCommands();
    var _utils2 = require_utils();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Shift"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Alt"))
        mask |= 4;
      if (modifiers.has("Meta"))
        mask |= 8;
      return mask;
    }
    function toButtonsMask(buttons) {
      let mask = 0;
      if (buttons.has("left"))
        mask |= 1;
      if (buttons.has("right"))
        mask |= 2;
      if (buttons.has("middle"))
        mask |= 4;
      return mask;
    }
    var RawKeyboardImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._session = void 0;
        this._pageProxySession = session;
      }
      setSession(session) {
        this._session = session;
      }
      keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        return __async(this, null, function* () {
          const parts = [];
          for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
            if (modifiers.has(modifier))
              parts.push(modifier);
          }
          parts.push(code);
          const shortcut = parts.join("+");
          let commands = _macEditingCommands.macEditingCommands[shortcut];
          if ((0, _utils2.isString)(commands))
            commands = [commands];
          yield this._pageProxySession.send("Input.dispatchKeyEvent", {
            type: "keyDown",
            modifiers: toModifiersMask(modifiers),
            windowsVirtualKeyCode: keyCode,
            code,
            key,
            text,
            unmodifiedText: text,
            autoRepeat,
            macCommands: commands,
            isKeypad: location2 === input.keypadLocation
          });
        });
      }
      keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchKeyEvent", {
            type: "keyUp",
            modifiers: toModifiersMask(modifiers),
            key,
            windowsVirtualKeyCode: keyCode,
            code,
            isKeypad: location2 === input.keypadLocation
          });
        });
      }
      sendText(text) {
        return __async(this, null, function* () {
          yield this._session.send("Page.insertText", {
            text
          });
        });
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._session = void 0;
        this._page = void 0;
        this._pageProxySession = session;
      }
      setSession(session) {
        this._session = session;
      }
      move(x, y, button, buttons, modifiers, forClick) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchMouseEvent", {
            type: "move",
            button,
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      down(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchMouseEvent", {
            type: "down",
            button,
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      up(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchMouseEvent", {
            type: "up",
            button,
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        return __async(this, null, function* () {
          var _this$_page;
          if ((_this$_page = this._page) !== null && _this$_page !== void 0 && _this$_page._browserContext._options.isMobile)
            throw new Error("Mouse wheel is not supported in mobile WebKit");
          yield this._session.send("Page.updateScrollingState");
          yield this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, false, false, "utility");
          yield this._pageProxySession.send("Input.dispatchWheelEvent", {
            x,
            y,
            deltaX,
            deltaY,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      setPage(page) {
        this._page = page;
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._pageProxySession = session;
      }
      tap(x, y, modifiers) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchTapEvent", {
            x,
            y,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkInterceptableRequest.js
var require_wkInterceptableRequest = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkInterceptableRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKRouteImpl = exports2.WKInterceptableRequest = void 0;
    var network = _interopRequireWildcard2(require_network());
    var _utils2 = require_utils();
    var _async = require_async();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var errorReasons = {
      "aborted": "Cancellation",
      "accessdenied": "AccessControl",
      "addressunreachable": "General",
      "blockedbyclient": "Cancellation",
      "blockedbyresponse": "General",
      "connectionaborted": "General",
      "connectionclosed": "General",
      "connectionfailed": "General",
      "connectionrefused": "General",
      "connectionreset": "General",
      "internetdisconnected": "General",
      "namenotresolved": "General",
      "timedout": "Timeout",
      "failed": "General"
    };
    var WKInterceptableRequest = class {
      constructor(session, route, frame, event, redirectedFrom, documentId) {
        this._session = void 0;
        this.request = void 0;
        this._requestId = void 0;
        this._timestamp = void 0;
        this._wallTime = void 0;
        this._route = void 0;
        this._redirectedFrom = void 0;
        this._session = session;
        this._requestId = event.requestId;
        this._route = route;
        this._redirectedFrom = redirectedFrom;
        const resourceType = event.type ? event.type.toLowerCase() : redirectedFrom ? redirectedFrom.request.resourceType() : "other";
        let postDataBuffer = null;
        this._timestamp = event.timestamp;
        this._wallTime = event.walltime * 1e3;
        if (event.request.postData)
          postDataBuffer = Buffer.from(event.request.postData, "base64");
        this.request = new network.Request(frame, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, event.request.url, resourceType, event.request.method, postDataBuffer, (0, _utils2.headersObjectToArray)(event.request.headers));
      }
      _routeForRedirectChain() {
        let request = this;
        while (request._redirectedFrom)
          request = request._redirectedFrom;
        return request._route;
      }
      createResponse(responsePayload) {
        const getResponseBody = () => __async(this, null, function* () {
          const response = yield this._session.send("Network.getResponseBody", {
            requestId: this._requestId
          });
          return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
        });
        const timingPayload = responsePayload.timing;
        const timing = {
          startTime: this._wallTime,
          domainLookupStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupStart) : -1,
          domainLookupEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupEnd) : -1,
          connectStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectStart) : -1,
          secureConnectionStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.secureConnectionStart) : -1,
          connectEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectEnd) : -1,
          requestStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.requestStart) : -1,
          responseStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.responseStart) : -1
        };
        const setCookieSeparator = process.platform === "darwin" ? "," : "\n";
        return new network.Response(this.request, responsePayload.status, responsePayload.statusText, (0, _utils2.headersObjectToArray)(responsePayload.headers, ",", setCookieSeparator), timing, getResponseBody);
      }
    };
    exports2.WKInterceptableRequest = WKInterceptableRequest;
    var WKRouteImpl = class {
      constructor(session, requestId) {
        this._session = void 0;
        this._requestId = void 0;
        this._requestInterceptedPromise = new _async.ManualPromise();
        this._session = session;
        this._requestId = requestId;
      }
      abort(errorCode) {
        return __async(this, null, function* () {
          const errorType = errorReasons[errorCode];
          (0, _utils2.assert)(errorType, "Unknown error code: " + errorCode);
          yield this._requestInterceptedPromise;
          yield this._session.sendMayFail("Network.interceptRequestWithError", {
            requestId: this._requestId,
            errorType
          });
        });
      }
      fulfill(response) {
        return __async(this, null, function* () {
          if (300 <= response.status && response.status < 400)
            throw new Error("Cannot fulfill with redirect status: " + response.status);
          yield this._requestInterceptedPromise;
          let mimeType = response.isBase64 ? "application/octet-stream" : "text/plain";
          const headers = (0, _utils2.headersArrayToObject)(response.headers, true);
          const contentType = headers["content-type"];
          if (contentType)
            mimeType = contentType.split(";")[0].trim();
          yield this._session.sendMayFail("Network.interceptRequestWithResponse", {
            requestId: this._requestId,
            status: response.status,
            statusText: network.STATUS_TEXTS[String(response.status)],
            mimeType,
            headers,
            base64Encoded: response.isBase64,
            content: response.body
          });
        });
      }
      continue(request, overrides) {
        return __async(this, null, function* () {
          yield this._requestInterceptedPromise;
          yield this._session.sendMayFail("Network.interceptWithRequest", {
            requestId: this._requestId,
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers ? (0, _utils2.headersArrayToObject)(overrides.headers, false) : void 0,
            postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
          });
        });
      }
    };
    exports2.WKRouteImpl = WKRouteImpl;
    function wkMillisToRoundishMillis(value) {
      if (value === -1e3)
        return -1;
      if (value <= 0) {
        return -1;
      }
      return (value * 1e3 | 0) / 1e3;
    }
  }
});

// node_modules/playwright-core/lib/server/webkit/wkProvisionalPage.js
var require_wkProvisionalPage = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkProvisionalPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKProvisionalPage = void 0;
    var _eventsHelper = require_eventsHelper();
    var _utils2 = require_utils();
    var WKProvisionalPage = class {
      constructor(session, page) {
        this._session = void 0;
        this._wkPage = void 0;
        this._sessionListeners = [];
        this._mainFrameId = null;
        this.initializationPromise = void 0;
        this._session = session;
        this._wkPage = page;
        const overrideFrameId = (handler) => {
          return (payload) => {
            if (payload.frameId)
              payload.frameId = this._wkPage._page._frameManager.mainFrame()._id;
            handler(payload);
          };
        };
        const wkPage = this._wkPage;
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSent", overrideFrameId((e) => wkPage._onRequestWillBeSent(session, e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestIntercepted", overrideFrameId((e) => wkPage._onRequestIntercepted(session, e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceived", overrideFrameId((e) => wkPage._onResponseReceived(e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFinished", overrideFrameId((e) => wkPage._onLoadingFinished(e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFailed", overrideFrameId((e) => wkPage._onLoadingFailed(e)))];
        this.initializationPromise = this._wkPage._initializeSession(session, true, ({
          frameTree
        }) => this._handleFrameTree(frameTree));
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
      }
      commit() {
        (0, _utils2.assert)(this._mainFrameId);
        this._wkPage._onFrameAttached(this._mainFrameId, null);
      }
      _handleFrameTree(frameTree) {
        (0, _utils2.assert)(!frameTree.frame.parentId);
        this._mainFrameId = frameTree.frame.id;
      }
    };
    exports2.WKProvisionalPage = WKProvisionalPage;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkWorkers.js
var require_wkWorkers = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkWorkers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKWorkers = void 0;
    var _eventsHelper = require_eventsHelper();
    var _page = require_page();
    var _wkConnection = require_wkConnection();
    var _wkExecutionContext = require_wkExecutionContext();
    var WKWorkers = class {
      constructor(page) {
        this._sessionListeners = [];
        this._page = void 0;
        this._workerSessions = /* @__PURE__ */ new Map();
        this._page = page;
      }
      setSession(session) {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        this.clear();
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Worker.workerCreated", (event) => {
          const worker = new _page.Worker(this._page, event.url);
          const workerSession = new _wkConnection.WKSession(session.connection, event.workerId, "Most likely the worker has been closed.", (message) => {
            session.send("Worker.sendMessageToWorker", {
              workerId: event.workerId,
              message: JSON.stringify(message)
            }).catch((e) => {
              workerSession.dispatchMessage({
                id: message.id,
                error: {
                  message: e.message
                }
              });
            });
          });
          this._workerSessions.set(event.workerId, workerSession);
          worker._createExecutionContext(new _wkExecutionContext.WKExecutionContext(workerSession, void 0));
          this._page._addWorker(event.workerId, worker);
          workerSession.on("Console.messageAdded", (event2) => this._onConsoleMessage(worker, event2));
          Promise.all([workerSession.send("Runtime.enable"), workerSession.send("Console.enable"), session.send("Worker.initialized", {
            workerId: event.workerId
          })]).catch((e) => {
            this._page._removeWorker(event.workerId);
          });
        }), _eventsHelper.eventsHelper.addEventListener(session, "Worker.dispatchMessageFromWorker", (event) => {
          const workerSession = this._workerSessions.get(event.workerId);
          if (!workerSession)
            return;
          workerSession.dispatchMessage(JSON.parse(event.message));
        }), _eventsHelper.eventsHelper.addEventListener(session, "Worker.workerTerminated", (event) => {
          const workerSession = this._workerSessions.get(event.workerId);
          if (!workerSession)
            return;
          workerSession.dispose(false);
          this._workerSessions.delete(event.workerId);
          this._page._removeWorker(event.workerId);
        })];
      }
      clear() {
        this._page._clearWorkers();
        this._workerSessions.clear();
      }
      initializeSession(session) {
        return __async(this, null, function* () {
          yield session.send("Worker.enable");
        });
      }
      _onConsoleMessage(worker, event) {
        return __async(this, null, function* () {
          const {
            type,
            level,
            text,
            parameters,
            url,
            line: lineNumber,
            column: columnNumber
          } = event.message;
          let derivedType = type || "";
          if (type === "log")
            derivedType = level;
          else if (type === "timing")
            derivedType = "timeEnd";
          const handles = (parameters || []).map((p) => {
            return worker._existingExecutionContext.createHandle(p);
          });
          const location2 = {
            url: url || "",
            lineNumber: (lineNumber || 1) - 1,
            columnNumber: (columnNumber || 1) - 1
          };
          this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
        });
      }
    };
    exports2.WKWorkers = WKWorkers;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkPage.js
var require_wkPage = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKPage = void 0;
    var jpeg = _interopRequireWildcard2(require_jpeg_js());
    var _path2 = _interopRequireDefault2(require("path"));
    var png = _interopRequireWildcard2(require_png());
    var _stackTrace = require_stackTrace();
    var _utils2 = require_utils();
    var dialog = _interopRequireWildcard2(require_dialog());
    var dom = _interopRequireWildcard2(require_dom());
    var _eventsHelper = require_eventsHelper();
    var _helper = require_helper();
    var network = _interopRequireWildcard2(require_network());
    var _page = require_page();
    var _wkAccessibility = require_wkAccessibility();
    var _wkConnection = require_wkConnection();
    var _wkExecutionContext = require_wkExecutionContext();
    var _wkInput = require_wkInput();
    var _wkInterceptableRequest = require_wkInterceptableRequest();
    var _wkProvisionalPage = require_wkProvisionalPage();
    var _wkWorkers = require_wkWorkers();
    var _debugLogger = require_debugLogger();
    var _async = require_async();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    var BINDING_CALL_MESSAGE = "__playwright_binding_call__";
    var WKPage = class {
      constructor(browserContext, pageProxySession, opener) {
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._session = void 0;
        this._provisionalPage = null;
        this._page = void 0;
        this._pagePromise = new _async.ManualPromise();
        this._pageProxySession = void 0;
        this._opener = void 0;
        this._requestIdToRequest = /* @__PURE__ */ new Map();
        this._workers = void 0;
        this._contextIdToContext = void 0;
        this._mainFrameContextId = void 0;
        this._sessionListeners = [];
        this._eventListeners = void 0;
        this._browserContext = void 0;
        this._initializedPage = null;
        this._firstNonInitialNavigationCommittedPromise = void 0;
        this._firstNonInitialNavigationCommittedFulfill = () => {
        };
        this._firstNonInitialNavigationCommittedReject = (e) => {
        };
        this._lastConsoleMessage = null;
        this._requestIdToResponseReceivedPayloadEvent = /* @__PURE__ */ new Map();
        this._nextWindowOpenPopupFeatures = void 0;
        this._recordingVideoFile = null;
        this._screencastGeneration = 0;
        this._pageProxySession = pageProxySession;
        this._opener = opener;
        this.rawKeyboard = new _wkInput.RawKeyboardImpl(pageProxySession);
        this.rawMouse = new _wkInput.RawMouseImpl(pageProxySession);
        this.rawTouchscreen = new _wkInput.RawTouchscreenImpl(pageProxySession);
        this._contextIdToContext = /* @__PURE__ */ new Map();
        this._page = new _page.Page(this, browserContext);
        this.rawMouse.setPage(this._page);
        this._workers = new _wkWorkers.WKWorkers(this._page);
        this._session = void 0;
        this._browserContext = browserContext;
        this._page.on(_page.Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame, false));
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.targetCreated", this._onTargetCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.targetDestroyed", this._onTargetDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.dispatchMessageFromTarget", this._onDispatchMessageFromTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.didCommitProvisionalTarget", this._onDidCommitProvisionalTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Screencast.screencastFrame", this._onScreencastFrame.bind(this))];
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
          this._firstNonInitialNavigationCommittedFulfill = f;
          this._firstNonInitialNavigationCommittedReject = r;
        });
        if (opener && !browserContext._options.noDefaultViewport && opener._nextWindowOpenPopupFeatures) {
          const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(opener._nextWindowOpenPopupFeatures);
          opener._nextWindowOpenPopupFeatures = void 0;
          if (viewportSize)
            this._page._state.emulatedSize = {
              viewport: viewportSize,
              screen: viewportSize
            };
        }
      }
      _initializePageProxySession() {
        return __async(this, null, function* () {
          const promises = [this._pageProxySession.send("Dialog.enable"), this._pageProxySession.send("Emulation.setActiveAndFocused", {
            active: true
          })];
          const contextOptions = this._browserContext._options;
          if (contextOptions.javaScriptEnabled === false)
            promises.push(this._pageProxySession.send("Emulation.setJavaScriptEnabled", {
              enabled: false
            }));
          promises.push(this._updateViewport());
          promises.push(this.updateHttpCredentials());
          if (this._browserContext._permissions.size) {
            for (const [key, value] of this._browserContext._permissions)
              promises.push(this._grantPermissions(key, value));
          }
          if (this._browserContext._options.recordVideo) {
            const outputFile = _path2.default.join(this._browserContext._options.recordVideo.dir, (0, _utils2.createGuid)() + ".webm");
            promises.push(this._browserContext._ensureVideosPath().then(() => {
              return this._startVideo(__spreadProps(__spreadValues({}, this._browserContext._options.recordVideo.size), {
                outputFile
              }));
            }));
          }
          yield Promise.all(promises);
        });
      }
      _setSession(session) {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        this._session = session;
        this.rawKeyboard.setSession(session);
        this.rawMouse.setSession(session);
        this._addSessionListeners();
        this._workers.setSession(session);
      }
      _initializeSession(session, provisional, resourceTreeHandler) {
        return __async(this, null, function* () {
          yield this._initializeSessionMayThrow(session, resourceTreeHandler).catch((e) => {
            if (provisional && session.isDisposed())
              return;
            if (this._session === session)
              throw e;
          });
        });
      }
      _initializeSessionMayThrow(session, resourceTreeHandler) {
        return __async(this, null, function* () {
          const [, frameTree] = yield Promise.all([
            session.send("Page.enable"),
            session.send("Page.getResourceTree")
          ]);
          resourceTreeHandler(frameTree);
          const promises = [
            session.send("Runtime.enable"),
            session.send("Page.createUserWorld", {
              name: UTILITY_WORLD_NAME
            }).catch((_) => {
            }),
            session.send("Console.enable"),
            session.send("Network.enable"),
            this._workers.initializeSession(session)
          ];
          if (this._page._needsRequestInterception()) {
            promises.push(session.send("Network.setInterceptionEnabled", {
              enabled: true
            }));
            promises.push(session.send("Network.addInterception", {
              url: ".*",
              stage: "request",
              isRegex: true
            }));
          }
          const contextOptions = this._browserContext._options;
          if (contextOptions.userAgent)
            promises.push(session.send("Page.overrideUserAgent", {
              value: contextOptions.userAgent
            }));
          if (this._page._state.mediaType || this._page._state.colorScheme || this._page._state.reducedMotion)
            promises.push(WKPage._setEmulateMedia(session, this._page._state.mediaType, this._page._state.colorScheme, this._page._state.reducedMotion));
          const bootstrapScript = this._calculateBootstrapScript();
          if (bootstrapScript.length)
            promises.push(session.send("Page.setBootstrapScript", {
              source: bootstrapScript
            }));
          this._page.frames().map((frame) => frame.evaluateExpression(bootstrapScript, false, void 0).catch((e) => {
          }));
          if (contextOptions.bypassCSP)
            promises.push(session.send("Page.setBypassCSP", {
              enabled: true
            }));
          if (this._page._state.emulatedSize) {
            promises.push(session.send("Page.setScreenSizeOverride", {
              width: this._page._state.emulatedSize.screen.width,
              height: this._page._state.emulatedSize.screen.height
            }));
          }
          promises.push(this.updateEmulateMedia());
          promises.push(session.send("Network.setExtraHTTPHeaders", {
            headers: (0, _utils2.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false)
          }));
          if (contextOptions.offline)
            promises.push(session.send("Network.setEmulateOfflineState", {
              offline: true
            }));
          promises.push(session.send("Page.setTouchEmulationEnabled", {
            enabled: !!contextOptions.hasTouch
          }));
          if (contextOptions.timezoneId) {
            promises.push(session.send("Page.setTimeZone", {
              timeZone: contextOptions.timezoneId
            }).catch((e) => {
              throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`);
            }));
          }
          promises.push(session.send("Page.overrideSetting", {
            setting: "DeviceOrientationEventEnabled",
            value: contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "FullScreenEnabled",
            value: !contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "NotificationsEnabled",
            value: !contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "PointerLockEnabled",
            value: !contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "InputTypeMonthEnabled",
            value: contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "InputTypeWeekEnabled",
            value: contextOptions.isMobile
          }));
          yield Promise.all(promises);
        });
      }
      _onDidCommitProvisionalTarget(event) {
        const {
          oldTargetId,
          newTargetId
        } = event;
        (0, _utils2.assert)(this._provisionalPage);
        (0, _utils2.assert)(this._provisionalPage._session.sessionId === newTargetId, "Unknown new target: " + newTargetId);
        (0, _utils2.assert)(this._session.sessionId === oldTargetId, "Unknown old target: " + oldTargetId);
        const newSession = this._provisionalPage._session;
        this._provisionalPage.commit();
        this._provisionalPage.dispose();
        this._provisionalPage = null;
        this._setSession(newSession);
      }
      _onTargetDestroyed(event) {
        const {
          targetId,
          crashed
        } = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) {
          this._provisionalPage._session.dispose(false);
          this._provisionalPage.dispose();
          this._provisionalPage = null;
        } else if (this._session.sessionId === targetId) {
          this._session.dispose(false);
          _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
          if (crashed) {
            this._session.markAsCrashed();
            this._page._didCrash();
          }
        }
      }
      didClose() {
        this._page._didClose();
      }
      dispose(disconnected) {
        this._pageProxySession.dispose(disconnected);
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        if (this._session)
          this._session.dispose(disconnected);
        if (this._provisionalPage) {
          this._provisionalPage._session.dispose(disconnected);
          this._provisionalPage.dispose();
          this._provisionalPage = null;
        }
        this._page._didDisconnect();
        this._firstNonInitialNavigationCommittedReject(new Error("Page closed"));
      }
      dispatchMessageToSession(message) {
        this._pageProxySession.dispatchMessage(message);
      }
      handleProvisionalLoadFailed(event) {
        if (!this._initializedPage) {
          this._firstNonInitialNavigationCommittedReject(new Error("Initial load failed"));
          return;
        }
        if (!this._provisionalPage)
          return;
        let errorText = event.error;
        if (errorText.includes("cancelled"))
          errorText += "; maybe frame was detached?";
        this._page._frameManager.frameAbortedNavigation(this._page.mainFrame()._id, errorText, event.loaderId);
      }
      handleWindowOpen(event) {
        (0, _utils2.debugAssert)(!this._nextWindowOpenPopupFeatures);
        this._nextWindowOpenPopupFeatures = event.windowFeatures;
      }
      pageOrError() {
        return __async(this, null, function* () {
          return this._pagePromise;
        });
      }
      _onTargetCreated(event) {
        return __async(this, null, function* () {
          const {
            targetInfo
          } = event;
          const session = new _wkConnection.WKSession(this._pageProxySession.connection, targetInfo.targetId, `Target closed`, (message) => {
            this._pageProxySession.send("Target.sendMessageToTarget", {
              message: JSON.stringify(message),
              targetId: targetInfo.targetId
            }).catch((e) => {
              session.dispatchMessage({
                id: message.id,
                error: {
                  message: e.message
                }
              });
            });
          });
          (0, _utils2.assert)(targetInfo.type === "page", "Only page targets are expected in WebKit, received: " + targetInfo.type);
          if (!targetInfo.isProvisional) {
            (0, _utils2.assert)(!this._initializedPage);
            let pageOrError;
            try {
              this._setSession(session);
              yield Promise.all([this._initializePageProxySession(), this._initializeSession(session, false, ({
                frameTree
              }) => this._handleFrameTree(frameTree))]);
              pageOrError = this._page;
            } catch (e) {
              pageOrError = e;
            }
            if (targetInfo.isPaused)
              this._pageProxySession.sendMayFail("Target.resume", {
                targetId: targetInfo.targetId
              });
            if (pageOrError instanceof _page.Page && this._page.mainFrame().url() === "") {
              try {
                yield this._firstNonInitialNavigationCommittedPromise;
              } catch (e) {
                pageOrError = e;
              }
            } else {
              this._firstNonInitialNavigationCommittedPromise.catch(() => {
              });
            }
            yield this._page.initOpener(this._opener);
            this._initializedPage = pageOrError instanceof _page.Page ? pageOrError : null;
            this._page.reportAsNew(pageOrError instanceof _page.Page ? void 0 : pageOrError);
            this._pagePromise.resolve(pageOrError);
          } else {
            (0, _utils2.assert)(targetInfo.isProvisional);
            (0, _utils2.assert)(!this._provisionalPage);
            this._provisionalPage = new _wkProvisionalPage.WKProvisionalPage(session, this);
            if (targetInfo.isPaused) {
              this._provisionalPage.initializationPromise.then(() => {
                this._pageProxySession.sendMayFail("Target.resume", {
                  targetId: targetInfo.targetId
                });
              });
            }
          }
        });
      }
      _onDispatchMessageFromTarget(event) {
        const {
          targetId,
          message
        } = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId)
          this._provisionalPage._session.dispatchMessage(JSON.parse(message));
        else if (this._session.sessionId === targetId)
          this._session.dispatchMessage(JSON.parse(message));
        else
          throw new Error("Unknown target: " + targetId);
      }
      _addSessionListeners() {
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameScheduledNavigation", (event) => this._onFrameScheduledNavigation(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameStoppedLoading", (event) => this._onFrameStoppedLoading(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.loadEventFired", (event) => this._onLifecycleEvent(event.frameId, "load")), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.domContentEventFired", (event) => this._onLifecycleEvent(event.frameId, "domcontentloaded")), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._session, "Console.messageAdded", (event) => this._onConsoleMessage(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Console.messageRepeatCountUpdated", (event) => this._onConsoleRepeatCountUpdated(event)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Dialog.javascriptDialogOpening", (event) => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.requestWillBeSent", (e) => this._onRequestWillBeSent(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.requestIntercepted", (e) => this._onRequestIntercepted(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.responseReceived", (e) => this._onResponseReceived(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.loadingFinished", (e) => this._onLoadingFinished(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.loadingFailed", (e) => this._onLoadingFailed(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))];
      }
      _updateState(method, params) {
        return __async(this, null, function* () {
          yield this._forAllSessions((session) => session.send(method, params).then());
        });
      }
      _forAllSessions(callback) {
        return __async(this, null, function* () {
          const sessions = [this._session];
          if (this._provisionalPage)
            sessions.push(this._provisionalPage._session);
          yield Promise.all(sessions.map((session) => callback(session).catch((e) => {
          })));
        });
      }
      _onFrameScheduledNavigation(frameId) {
        this._page._frameManager.frameRequestedNavigation(frameId);
      }
      _onFrameStoppedLoading(frameId) {
        this._page._frameManager.frameStoppedLoading(frameId);
      }
      _onLifecycleEvent(frameId, event) {
        this._page._frameManager.frameLifecycleEvent(frameId, event);
      }
      _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "domcontentloaded");
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "load");
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      _onFrameAttached(frameId, parentFrameId) {
        return this._page._frameManager.frameAttached(frameId, parentFrameId);
      }
      _onFrameNavigated(framePayload, initial) {
        const frame = this._page._frameManager.frame(framePayload.id);
        (0, _utils2.assert)(frame);
        this._removeContextsForFrame(frame, true);
        if (!framePayload.parentId)
          this._workers.clear();
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || "", framePayload.loaderId, initial);
        if (!initial)
          this._firstNonInitialNavigationCommittedFulfill();
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
      }
      _onFrameDetached(frameId) {
        this._page._frameManager.frameDetached(frameId);
      }
      _removeContextsForFrame(frame, notifyFrame) {
        for (const [contextId, context] of this._contextIdToContext) {
          if (context.frame === frame) {
            this._contextIdToContext.delete(contextId);
            if (notifyFrame)
              frame._contextDestroyed(context);
          }
        }
      }
      _onExecutionContextCreated(contextPayload) {
        if (this._contextIdToContext.has(contextPayload.id))
          return;
        const frame = this._page._frameManager.frame(contextPayload.frameId);
        if (!frame)
          return;
        const delegate = new _wkExecutionContext.WKExecutionContext(this._session, contextPayload.id);
        let worldName = null;
        if (contextPayload.type === "normal")
          worldName = "main";
        else if (contextPayload.type === "user" && contextPayload.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        if (contextPayload.type === "normal" && frame === this._page.mainFrame())
          this._mainFrameContextId = contextPayload.id;
        this._contextIdToContext.set(contextPayload.id, context);
      }
      navigateFrame(frame, url, referrer) {
        return __async(this, null, function* () {
          if (this._pageProxySession.isDisposed())
            throw new Error("Target closed");
          const pageProxyId = this._pageProxySession.sessionId;
          const result = yield this._pageProxySession.connection.browserSession.send("Playwright.navigate", {
            url,
            pageProxyId,
            frameId: frame._id,
            referrer
          });
          return {
            newDocumentId: result.loaderId
          };
        });
      }
      _onConsoleMessage(event) {
        const {
          type,
          level,
          text,
          parameters,
          url,
          line: lineNumber,
          column: columnNumber,
          source
        } = event.message;
        if (level === "debug" && parameters && parameters[0].value === BINDING_CALL_MESSAGE) {
          const parsedObjectId = JSON.parse(parameters[1].objectId);
          this.pageOrError().then((pageOrError) => {
            const context = this._contextIdToContext.get(parsedObjectId.injectedScriptId);
            if (!(pageOrError instanceof Error) && context)
              this._page._onBindingCalled(parameters[2].value, context);
          });
          return;
        }
        if (level === "error" && source === "javascript") {
          const {
            name,
            message
          } = (0, _stackTrace.splitErrorMessage)(text);
          let stack;
          if (event.message.stackTrace) {
            stack = text + "\n" + event.message.stackTrace.map((callFrame) => {
              return `    at ${callFrame.functionName || "unknown"} (${callFrame.url}:${callFrame.lineNumber}:${callFrame.columnNumber})`;
            }).join("\n");
          } else {
            stack = "";
          }
          const error = new Error(message);
          error.stack = stack;
          error.name = name;
          this._page.firePageError(error);
          return;
        }
        let derivedType = type || "";
        if (type === "log")
          derivedType = level;
        else if (type === "timing")
          derivedType = "timeEnd";
        const handles = [];
        for (const p of parameters || []) {
          let context;
          if (p.objectId) {
            const objectId = JSON.parse(p.objectId);
            context = this._contextIdToContext.get(objectId.injectedScriptId);
          } else {
            context = this._contextIdToContext.get(this._mainFrameContextId);
          }
          if (!context)
            return;
          handles.push(context.createHandle(p));
        }
        this._lastConsoleMessage = {
          derivedType,
          text,
          handles,
          count: 0,
          location: {
            url: url || "",
            lineNumber: (lineNumber || 1) - 1,
            columnNumber: (columnNumber || 1) - 1
          }
        };
        this._onConsoleRepeatCountUpdated({
          count: 1
        });
      }
      _onConsoleRepeatCountUpdated(event) {
        if (this._lastConsoleMessage) {
          const {
            derivedType,
            text,
            handles,
            count,
            location: location2
          } = this._lastConsoleMessage;
          for (let i = count; i < event.count; ++i)
            this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
          this._lastConsoleMessage.count = event.count;
        }
      }
      _onDialog(event) {
        this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, (accept, promptText) => __async(this, null, function* () {
          yield this._pageProxySession.send("Dialog.handleJavaScriptDialog", {
            accept,
            promptText
          });
        }), event.defaultPrompt));
      }
      _onFileChooserOpened(event) {
        return __async(this, null, function* () {
          let handle;
          try {
            const context = yield this._page._frameManager.frame(event.frameId)._mainContext();
            handle = context.createHandle(event.element).asElement();
          } catch (e) {
            return;
          }
          yield this._page._onFileChooserOpened(handle);
        });
      }
      static _setEmulateMedia(session, mediaType, colorScheme, reducedMotion) {
        return __async(this, null, function* () {
          const promises = [];
          promises.push(session.send("Page.setEmulatedMedia", {
            media: mediaType || ""
          }));
          let appearance = void 0;
          switch (colorScheme) {
            case "light":
              appearance = "Light";
              break;
            case "dark":
              appearance = "Dark";
              break;
          }
          promises.push(session.send("Page.setForcedAppearance", {
            appearance
          }));
          let reducedMotionWk = void 0;
          switch (reducedMotion) {
            case "reduce":
              reducedMotionWk = "Reduce";
              break;
            case "no-preference":
              reducedMotionWk = "NoPreference";
              break;
          }
          promises.push(session.send("Page.setForcedReducedMotion", {
            reducedMotion: reducedMotionWk
          }));
          yield Promise.all(promises);
        });
      }
      updateExtraHTTPHeaders() {
        return __async(this, null, function* () {
          yield this._updateState("Network.setExtraHTTPHeaders", {
            headers: (0, _utils2.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false)
          });
        });
      }
      _calculateExtraHTTPHeaders() {
        const locale = this._browserContext._options.locale;
        const headers = network.mergeHeaders([this._browserContext._options.extraHTTPHeaders, this._page._state.extraHTTPHeaders, locale ? network.singleHeader("Accept-Language", locale) : void 0]);
        return headers;
      }
      updateEmulateMedia() {
        return __async(this, null, function* () {
          const colorScheme = this._page._state.colorScheme;
          const reducedMotion = this._page._state.reducedMotion;
          yield this._forAllSessions((session) => WKPage._setEmulateMedia(session, this._page._state.mediaType, colorScheme, reducedMotion));
        });
      }
      setEmulatedSize(emulatedSize) {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this._page._state.emulatedSize === emulatedSize);
          yield this._updateViewport();
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          this._pageProxySession.send("Target.activate", {
            targetId: this._session.sessionId
          });
        });
      }
      _updateViewport() {
        return __async(this, null, function* () {
          const options = this._browserContext._options;
          const deviceSize = this._page._state.emulatedSize;
          if (deviceSize === null)
            return;
          const viewportSize = deviceSize.viewport;
          const screenSize = deviceSize.screen;
          const promises = [this._pageProxySession.send("Emulation.setDeviceMetricsOverride", {
            width: viewportSize.width,
            height: viewportSize.height,
            fixedLayout: !!options.isMobile,
            deviceScaleFactor: options.deviceScaleFactor || 1
          }), this._session.send("Page.setScreenSizeOverride", {
            width: screenSize.width,
            height: screenSize.height
          })];
          if (options.isMobile) {
            const angle = viewportSize.width > viewportSize.height ? 90 : 0;
            promises.push(this._session.send("Page.setOrientationOverride", {
              angle
            }));
          }
          yield Promise.all(promises);
        });
      }
      updateRequestInterception() {
        return __async(this, null, function* () {
          const enabled = this._page._needsRequestInterception();
          yield Promise.all([this._updateState("Network.setInterceptionEnabled", {
            enabled
          }), this._updateState("Network.addInterception", {
            url: ".*",
            stage: "request",
            isRegex: true
          })]);
        });
      }
      updateOffline() {
        return __async(this, null, function* () {
          yield this._updateState("Network.setEmulateOfflineState", {
            offline: !!this._browserContext._options.offline
          });
        });
      }
      updateHttpCredentials() {
        return __async(this, null, function* () {
          const credentials = this._browserContext._options.httpCredentials || {
            username: "",
            password: ""
          };
          yield this._pageProxySession.send("Emulation.setAuthCredentials", {
            username: credentials.username,
            password: credentials.password
          });
        });
      }
      setFileChooserIntercepted(enabled) {
        return __async(this, null, function* () {
          yield this._session.send("Page.setInterceptFileChooserDialog", {
            enabled
          }).catch((e) => {
          });
        });
      }
      reload() {
        return __async(this, null, function* () {
          yield this._session.send("Page.reload");
        });
      }
      goBack() {
        return this._session.send("Page.goBack").then(() => true).catch((error) => {
          if (error instanceof Error && error.message.includes(`Protocol error (Page.goBack): Failed to go`))
            return false;
          throw error;
        });
      }
      goForward() {
        return this._session.send("Page.goForward").then(() => true).catch((error) => {
          if (error instanceof Error && error.message.includes(`Protocol error (Page.goForward): Failed to go`))
            return false;
          throw error;
        });
      }
      exposeBinding(binding) {
        return __async(this, null, function* () {
          yield this._updateBootstrapScript();
          yield this._evaluateBindingScript(binding);
        });
      }
      _evaluateBindingScript(binding) {
        return __async(this, null, function* () {
          const script = this._bindingToScript(binding);
          yield Promise.all(this._page.frames().map((frame) => frame.evaluateExpression(script, false, {}).catch((e) => {
          })));
        });
      }
      evaluateOnNewDocument(script) {
        return __async(this, null, function* () {
          yield this._updateBootstrapScript();
        });
      }
      _bindingToScript(binding) {
        return `self.${binding.name} = (param) => console.debug('${BINDING_CALL_MESSAGE}', {}, param); ${binding.source}`;
      }
      _calculateBootstrapScript() {
        const scripts = [];
        if (!this._page.context()._options.isMobile) {
          scripts.push("delete window.orientation");
          scripts.push("delete window.ondevicemotion");
          scripts.push("delete window.ondeviceorientation");
        }
        for (const binding of this._page.allBindings())
          scripts.push(this._bindingToScript(binding));
        scripts.push(...this._browserContext._evaluateOnNewDocumentSources);
        scripts.push(...this._page._evaluateOnNewDocumentSources);
        return scripts.join(";");
      }
      _updateBootstrapScript() {
        return __async(this, null, function* () {
          yield this._updateState("Page.setBootstrapScript", {
            source: this._calculateBootstrapScript()
          });
        });
      }
      closePage(runBeforeUnload) {
        return __async(this, null, function* () {
          yield this._stopVideo();
          yield this._pageProxySession.sendMayFail("Target.close", {
            targetId: this._session.sessionId,
            runBeforeUnload
          });
        });
      }
      setBackgroundColor(color) {
        return __async(this, null, function* () {
          yield this._session.send("Page.setDefaultBackgroundColorOverride", {
            color
          });
        });
      }
      _toolbarHeight() {
        var _this$_page$_browserC;
        if ((_this$_page$_browserC = this._page._browserContext._browser) !== null && _this$_page$_browserC !== void 0 && _this$_page$_browserC.options.headful)
          return _utils2.hostPlatform === "mac10.15" ? 55 : 59;
        return 0;
      }
      _startVideo(options) {
        return __async(this, null, function* () {
          (0, _utils2.assert)(!this._recordingVideoFile);
          const {
            screencastId
          } = yield this._pageProxySession.send("Screencast.startVideo", {
            file: options.outputFile,
            width: options.width,
            height: options.height,
            toolbarHeight: this._toolbarHeight()
          });
          this._recordingVideoFile = options.outputFile;
          this._browserContext._browser._videoStarted(this._browserContext, screencastId, options.outputFile, this.pageOrError());
        });
      }
      _stopVideo() {
        return __async(this, null, function* () {
          if (!this._recordingVideoFile)
            return;
          yield this._pageProxySession.sendMayFail("Screencast.stopVideo");
          this._recordingVideoFile = null;
        });
      }
      takeScreenshot(progress, format, documentRect, viewportRect, quality) {
        return __async(this, null, function* () {
          const rect = documentRect || viewportRect;
          const result = yield this._session.send("Page.snapshotRect", __spreadProps(__spreadValues({}, rect), {
            coordinateSystem: documentRect ? "Page" : "Viewport"
          }));
          const prefix = "data:image/png;base64,";
          let buffer = Buffer.from(result.dataURL.substr(prefix.length), "base64");
          if (format === "jpeg")
            buffer = jpeg.encode(png.PNG.sync.read(buffer), quality).data;
          return buffer;
        });
      }
      getContentFrame(handle) {
        return __async(this, null, function* () {
          const nodeInfo = yield this._session.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          if (!nodeInfo.contentFrameId)
            return null;
          return this._page._frameManager.frame(nodeInfo.contentFrameId);
        });
      }
      getOwnerFrame(handle) {
        return __async(this, null, function* () {
          if (!handle._objectId)
            return null;
          const nodeInfo = yield this._session.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          return nodeInfo.ownerFrameId || null;
        });
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      getBoundingBox(handle) {
        return __async(this, null, function* () {
          const quads = yield this.getContentQuads(handle);
          if (!quads || !quads.length)
            return null;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (const quad of quads) {
            for (const point of quad) {
              minX = Math.min(minX, point.x);
              maxX = Math.max(maxX, point.x);
              minY = Math.min(minY, point.y);
              maxY = Math.max(maxY, point.y);
            }
          }
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        });
      }
      scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return yield this._session.send("DOM.scrollIntoViewIfNeeded", {
            objectId: handle._objectId,
            rect
          }).then(() => "done").catch((e) => {
            if (e instanceof Error && e.message.includes("Node does not have a layout object"))
              return "error:notvisible";
            if (e instanceof Error && e.message.includes("Node is detached from document"))
              return "error:notconnected";
            throw e;
          });
        });
      }
      setScreencastOptions(options) {
        return __async(this, null, function* () {
          if (options) {
            const so = __spreadProps(__spreadValues({}, options), {
              toolbarHeight: this._toolbarHeight()
            });
            const {
              generation
            } = yield this._pageProxySession.send("Screencast.startScreencast", so);
            this._screencastGeneration = generation;
          } else {
            yield this._pageProxySession.send("Screencast.stopScreencast");
          }
        });
      }
      _onScreencastFrame(event) {
        const generation = this._screencastGeneration;
        this._page.throttleScreencastFrameAck(() => {
          this._pageProxySession.send("Screencast.screencastFrameAck", {
            generation
          }).catch((e) => _debugLogger.debugLogger.log("error", e));
        });
        const buffer = Buffer.from(event.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          width: event.deviceWidth,
          height: event.deviceHeight
        });
      }
      rafCountForStablePosition() {
        return process.platform === "win32" ? 5 : 1;
      }
      getContentQuads(handle) {
        return __async(this, null, function* () {
          const result = yield this._session.sendMayFail("DOM.getContentQuads", {
            objectId: handle._objectId
          });
          if (!result)
            return null;
          return result.quads.map((quad) => [{
            x: quad[0],
            y: quad[1]
          }, {
            x: quad[2],
            y: quad[3]
          }, {
            x: quad[4],
            y: quad[5]
          }, {
            x: quad[6],
            y: quad[7]
          }]);
        });
      }
      setInputFiles(handle, files) {
        return __async(this, null, function* () {
          const objectId = handle._objectId;
          const protocolFiles = files.map((file) => ({
            name: file.name,
            type: file.mimeType,
            data: file.buffer
          }));
          yield this._session.send("DOM.setInputFiles", {
            objectId,
            files: protocolFiles
          });
        });
      }
      adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          const result = yield this._session.sendMayFail("DOM.resolveNode", {
            objectId: handle._objectId,
            executionContextId: to[contextDelegateSymbol]._contextId
          });
          if (!result || result.object.subtype === "null")
            throw new Error(dom.kUnableToAdoptErrorMessage);
          return to.createHandle(result.object);
        });
      }
      getAccessibilityTree(needle) {
        return __async(this, null, function* () {
          return (0, _wkAccessibility.getAccessibilityTree)(this._session, needle);
        });
      }
      inputActionEpilogue() {
        return __async(this, null, function* () {
        });
      }
      getFrameElement(frame) {
        return __async(this, null, function* () {
          const parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          const info = this._page.parseSelector("frame,iframe");
          const handles = yield this._page.selectors._queryAll(parent, info);
          const items = yield Promise.all(handles.map((handle) => __async(this, null, function* () {
            const frame2 = yield handle.contentFrame().catch((e) => null);
            return {
              handle,
              frame: frame2
            };
          })));
          const result = items.find((item) => item.frame === frame);
          items.map((item) => item === result ? Promise.resolve() : item.handle.dispose());
          if (!result)
            throw new Error("Frame has been detached.");
          return result.handle;
        });
      }
      _onRequestWillBeSent(session, event) {
        if (event.request.url.startsWith("data:"))
          return;
        let redirectedFrom = null;
        if (event.redirectResponse) {
          const request2 = this._requestIdToRequest.get(event.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, event.redirectResponse, event.timestamp);
            redirectedFrom = request2;
          }
        }
        const frame = redirectedFrom ? redirectedFrom.request.frame() : this._page._frameManager.frame(event.frameId);
        if (!frame)
          return;
        const isNavigationRequest = event.type === "Document";
        const documentId = isNavigationRequest ? event.loaderId : void 0;
        let route = null;
        if (this._page._needsRequestInterception() && !redirectedFrom)
          route = new _wkInterceptableRequest.WKRouteImpl(session, event.requestId);
        const request = new _wkInterceptableRequest.WKInterceptableRequest(session, route, frame, event, redirectedFrom, documentId);
        this._requestIdToRequest.set(event.requestId, request);
        this._page._frameManager.requestStarted(request.request, route || void 0);
      }
      _handleRequestRedirect(request, responsePayload, timestamp) {
        const response = request.createResponse(responsePayload);
        response._securityDetailsFinished();
        response._serverAddrFinished();
        response._requestFinished(responsePayload.timing ? _helper.helper.secondsToRoundishMillis(timestamp - request._timestamp) : -1);
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onRequestIntercepted(session, event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request) {
          session.sendMayFail("Network.interceptRequestWithError", {
            errorType: "Cancellation",
            requestId: event.requestId
          });
          return;
        }
        if (!request._route) {
          session.sendMayFail("Network.interceptWithRequest", {
            requestId: request._requestId
          });
        } else {
          request._route._requestInterceptedPromise.resolve();
        }
      }
      _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        this._requestIdToResponseReceivedPayloadEvent.set(request._requestId, event);
        const response = request.createResponse(event.response);
        if (event.response.requestHeaders && Object.keys(event.response.requestHeaders).length) {
          const headers = __spreadValues({}, event.response.requestHeaders);
          if (!headers["host"])
            headers["Host"] = new URL(request.request.url()).host;
          request.request.setRawRequestHeaders((0, _utils2.headersObjectToArray)(headers));
        }
        this._page._frameManager.requestReceivedResponse(response);
        if (response.status() === 204) {
          this._onLoadingFailed({
            requestId: event.requestId,
            errorText: "Aborted: 204 No Content",
            timestamp: event.timestamp
          });
        }
      }
      _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          var _event$metrics, _event$metrics2, _event$metrics2$secur, _responseReceivedPayl, _responseReceivedPayl2, _responseReceivedPayl3, _responseReceivedPayl4, _responseReceivedPayl5, _responseReceivedPayl6, _event$metrics3, _event$metrics4, _event$metrics5;
          const responseReceivedPayload = this._requestIdToResponseReceivedPayloadEvent.get(request._requestId);
          response._serverAddrFinished(parseRemoteAddress(event === null || event === void 0 ? void 0 : (_event$metrics = event.metrics) === null || _event$metrics === void 0 ? void 0 : _event$metrics.remoteAddress));
          response._securityDetailsFinished({
            protocol: isLoadedSecurely(response.url(), response.timing()) ? (_event$metrics2 = event.metrics) === null || _event$metrics2 === void 0 ? void 0 : (_event$metrics2$secur = _event$metrics2.securityConnection) === null || _event$metrics2$secur === void 0 ? void 0 : _event$metrics2$secur.protocol : void 0,
            subjectName: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl = responseReceivedPayload.response.security) === null || _responseReceivedPayl === void 0 ? void 0 : (_responseReceivedPayl2 = _responseReceivedPayl.certificate) === null || _responseReceivedPayl2 === void 0 ? void 0 : _responseReceivedPayl2.subject,
            validFrom: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl3 = responseReceivedPayload.response.security) === null || _responseReceivedPayl3 === void 0 ? void 0 : (_responseReceivedPayl4 = _responseReceivedPayl3.certificate) === null || _responseReceivedPayl4 === void 0 ? void 0 : _responseReceivedPayl4.validFrom,
            validTo: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl5 = responseReceivedPayload.response.security) === null || _responseReceivedPayl5 === void 0 ? void 0 : (_responseReceivedPayl6 = _responseReceivedPayl5.certificate) === null || _responseReceivedPayl6 === void 0 ? void 0 : _responseReceivedPayl6.validUntil
          });
          if ((_event$metrics3 = event.metrics) !== null && _event$metrics3 !== void 0 && _event$metrics3.protocol)
            response._setHttpVersion(event.metrics.protocol);
          if ((_event$metrics4 = event.metrics) !== null && _event$metrics4 !== void 0 && _event$metrics4.responseBodyBytesReceived)
            request.request.responseSize.encodedBodySize = event.metrics.responseBodyBytesReceived;
          if ((_event$metrics5 = event.metrics) !== null && _event$metrics5 !== void 0 && _event$metrics5.responseHeaderBytesReceived)
            request.request.responseSize.responseHeadersSize = event.metrics.responseHeaderBytesReceived;
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        }
        this._requestIdToResponseReceivedPayloadEvent.delete(request._requestId);
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          response._serverAddrFinished();
          response._securityDetailsFinished();
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        }
        this._requestIdToRequest.delete(request._requestId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, event.errorText.includes("cancelled"));
      }
      _grantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          const webPermissionToProtocol = /* @__PURE__ */ new Map([["geolocation", "geolocation"]]);
          const filtered = permissions.map((permission) => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
              throw new Error("Unknown permission: " + permission);
            return protocolPermission;
          });
          yield this._pageProxySession.send("Emulation.grantPermissions", {
            origin,
            permissions: filtered
          });
        });
      }
      _clearPermissions() {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Emulation.resetPermissions", {});
        });
      }
    };
    exports2.WKPage = WKPage;
    function parseRemoteAddress(value) {
      if (!value)
        return;
      try {
        const colon = value.lastIndexOf(":");
        const dot = value.lastIndexOf(".");
        if (dot < 0) {
          return {
            ipAddress: `[${value.slice(0, colon)}]`,
            port: +value.slice(colon + 1)
          };
        }
        if (colon > dot) {
          const [address, port] = value.split(":");
          return {
            ipAddress: address,
            port: +port
          };
        } else {
          const [address, port] = value.split(".");
          return {
            ipAddress: `[${address}]`,
            port: +port
          };
        }
      } catch (_) {
      }
    }
    function isLoadedSecurely(url, timing) {
      try {
        const u = new URL(url);
        if (u.protocol !== "https:" && u.protocol !== "wss:" && u.protocol !== "sftp:")
          return false;
        if (timing.secureConnectionStart === -1 && timing.connectStart !== -1)
          return false;
        return true;
      } catch (_) {
      }
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/webkit/wkBrowser.js
var require_wkBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkBrowser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKBrowserContext = exports2.WKBrowser = void 0;
    var _browser = require_browser2();
    var _browserContext = require_browserContext();
    var _eventsHelper = require_eventsHelper();
    var _utils2 = require_utils();
    var network = _interopRequireWildcard2(require_network());
    var _wkConnection = require_wkConnection();
    var _wkPage = require_wkPage();
    var _errors = require_errors();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var DEFAULT_USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Safari/605.1.15";
    var BROWSER_VERSION = "15.4";
    var WKBrowser = class extends _browser.Browser {
      static connect(transport, options) {
        return __async(this, null, function* () {
          const browser = new WKBrowser(transport, options);
          if (options.__testHookOnConnectToBrowser)
            yield options.__testHookOnConnectToBrowser();
          const promises = [browser._browserSession.send("Playwright.enable")];
          if (options.persistent) {
            browser._defaultContext = new WKBrowserContext(browser, void 0, options.persistent);
            promises.push(browser._defaultContext._initialize());
          }
          yield Promise.all(promises);
          return browser;
        });
      }
      constructor(transport, options) {
        super(options);
        this._connection = void 0;
        this._browserSession = void 0;
        this._contexts = /* @__PURE__ */ new Map();
        this._wkPages = /* @__PURE__ */ new Map();
        this._eventListeners = void 0;
        this._connection = new _wkConnection.WKConnection(transport, this._onDisconnect.bind(this), options.protocolLogger, options.browserLogsCollector);
        this._browserSession = this._connection.browserSession;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.pageProxyCreated", this._onPageProxyCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.pageProxyDestroyed", this._onPageProxyDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.provisionalLoadFailed", (event) => this._onProvisionalLoadFailed(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.windowOpen", (event) => this._onWindowOpen(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadCreated", this._onDownloadCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadFilenameSuggested", this._onDownloadFilenameSuggested.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadFinished", this._onDownloadFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.screencastFinished", this._onScreencastFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, _wkConnection.kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this))];
      }
      _onDisconnect() {
        for (const wkPage of this._wkPages.values())
          wkPage.dispose(true);
        for (const video of this._idToVideo.values())
          video.artifact.reportFinished(_errors.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
      }
      newContext(options) {
        return __async(this, null, function* () {
          (0, _browserContext.validateBrowserContextOptions)(options, this.options);
          const createOptions = options.proxy ? {
            proxyServer: options.proxy.server,
            proxyBypassList: options.proxy.bypass
          } : void 0;
          const {
            browserContextId
          } = yield this._browserSession.send("Playwright.createContext", createOptions);
          options.userAgent = options.userAgent || DEFAULT_USER_AGENT;
          const context = new WKBrowserContext(this, browserContextId, options);
          yield context._initialize();
          this._contexts.set(browserContextId, context);
          return context;
        });
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return BROWSER_VERSION;
      }
      userAgent() {
        return DEFAULT_USER_AGENT;
      }
      _onDownloadCreated(payload) {
        const page = this._wkPages.get(payload.pageProxyId);
        if (!page)
          return;
        page._page._frameManager.frameAbortedNavigation(payload.frameId, "Download is starting");
        let originPage = page._initializedPage;
        if (!originPage) {
          page._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
          if (page._opener)
            originPage = page._opener._initializedPage;
        }
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.uuid, payload.url);
      }
      _onDownloadFilenameSuggested(payload) {
        this._downloadFilenameSuggested(payload.uuid, payload.suggestedFilename);
      }
      _onDownloadFinished(payload) {
        this._downloadFinished(payload.uuid, payload.error);
      }
      _onScreencastFinished(payload) {
        var _this$_takeVideo;
        (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();
      }
      _onPageProxyCreated(event) {
        const pageProxyId = event.pageProxyId;
        let context = null;
        if (event.browserContextId) {
          context = this._contexts.get(event.browserContextId) || null;
        }
        if (!context)
          context = this._defaultContext;
        if (!context)
          return;
        const pageProxySession = new _wkConnection.WKSession(this._connection, pageProxyId, `Target closed`, (message) => {
          this._connection.rawSend(__spreadProps(__spreadValues({}, message), {
            pageProxyId
          }));
        });
        const opener = event.openerId ? this._wkPages.get(event.openerId) : void 0;
        const wkPage = new _wkPage.WKPage(context, pageProxySession, opener || null);
        this._wkPages.set(pageProxyId, wkPage);
      }
      _onPageProxyDestroyed(event) {
        const pageProxyId = event.pageProxyId;
        const wkPage = this._wkPages.get(pageProxyId);
        if (!wkPage)
          return;
        wkPage.didClose();
        wkPage.dispose(false);
        this._wkPages.delete(pageProxyId);
      }
      _onPageProxyMessageReceived(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.dispatchMessageToSession(event.message);
      }
      _onProvisionalLoadFailed(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.handleProvisionalLoadFailed(event);
      }
      _onWindowOpen(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.handleWindowOpen(event);
      }
      isConnected() {
        return !this._connection.isClosed();
      }
    };
    exports2.WKBrowser = WKBrowser;
    var WKBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
        this._evaluateOnNewDocumentSources = void 0;
        this._evaluateOnNewDocumentSources = [];
        this._authenticateProxyViaHeader();
      }
      _initialize() {
        var __superGet = (key) => super[key];
        return __async(this, null, function* () {
          (0, _utils2.assert)(!this._wkPages().length);
          const browserContextId = this._browserContextId;
          const promises = [__superGet("_initialize").call(this)];
          promises.push(this._browser._browserSession.send("Playwright.setDownloadBehavior", {
            behavior: this._options.acceptDownloads ? "allow" : "deny",
            downloadPath: this._browser.options.downloadsPath,
            browserContextId
          }));
          if (this._options.ignoreHTTPSErrors)
            promises.push(this._browser._browserSession.send("Playwright.setIgnoreCertificateErrors", {
              browserContextId,
              ignore: true
            }));
          if (this._options.locale)
            promises.push(this._browser._browserSession.send("Playwright.setLanguages", {
              browserContextId,
              languages: [this._options.locale]
            }));
          if (this._options.permissions)
            promises.push(this.grantPermissions(this._options.permissions));
          if (this._options.geolocation)
            promises.push(this.setGeolocation(this._options.geolocation));
          if (this._options.offline)
            promises.push(this.setOffline(this._options.offline));
          if (this._options.httpCredentials)
            promises.push(this.setHTTPCredentials(this._options.httpCredentials));
          yield Promise.all(promises);
        });
      }
      _wkPages() {
        return Array.from(this._browser._wkPages.values()).filter((wkPage) => wkPage._browserContext === this);
      }
      pages() {
        return this._wkPages().map((wkPage) => wkPage._initializedPage).filter((pageOrNull) => !!pageOrNull);
      }
      newPageDelegate() {
        return __async(this, null, function* () {
          (0, _browserContext.assertBrowserContextIsNotOwned)(this);
          const {
            pageProxyId
          } = yield this._browser._browserSession.send("Playwright.createPage", {
            browserContextId: this._browserContextId
          });
          return this._browser._wkPages.get(pageProxyId);
        });
      }
      _doCookies(urls) {
        return __async(this, null, function* () {
          const {
            cookies
          } = yield this._browser._browserSession.send("Playwright.getAllCookies", {
            browserContextId: this._browserContextId
          });
          return network.filterCookies(cookies.map((c) => {
            const copy = __spreadValues({}, c);
            copy.expires = c.expires === -1 ? -1 : c.expires / 1e3;
            delete copy.session;
            return copy;
          }), urls);
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          const cc = network.rewriteCookies(cookies).map((c) => __spreadProps(__spreadValues({}, c), {
            session: c.expires === -1 || c.expires === void 0,
            expires: c.expires && c.expires !== -1 ? c.expires * 1e3 : c.expires
          }));
          yield this._browser._browserSession.send("Playwright.setCookies", {
            cookies: cc,
            browserContextId: this._browserContextId
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._browser._browserSession.send("Playwright.deleteAllCookies", {
            browserContextId: this._browserContextId
          });
        });
      }
      _doGrantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          yield Promise.all(this.pages().map((page) => page._delegate._grantPermissions(origin, permissions)));
        });
      }
      _doClearPermissions() {
        return __async(this, null, function* () {
          yield Promise.all(this.pages().map((page) => page._delegate._clearPermissions()));
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          (0, _browserContext.verifyGeolocation)(geolocation);
          this._options.geolocation = geolocation;
          const payload = geolocation ? __spreadProps(__spreadValues({}, geolocation), {
            timestamp: Date.now()
          }) : void 0;
          yield this._browser._browserSession.send("Playwright.setGeolocationOverride", {
            browserContextId: this._browserContextId,
            geolocation: payload
          });
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          this._options.extraHTTPHeaders = headers;
          for (const page of this.pages())
            yield page._delegate.updateExtraHTTPHeaders();
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          this._options.offline = offline;
          for (const page of this.pages())
            yield page._delegate.updateOffline();
        });
      }
      _doSetHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          this._options.httpCredentials = httpCredentials;
          for (const page of this.pages())
            yield page._delegate.updateHttpCredentials();
        });
      }
      _doAddInitScript(source) {
        return __async(this, null, function* () {
          this._evaluateOnNewDocumentSources.push(source);
          for (const page of this.pages())
            yield page._delegate._updateBootstrapScript();
        });
      }
      _doExposeBinding(binding) {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.exposeBinding(binding);
        });
      }
      _doUpdateRequestInterception() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.updateRequestInterception();
        });
      }
      _onClosePersistent() {
      }
      _doClose() {
        return __async(this, null, function* () {
          (0, _utils2.assert)(this._browserContextId);
          yield this._browser._browserSession.send("Playwright.deleteContext", {
            browserContextId: this._browserContextId
          });
          this._browser._contexts.delete(this._browserContextId);
        });
      }
      _doCancelDownload(uuid) {
        return __async(this, null, function* () {
          yield this._browser._browserSession.send("Playwright.cancelDownload", {
            uuid
          });
        });
      }
    };
    exports2.WKBrowserContext = WKBrowserContext;
  }
});

// node_modules/playwright-core/lib/server/webkit/webkit.js
var require_webkit = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/webkit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebKit = void 0;
    var _wkBrowser = require_wkBrowser();
    var _path2 = _interopRequireDefault2(require("path"));
    var _wkConnection = require_wkConnection();
    var _browserType = require_browserType();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var WebKit = class extends _browserType.BrowserType {
      constructor(playwrightOptions) {
        super("webkit", playwrightOptions);
      }
      _connectToTransport(transport, options) {
        return _wkBrowser.WKBrowser.connect(transport, options);
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        return __spreadProps(__spreadValues({}, env), {
          CURL_COOKIE_JAR_PATH: _path2.default.join(userDataDir, "cookiejar.db")
        });
      }
      _rewriteStartupError(error) {
        return error;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        transport.send({
          method: "Playwright.close",
          params: {},
          id: _wkConnection.kBrowserCloseMessageId
        });
      }
      _defaultArgs(options, isPersistent, userDataDir) {
        const {
          args = [],
          proxy,
          devtools,
          headless
        } = options;
        if (devtools)
          console.warn("devtools parameter as a launch argument in WebKit is not supported. Also starting Web Inspector manually will terminate the execution in WebKit.");
        const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument");
        if (args.find((arg) => !arg.startsWith("-")))
          throw new Error("Arguments can not specify page to be opened");
        const webkitArguments = ["--inspector-pipe"];
        if (process.platform === "win32")
          webkitArguments.push("--disable-accelerated-compositing");
        if (headless)
          webkitArguments.push("--headless");
        if (isPersistent)
          webkitArguments.push(`--user-data-dir=${userDataDir}`);
        else
          webkitArguments.push(`--no-startup-window`);
        if (proxy) {
          if (process.platform === "darwin") {
            webkitArguments.push(`--proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(`--proxy-bypass-list=${proxy.bypass}`);
          } else if (process.platform === "linux") {
            webkitArguments.push(`--proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(...proxy.bypass.split(",").map((t) => `--ignore-host=${t}`));
          } else if (process.platform === "win32") {
            webkitArguments.push(`--curl-proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(`--curl-noproxy=${proxy.bypass}`);
          }
        }
        webkitArguments.push(...args);
        if (isPersistent)
          webkitArguments.push("about:blank");
        return webkitArguments;
      }
    };
    exports2.WebKit = WebKit;
  }
});

// node_modules/playwright-core/lib/server/playwright.js
var require_playwright = __commonJS({
  "node_modules/playwright-core/lib/server/playwright.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createPlaywright = createPlaywright;
    exports2.Playwright = void 0;
    var _android = require_android();
    var _backendAdb = require_backendAdb();
    var _chromium = require_chromium();
    var _electron = require_electron2();
    var _firefox = require_firefox();
    var _selectors = require_selectors();
    var _webkit = require_webkit();
    var _instrumentation = require_instrumentation();
    var _debugLogger = require_debugLogger();
    var Playwright = class extends _instrumentation.SdkObject {
      constructor(sdkLanguage, isInternal) {
        super({
          attribution: {
            isInternal
          },
          instrumentation: (0, _instrumentation.createInstrumentation)()
        }, void 0, "Playwright");
        this.selectors = void 0;
        this.chromium = void 0;
        this.android = void 0;
        this.electron = void 0;
        this.firefox = void 0;
        this.webkit = void 0;
        this.options = void 0;
        this._allPages = /* @__PURE__ */ new Set();
        this.instrumentation.addListener({
          onPageOpen: (page) => this._allPages.add(page),
          onPageClose: (page) => this._allPages.delete(page),
          onCallLog: (sdkObject, metadata, logName, message) => {
            _debugLogger.debugLogger.log(logName, message);
          }
        }, null);
        this.options = {
          rootSdkObject: this,
          selectors: new _selectors.Selectors(),
          sdkLanguage
        };
        this.chromium = new _chromium.Chromium(this.options);
        this.firefox = new _firefox.Firefox(this.options);
        this.webkit = new _webkit.WebKit(this.options);
        this.electron = new _electron.Electron(this.options);
        this.android = new _android.Android(new _backendAdb.AdbBackend(), this.options);
        this.selectors = this.options.selectors;
      }
      hideHighlight() {
        return __async(this, null, function* () {
          yield Promise.all([...this._allPages].map((p) => p.hideHighlight().catch(() => {
          })));
        });
      }
    };
    exports2.Playwright = Playwright;
    function createPlaywright(sdkLanguage, isInternal = false) {
      return new Playwright(sdkLanguage, isInternal);
    }
  }
});

// node_modules/playwright-core/lib/utils/socksProxy.js
var require_socksProxy = __commonJS({
  "node_modules/playwright-core/lib/utils/socksProxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SocksConnection = void 0;
    var _net = _interopRequireDefault2(require("net"));
    var _utils2 = require_utils();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SocksAuth;
    (function(SocksAuth2) {
      SocksAuth2[SocksAuth2["NO_AUTHENTICATION_REQUIRED"] = 0] = "NO_AUTHENTICATION_REQUIRED";
      SocksAuth2[SocksAuth2["GSSAPI"] = 1] = "GSSAPI";
      SocksAuth2[SocksAuth2["USERNAME_PASSWORD"] = 2] = "USERNAME_PASSWORD";
      SocksAuth2[SocksAuth2["NO_ACCEPTABLE_METHODS"] = 255] = "NO_ACCEPTABLE_METHODS";
    })(SocksAuth || (SocksAuth = {}));
    var SocksAddressType;
    (function(SocksAddressType2) {
      SocksAddressType2[SocksAddressType2["IPv4"] = 1] = "IPv4";
      SocksAddressType2[SocksAddressType2["FqName"] = 3] = "FqName";
      SocksAddressType2[SocksAddressType2["IPv6"] = 4] = "IPv6";
    })(SocksAddressType || (SocksAddressType = {}));
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["CONNECT"] = 1] = "CONNECT";
      SocksCommand2[SocksCommand2["BIND"] = 2] = "BIND";
      SocksCommand2[SocksCommand2["UDP_ASSOCIATE"] = 3] = "UDP_ASSOCIATE";
    })(SocksCommand || (SocksCommand = {}));
    var SocksReply;
    (function(SocksReply2) {
      SocksReply2[SocksReply2["Succeeded"] = 0] = "Succeeded";
      SocksReply2[SocksReply2["GeneralServerFailure"] = 1] = "GeneralServerFailure";
      SocksReply2[SocksReply2["NotAllowedByRuleSet"] = 2] = "NotAllowedByRuleSet";
      SocksReply2[SocksReply2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      SocksReply2[SocksReply2["HostUnreachable"] = 4] = "HostUnreachable";
      SocksReply2[SocksReply2["ConnectionRefused"] = 5] = "ConnectionRefused";
      SocksReply2[SocksReply2["TtlExpired"] = 6] = "TtlExpired";
      SocksReply2[SocksReply2["CommandNotSupported"] = 7] = "CommandNotSupported";
      SocksReply2[SocksReply2["AddressTypeNotSupported"] = 8] = "AddressTypeNotSupported";
    })(SocksReply || (SocksReply = {}));
    var SocksConnection = class {
      constructor(uid, socket, client) {
        this._buffer = Buffer.from([]);
        this._offset = 0;
        this._fence = 0;
        this._fenceCallback = void 0;
        this._socket = void 0;
        this._boundOnData = void 0;
        this._uid = void 0;
        this._client = void 0;
        this._uid = uid;
        this._socket = socket;
        this._client = client;
        this._boundOnData = this._onData.bind(this);
        socket.on("data", this._boundOnData);
        socket.on("close", () => this._onClose());
        socket.on("end", () => this._onClose());
        socket.on("error", () => this._onClose());
        this._run().catch(() => this._socket.end());
      }
      _run() {
        return __async(this, null, function* () {
          (0, _utils2.assert)(yield this._authenticate());
          const {
            command,
            host,
            port
          } = yield this._parseRequest();
          if (command !== SocksCommand.CONNECT) {
            this._writeBytes(Buffer.from([
              5,
              SocksReply.CommandNotSupported,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              0
            ]));
            return;
          }
          this._socket.off("data", this._boundOnData);
          this._client.onSocketRequested(this._uid, host, port);
        });
      }
      _authenticate() {
        return __async(this, null, function* () {
          const version = yield this._readByte();
          (0, _utils2.assert)(version === 5, "The VER field must be set to x05 for this version of the protocol, was " + version);
          const nMethods = yield this._readByte();
          (0, _utils2.assert)(nMethods, "No authentication methods specified");
          const methods = yield this._readBytes(nMethods);
          for (const method of methods) {
            if (method === 0) {
              this._writeBytes(Buffer.from([version, method]));
              return true;
            }
          }
          this._writeBytes(Buffer.from([version, SocksAuth.NO_ACCEPTABLE_METHODS]));
          return false;
        });
      }
      _parseRequest() {
        return __async(this, null, function* () {
          const version = yield this._readByte();
          (0, _utils2.assert)(version === 5, "The VER field must be set to x05 for this version of the protocol, was " + version);
          const command = yield this._readByte();
          yield this._readByte();
          const addressType = yield this._readByte();
          let host = "";
          switch (addressType) {
            case SocksAddressType.IPv4:
              host = (yield this._readBytes(4)).join(".");
              break;
            case SocksAddressType.FqName:
              const length = yield this._readByte();
              host = (yield this._readBytes(length)).toString();
              break;
            case SocksAddressType.IPv6:
              const bytes = yield this._readBytes(16);
              const tokens = [];
              for (let i = 0; i < 8; ++i)
                tokens.push(bytes.readUInt16BE(i * 2));
              host = tokens.join(":");
              break;
          }
          const port = (yield this._readBytes(2)).readUInt16BE(0);
          this._buffer = Buffer.from([]);
          this._offset = 0;
          this._fence = 0;
          return {
            command,
            host,
            port
          };
        });
      }
      _readByte() {
        return __async(this, null, function* () {
          const buffer = yield this._readBytes(1);
          return buffer[0];
        });
      }
      _readBytes(length) {
        return __async(this, null, function* () {
          this._fence = this._offset + length;
          if (!this._buffer || this._buffer.length < this._fence)
            yield new Promise((f) => this._fenceCallback = f);
          this._offset += length;
          return this._buffer.slice(this._offset - length, this._offset);
        });
      }
      _writeBytes(buffer) {
        if (this._socket.writable)
          this._socket.write(buffer);
      }
      _onClose() {
        this._client.onSocketClosed(this._uid);
      }
      _onData(buffer) {
        this._buffer = Buffer.concat([this._buffer, buffer]);
        if (this._fenceCallback && this._buffer.length >= this._fence) {
          const callback = this._fenceCallback;
          this._fenceCallback = void 0;
          callback();
        }
      }
      socketConnected(host, port) {
        this._writeBytes(Buffer.from([
          5,
          SocksReply.Succeeded,
          0,
          1,
          ...parseIP(host),
          port << 8,
          port & 255
        ]));
        this._socket.on("data", (data) => this._client.onSocketData(this._uid, data));
      }
      socketFailed(errorCode) {
        const buffer = Buffer.from([
          5,
          0,
          0,
          1,
          ...parseIP("0.0.0.0"),
          0,
          0
        ]);
        switch (errorCode) {
          case "ENOENT":
          case "ENOTFOUND":
          case "ETIMEDOUT":
          case "EHOSTUNREACH":
            buffer[1] = SocksReply.HostUnreachable;
            break;
          case "ENETUNREACH":
            buffer[1] = SocksReply.NetworkUnreachable;
            break;
          case "ECONNREFUSED":
            buffer[1] = SocksReply.ConnectionRefused;
            break;
        }
        this._writeBytes(buffer);
        this._socket.end();
      }
      sendData(data) {
        this._socket.write(data);
      }
      end() {
        this._socket.end();
      }
      error(error) {
        this._socket.destroy(new Error(error));
      }
    };
    exports2.SocksConnection = SocksConnection;
    function parseIP(address) {
      if (!_net.default.isIPv4(address))
        throw new Error("IPv6 is not supported");
      return address.split(".", 4).map((t) => +t);
    }
  }
});

// node_modules/playwright-core/lib/dispatchers/jsHandleDispatcher.js
var require_jsHandleDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/jsHandleDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parseArgument = parseArgument;
    exports2.parseValue = parseValue;
    exports2.serializeResult = serializeResult;
    exports2.JSHandleDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _serializers = require_serializers();
    var JSHandleDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, jsHandle) {
        super(scope, jsHandle, jsHandle.asElement() ? "ElementHandle" : "JSHandle", {
          preview: jsHandle.toString()
        });
        this._type_JSHandle = true;
        jsHandle._setPreviewCallback((preview) => this._dispatchEvent("previewUpdated", {
          preview
        }));
      }
      evaluateExpression(params) {
        return __async(this, null, function* () {
          return {
            value: serializeResult(yield this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true, parseArgument(params.arg)))
          };
        });
      }
      evaluateExpressionHandle(params) {
        return __async(this, null, function* () {
          const jsHandle = yield this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false, parseArgument(params.arg));
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle)
          };
        });
      }
      getProperty(params) {
        return __async(this, null, function* () {
          const jsHandle = yield this._object.getProperty(params.name);
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle)
          };
        });
      }
      getPropertyList() {
        return __async(this, null, function* () {
          const map = yield this._object.getProperties();
          const properties = [];
          for (const [name, value] of map)
            properties.push({
              name,
              value: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, value)
            });
          return {
            properties
          };
        });
      }
      jsonValue() {
        return __async(this, null, function* () {
          return {
            value: serializeResult(yield this._object.jsonValue())
          };
        });
      }
      dispose() {
        return __async(this, null, function* () {
          yield this._object.dispose();
        });
      }
    };
    exports2.JSHandleDispatcher = JSHandleDispatcher;
    function parseArgument(arg) {
      return (0, _serializers.parseSerializedValue)(arg.value, arg.handles.map((a) => a._object));
    }
    function parseValue(v) {
      return (0, _serializers.parseSerializedValue)(v, []);
    }
    function serializeResult(arg) {
      return (0, _serializers.serializeValue)(arg, (value) => ({
        fallThrough: value
      }), /* @__PURE__ */ new Set());
    }
  }
});

// node_modules/playwright-core/lib/dispatchers/elementHandlerDispatcher.js
var require_elementHandlerDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/elementHandlerDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElementHandleDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var ElementHandleDispatcher = class extends _jsHandleDispatcher.JSHandleDispatcher {
      static from(scope, handle) {
        return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);
      }
      static fromNullable(scope, handle) {
        if (!handle)
          return void 0;
        return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);
      }
      static fromJSHandle(scope, handle) {
        const result = (0, _dispatcher.existingDispatcher)(handle);
        if (result)
          return result;
        return handle.asElement() ? new ElementHandleDispatcher(scope, handle.asElement()) : new _jsHandleDispatcher.JSHandleDispatcher(scope, handle);
      }
      constructor(scope, elementHandle) {
        super(scope, elementHandle);
        this._type_ElementHandle = true;
        this._elementHandle = void 0;
        this._elementHandle = elementHandle;
      }
      ownerFrame(params, metadata) {
        return __async(this, null, function* () {
          return {
            frame: (0, _dispatcher.lookupNullableDispatcher)(yield this._elementHandle.ownerFrame())
          };
        });
      }
      contentFrame(params, metadata) {
        return __async(this, null, function* () {
          return {
            frame: (0, _dispatcher.lookupNullableDispatcher)(yield this._elementHandle.contentFrame())
          };
        });
      }
      getAttribute(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.getAttribute(params.name);
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      inputValue(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.inputValue();
          return {
            value
          };
        });
      }
      textContent(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.textContent();
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      innerText(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.innerText()
          };
        });
      }
      innerHTML(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.innerHTML()
          };
        });
      }
      isChecked(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isChecked()
          };
        });
      }
      isDisabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isDisabled()
          };
        });
      }
      isEditable(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isEditable()
          };
        });
      }
      isEnabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isEnabled()
          };
        });
      }
      isHidden(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isHidden()
          };
        });
      }
      isVisible(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isVisible()
          };
        });
      }
      dispatchEvent(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.dispatchEvent(params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit));
        });
      }
      scrollIntoViewIfNeeded(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.scrollIntoViewIfNeeded(metadata, params);
        });
      }
      hover(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.hover(metadata, params);
        });
      }
      click(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.click(metadata, params);
        });
      }
      dblclick(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.dblclick(metadata, params);
        });
      }
      tap(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.tap(metadata, params);
        });
      }
      selectOption(params, metadata) {
        return __async(this, null, function* () {
          const elements = (params.elements || []).map((e) => e._elementHandle);
          return {
            values: yield this._elementHandle.selectOption(metadata, elements, params.options || [], params)
          };
        });
      }
      fill(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.fill(metadata, params.value, params);
        });
      }
      selectText(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.selectText(metadata, params);
        });
      }
      setInputFiles(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.setInputFiles(metadata, params.files, params);
        });
      }
      focus(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.focus(metadata);
        });
      }
      type(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.type(metadata, params.text, params);
        });
      }
      press(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.press(metadata, params.key, params);
        });
      }
      check(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.check(metadata, params);
        });
      }
      uncheck(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.uncheck(metadata, params);
        });
      }
      boundingBox(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.boundingBox();
          return {
            value: value || void 0
          };
        });
      }
      screenshot(params, metadata) {
        return __async(this, null, function* () {
          return {
            binary: (yield this._elementHandle.screenshot(metadata, params)).toString("base64")
          };
        });
      }
      querySelector(params, metadata) {
        return __async(this, null, function* () {
          const handle = yield this._elementHandle.querySelector(params.selector, params);
          return {
            element: ElementHandleDispatcher.fromNullable(this._scope, handle)
          };
        });
      }
      querySelectorAll(params, metadata) {
        return __async(this, null, function* () {
          const elements = yield this._elementHandle.querySelectorAll(params.selector);
          return {
            elements: elements.map((e) => ElementHandleDispatcher.from(this._scope, e))
          };
        });
      }
      evalOnSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._elementHandle.evalOnSelectorAndWaitForSignals(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evalOnSelectorAll(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._elementHandle.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      waitForElementState(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.waitForElementState(metadata, params.state, params);
        });
      }
      waitForSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: ElementHandleDispatcher.fromNullable(this._scope, yield this._elementHandle.waitForSelector(metadata, params.selector, params))
          };
        });
      }
    };
    exports2.ElementHandleDispatcher = ElementHandleDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/consoleMessageDispatcher.js
var require_consoleMessageDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/consoleMessageDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConsoleMessageDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var ConsoleMessageDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, message) {
        super(scope, message, "ConsoleMessage", {
          type: message.type(),
          text: message.text(),
          args: message.args().map((a) => _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(scope, a)),
          location: message.location()
        });
        this._type_ConsoleMessage = true;
      }
    };
    exports2.ConsoleMessageDispatcher = ConsoleMessageDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/dialogDispatcher.js
var require_dialogDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/dialogDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DialogDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var DialogDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, dialog) {
        super(scope, dialog, "Dialog", {
          type: dialog.type(),
          message: dialog.message(),
          defaultValue: dialog.defaultValue()
        });
        this._type_Dialog = true;
      }
      accept(params) {
        return __async(this, null, function* () {
          yield this._object.accept(params.promptText);
        });
      }
      dismiss() {
        return __async(this, null, function* () {
          yield this._object.dismiss();
        });
      }
    };
    exports2.DialogDispatcher = DialogDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/networkDispatchers.js
var require_networkDispatchers = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/networkDispatchers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.APIRequestContextDispatcher = exports2.WebSocketDispatcher = exports2.RouteDispatcher = exports2.ResponseDispatcher = exports2.RequestDispatcher = void 0;
    var _fetch = require_fetch();
    var _network = require_network();
    var _dispatcher = require_dispatcher();
    var _frameDispatcher = require_frameDispatcher();
    var RequestDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, request) {
        const result = (0, _dispatcher.existingDispatcher)(request);
        return result || new RequestDispatcher(scope, request);
      }
      static fromNullable(scope, request) {
        return request ? RequestDispatcher.from(scope, request) : void 0;
      }
      constructor(scope, request) {
        const postData = request.postDataBuffer();
        super(scope, request, "Request", {
          frame: _frameDispatcher.FrameDispatcher.from(scope, request.frame()),
          url: request.url(),
          resourceType: request.resourceType(),
          method: request.method(),
          postData: postData === null ? void 0 : postData.toString("base64"),
          headers: request.headers(),
          isNavigationRequest: request.isNavigationRequest(),
          redirectedFrom: RequestDispatcher.fromNullable(scope, request.redirectedFrom())
        });
        this._type_Request = void 0;
        this._type_Request = true;
      }
      rawRequestHeaders(params) {
        return __async(this, null, function* () {
          return {
            headers: yield this._object.rawRequestHeaders()
          };
        });
      }
      response() {
        return __async(this, null, function* () {
          return {
            response: (0, _dispatcher.lookupNullableDispatcher)(yield this._object.response())
          };
        });
      }
    };
    exports2.RequestDispatcher = RequestDispatcher;
    var ResponseDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, response) {
        const result = (0, _dispatcher.existingDispatcher)(response);
        return result || new ResponseDispatcher(scope, response);
      }
      static fromNullable(scope, response) {
        return response ? ResponseDispatcher.from(scope, response) : void 0;
      }
      constructor(scope, response) {
        super(scope, response, "Response", {
          request: RequestDispatcher.from(scope, response.request()),
          url: response.url(),
          status: response.status(),
          statusText: response.statusText(),
          headers: response.headers(),
          timing: response.timing()
        });
        this._type_Response = true;
      }
      body() {
        return __async(this, null, function* () {
          return {
            binary: (yield this._object.body()).toString("base64")
          };
        });
      }
      securityDetails() {
        return __async(this, null, function* () {
          return {
            value: (yield this._object.securityDetails()) || void 0
          };
        });
      }
      serverAddr() {
        return __async(this, null, function* () {
          return {
            value: (yield this._object.serverAddr()) || void 0
          };
        });
      }
      rawResponseHeaders(params) {
        return __async(this, null, function* () {
          return {
            headers: yield this._object.rawResponseHeaders()
          };
        });
      }
      sizes(params) {
        return __async(this, null, function* () {
          return {
            sizes: yield this._object.sizes()
          };
        });
      }
    };
    exports2.ResponseDispatcher = ResponseDispatcher;
    var RouteDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, route) {
        const result = (0, _dispatcher.existingDispatcher)(route);
        return result || new RouteDispatcher(scope, route);
      }
      constructor(scope, route) {
        super(scope, route, "Route", {
          request: RequestDispatcher.from(scope, route.request())
        });
        this._type_Route = true;
      }
      continue(params, metadata) {
        return __async(this, null, function* () {
          yield this._object.continue({
            url: params.url,
            method: params.method,
            headers: params.headers,
            postData: params.postData ? Buffer.from(params.postData, "base64") : void 0
          });
        });
      }
      fulfill(params) {
        return __async(this, null, function* () {
          yield this._object.fulfill(params);
        });
      }
      abort(params) {
        return __async(this, null, function* () {
          yield this._object.abort(params.errorCode || "failed");
        });
      }
    };
    exports2.RouteDispatcher = RouteDispatcher;
    var WebSocketDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, webSocket) {
        super(scope, webSocket, "WebSocket", {
          url: webSocket.url()
        });
        this._type_EventTarget = true;
        this._type_WebSocket = true;
        webSocket.on(_network.WebSocket.Events.FrameSent, (event) => this._dispatchEvent("frameSent", event));
        webSocket.on(_network.WebSocket.Events.FrameReceived, (event) => this._dispatchEvent("frameReceived", event));
        webSocket.on(_network.WebSocket.Events.SocketError, (error) => this._dispatchEvent("socketError", {
          error
        }));
        webSocket.on(_network.WebSocket.Events.Close, () => this._dispatchEvent("close", {}));
      }
    };
    exports2.WebSocketDispatcher = WebSocketDispatcher;
    var APIRequestContextDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, request) {
        const result = (0, _dispatcher.existingDispatcher)(request);
        return result || new APIRequestContextDispatcher(scope, request);
      }
      static fromNullable(scope, request) {
        return request ? APIRequestContextDispatcher.from(scope, request) : void 0;
      }
      constructor(scope, request) {
        super(scope, request, "APIRequestContext", {}, true);
        this._type_APIRequestContext = true;
        request.once(_fetch.APIRequestContext.Events.Dispose, () => {
          if (!this._disposed)
            super._dispose();
        });
      }
      storageState(params) {
        return __async(this, null, function* () {
          return this._object.storageState();
        });
      }
      dispose(params) {
        return __async(this, null, function* () {
          this._object.dispose();
        });
      }
      fetch(params, metadata) {
        return __async(this, null, function* () {
          const fetchResponse = yield this._object.fetch(params, metadata);
          return {
            response: {
              url: fetchResponse.url,
              status: fetchResponse.status,
              statusText: fetchResponse.statusText,
              headers: fetchResponse.headers,
              fetchUid: fetchResponse.fetchUid
            }
          };
        });
      }
      fetchResponseBody(params, metadata) {
        return __async(this, null, function* () {
          const buffer = this._object.fetchResponses.get(params.fetchUid);
          return {
            binary: buffer ? buffer.toString("base64") : void 0
          };
        });
      }
      fetchLog(params, metadata) {
        return __async(this, null, function* () {
          const log = this._object.fetchLog.get(params.fetchUid) || [];
          return {
            log
          };
        });
      }
      disposeAPIResponse(params, metadata) {
        return __async(this, null, function* () {
          this._object.disposeResponse(params.fetchUid);
        });
      }
    };
    exports2.APIRequestContextDispatcher = APIRequestContextDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/frameDispatcher.js
var require_frameDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/frameDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FrameDispatcher = void 0;
    var _frames = require_frames();
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var FrameDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, frame) {
        const result = (0, _dispatcher.existingDispatcher)(frame);
        return result || new FrameDispatcher(scope, frame);
      }
      static fromNullable(scope, frame) {
        if (!frame)
          return;
        return FrameDispatcher.from(scope, frame);
      }
      constructor(scope, frame) {
        super(scope, frame, "Frame", {
          url: frame.url(),
          name: frame.name(),
          parentFrame: FrameDispatcher.fromNullable(scope, frame.parentFrame()),
          loadStates: Array.from(frame._subtreeLifecycleEvents)
        });
        this._type_Frame = true;
        this._frame = void 0;
        this._frame = frame;
        frame.on(_frames.Frame.Events.AddLifecycle, (lifecycleEvent) => {
          this._dispatchEvent("loadstate", {
            add: lifecycleEvent
          });
        });
        frame.on(_frames.Frame.Events.RemoveLifecycle, (lifecycleEvent) => {
          this._dispatchEvent("loadstate", {
            remove: lifecycleEvent
          });
        });
        frame.on(_frames.Frame.Events.Navigation, (event) => {
          const params = {
            url: event.url,
            name: event.name,
            error: event.error ? event.error.message : void 0
          };
          if (event.newDocument)
            params.newDocument = {
              request: _networkDispatchers.RequestDispatcher.fromNullable(this._scope, event.newDocument.request || null)
            };
          this._dispatchEvent("navigated", params);
        });
      }
      goto(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: (0, _dispatcher.lookupNullableDispatcher)(yield this._frame.goto(metadata, params.url, params))
          };
        });
      }
      frameElement() {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, yield this._frame.frameElement())
          };
        });
      }
      evaluateExpression(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._frame.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), "main"))
          };
        });
      }
      evaluateExpressionHandle(params, metadata) {
        return __async(this, null, function* () {
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, yield this._frame.evaluateExpressionHandleAndWaitForSignals(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), "main"))
          };
        });
      }
      waitForSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this._scope, yield this._frame.waitForSelector(metadata, params.selector, params))
          };
        });
      }
      dispatchEvent(params, metadata) {
        return __async(this, null, function* () {
          return this._frame.dispatchEvent(metadata, params.selector, params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit), params);
        });
      }
      evalOnSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._frame.evalOnSelectorAndWaitForSignals(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evalOnSelectorAll(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._frame.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      querySelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this._scope, yield this._frame.querySelector(params.selector, params))
          };
        });
      }
      querySelectorAll(params, metadata) {
        return __async(this, null, function* () {
          const elements = yield this._frame.querySelectorAll(params.selector);
          return {
            elements: elements.map((e) => _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, e))
          };
        });
      }
      queryCount(params) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.queryCount(params.selector)
          };
        });
      }
      content() {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.content()
          };
        });
      }
      setContent(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.setContent(metadata, params.html, params);
        });
      }
      addScriptTag(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, yield this._frame.addScriptTag(params))
          };
        });
      }
      addStyleTag(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, yield this._frame.addStyleTag(params))
          };
        });
      }
      click(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.click(metadata, params.selector, params);
        });
      }
      dblclick(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.dblclick(metadata, params.selector, params);
        });
      }
      dragAndDrop(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.dragAndDrop(metadata, params.source, params.target, params);
        });
      }
      tap(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.tap(metadata, params.selector, params);
        });
      }
      fill(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.fill(metadata, params.selector, params.value, params);
        });
      }
      focus(params, metadata) {
        return __async(this, null, function* () {
          yield this._frame.focus(metadata, params.selector, params);
        });
      }
      textContent(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._frame.textContent(metadata, params.selector, params);
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      innerText(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.innerText(metadata, params.selector, params)
          };
        });
      }
      innerHTML(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.innerHTML(metadata, params.selector, params)
          };
        });
      }
      getAttribute(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._frame.getAttribute(metadata, params.selector, params.name, params);
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      inputValue(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._frame.inputValue(metadata, params.selector, params);
          return {
            value
          };
        });
      }
      isChecked(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isChecked(metadata, params.selector, params)
          };
        });
      }
      isDisabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isDisabled(metadata, params.selector, params)
          };
        });
      }
      isEditable(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isEditable(metadata, params.selector, params)
          };
        });
      }
      isEnabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isEnabled(metadata, params.selector, params)
          };
        });
      }
      isHidden(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isHidden(metadata, params.selector, params)
          };
        });
      }
      isVisible(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isVisible(metadata, params.selector, params)
          };
        });
      }
      hover(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.hover(metadata, params.selector, params);
        });
      }
      selectOption(params, metadata) {
        return __async(this, null, function* () {
          const elements = (params.elements || []).map((e) => e._elementHandle);
          return {
            values: yield this._frame.selectOption(metadata, params.selector, elements, params.options || [], params)
          };
        });
      }
      setInputFiles(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.setInputFiles(metadata, params.selector, params.files, params);
        });
      }
      type(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.type(metadata, params.selector, params.text, params);
        });
      }
      press(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.press(metadata, params.selector, params.key, params);
        });
      }
      check(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.check(metadata, params.selector, params);
        });
      }
      uncheck(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.uncheck(metadata, params.selector, params);
        });
      }
      waitForTimeout(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.waitForTimeout(metadata, params.timeout);
        });
      }
      waitForFunction(params, metadata) {
        return __async(this, null, function* () {
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, yield this._frame._waitForFunctionExpression(metadata, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), params))
          };
        });
      }
      title(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.title()
          };
        });
      }
      highlight(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.highlight(params.selector);
        });
      }
      expect(params, metadata) {
        return __async(this, null, function* () {
          const expectedValue = params.expectedValue ? (0, _jsHandleDispatcher.parseArgument)(params.expectedValue) : void 0;
          const result = yield this._frame.expect(metadata, params.selector, __spreadProps(__spreadValues({}, params), {
            expectedValue
          }));
          if (result.received !== void 0)
            result.received = (0, _jsHandleDispatcher.serializeResult)(result.received);
          if (result.matches === params.isNot)
            metadata.error = {
              error: {
                name: "Expect",
                message: "Expect failed"
              }
            };
          return result;
        });
      }
    };
    exports2.FrameDispatcher = FrameDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/streamDispatcher.js
var require_streamDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/streamDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.StreamDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _utils2 = require_utils();
    var StreamDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, stream) {
        super(scope, {
          guid: "stream@" + (0, _utils2.createGuid)(),
          stream
        }, "Stream", {});
        this._type_Stream = true;
        this._ended = false;
        stream.once("end", () => this._ended = true);
        stream.once("error", () => this._ended = true);
      }
      read(params) {
        return __async(this, null, function* () {
          const stream = this._object.stream;
          if (this._ended)
            return {
              binary: ""
            };
          if (!stream.readableLength) {
            yield new Promise((fulfill, reject) => {
              stream.once("readable", fulfill);
              stream.once("end", fulfill);
              stream.once("error", reject);
            });
          }
          const buffer = stream.read(Math.min(stream.readableLength, params.size || stream.readableLength));
          return {
            binary: buffer ? buffer.toString("base64") : ""
          };
        });
      }
      close() {
        return __async(this, null, function* () {
          this._object.stream.destroy();
        });
      }
    };
    exports2.StreamDispatcher = StreamDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/artifactDispatcher.js
var require_artifactDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/artifactDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArtifactDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _streamDispatcher = require_streamDispatcher();
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _utils2 = require_utils();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ArtifactDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, artifact) {
        super(scope, artifact, "Artifact", {
          absolutePath: artifact.localPath()
        });
        this._type_Artifact = true;
      }
      pathAfterFinished() {
        return __async(this, null, function* () {
          const path = yield this._object.localPathAfterFinished();
          return {
            value: path || void 0
          };
        });
      }
      saveAs(params) {
        return __async(this, null, function* () {
          return yield new Promise((resolve, reject) => {
            this._object.saveAs((localPath, error) => __async(this, null, function* () {
              if (error !== void 0) {
                reject(new Error(error));
                return;
              }
              try {
                yield (0, _utils2.mkdirIfNeeded)(params.path);
                yield _fs2.default.promises.copyFile(localPath, params.path);
                resolve();
              } catch (e) {
                reject(e);
              }
            }));
          });
        });
      }
      saveAsStream() {
        return __async(this, null, function* () {
          return yield new Promise((resolve, reject) => {
            this._object.saveAs((localPath, error) => __async(this, null, function* () {
              if (error !== void 0) {
                reject(new Error(error));
                return;
              }
              try {
                const readable = _fs2.default.createReadStream(localPath);
                const stream = new _streamDispatcher.StreamDispatcher(this._scope, readable);
                resolve({
                  stream
                });
                yield new Promise((resolve2) => {
                  readable.on("close", resolve2);
                  readable.on("end", resolve2);
                  readable.on("error", resolve2);
                });
              } catch (e) {
                reject(e);
              }
            }));
          });
        });
      }
      stream() {
        return __async(this, null, function* () {
          const fileName = yield this._object.localPathAfterFinished();
          if (!fileName)
            return {};
          const readable = _fs2.default.createReadStream(fileName);
          return {
            stream: new _streamDispatcher.StreamDispatcher(this._scope, readable)
          };
        });
      }
      failure() {
        return __async(this, null, function* () {
          const error = yield this._object.failureError();
          return {
            error: error || void 0
          };
        });
      }
      cancel() {
        return __async(this, null, function* () {
          yield this._object.cancel();
        });
      }
      delete() {
        return __async(this, null, function* () {
          yield this._object.delete();
          this._dispose();
        });
      }
    };
    exports2.ArtifactDispatcher = ArtifactDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/pageDispatcher.js
var require_pageDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/pageDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BindingCallDispatcher = exports2.WorkerDispatcher = exports2.PageDispatcher = void 0;
    var _page = require_page();
    var _dispatcher = require_dispatcher();
    var _serializers = require_serializers();
    var _consoleMessageDispatcher = require_consoleMessageDispatcher();
    var _dialogDispatcher = require_dialogDispatcher();
    var _frameDispatcher = require_frameDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _artifactDispatcher = require_artifactDispatcher();
    var _utils2 = require_utils();
    var PageDispatcher = class extends _dispatcher.Dispatcher {
      static fromNullable(scope, page) {
        if (!page)
          return void 0;
        const result = (0, _dispatcher.existingDispatcher)(page);
        return result || new PageDispatcher(scope, page);
      }
      constructor(scope, page) {
        super(scope, page, "Page", {
          mainFrame: _frameDispatcher.FrameDispatcher.from(scope, page.mainFrame()),
          viewportSize: page.viewportSize() || void 0,
          isClosed: page.isClosed(),
          opener: PageDispatcher.fromNullable(scope, page.opener())
        }, true);
        this._type_EventTarget = true;
        this._type_Page = true;
        this._page = void 0;
        this._page = page;
        page.on(_page.Page.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
        page.on(_page.Page.Events.Console, (message) => this._dispatchEvent("console", {
          message: new _consoleMessageDispatcher.ConsoleMessageDispatcher(this._scope, message)
        }));
        page.on(_page.Page.Events.Crash, () => this._dispatchEvent("crash"));
        page.on(_page.Page.Events.DOMContentLoaded, () => this._dispatchEvent("domcontentloaded"));
        page.on(_page.Page.Events.Dialog, (dialog) => this._dispatchEvent("dialog", {
          dialog: new _dialogDispatcher.DialogDispatcher(this._scope, dialog)
        }));
        page.on(_page.Page.Events.Download, (download) => {
          this._dispatchEvent("download", {
            url: download.url,
            suggestedFilename: download.suggestedFilename(),
            artifact: new _artifactDispatcher.ArtifactDispatcher(scope, download.artifact)
          });
        });
        this._page.on(_page.Page.Events.FileChooser, (fileChooser) => this._dispatchEvent("fileChooser", {
          element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, fileChooser.element()),
          isMultiple: fileChooser.isMultiple()
        }));
        page.on(_page.Page.Events.FrameAttached, (frame) => this._onFrameAttached(frame));
        page.on(_page.Page.Events.FrameDetached, (frame) => this._onFrameDetached(frame));
        page.on(_page.Page.Events.Load, () => this._dispatchEvent("load"));
        page.on(_page.Page.Events.PageError, (error) => this._dispatchEvent("pageError", {
          error: (0, _serializers.serializeError)(error)
        }));
        page.on(_page.Page.Events.WebSocket, (webSocket) => this._dispatchEvent("webSocket", {
          webSocket: new _networkDispatchers.WebSocketDispatcher(this._scope, webSocket)
        }));
        page.on(_page.Page.Events.Worker, (worker) => this._dispatchEvent("worker", {
          worker: new WorkerDispatcher(this._scope, worker)
        }));
        page.on(_page.Page.Events.Video, (artifact) => this._dispatchEvent("video", {
          artifact: (0, _dispatcher.existingDispatcher)(artifact)
        }));
        if (page._video)
          this._dispatchEvent("video", {
            artifact: (0, _dispatcher.existingDispatcher)(page._video)
          });
        const frames = page._frameManager.frames();
        for (let i = 1; i < frames.length; i++)
          this._onFrameAttached(frames[i]);
      }
      page() {
        return this._page;
      }
      setDefaultNavigationTimeoutNoReply(params, metadata) {
        return __async(this, null, function* () {
          this._page.setDefaultNavigationTimeout(params.timeout);
        });
      }
      setDefaultTimeoutNoReply(params, metadata) {
        return __async(this, null, function* () {
          this._page.setDefaultTimeout(params.timeout);
        });
      }
      exposeBinding(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
            const binding = new BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);
            this._dispatchEvent("bindingCall", {
              binding
            });
            return binding.promise();
          });
        });
      }
      setExtraHTTPHeaders(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.setExtraHTTPHeaders(params.headers);
        });
      }
      reload(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: (0, _dispatcher.lookupNullableDispatcher)(yield this._page.reload(metadata, params))
          };
        });
      }
      goBack(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: (0, _dispatcher.lookupNullableDispatcher)(yield this._page.goBack(metadata, params))
          };
        });
      }
      goForward(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: (0, _dispatcher.lookupNullableDispatcher)(yield this._page.goForward(metadata, params))
          };
        });
      }
      emulateMedia(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.emulateMedia({
            media: params.media === "null" ? null : params.media,
            colorScheme: params.colorScheme === "null" ? null : params.colorScheme,
            reducedMotion: params.reducedMotion === "null" ? null : params.reducedMotion,
            forcedColors: params.forcedColors === "null" ? null : params.forcedColors
          });
        });
      }
      setViewportSize(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.setViewportSize(params.viewportSize);
        });
      }
      addInitScript(params, metadata) {
        return __async(this, null, function* () {
          yield this._page._addInitScriptExpression(params.source);
        });
      }
      setNetworkInterceptionEnabled(params, metadata) {
        return __async(this, null, function* () {
          if (!params.enabled) {
            yield this._page._setClientRequestInterceptor(void 0);
            return;
          }
          yield this._page._setClientRequestInterceptor((route, request) => {
            this._dispatchEvent("route", {
              route: _networkDispatchers.RouteDispatcher.from(this._scope, route),
              request: _networkDispatchers.RequestDispatcher.from(this._scope, request)
            });
          });
        });
      }
      screenshot(params, metadata) {
        return __async(this, null, function* () {
          return {
            binary: (yield this._page.screenshot(metadata, params)).toString("base64")
          };
        });
      }
      close(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.close(metadata, params);
        });
      }
      setFileChooserInterceptedNoReply(params, metadata) {
        return __async(this, null, function* () {
          yield this._page._setFileChooserIntercepted(params.intercepted);
        });
      }
      keyboardDown(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.down(params.key);
        });
      }
      keyboardUp(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.up(params.key);
        });
      }
      keyboardInsertText(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.insertText(params.text);
        });
      }
      keyboardType(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.type(params.text, params);
        });
      }
      keyboardPress(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.press(params.key, params);
        });
      }
      mouseMove(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.move(params.x, params.y, params);
        });
      }
      mouseDown(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.down(params);
        });
      }
      mouseUp(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.up(params);
        });
      }
      mouseClick(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.click(params.x, params.y, params);
        });
      }
      mouseWheel(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.wheel(params.deltaX, params.deltaY);
        });
      }
      touchscreenTap(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.touchscreen.tap(params.x, params.y);
        });
      }
      accessibilitySnapshot(params, metadata) {
        return __async(this, null, function* () {
          const rootAXNode = yield this._page.accessibility.snapshot({
            interestingOnly: params.interestingOnly,
            root: params.root ? params.root._elementHandle : void 0
          });
          return {
            rootAXNode: rootAXNode || void 0
          };
        });
      }
      pdf(params, metadata) {
        return __async(this, null, function* () {
          if (!this._page.pdf)
            throw new Error("PDF generation is only supported for Headless Chromium");
          const buffer = yield this._page.pdf(params);
          return {
            pdf: buffer.toString("base64")
          };
        });
      }
      bringToFront(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.bringToFront();
        });
      }
      startJSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          yield coverage.startJSCoverage(params);
        });
      }
      stopJSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          return {
            entries: yield coverage.stopJSCoverage()
          };
        });
      }
      startCSSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          yield coverage.startCSSCoverage(params);
        });
      }
      stopCSSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          return {
            entries: yield coverage.stopCSSCoverage()
          };
        });
      }
      _onFrameAttached(frame) {
        this._dispatchEvent("frameAttached", {
          frame: _frameDispatcher.FrameDispatcher.from(this._scope, frame)
        });
      }
      _onFrameDetached(frame) {
        this._dispatchEvent("frameDetached", {
          frame: (0, _dispatcher.lookupDispatcher)(frame)
        });
      }
    };
    exports2.PageDispatcher = PageDispatcher;
    var WorkerDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, worker) {
        super(scope, worker, "Worker", {
          url: worker.url()
        });
        this._type_Worker = true;
        worker.on(_page.Worker.Events.Close, () => this._dispatchEvent("close"));
      }
      evaluateExpression(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._object.evaluateExpression(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evaluateExpressionHandle(params, metadata) {
        return __async(this, null, function* () {
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, yield this._object.evaluateExpressionHandle(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
    };
    exports2.WorkerDispatcher = WorkerDispatcher;
    var BindingCallDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, name, needsHandle, source, args) {
        super(scope, {
          guid: "bindingCall@" + (0, _utils2.createGuid)()
        }, "BindingCall", {
          frame: (0, _dispatcher.lookupDispatcher)(source.frame),
          name,
          args: needsHandle ? void 0 : args.map(_jsHandleDispatcher.serializeResult),
          handle: needsHandle ? _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(scope, args[0]) : void 0
        });
        this._type_BindingCall = true;
        this._resolve = void 0;
        this._reject = void 0;
        this._promise = void 0;
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
      promise() {
        return this._promise;
      }
      resolve(params, metadata) {
        return __async(this, null, function* () {
          this._resolve((0, _jsHandleDispatcher.parseArgument)(params.result));
        });
      }
      reject(params, metadata) {
        return __async(this, null, function* () {
          this._reject((0, _serializers.parseError)(params.error));
        });
      }
    };
    exports2.BindingCallDispatcher = BindingCallDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/cdpSessionDispatcher.js
var require_cdpSessionDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/cdpSessionDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CDPSessionDispatcher = void 0;
    var _crConnection = require_crConnection();
    var _dispatcher = require_dispatcher();
    var CDPSessionDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, crSession) {
        super(scope, crSession, "CDPSession", {}, true);
        this._type_CDPSession = true;
        crSession._eventListener = (method, params) => {
          this._dispatchEvent("event", {
            method,
            params
          });
        };
        crSession.on(_crConnection.CRSessionEvents.Disconnected, () => this._dispose());
      }
      send(params) {
        return __async(this, null, function* () {
          return {
            result: yield this._object.send(params.method, params.params)
          };
        });
      }
      detach() {
        return __async(this, null, function* () {
          return this._object.detach();
        });
      }
    };
    exports2.CDPSessionDispatcher = CDPSessionDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/browserContextDispatcher.js
var require_browserContextDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/browserContextDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserContextDispatcher = void 0;
    var _browserContext = require_browserContext();
    var _dispatcher = require_dispatcher();
    var _pageDispatcher = require_pageDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _crBrowser = require_crBrowser();
    var _cdpSessionDispatcher = require_cdpSessionDispatcher();
    var _recorderSupplement = require_recorderSupplement();
    var _artifactDispatcher = require_artifactDispatcher();
    var BrowserContextDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, context) {
        super(scope, context, "BrowserContext", {
          isChromium: context._browser.options.isChromium,
          APIRequestContext: _networkDispatchers.APIRequestContextDispatcher.from(scope, context.fetchRequest)
        }, true);
        this._type_EventTarget = true;
        this._type_BrowserContext = true;
        this._context = void 0;
        this._context = context;
        const onVideo = (artifact) => {
          const artifactDispatcher = new _artifactDispatcher.ArtifactDispatcher(scope, artifact);
          this._dispatchEvent("video", {
            artifact: artifactDispatcher
          });
        };
        context.on(_browserContext.BrowserContext.Events.VideoStarted, onVideo);
        for (const video of context._browser._idToVideo.values()) {
          if (video.context === context)
            onVideo(video.artifact);
        }
        for (const page of context.pages())
          this._dispatchEvent("page", {
            page: new _pageDispatcher.PageDispatcher(this._scope, page)
          });
        context.on(_browserContext.BrowserContext.Events.Page, (page) => this._dispatchEvent("page", {
          page: new _pageDispatcher.PageDispatcher(this._scope, page)
        }));
        context.on(_browserContext.BrowserContext.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
        if (context._browser.options.name === "chromium") {
          for (const page of context.backgroundPages())
            this._dispatchEvent("backgroundPage", {
              page: new _pageDispatcher.PageDispatcher(this._scope, page)
            });
          context.on(_crBrowser.CRBrowserContext.CREvents.BackgroundPage, (page) => this._dispatchEvent("backgroundPage", {
            page: new _pageDispatcher.PageDispatcher(this._scope, page)
          }));
          for (const serviceWorker of context.serviceWorkers())
            this._dispatchEvent("serviceWorker", {
              worker: new _pageDispatcher.WorkerDispatcher(this._scope, serviceWorker)
            });
          context.on(_crBrowser.CRBrowserContext.CREvents.ServiceWorker, (serviceWorker) => this._dispatchEvent("serviceWorker", {
            worker: new _pageDispatcher.WorkerDispatcher(this._scope, serviceWorker)
          }));
        }
        context.on(_browserContext.BrowserContext.Events.Request, (request) => {
          return this._dispatchEvent("request", {
            request: _networkDispatchers.RequestDispatcher.from(this._scope, request),
            page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
          });
        });
        context.on(_browserContext.BrowserContext.Events.Response, (response) => this._dispatchEvent("response", {
          response: _networkDispatchers.ResponseDispatcher.from(this._scope, response),
          page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, response.frame()._page.initializedOrUndefined())
        }));
        context.on(_browserContext.BrowserContext.Events.RequestFailed, (request) => this._dispatchEvent("requestFailed", {
          request: _networkDispatchers.RequestDispatcher.from(this._scope, request),
          failureText: request._failureText || void 0,
          responseEndTiming: request._responseEndTiming,
          page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
        }));
        context.on(_browserContext.BrowserContext.Events.RequestFinished, ({
          request,
          response
        }) => this._dispatchEvent("requestFinished", {
          request: _networkDispatchers.RequestDispatcher.from(scope, request),
          response: _networkDispatchers.ResponseDispatcher.fromNullable(scope, response),
          responseEndTiming: request._responseEndTiming,
          page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
        }));
      }
      setDefaultNavigationTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._context.setDefaultNavigationTimeout(params.timeout);
        });
      }
      setDefaultTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._context.setDefaultTimeout(params.timeout);
        });
      }
      exposeBinding(params) {
        return __async(this, null, function* () {
          yield this._context.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
            const binding = new _pageDispatcher.BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);
            this._dispatchEvent("bindingCall", {
              binding
            });
            return binding.promise();
          });
        });
      }
      newPage(params, metadata) {
        return __async(this, null, function* () {
          return {
            page: (0, _dispatcher.lookupDispatcher)(yield this._context.newPage(metadata))
          };
        });
      }
      cookies(params) {
        return __async(this, null, function* () {
          return {
            cookies: yield this._context.cookies(params.urls)
          };
        });
      }
      addCookies(params) {
        return __async(this, null, function* () {
          yield this._context.addCookies(params.cookies);
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._context.clearCookies();
        });
      }
      grantPermissions(params) {
        return __async(this, null, function* () {
          yield this._context.grantPermissions(params.permissions, params.origin);
        });
      }
      clearPermissions() {
        return __async(this, null, function* () {
          yield this._context.clearPermissions();
        });
      }
      setGeolocation(params) {
        return __async(this, null, function* () {
          yield this._context.setGeolocation(params.geolocation);
        });
      }
      setExtraHTTPHeaders(params) {
        return __async(this, null, function* () {
          yield this._context.setExtraHTTPHeaders(params.headers);
        });
      }
      setOffline(params) {
        return __async(this, null, function* () {
          yield this._context.setOffline(params.offline);
        });
      }
      setHTTPCredentials(params) {
        return __async(this, null, function* () {
          yield this._context.setHTTPCredentials(params.httpCredentials);
        });
      }
      addInitScript(params) {
        return __async(this, null, function* () {
          yield this._context._doAddInitScript(params.source);
        });
      }
      setNetworkInterceptionEnabled(params) {
        return __async(this, null, function* () {
          if (!params.enabled) {
            yield this._context._setRequestInterceptor(void 0);
            return;
          }
          yield this._context._setRequestInterceptor((route, request) => {
            this._dispatchEvent("route", {
              route: _networkDispatchers.RouteDispatcher.from(this._scope, route),
              request: _networkDispatchers.RequestDispatcher.from(this._scope, request)
            });
          });
        });
      }
      storageState(params, metadata) {
        return __async(this, null, function* () {
          return yield this._context.storageState();
        });
      }
      close(params, metadata) {
        return __async(this, null, function* () {
          yield this._context.close(metadata);
        });
      }
      recorderSupplementEnable(params) {
        return __async(this, null, function* () {
          yield _recorderSupplement.RecorderSupplement.show(this._context, params);
        });
      }
      pause(params, metadata) {
        return __async(this, null, function* () {
        });
      }
      newCDPSession(params) {
        return __async(this, null, function* () {
          if (!this._object._browser.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
          if (!params.page && !params.frame || params.page && params.frame)
            throw new Error(`CDP session must be initiated with either Page or Frame, not none or both`);
          const crBrowserContext = this._object;
          return {
            session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, yield crBrowserContext.newCDPSession((params.page ? params.page : params.frame)._object))
          };
        });
      }
      tracingStart(params) {
        return __async(this, null, function* () {
          yield this._context.tracing.start(params);
        });
      }
      tracingStartChunk(params) {
        return __async(this, null, function* () {
          yield this._context.tracing.startChunk(params);
        });
      }
      tracingStopChunk(params) {
        return __async(this, null, function* () {
          const {
            artifact,
            sourceEntries
          } = yield this._context.tracing.stopChunk(params);
          return {
            artifact: artifact ? new _artifactDispatcher.ArtifactDispatcher(this._scope, artifact) : void 0,
            sourceEntries
          };
        });
      }
      tracingStop(params) {
        return __async(this, null, function* () {
          yield this._context.tracing.stop();
        });
      }
      harExport(params) {
        return __async(this, null, function* () {
          var _this$_context$_harRe;
          const artifact = yield (_this$_context$_harRe = this._context._harRecorder) === null || _this$_context$_harRe === void 0 ? void 0 : _this$_context$_harRe.export();
          if (!artifact)
            throw new Error("No HAR artifact. Ensure record.harPath is set.");
          return {
            artifact: new _artifactDispatcher.ArtifactDispatcher(this._scope, artifact)
          };
        });
      }
    };
    exports2.BrowserContextDispatcher = BrowserContextDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/androidDispatcher.js
var require_androidDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/androidDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AndroidSocketDispatcher = exports2.AndroidDeviceDispatcher = exports2.AndroidDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _android = require_android();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var AndroidDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, android) {
        super(scope, android, "Android", {}, true);
        this._type_Android = true;
      }
      devices(params) {
        return __async(this, null, function* () {
          const devices = yield this._object.devices();
          return {
            devices: devices.map((d) => AndroidDeviceDispatcher.from(this._scope, d))
          };
        });
      }
      setDefaultTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._object.setDefaultTimeout(params.timeout);
        });
      }
    };
    exports2.AndroidDispatcher = AndroidDispatcher;
    var AndroidDeviceDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, device) {
        const result = (0, _dispatcher.existingDispatcher)(device);
        return result || new AndroidDeviceDispatcher(scope, device);
      }
      constructor(scope, device) {
        super(scope, device, "AndroidDevice", {
          model: device.model,
          serial: device.serial
        }, true);
        this._type_EventTarget = true;
        this._type_AndroidDevice = true;
        for (const webView of device.webViews())
          this._dispatchEvent("webViewAdded", {
            webView
          });
        device.on(_android.AndroidDevice.Events.WebViewAdded, (webView) => this._dispatchEvent("webViewAdded", {
          webView
        }));
        device.on(_android.AndroidDevice.Events.WebViewRemoved, (pid) => this._dispatchEvent("webViewRemoved", {
          pid
        }));
      }
      wait(params) {
        return __async(this, null, function* () {
          yield this._object.send("wait", params);
        });
      }
      fill(params) {
        return __async(this, null, function* () {
          yield this._object.send("click", {
            selector: params.selector
          });
          yield this._object.send("fill", params);
        });
      }
      tap(params) {
        return __async(this, null, function* () {
          yield this._object.send("click", params);
        });
      }
      drag(params) {
        return __async(this, null, function* () {
          yield this._object.send("drag", params);
        });
      }
      fling(params) {
        return __async(this, null, function* () {
          yield this._object.send("fling", params);
        });
      }
      longTap(params) {
        return __async(this, null, function* () {
          yield this._object.send("longClick", params);
        });
      }
      pinchClose(params) {
        return __async(this, null, function* () {
          yield this._object.send("pinchClose", params);
        });
      }
      pinchOpen(params) {
        return __async(this, null, function* () {
          yield this._object.send("pinchOpen", params);
        });
      }
      scroll(params) {
        return __async(this, null, function* () {
          yield this._object.send("scroll", params);
        });
      }
      swipe(params) {
        return __async(this, null, function* () {
          yield this._object.send("swipe", params);
        });
      }
      info(params) {
        return __async(this, null, function* () {
          return {
            info: yield this._object.send("info", params)
          };
        });
      }
      inputType(params) {
        return __async(this, null, function* () {
          const text = params.text;
          const keyCodes = [];
          for (let i = 0; i < text.length; ++i) {
            const code = keyMap.get(text[i].toUpperCase());
            if (code === void 0)
              throw new Error("No mapping for " + text[i] + " found");
            keyCodes.push(code);
          }
          yield Promise.all(keyCodes.map((keyCode) => this._object.send("inputPress", {
            keyCode
          })));
        });
      }
      inputPress(params) {
        return __async(this, null, function* () {
          if (!keyMap.has(params.key))
            throw new Error("Unknown key: " + params.key);
          yield this._object.send("inputPress", {
            keyCode: keyMap.get(params.key)
          });
        });
      }
      inputTap(params) {
        return __async(this, null, function* () {
          yield this._object.send("inputClick", params);
        });
      }
      inputSwipe(params) {
        return __async(this, null, function* () {
          yield this._object.send("inputSwipe", params);
        });
      }
      inputDrag(params) {
        return __async(this, null, function* () {
          yield this._object.send("inputDrag", params);
        });
      }
      screenshot(params) {
        return __async(this, null, function* () {
          return {
            binary: (yield this._object.screenshot()).toString("base64")
          };
        });
      }
      shell(params) {
        return __async(this, null, function* () {
          return {
            result: (yield this._object.shell(params.command)).toString("base64")
          };
        });
      }
      open(params, metadata) {
        return __async(this, null, function* () {
          const socket = yield this._object.open(params.command);
          return {
            socket: new AndroidSocketDispatcher(this._scope, socket)
          };
        });
      }
      installApk(params) {
        return __async(this, null, function* () {
          yield this._object.installApk(Buffer.from(params.file, "base64"), {
            args: params.args
          });
        });
      }
      push(params) {
        return __async(this, null, function* () {
          yield this._object.push(Buffer.from(params.file, "base64"), params.path, params.mode);
        });
      }
      launchBrowser(params) {
        return __async(this, null, function* () {
          const context = yield this._object.launchBrowser(params.pkg, params);
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
          };
        });
      }
      close(params) {
        return __async(this, null, function* () {
          yield this._object.close();
        });
      }
      setDefaultTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._object.setDefaultTimeout(params.timeout);
        });
      }
      connectToWebView(params) {
        return __async(this, null, function* () {
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, yield this._object.connectToWebView(params.pid))
          };
        });
      }
    };
    exports2.AndroidDeviceDispatcher = AndroidDeviceDispatcher;
    var AndroidSocketDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, socket) {
        super(scope, socket, "AndroidSocket", {}, true);
        this._type_AndroidSocket = true;
        socket.on("data", (data) => this._dispatchEvent("data", {
          data: data.toString("base64")
        }));
        socket.on("close", () => {
          this._dispatchEvent("close");
          this._dispose();
        });
      }
      write(params, metadata) {
        return __async(this, null, function* () {
          yield this._object.write(Buffer.from(params.data, "base64"));
        });
      }
      close(params, metadata) {
        return __async(this, null, function* () {
          this._object.close();
        });
      }
    };
    exports2.AndroidSocketDispatcher = AndroidSocketDispatcher;
    var keyMap = /* @__PURE__ */ new Map([["Unknown", 0], ["SoftLeft", 1], ["SoftRight", 2], ["Home", 3], ["Back", 4], ["Call", 5], ["EndCall", 6], ["0", 7], ["1", 8], ["2", 9], ["3", 10], ["4", 11], ["5", 12], ["6", 13], ["7", 14], ["8", 15], ["9", 16], ["Star", 17], ["*", 17], ["Pound", 18], ["#", 18], ["DialUp", 19], ["DialDown", 20], ["DialLeft", 21], ["DialRight", 22], ["DialCenter", 23], ["VolumeUp", 24], ["VolumeDown", 25], ["Power", 26], ["Camera", 27], ["Clear", 28], ["A", 29], ["B", 30], ["C", 31], ["D", 32], ["E", 33], ["F", 34], ["G", 35], ["H", 36], ["I", 37], ["J", 38], ["K", 39], ["L", 40], ["M", 41], ["N", 42], ["O", 43], ["P", 44], ["Q", 45], ["R", 46], ["S", 47], ["T", 48], ["U", 49], ["V", 50], ["W", 51], ["X", 52], ["Y", 53], ["Z", 54], ["Comma", 55], [",", 55], ["Period", 56], [".", 56], ["AltLeft", 57], ["AltRight", 58], ["ShiftLeft", 59], ["ShiftRight", 60], ["Tab", 61], ["	", 61], ["Space", 62], [" ", 62], ["Sym", 63], ["Explorer", 64], ["Envelop", 65], ["Enter", 66], ["Del", 67], ["Grave", 68], ["Minus", 69], ["-", 69], ["Equals", 70], ["=", 70], ["LeftBracket", 71], ["(", 71], ["RightBracket", 72], [")", 72], ["Backslash", 73], ["\\", 73], ["Semicolon", 74], [";", 74], ["Apostrophe", 75], ["`", 75], ["Slash", 76], ["/", 76], ["At", 77], ["@", 77], ["Num", 78], ["HeadsetHook", 79], ["Focus", 80], ["Plus", 81], ["Menu", 82], ["Notification", 83], ["Search", 84], ["AppSwitch", 187], ["Assist", 219], ["Cut", 277], ["Copy", 278], ["Paste", 279]]);
  }
});

// node_modules/playwright-core/lib/dispatchers/browserDispatcher.js
var require_browserDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/browserDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserDispatcher = void 0;
    var _browser = require_browser2();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _cdpSessionDispatcher = require_cdpSessionDispatcher();
    var _dispatcher = require_dispatcher();
    var BrowserDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browser) {
        super(scope, browser, "Browser", {
          version: browser.version(),
          name: browser.options.name
        }, true);
        this._type_Browser = true;
        browser.on(_browser.Browser.Events.Disconnected, () => this._didClose());
      }
      _didClose() {
        this._dispatchEvent("close");
        this._dispose();
      }
      newContext(params, metadata) {
        return __async(this, null, function* () {
          const context = yield this._object.newContext(params);
          if (params.storageState)
            yield context.setStorageState(metadata, params.storageState);
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
          };
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._object.close();
        });
      }
      killForTests() {
        return __async(this, null, function* () {
          yield this._object.killForTests();
        });
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
          const crBrowser = this._object;
          return {
            session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, yield crBrowser.newBrowserCDPSession())
          };
        });
      }
      startTracing(params) {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          yield crBrowser.startTracing(params.page ? params.page._object : void 0, params);
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          const buffer = yield crBrowser.stopTracing();
          return {
            binary: buffer.toString("base64")
          };
        });
      }
    };
    exports2.BrowserDispatcher = BrowserDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/jsonPipeDispatcher.js
var require_jsonPipeDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/jsonPipeDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JsonPipeDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _utils2 = require_utils();
    var _serializers = require_serializers();
    var JsonPipeDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope) {
        super(scope, {
          guid: "jsonPipe@" + (0, _utils2.createGuid)()
        }, "JsonPipe", {});
        this._type_JsonPipe = true;
      }
      send(params) {
        return __async(this, null, function* () {
          this.emit("message", params.message);
        });
      }
      close() {
        return __async(this, null, function* () {
          this.emit("close");
          if (!this._disposed) {
            this._dispatchEvent("closed", {});
            this._dispose();
          }
        });
      }
      dispatch(message) {
        if (!this._disposed)
          this._dispatchEvent("message", {
            message
          });
      }
      wasClosed(error) {
        if (!this._disposed) {
          const params = error ? {
            error: (0, _serializers.serializeError)(error)
          } : {};
          this._dispatchEvent("closed", params);
          this._dispose();
        }
      }
      dispose() {
        this._dispose();
      }
    };
    exports2.JsonPipeDispatcher = JsonPipeDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/browserTypeDispatcher.js
var require_browserTypeDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/browserTypeDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserTypeDispatcher = void 0;
    var _browserDispatcher = require_browserDispatcher();
    var _dispatcher = require_dispatcher();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _ws = _interopRequireDefault2(require("ws"));
    var _jsonPipeDispatcher = require_jsonPipeDispatcher();
    var _utils2 = require_utils();
    var _async = require_async();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var BrowserTypeDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browserType) {
        super(scope, browserType, "BrowserType", {
          executablePath: browserType.executablePath(),
          name: browserType.name()
        }, true);
        this._type_BrowserType = true;
      }
      launch(params, metadata) {
        return __async(this, null, function* () {
          const browser = yield this._object.launch(metadata, params);
          return {
            browser: new _browserDispatcher.BrowserDispatcher(this._scope, browser)
          };
        });
      }
      launchPersistentContext(params, metadata) {
        return __async(this, null, function* () {
          const browserContext = yield this._object.launchPersistentContext(metadata, params.userDataDir, params);
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, browserContext)
          };
        });
      }
      connectOverCDP(params, metadata) {
        return __async(this, null, function* () {
          const browser = yield this._object.connectOverCDP(metadata, params.endpointURL, params, params.timeout);
          const browserDispatcher = new _browserDispatcher.BrowserDispatcher(this._scope, browser);
          return {
            browser: browserDispatcher,
            defaultContext: browser._defaultContext ? new _browserContextDispatcher.BrowserContextDispatcher(browserDispatcher._scope, browser._defaultContext) : void 0
          };
        });
      }
      connect(params) {
        return __async(this, null, function* () {
          const waitForNextTask = params.slowMo ? (cb) => setTimeout(cb, params.slowMo) : (0, _utils2.makeWaitForNextTask)();
          const paramsHeaders = Object.assign({
            "User-Agent": (0, _utils2.getUserAgent)()
          }, params.headers || {});
          const ws = new _ws.default(params.wsEndpoint, [], {
            perMessageDeflate: false,
            maxPayload: 256 * 1024 * 1024,
            handshakeTimeout: params.timeout,
            headers: paramsHeaders
          });
          const pipe = new _jsonPipeDispatcher.JsonPipeDispatcher(this._scope);
          const openPromise = new _async.ManualPromise();
          ws.on("open", () => openPromise.resolve({
            pipe
          }));
          ws.on("close", () => pipe.wasClosed());
          ws.on("error", (error) => {
            if (openPromise.isDone()) {
              pipe.wasClosed(error);
            } else {
              pipe.dispose();
              openPromise.reject(error);
            }
          });
          pipe.on("close", () => ws.close());
          pipe.on("message", (message) => ws.send(JSON.stringify(message)));
          ws.addEventListener("message", (event) => {
            waitForNextTask(() => {
              try {
                pipe.dispatch(JSON.parse(event.data));
              } catch (e) {
                ws.close();
              }
            });
          });
          return openPromise;
        });
      }
    };
    exports2.BrowserTypeDispatcher = BrowserTypeDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/electronDispatcher.js
var require_electronDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/electronDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElectronApplicationDispatcher = exports2.ElectronDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _electron = require_electron2();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var ElectronDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, electron) {
        super(scope, electron, "Electron", {}, true);
        this._type_Electron = true;
      }
      launch(params) {
        return __async(this, null, function* () {
          const electronApplication = yield this._object.launch(params);
          return {
            electronApplication: new ElectronApplicationDispatcher(this._scope, electronApplication)
          };
        });
      }
    };
    exports2.ElectronDispatcher = ElectronDispatcher;
    var ElectronApplicationDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, electronApplication) {
        super(scope, electronApplication, "ElectronApplication", {
          context: new _browserContextDispatcher.BrowserContextDispatcher(scope, electronApplication.context())
        }, true);
        this._type_EventTarget = true;
        this._type_ElectronApplication = true;
        electronApplication.on(_electron.ElectronApplication.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
      }
      browserWindow(params) {
        return __async(this, null, function* () {
          const handle = yield this._object.browserWindow(params.page.page());
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, handle)
          };
        });
      }
      evaluateExpression(params) {
        return __async(this, null, function* () {
          const handle = yield this._object._nodeElectronHandlePromise;
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evaluateExpressionHandle(params) {
        return __async(this, null, function* () {
          const handle = yield this._object._nodeElectronHandlePromise;
          const result = yield handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false, (0, _jsHandleDispatcher.parseArgument)(params.arg));
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, result)
          };
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._object.close();
        });
      }
    };
    exports2.ElectronApplicationDispatcher = ElectronApplicationDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/localUtilsDispatcher.js
var require_localUtilsDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/localUtilsDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LocalUtilsDispatcher = void 0;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _path2 = _interopRequireDefault2(require("path"));
    var _yauzl = _interopRequireDefault2(require_yauzl());
    var _yazl = _interopRequireDefault2(require_yazl());
    var _async = require_async();
    var _utils2 = require_utils();
    var _dispatcher = require_dispatcher();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var LocalUtilsDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope) {
        super(scope, {
          guid: "localUtils@" + (0, _utils2.createGuid)()
        }, "LocalUtils", {});
        this._type_LocalUtils = void 0;
        this._type_LocalUtils = true;
      }
      zip(params, metadata) {
        return __async(this, null, function* () {
          const promise = new _async.ManualPromise();
          const zipFile = new _yazl.default.ZipFile();
          zipFile.on("error", (error) => promise.reject(error));
          for (const entry of params.entries) {
            try {
              if (_fs2.default.statSync(entry.value).isFile())
                zipFile.addFile(entry.value, entry.name);
            } catch (e) {
            }
          }
          if (!_fs2.default.existsSync(params.zipFile)) {
            yield _fs2.default.promises.mkdir(_path2.default.dirname(params.zipFile), {
              recursive: true
            });
            zipFile.end(void 0, () => {
              zipFile.outputStream.pipe(_fs2.default.createWriteStream(params.zipFile)).on("close", () => promise.resolve());
            });
            return promise;
          }
          const tempFile = params.zipFile + ".tmp";
          yield _fs2.default.promises.rename(params.zipFile, tempFile);
          _yauzl.default.open(tempFile, (err, inZipFile) => {
            if (err) {
              promise.reject(err);
              return;
            }
            (0, _utils2.assert)(inZipFile);
            let pendingEntries = inZipFile.entryCount;
            inZipFile.on("entry", (entry) => {
              inZipFile.openReadStream(entry, (err2, readStream) => {
                if (err2) {
                  promise.reject(err2);
                  return;
                }
                zipFile.addReadStream(readStream, entry.fileName);
                if (--pendingEntries === 0) {
                  zipFile.end(void 0, () => {
                    zipFile.outputStream.pipe(_fs2.default.createWriteStream(params.zipFile)).on("close", () => {
                      _fs2.default.promises.unlink(tempFile).then(() => {
                        promise.resolve();
                      });
                    });
                  });
                }
              });
            });
          });
          return promise;
        });
      }
    };
    exports2.LocalUtilsDispatcher = LocalUtilsDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/selectorsDispatcher.js
var require_selectorsDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/selectorsDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SelectorsDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var SelectorsDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, selectors) {
        super(scope, selectors, "Selectors", {});
        this._type_Selectors = true;
      }
      register(params) {
        return __async(this, null, function* () {
          yield this._object.register(params.name, params.source, params.contentScript);
        });
      }
    };
    exports2.SelectorsDispatcher = SelectorsDispatcher;
  }
});

// node_modules/playwright-core/lib/dispatchers/playwrightDispatcher.js
var require_playwrightDispatcher = __commonJS({
  "node_modules/playwright-core/lib/dispatchers/playwrightDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PlaywrightDispatcher = void 0;
    var _net = _interopRequireDefault2(require("net"));
    var _fetch = require_fetch();
    var _debugLogger = require_debugLogger();
    var _socksProxy = require_socksProxy();
    var _utils2 = require_utils();
    var _androidDispatcher = require_androidDispatcher();
    var _browserTypeDispatcher = require_browserTypeDispatcher();
    var _dispatcher = require_dispatcher();
    var _electronDispatcher = require_electronDispatcher();
    var _localUtilsDispatcher = require_localUtilsDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _selectorsDispatcher = require_selectorsDispatcher();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var PlaywrightDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, playwright2, customSelectors, preLaunchedBrowser) {
        const descriptors = require_deviceDescriptors();
        const deviceDescriptors = Object.entries(descriptors).map(([name, descriptor]) => ({
          name,
          descriptor
        }));
        super(scope, playwright2, "Playwright", {
          chromium: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright2.chromium),
          firefox: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright2.firefox),
          webkit: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright2.webkit),
          android: new _androidDispatcher.AndroidDispatcher(scope, playwright2.android),
          electron: new _electronDispatcher.ElectronDispatcher(scope, playwright2.electron),
          utils: new _localUtilsDispatcher.LocalUtilsDispatcher(scope),
          deviceDescriptors,
          selectors: customSelectors || new _selectorsDispatcher.SelectorsDispatcher(scope, playwright2.selectors),
          preLaunchedBrowser
        }, false);
        this._type_Playwright = void 0;
        this._socksProxy = void 0;
        this._type_Playwright = true;
      }
      enableSocksProxy() {
        return __async(this, null, function* () {
          this._socksProxy = new SocksProxy(this);
          this._object.options.socksProxyPort = yield this._socksProxy.listen(0);
          _debugLogger.debugLogger.log("proxy", `Starting socks proxy server on port ${this._object.options.socksProxyPort}`);
        });
      }
      socksConnected(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy;
          (_this$_socksProxy = this._socksProxy) === null || _this$_socksProxy === void 0 ? void 0 : _this$_socksProxy.socketConnected(params);
        });
      }
      socksFailed(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy2;
          (_this$_socksProxy2 = this._socksProxy) === null || _this$_socksProxy2 === void 0 ? void 0 : _this$_socksProxy2.socketFailed(params);
        });
      }
      socksData(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy3;
          (_this$_socksProxy3 = this._socksProxy) === null || _this$_socksProxy3 === void 0 ? void 0 : _this$_socksProxy3.sendSocketData(params);
        });
      }
      socksError(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy4;
          (_this$_socksProxy4 = this._socksProxy) === null || _this$_socksProxy4 === void 0 ? void 0 : _this$_socksProxy4.sendSocketError(params);
        });
      }
      socksEnd(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy5;
          (_this$_socksProxy5 = this._socksProxy) === null || _this$_socksProxy5 === void 0 ? void 0 : _this$_socksProxy5.sendSocketEnd(params);
        });
      }
      newRequest(params, metadata) {
        return __async(this, null, function* () {
          const request = new _fetch.GlobalAPIRequestContext(this._object, params);
          return {
            request: _networkDispatchers.APIRequestContextDispatcher.from(this._scope, request)
          };
        });
      }
      hideHighlight(params, metadata) {
        return __async(this, null, function* () {
          yield this._object.hideHighlight();
        });
      }
    };
    exports2.PlaywrightDispatcher = PlaywrightDispatcher;
    var SocksProxy = class {
      constructor(dispatcher) {
        this._server = void 0;
        this._connections = /* @__PURE__ */ new Map();
        this._dispatcher = void 0;
        this._dispatcher = dispatcher;
        this._server = new _net.default.Server((socket) => {
          const uid = (0, _utils2.createGuid)();
          const connection = new _socksProxy.SocksConnection(uid, socket, this);
          this._connections.set(uid, connection);
        });
      }
      listen(port) {
        return __async(this, null, function* () {
          return new Promise((f) => {
            this._server.listen(port, () => {
              f(this._server.address().port);
            });
          });
        });
      }
      onSocketRequested(uid, host, port) {
        this._dispatcher._dispatchEvent("socksRequested", {
          uid,
          host,
          port
        });
      }
      onSocketData(uid, data) {
        this._dispatcher._dispatchEvent("socksData", {
          uid,
          data: data.toString("base64")
        });
      }
      onSocketClosed(uid) {
        this._dispatcher._dispatchEvent("socksClosed", {
          uid
        });
      }
      socketConnected(params) {
        var _this$_connections$ge;
        (_this$_connections$ge = this._connections.get(params.uid)) === null || _this$_connections$ge === void 0 ? void 0 : _this$_connections$ge.socketConnected(params.host, params.port);
      }
      socketFailed(params) {
        var _this$_connections$ge2;
        (_this$_connections$ge2 = this._connections.get(params.uid)) === null || _this$_connections$ge2 === void 0 ? void 0 : _this$_connections$ge2.socketFailed(params.errorCode);
      }
      sendSocketData(params) {
        var _this$_connections$ge3;
        (_this$_connections$ge3 = this._connections.get(params.uid)) === null || _this$_connections$ge3 === void 0 ? void 0 : _this$_connections$ge3.sendData(Buffer.from(params.data, "base64"));
      }
      sendSocketEnd(params) {
        var _this$_connections$ge4;
        (_this$_connections$ge4 = this._connections.get(params.uid)) === null || _this$_connections$ge4 === void 0 ? void 0 : _this$_connections$ge4.end();
      }
      sendSocketError(params) {
        var _this$_connections$ge5;
        (_this$_connections$ge5 = this._connections.get(params.uid)) === null || _this$_connections$ge5 === void 0 ? void 0 : _this$_connections$ge5.error(params.error);
      }
    };
  }
});

// node_modules/playwright-core/lib/client/events.js
var require_events = __commonJS({
  "node_modules/playwright-core/lib/client/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Events = void 0;
    var Events = {
      AndroidDevice: {
        WebView: "webview",
        Close: "close"
      },
      AndroidSocket: {
        Data: "data",
        Close: "close"
      },
      AndroidWebView: {
        Close: "close"
      },
      Browser: {
        Disconnected: "disconnected"
      },
      BrowserContext: {
        Close: "close",
        Page: "page",
        BackgroundPage: "backgroundpage",
        ServiceWorker: "serviceworker",
        Request: "request",
        Response: "response",
        RequestFailed: "requestfailed",
        RequestFinished: "requestfinished"
      },
      BrowserServer: {
        Close: "close"
      },
      Page: {
        Close: "close",
        Crash: "crash",
        Console: "console",
        Dialog: "dialog",
        Download: "download",
        FileChooser: "filechooser",
        DOMContentLoaded: "domcontentloaded",
        PageError: "pageerror",
        Request: "request",
        Response: "response",
        RequestFailed: "requestfailed",
        RequestFinished: "requestfinished",
        FrameAttached: "frameattached",
        FrameDetached: "framedetached",
        FrameNavigated: "framenavigated",
        Load: "load",
        Popup: "popup",
        WebSocket: "websocket",
        Worker: "worker"
      },
      WebSocket: {
        Close: "close",
        Error: "socketerror",
        FrameReceived: "framereceived",
        FrameSent: "framesent"
      },
      Worker: {
        Close: "close"
      },
      ElectronApplication: {
        Close: "close",
        Window: "window"
      }
    };
    exports2.Events = Events;
  }
});

// node_modules/playwright-core/lib/client/accessibility.js
var require_accessibility2 = __commonJS({
  "node_modules/playwright-core/lib/client/accessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Accessibility = void 0;
    function axNodeFromProtocol(axNode) {
      const result = __spreadProps(__spreadValues({}, axNode), {
        value: axNode.valueNumber !== void 0 ? axNode.valueNumber : axNode.valueString,
        checked: axNode.checked === "checked" ? true : axNode.checked === "unchecked" ? false : axNode.checked,
        pressed: axNode.pressed === "pressed" ? true : axNode.pressed === "released" ? false : axNode.pressed,
        children: axNode.children ? axNode.children.map(axNodeFromProtocol) : void 0
      });
      delete result.valueNumber;
      delete result.valueString;
      return result;
    }
    var Accessibility = class {
      constructor(channel) {
        this._channel = void 0;
        this._channel = channel;
      }
      snapshot() {
        return __async(this, arguments, function* (options = {}) {
          const root = options.root ? options.root._elementChannel : void 0;
          const result = yield this._channel.accessibilitySnapshot({
            interestingOnly: options.interestingOnly,
            root
          });
          return result.rootAXNode ? axNodeFromProtocol(result.rootAXNode) : null;
        });
      }
    };
    exports2.Accessibility = Accessibility;
  }
});

// node_modules/playwright-core/lib/utils/zones.js
var require_zones = __commonJS({
  "node_modules/playwright-core/lib/utils/zones.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.zones = void 0;
    var _stackTrace = require_stackTrace();
    var ZoneManager = class {
      constructor() {
        this.lastZoneId = 0;
        this._zones = /* @__PURE__ */ new Map();
      }
      run(type, data, func) {
        return __async(this, null, function* () {
          const zone = new Zone(this, ++this.lastZoneId, type, data);
          this._zones.set(zone.id, zone);
          return zone.run(func);
        });
      }
      zoneData(type, rawStack) {
        const stack = rawStack || (0, _stackTrace.captureRawStack)();
        for (const line of stack.split("\n")) {
          const index = line.indexOf("__PWZONE__[");
          if (index !== -1) {
            const zoneId = +line.substring(index + "__PWZONE__[".length, line.indexOf("]", index));
            const zone = this._zones.get(zoneId);
            if (zone && zone.type === type)
              return zone.data;
          }
        }
        return null;
      }
    };
    var Zone = class {
      constructor(manager, id, type, data) {
        this._manager = void 0;
        this.id = void 0;
        this.type = void 0;
        this.data = {};
        this._manager = manager;
        this.id = id;
        this.type = type;
        this.data = data;
      }
      run(func) {
        return __async(this, null, function* () {
          Object.defineProperty(func, "name", {
            value: `__PWZONE__[${this.id}]`
          });
          try {
            return yield func();
          } finally {
            this._manager._zones.delete(this.id);
          }
        });
      }
    };
    var zones = new ZoneManager();
    exports2.zones = zones;
  }
});

// node_modules/playwright-core/lib/client/channelOwner.js
var require_channelOwner = __commonJS({
  "node_modules/playwright-core/lib/client/channelOwner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.renderCallWithParams = renderCallWithParams;
    exports2.ChannelOwner = void 0;
    var _events = require("events");
    var _validator = require_validator();
    var _debugLogger = require_debugLogger();
    var _stackTrace = require_stackTrace();
    var _utils2 = require_utils();
    var _zones = require_zones();
    var ChannelOwner = class extends _events.EventEmitter {
      constructor(parent, type, guid, initializer, instrumentation) {
        var _this$_parent;
        super();
        this._connection = void 0;
        this._parent = void 0;
        this._objects = /* @__PURE__ */ new Map();
        this._type = void 0;
        this._guid = void 0;
        this._channel = void 0;
        this._initializer = void 0;
        this._logger = void 0;
        this._instrumentation = void 0;
        this.setMaxListeners(0);
        this._connection = parent instanceof ChannelOwner ? parent._connection : parent;
        this._type = type;
        this._guid = guid;
        this._parent = parent instanceof ChannelOwner ? parent : void 0;
        this._instrumentation = instrumentation || ((_this$_parent = this._parent) === null || _this$_parent === void 0 ? void 0 : _this$_parent._instrumentation);
        this._connection._objects.set(guid, this);
        if (this._parent) {
          this._parent._objects.set(guid, this);
          this._logger = this._parent._logger;
        }
        this._channel = this._createChannel(new _events.EventEmitter());
        this._initializer = initializer;
      }
      _dispose() {
        if (this._parent)
          this._parent._objects.delete(this._guid);
        this._connection._objects.delete(this._guid);
        for (const object of [...this._objects.values()])
          object._dispose();
        this._objects.clear();
      }
      _debugScopeState() {
        return {
          _guid: this._guid,
          objects: Array.from(this._objects.values()).map((o) => o._debugScopeState())
        };
      }
      _createChannel(base) {
        const channel = new Proxy(base, {
          get: (obj, prop) => {
            if (prop === "debugScopeState")
              return (params) => this._connection.sendMessageToServer(this, prop, params, null);
            if (typeof prop === "string") {
              const validator = scheme[paramsName(this._type, prop)];
              if (validator) {
                return (params) => {
                  return this._wrapApiCall((apiZone) => {
                    const {
                      stackTrace,
                      csi,
                      callCookie
                    } = apiZone.reported ? {
                      csi: void 0,
                      callCookie: void 0,
                      stackTrace: null
                    } : apiZone;
                    apiZone.reported = true;
                    if (csi && stackTrace && stackTrace.apiName)
                      csi.onApiCallBegin(renderCallWithParams(stackTrace.apiName, params), stackTrace, callCookie);
                    return this._connection.sendMessageToServer(this, prop, validator(params, ""), stackTrace);
                  });
                };
              }
            }
            return obj[prop];
          }
        });
        channel._object = this;
        return channel;
      }
      _wrapApiCall(func, isInternal = false) {
        return __async(this, null, function* () {
          const logger = this._logger;
          const stack = (0, _stackTrace.captureRawStack)();
          const apiZone = _zones.zones.zoneData("apiZone", stack);
          if (apiZone)
            return func(apiZone);
          const stackTrace = (0, _stackTrace.captureStackTrace)(stack);
          if (isInternal)
            delete stackTrace.apiName;
          const csi = isInternal ? void 0 : this._instrumentation;
          const callCookie = {};
          const {
            apiName,
            frameTexts
          } = stackTrace;
          try {
            logApiCall(logger, `=> ${apiName} started`, isInternal);
            const apiZone2 = {
              stackTrace,
              isInternal,
              reported: false,
              csi,
              callCookie
            };
            const result = yield _zones.zones.run("apiZone", apiZone2, () => __async(this, null, function* () {
              return yield func(apiZone2);
            }));
            csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie);
            logApiCall(logger, `<= ${apiName} succeeded`, isInternal);
            return result;
          } catch (e) {
            const innerError = (process.env.PWDEBUGIMPL || (0, _utils2.isUnderTest)()) && e.stack ? "\n<inner error>\n" + e.stack : "";
            e.message = apiName + ": " + e.message;
            e.stack = e.message + "\n" + frameTexts.join("\n") + innerError;
            csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie, e);
            logApiCall(logger, `<= ${apiName} failed`, isInternal);
            throw e;
          }
        });
      }
      toJSON() {
        return {
          _type: this._type,
          _guid: this._guid
        };
      }
    };
    exports2.ChannelOwner = ChannelOwner;
    function logApiCall(logger, message, isNested) {
      if (isNested)
        return;
      if (logger && logger.isEnabled("api", "info"))
        logger.log("api", "info", message, [], {
          color: "cyan"
        });
      _debugLogger.debugLogger.log("api", message);
    }
    function paramsName(type, method) {
      return type + method[0].toUpperCase() + method.substring(1) + "Params";
    }
    var paramsToRender = ["url", "selector", "text", "key"];
    function renderCallWithParams(apiName, params) {
      const paramsArray = [];
      if (params) {
        for (const name of paramsToRender) {
          if (params[name])
            paramsArray.push(params[name]);
        }
      }
      const paramsText = paramsArray.length ? "(" + paramsArray.join(", ") + ")" : "";
      return apiName + paramsText;
    }
    var tChannel = (name) => {
      return (arg, path) => {
        if (arg._object instanceof ChannelOwner && (name === "*" || arg._object._type === name))
          return {
            guid: arg._object._guid
          };
        throw new _validator.ValidationError(`${path}: expected ${name}`);
      };
    };
    var scheme = (0, _validator.createScheme)(tChannel);
  }
});

// node_modules/playwright-core/lib/client/jsHandle.js
var require_jsHandle = __commonJS({
  "node_modules/playwright-core/lib/client/jsHandle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.serializeArgument = serializeArgument;
    exports2.parseResult = parseResult;
    exports2.assertMaxArguments = assertMaxArguments;
    exports2.JSHandle = void 0;
    var _channelOwner = require_channelOwner();
    var _serializers = require_serializers();
    var JSHandle = class extends _channelOwner.ChannelOwner {
      static from(handle) {
        return handle._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._preview = void 0;
        this._preview = this._initializer.preview;
        this._channel.on("previewUpdated", ({
          preview
        }) => this._preview = preview);
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: serializeArgument(arg)
          });
          return parseResult(result.value);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: serializeArgument(arg)
          });
          return JSHandle.from(result.handle);
        });
      }
      getProperty(propertyName) {
        return __async(this, null, function* () {
          const result = yield this._channel.getProperty({
            name: propertyName
          });
          return JSHandle.from(result.handle);
        });
      }
      getProperties() {
        return __async(this, null, function* () {
          const map = /* @__PURE__ */ new Map();
          for (const {
            name,
            value
          } of (yield this._channel.getPropertyList()).properties)
            map.set(name, JSHandle.from(value));
          return map;
        });
      }
      jsonValue() {
        return __async(this, null, function* () {
          return parseResult((yield this._channel.jsonValue()).value);
        });
      }
      asElement() {
        return null;
      }
      dispose() {
        return __async(this, null, function* () {
          return yield this._channel.dispose();
        });
      }
      toString() {
        return this._preview;
      }
    };
    exports2.JSHandle = JSHandle;
    function serializeArgument(arg) {
      const handles = [];
      const pushHandle = (channel) => {
        handles.push(channel);
        return handles.length - 1;
      };
      const value = (0, _serializers.serializeValue)(arg, (value2) => {
        if (value2 instanceof JSHandle)
          return {
            h: pushHandle(value2._channel)
          };
        return {
          fallThrough: value2
        };
      }, /* @__PURE__ */ new Set());
      return {
        value,
        handles
      };
    }
    function parseResult(value) {
      return (0, _serializers.parseSerializedValue)(value, void 0);
    }
    function assertMaxArguments(count, max) {
      if (count > max)
        throw new Error("Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.");
    }
  }
});

// node_modules/playwright-core/lib/client/consoleMessage.js
var require_consoleMessage = __commonJS({
  "node_modules/playwright-core/lib/client/consoleMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConsoleMessage = void 0;
    var util = _interopRequireWildcard2(require("util"));
    var _jsHandle = require_jsHandle();
    var _channelOwner = require_channelOwner();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var ConsoleMessage = class extends _channelOwner.ChannelOwner {
      static from(message) {
        return message._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      type() {
        return this._initializer.type;
      }
      text() {
        return this._initializer.text;
      }
      args() {
        return this._initializer.args.map(_jsHandle.JSHandle.from);
      }
      location() {
        return this._initializer.location;
      }
      [util.inspect.custom]() {
        return this.text();
      }
    };
    exports2.ConsoleMessage = ConsoleMessage;
  }
});

// node_modules/playwright-core/lib/client/dialog.js
var require_dialog2 = __commonJS({
  "node_modules/playwright-core/lib/client/dialog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Dialog = void 0;
    var _channelOwner = require_channelOwner();
    var Dialog = class extends _channelOwner.ChannelOwner {
      static from(dialog) {
        return dialog._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      type() {
        return this._initializer.type;
      }
      message() {
        return this._initializer.message;
      }
      defaultValue() {
        return this._initializer.defaultValue;
      }
      accept(promptText) {
        return __async(this, null, function* () {
          yield this._channel.accept({
            promptText
          });
        });
      }
      dismiss() {
        return __async(this, null, function* () {
          yield this._channel.dismiss();
        });
      }
    };
    exports2.Dialog = Dialog;
  }
});

// node_modules/playwright-core/lib/client/download.js
var require_download2 = __commonJS({
  "node_modules/playwright-core/lib/client/download.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Download = void 0;
    var Download = class {
      constructor(page, url, suggestedFilename, artifact) {
        this._page = void 0;
        this._url = void 0;
        this._suggestedFilename = void 0;
        this._artifact = void 0;
        this._page = page;
        this._url = url;
        this._suggestedFilename = suggestedFilename;
        this._artifact = artifact;
      }
      page() {
        return this._page;
      }
      url() {
        return this._url;
      }
      suggestedFilename() {
        return this._suggestedFilename;
      }
      path() {
        return __async(this, null, function* () {
          return this._artifact.pathAfterFinished();
        });
      }
      saveAs(path) {
        return __async(this, null, function* () {
          return this._artifact.saveAs(path);
        });
      }
      failure() {
        return __async(this, null, function* () {
          return this._artifact.failure();
        });
      }
      createReadStream() {
        return __async(this, null, function* () {
          return this._artifact.createReadStream();
        });
      }
      cancel() {
        return __async(this, null, function* () {
          return this._artifact.cancel();
        });
      }
      delete() {
        return __async(this, null, function* () {
          return this._artifact.delete();
        });
      }
    };
    exports2.Download = Download;
  }
});

// node_modules/playwright-core/lib/client/locator.js
var require_locator = __commonJS({
  "node_modules/playwright-core/lib/client/locator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FrameLocator = exports2.Locator = void 0;
    var util = _interopRequireWildcard2(require("util"));
    var _utils2 = require_utils();
    var _elementHandle = require_elementHandle();
    var _jsHandle = require_jsHandle();
    var _stringUtils = require_stringUtils();
    var _util$inspect$custom;
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    _util$inspect$custom = util.inspect.custom;
    var Locator = class {
      constructor(frame, selector, options) {
        this._frame = void 0;
        this._selector = void 0;
        this._frame = frame;
        this._selector = selector;
        if (options !== null && options !== void 0 && options.hasText) {
          const text = options.hasText;
          if ((0, _utils2.isRegExp)(text))
            this._selector += ` >> :scope:text-matches(${(0, _stringUtils.escapeWithQuotes)(text.source, '"')}, "${text.flags}")`;
          else
            this._selector += ` >> :scope:has-text(${(0, _stringUtils.escapeWithQuotes)(text, '"')})`;
        }
      }
      _withElement(task, timeout) {
        return __async(this, null, function* () {
          timeout = this._frame.page()._timeoutSettings.timeout({
            timeout
          });
          const deadline = timeout ? (0, _utils2.monotonicTime)() + timeout : 0;
          return this._frame._wrapApiCall(() => __async(this, null, function* () {
            const result = yield this._frame._channel.waitForSelector({
              selector: this._selector,
              strict: true,
              state: "attached",
              timeout
            });
            const handle = _elementHandle.ElementHandle.fromNullable(result.element);
            if (!handle)
              throw new Error(`Could not resolve ${this._selector} to DOM Element`);
            try {
              return yield task(handle, deadline ? deadline - (0, _utils2.monotonicTime)() : 0);
            } finally {
              yield handle.dispose();
            }
          }));
        });
      }
      boundingBox(options) {
        return __async(this, null, function* () {
          return this._withElement((h) => h.boundingBox(), options === null || options === void 0 ? void 0 : options.timeout);
        });
      }
      check() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.check(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      click() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.click(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      dblclick() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.dblclick(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      dispatchEvent(_0) {
        return __async(this, arguments, function* (type, eventInit = {}, options) {
          return this._frame.dispatchEvent(this._selector, type, eventInit, __spreadValues({
            strict: true
          }, options));
        });
      }
      dragTo(_0) {
        return __async(this, arguments, function* (target, options = {}) {
          return this._frame.dragAndDrop(this._selector, target._selector, __spreadProps(__spreadValues({}, options), {
            strict: true
          }));
        });
      }
      evaluate(pageFunction, arg, options) {
        return __async(this, null, function* () {
          return this._withElement((h) => h.evaluate(pageFunction, arg), options === null || options === void 0 ? void 0 : options.timeout);
        });
      }
      evaluateAll(pageFunction, arg) {
        return __async(this, null, function* () {
          return this._frame.$$eval(this._selector, pageFunction, arg);
        });
      }
      evaluateHandle(pageFunction, arg, options) {
        return __async(this, null, function* () {
          return this._withElement((h) => h.evaluateHandle(pageFunction, arg), options === null || options === void 0 ? void 0 : options.timeout);
        });
      }
      fill(_0) {
        return __async(this, arguments, function* (value, options = {}) {
          return this._frame.fill(this._selector, value, __spreadValues({
            strict: true
          }, options));
        });
      }
      _highlight() {
        return __async(this, null, function* () {
          return this._frame._highlight(this._selector);
        });
      }
      locator(selector, options) {
        return new Locator(this._frame, this._selector + " >> " + selector, options);
      }
      frameLocator(selector) {
        return new FrameLocator(this._frame, this._selector + " >> " + selector);
      }
      elementHandle(options) {
        return __async(this, null, function* () {
          return yield this._frame.waitForSelector(this._selector, __spreadValues({
            strict: true,
            state: "attached"
          }, options));
        });
      }
      elementHandles() {
        return __async(this, null, function* () {
          return this._frame.$$(this._selector);
        });
      }
      first() {
        return new Locator(this._frame, this._selector + " >> nth=0");
      }
      last() {
        return new Locator(this._frame, this._selector + ` >> nth=-1`);
      }
      nth(index) {
        return new Locator(this._frame, this._selector + ` >> nth=${index}`);
      }
      focus(options) {
        return __async(this, null, function* () {
          return this._frame.focus(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      count() {
        return __async(this, null, function* () {
          return this._frame._queryCount(this._selector);
        });
      }
      getAttribute(name, options) {
        return __async(this, null, function* () {
          return this._frame.getAttribute(this._selector, name, __spreadValues({
            strict: true
          }, options));
        });
      }
      hover() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.hover(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      innerHTML(options) {
        return __async(this, null, function* () {
          return this._frame.innerHTML(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      innerText(options) {
        return __async(this, null, function* () {
          return this._frame.innerText(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      inputValue(options) {
        return __async(this, null, function* () {
          return this._frame.inputValue(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isChecked(options) {
        return __async(this, null, function* () {
          return this._frame.isChecked(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isDisabled(options) {
        return __async(this, null, function* () {
          return this._frame.isDisabled(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isEditable(options) {
        return __async(this, null, function* () {
          return this._frame.isEditable(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isEnabled(options) {
        return __async(this, null, function* () {
          return this._frame.isEnabled(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isHidden(options) {
        return __async(this, null, function* () {
          return this._frame.isHidden(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isVisible(options) {
        return __async(this, null, function* () {
          return this._frame.isVisible(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          return this._frame.press(this._selector, key, __spreadValues({
            strict: true
          }, options));
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          return this._withElement((h, timeout) => h.screenshot(__spreadProps(__spreadValues({}, options), {
            timeout
          })), options.timeout);
        });
      }
      scrollIntoViewIfNeeded() {
        return __async(this, arguments, function* (options = {}) {
          return this._withElement((h, timeout) => h.scrollIntoViewIfNeeded(__spreadProps(__spreadValues({}, options), {
            timeout
          })), options.timeout);
        });
      }
      selectOption(_0) {
        return __async(this, arguments, function* (values, options = {}) {
          return this._frame.selectOption(this._selector, values, __spreadValues({
            strict: true
          }, options));
        });
      }
      selectText() {
        return __async(this, arguments, function* (options = {}) {
          return this._withElement((h, timeout) => h.selectText(__spreadProps(__spreadValues({}, options), {
            timeout
          })), options.timeout);
        });
      }
      setChecked(checked, options) {
        return __async(this, null, function* () {
          if (checked)
            yield this.check(options);
          else
            yield this.uncheck(options);
        });
      }
      setInputFiles(_0) {
        return __async(this, arguments, function* (files, options = {}) {
          return this._frame.setInputFiles(this._selector, files, __spreadValues({
            strict: true
          }, options));
        });
      }
      tap() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.tap(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      textContent(options) {
        return __async(this, null, function* () {
          return this._frame.textContent(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      type(_0) {
        return __async(this, arguments, function* (text, options = {}) {
          return this._frame.type(this._selector, text, __spreadValues({
            strict: true
          }, options));
        });
      }
      uncheck() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.uncheck(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      allInnerTexts() {
        return __async(this, null, function* () {
          return this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.innerText));
        });
      }
      allTextContents() {
        return __async(this, null, function* () {
          return this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.textContent || ""));
        });
      }
      waitFor(options) {
        return __async(this, null, function* () {
          yield this._frame._channel.waitForSelector(__spreadValues({
            selector: this._selector,
            strict: true,
            omitReturnValue: true
          }, options));
        });
      }
      _expect(expression, options) {
        return __async(this, null, function* () {
          const params = __spreadProps(__spreadValues({
            selector: this._selector,
            expression
          }, options), {
            isNot: !!options.isNot
          });
          if (options.expectedValue)
            params.expectedValue = (0, _jsHandle.serializeArgument)(options.expectedValue);
          const result = yield this._frame._channel.expect(params);
          if (result.received !== void 0)
            result.received = (0, _jsHandle.parseResult)(result.received);
          return result;
        });
      }
      [_util$inspect$custom]() {
        return this.toString();
      }
      toString() {
        return `Locator@${this._selector}`;
      }
    };
    exports2.Locator = Locator;
    var FrameLocator = class {
      constructor(frame, selector) {
        this._frame = void 0;
        this._frameSelector = void 0;
        this._frame = frame;
        this._frameSelector = selector;
      }
      locator(selector, options) {
        return new Locator(this._frame, this._frameSelector + " >> control=enter-frame >> " + selector, options);
      }
      frameLocator(selector) {
        return new FrameLocator(this._frame, this._frameSelector + " >> control=enter-frame >> " + selector);
      }
      first() {
        return new FrameLocator(this._frame, this._frameSelector + " >> nth=0");
      }
      last() {
        return new FrameLocator(this._frame, this._frameSelector + ` >> nth=-1`);
      }
      nth(index) {
        return new FrameLocator(this._frame, this._frameSelector + ` >> nth=${index}`);
      }
    };
    exports2.FrameLocator = FrameLocator;
  }
});

// node_modules/playwright-core/lib/client/waiter.js
var require_waiter = __commonJS({
  "node_modules/playwright-core/lib/client/waiter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Waiter = void 0;
    var _stackTrace = require_stackTrace();
    var _errors = require_errors();
    var _utils2 = require_utils();
    var Waiter = class {
      constructor(channelOwner, event) {
        this._dispose = void 0;
        this._failures = [];
        this._immediateError = void 0;
        this._logs = [];
        this._channelOwner = void 0;
        this._waitId = void 0;
        this._error = void 0;
        this._waitId = (0, _utils2.createGuid)();
        this._channelOwner = channelOwner;
        this._channelOwner._channel.waitForEventInfo({
          info: {
            waitId: this._waitId,
            phase: "before",
            event
          }
        }).catch(() => {
        });
        this._dispose = [() => this._channelOwner._wrapApiCall(() => __async(this, null, function* () {
          yield this._channelOwner._channel.waitForEventInfo({
            info: {
              waitId: this._waitId,
              phase: "after",
              error: this._error
            }
          });
        }), true).catch(() => {
        })];
      }
      static createForEvent(channelOwner, event) {
        return new Waiter(channelOwner, event);
      }
      waitForEvent(emitter, event, predicate) {
        return __async(this, null, function* () {
          const {
            promise,
            dispose
          } = waitForEvent(emitter, event, predicate);
          return this.waitForPromise(promise, dispose);
        });
      }
      rejectOnEvent(emitter, event, error, predicate) {
        const {
          promise,
          dispose
        } = waitForEvent(emitter, event, predicate);
        this._rejectOn(promise.then(() => {
          throw error;
        }), dispose);
      }
      rejectOnTimeout(timeout, message) {
        if (!timeout)
          return;
        const {
          promise,
          dispose
        } = waitForTimeout(timeout);
        this._rejectOn(promise.then(() => {
          throw new _errors.TimeoutError(message);
        }), dispose);
      }
      rejectImmediately(error) {
        this._immediateError = error;
      }
      dispose() {
        for (const dispose of this._dispose)
          dispose();
      }
      waitForPromise(promise, dispose) {
        return __async(this, null, function* () {
          try {
            if (this._immediateError)
              throw this._immediateError;
            const result = yield Promise.race([promise, ...this._failures]);
            if (dispose)
              dispose();
            return result;
          } catch (e) {
            if (dispose)
              dispose();
            this._error = e.message;
            this.dispose();
            (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(this._logs));
            throw e;
          }
        });
      }
      log(s) {
        this._logs.push(s);
        this._channelOwner._wrapApiCall(() => __async(this, null, function* () {
          yield this._channelOwner._channel.waitForEventInfo({
            info: {
              waitId: this._waitId,
              phase: "log",
              message: s
            }
          }).catch(() => {
          });
        }), true);
      }
      _rejectOn(promise, dispose) {
        this._failures.push(promise);
        if (dispose)
          this._dispose.push(dispose);
      }
    };
    exports2.Waiter = Waiter;
    function waitForEvent(emitter, event, predicate) {
      let listener;
      const promise = new Promise((resolve, reject) => {
        listener = (eventArg) => __async(this, null, function* () {
          try {
            if (predicate && !(yield predicate(eventArg)))
              return;
            emitter.removeListener(event, listener);
            resolve(eventArg);
          } catch (e) {
            emitter.removeListener(event, listener);
            reject(e);
          }
        });
        emitter.addListener(event, listener);
      });
      const dispose = () => emitter.removeListener(event, listener);
      return {
        promise,
        dispose
      };
    }
    function waitForTimeout(timeout) {
      let timeoutId;
      const promise = new Promise((resolve) => timeoutId = setTimeout(resolve, timeout));
      const dispose = () => clearTimeout(timeoutId);
      return {
        promise,
        dispose
      };
    }
    function formatLogRecording(log) {
      if (!log.length)
        return "";
      const header = ` logs `;
      const headerLength = 60;
      const leftLength = (headerLength - header.length) / 2;
      const rightLength = headerLength - header.length - leftLength;
      return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log.join("\n")}
${"=".repeat(headerLength)}`;
    }
  }
});

// node_modules/playwright-core/lib/client/clientHelper.js
var require_clientHelper = __commonJS({
  "node_modules/playwright-core/lib/client/clientHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.deprecate = deprecate;
    exports2.envObjectToArray = envObjectToArray;
    exports2.evaluationScript = evaluationScript;
    exports2.parsedURL = parsedURL;
    exports2.urlMatches = urlMatches;
    exports2.globToRegex = globToRegex;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _utils2 = require_utils();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var deprecatedHits = /* @__PURE__ */ new Set();
    function deprecate(methodName, message) {
      if (deprecatedHits.has(methodName))
        return;
      deprecatedHits.add(methodName);
      console.warn(message);
    }
    function envObjectToArray(env) {
      const result = [];
      for (const name in env) {
        if (!Object.is(env[name], void 0))
          result.push({
            name,
            value: String(env[name])
          });
      }
      return result;
    }
    function evaluationScript(fun, arg, addSourceUrl = true) {
      return __async(this, null, function* () {
        if (typeof fun === "function") {
          const source = fun.toString();
          const argString = Object.is(arg, void 0) ? "undefined" : JSON.stringify(arg);
          return `(${source})(${argString})`;
        }
        if (arg !== void 0)
          throw new Error("Cannot evaluate a string with arguments");
        if ((0, _utils2.isString)(fun))
          return fun;
        if (fun.content !== void 0)
          return fun.content;
        if (fun.path !== void 0) {
          let source = yield _fs2.default.promises.readFile(fun.path, "utf8");
          if (addSourceUrl)
            source += "//# sourceURL=" + fun.path.replace(/\n/g, "");
          return source;
        }
        throw new Error("Either path or content property must be present");
      });
    }
    function parsedURL(url) {
      try {
        return new URL(url);
      } catch (e) {
        return null;
      }
    }
    function urlMatches(baseURL, urlString, match) {
      if (match === void 0 || match === "")
        return true;
      if ((0, _utils2.isString)(match) && !match.startsWith("*"))
        match = (0, _utils2.constructURLBasedOnBaseURL)(baseURL, match);
      if ((0, _utils2.isString)(match))
        match = globToRegex(match);
      if ((0, _utils2.isRegExp)(match))
        return match.test(urlString);
      if (typeof match === "string" && match === urlString)
        return true;
      const url = parsedURL(urlString);
      if (!url)
        return false;
      if (typeof match === "string")
        return url.pathname === match;
      if (typeof match !== "function")
        throw new Error("url parameter should be string, RegExp or function");
      return match(url);
    }
    var escapeGlobChars = /* @__PURE__ */ new Set(["/", "$", "^", "+", ".", "(", ")", "=", "!", "|"]);
    function globToRegex(glob) {
      const tokens = ["^"];
      let inGroup;
      for (let i = 0; i < glob.length; ++i) {
        const c = glob[i];
        if (escapeGlobChars.has(c)) {
          tokens.push("\\" + c);
          continue;
        }
        if (c === "*") {
          const beforeDeep = glob[i - 1];
          let starCount = 1;
          while (glob[i + 1] === "*") {
            starCount++;
            i++;
          }
          const afterDeep = glob[i + 1];
          const isDeep = starCount > 1 && (beforeDeep === "/" || beforeDeep === void 0) && (afterDeep === "/" || afterDeep === void 0);
          if (isDeep) {
            tokens.push("((?:[^/]*(?:/|$))*)");
            i++;
          } else {
            tokens.push("([^/]*)");
          }
          continue;
        }
        switch (c) {
          case "?":
            tokens.push(".");
            break;
          case "{":
            inGroup = true;
            tokens.push("(");
            break;
          case "}":
            inGroup = false;
            tokens.push(")");
            break;
          case ",":
            if (inGroup) {
              tokens.push("|");
              break;
            }
            tokens.push("\\" + c);
            break;
          default:
            tokens.push(c);
        }
      }
      tokens.push("$");
      return new RegExp(tokens.join(""));
    }
  }
});

// node_modules/playwright-core/lib/utils/multimap.js
var require_multimap = __commonJS({
  "node_modules/playwright-core/lib/utils/multimap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.MultiMap = void 0;
    var MultiMap = class {
      constructor() {
        this._map = void 0;
        this._map = /* @__PURE__ */ new Map();
      }
      set(key, value) {
        let values = this._map.get(key);
        if (!values) {
          values = [];
          this._map.set(key, values);
        }
        values.push(value);
      }
      get(key) {
        return this._map.get(key) || [];
      }
      has(key) {
        return this._map.has(key);
      }
      hasValue(key, value) {
        const values = this._map.get(key);
        if (!values)
          return false;
        return values.includes(value);
      }
      get size() {
        return this._map.size;
      }
      keys() {
        return this._map.keys();
      }
      values() {
        const result = [];
        for (const key of this.keys())
          result.push(...this.get(key));
        return result;
      }
      clear() {
        this._map.clear();
      }
    };
    exports2.MultiMap = MultiMap;
  }
});

// node_modules/playwright-core/lib/client/clientInstrumentation.js
var require_clientInstrumentation = __commonJS({
  "node_modules/playwright-core/lib/client/clientInstrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createInstrumentation = createInstrumentation;
    function createInstrumentation() {
      const listeners = [];
      return new Proxy({}, {
        get: (obj, prop) => {
          if (prop === "addListener")
            return (listener) => listeners.push(listener);
          if (prop === "removeListener")
            return (listener) => listeners.splice(listeners.indexOf(listener), 1);
          if (prop === "removeAllListeners")
            return () => listeners.splice(0, listeners.length);
          if (!prop.startsWith("on"))
            return obj[prop];
          return (...params) => __async(this, null, function* () {
            for (const listener of listeners) {
              var _prop, _ref;
              yield (_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, ...params);
            }
          });
        }
      });
    }
  }
});

// node_modules/playwright-core/lib/client/fetch.js
var require_fetch2 = __commonJS({
  "node_modules/playwright-core/lib/client/fetch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.APIResponse = exports2.APIRequestContext = exports2.APIRequest = void 0;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _path2 = _interopRequireDefault2(require("path"));
    var util = _interopRequireWildcard2(require("util"));
    var _errors = require_errors();
    var _utils2 = require_utils();
    var _channelOwner = require_channelOwner();
    var network = _interopRequireWildcard2(require_network2());
    var _clientInstrumentation = require_clientInstrumentation();
    var _util$inspect$custom;
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var APIRequest = class {
      constructor(playwright2) {
        this._playwright = void 0;
        this._contexts = /* @__PURE__ */ new Set();
        this._onDidCreateContext = void 0;
        this._onWillCloseContext = void 0;
        this._playwright = playwright2;
      }
      newContext() {
        return __async(this, arguments, function* (options = {}) {
          var _this$_onDidCreateCon;
          const storageState = typeof options.storageState === "string" ? JSON.parse(yield _fs2.default.promises.readFile(options.storageState, "utf8")) : options.storageState;
          const context = APIRequestContext.from((yield this._playwright._channel.newRequest(__spreadProps(__spreadValues({}, options), {
            extraHTTPHeaders: options.extraHTTPHeaders ? (0, _utils2.headersObjectToArray)(options.extraHTTPHeaders) : void 0,
            storageState
          }))).request);
          this._contexts.add(context);
          yield (_this$_onDidCreateCon = this._onDidCreateContext) === null || _this$_onDidCreateCon === void 0 ? void 0 : _this$_onDidCreateCon.call(this, context);
          return context;
        });
      }
    };
    exports2.APIRequest = APIRequest;
    var APIRequestContext = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer, (0, _clientInstrumentation.createInstrumentation)());
        this._request = void 0;
        if (parent instanceof APIRequest)
          this._request = parent;
      }
      dispose() {
        return __async(this, null, function* () {
          var _this$_request, _this$_request$_onWil, _this$_request2;
          yield (_this$_request = this._request) === null || _this$_request === void 0 ? void 0 : (_this$_request$_onWil = _this$_request._onWillCloseContext) === null || _this$_request$_onWil === void 0 ? void 0 : _this$_request$_onWil.call(_this$_request, this);
          yield this._channel.dispose();
          (_this$_request2 = this._request) === null || _this$_request2 === void 0 ? void 0 : _this$_request2._contexts.delete(this);
        });
      }
      delete(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "DELETE"
          }));
        });
      }
      head(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "HEAD"
          }));
        });
      }
      get(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "GET"
          }));
        });
      }
      patch(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "PATCH"
          }));
        });
      }
      post(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "POST"
          }));
        });
      }
      put(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "PUT"
          }));
        });
      }
      fetch(_0) {
        return __async(this, arguments, function* (urlOrRequest, options = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const request = urlOrRequest instanceof network.Request ? urlOrRequest : void 0;
            (0, _utils2.assert)(request || typeof urlOrRequest === "string", "First argument must be either URL string or Request");
            (0, _utils2.assert)((options.data === void 0 ? 0 : 1) + (options.form === void 0 ? 0 : 1) + (options.multipart === void 0 ? 0 : 1) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
            const url = request ? request.url() : urlOrRequest;
            const params = (0, _utils2.objectToArray)(options.params);
            const method = options.method || (request === null || request === void 0 ? void 0 : request.method());
            const headersObj = options.headers || (request === null || request === void 0 ? void 0 : request.headers());
            const headers = headersObj ? (0, _utils2.headersObjectToArray)(headersObj) : void 0;
            let jsonData;
            let formData;
            let multipartData;
            let postDataBuffer;
            if (options.data !== void 0) {
              if ((0, _utils2.isString)(options.data)) {
                if (isJsonContentType(headers))
                  jsonData = options.data;
                else
                  postDataBuffer = Buffer.from(options.data, "utf8");
              } else if (Buffer.isBuffer(options.data)) {
                postDataBuffer = options.data;
              } else if (typeof options.data === "object" || typeof options.data === "number" || typeof options.data === "boolean") {
                jsonData = options.data;
              } else {
                throw new Error(`Unexpected 'data' type`);
              }
            } else if (options.form) {
              formData = (0, _utils2.objectToArray)(options.form);
            } else if (options.multipart) {
              multipartData = [];
              for (const [name, value] of Object.entries(options.multipart)) {
                if ((0, _utils2.isFilePayload)(value)) {
                  const payload = value;
                  if (!Buffer.isBuffer(payload.buffer))
                    throw new Error(`Unexpected buffer type of 'data.${name}'`);
                  multipartData.push({
                    name,
                    file: filePayloadToJson(payload)
                  });
                } else if (value instanceof _fs2.default.ReadStream) {
                  multipartData.push({
                    name,
                    file: yield readStreamToJson(value)
                  });
                } else {
                  multipartData.push({
                    name,
                    value: String(value)
                  });
                }
              }
            }
            if (postDataBuffer === void 0 && jsonData === void 0 && formData === void 0 && multipartData === void 0)
              postDataBuffer = (request === null || request === void 0 ? void 0 : request.postDataBuffer()) || void 0;
            const postData = postDataBuffer ? postDataBuffer.toString("base64") : void 0;
            const result = yield this._channel.fetch({
              url,
              params,
              method,
              headers,
              postData,
              jsonData,
              formData,
              multipartData,
              timeout: options.timeout,
              failOnStatusCode: options.failOnStatusCode,
              ignoreHTTPSErrors: options.ignoreHTTPSErrors
            });
            return new APIResponse(this, result.response);
          }));
        });
      }
      storageState() {
        return __async(this, arguments, function* (options = {}) {
          const state = yield this._channel.storageState();
          if (options.path) {
            yield (0, _utils2.mkdirIfNeeded)(options.path);
            yield _fs2.default.promises.writeFile(options.path, JSON.stringify(state, void 0, 2), "utf8");
          }
          return state;
        });
      }
    };
    exports2.APIRequestContext = APIRequestContext;
    _util$inspect$custom = util.inspect.custom;
    var APIResponse = class {
      constructor(context, initializer) {
        this._initializer = void 0;
        this._headers = void 0;
        this._request = void 0;
        this._request = context;
        this._initializer = initializer;
        this._headers = new network.RawHeaders(this._initializer.headers);
      }
      ok() {
        return this._initializer.status >= 200 && this._initializer.status <= 299;
      }
      url() {
        return this._initializer.url;
      }
      status() {
        return this._initializer.status;
      }
      statusText() {
        return this._initializer.statusText;
      }
      headers() {
        return this._headers.headers();
      }
      headersArray() {
        return this._headers.headersArray();
      }
      body() {
        return __async(this, null, function* () {
          try {
            const result = yield this._request._channel.fetchResponseBody({
              fetchUid: this._fetchUid()
            });
            if (result.binary === void 0)
              throw new Error("Response has been disposed");
            return Buffer.from(result.binary, "base64");
          } catch (e) {
            if (e.message.includes(_errors.kBrowserOrContextClosedError))
              throw new Error("Response has been disposed");
            throw e;
          }
        });
      }
      text() {
        return __async(this, null, function* () {
          const content = yield this.body();
          return content.toString("utf8");
        });
      }
      json() {
        return __async(this, null, function* () {
          const content = yield this.text();
          return JSON.parse(content);
        });
      }
      dispose() {
        return __async(this, null, function* () {
          yield this._request._channel.disposeAPIResponse({
            fetchUid: this._fetchUid()
          });
        });
      }
      [_util$inspect$custom]() {
        const headers = this.headersArray().map(({
          name,
          value
        }) => `  ${name}: ${value}`);
        return `APIResponse: ${this.status()} ${this.statusText()}
${headers.join("\n")}`;
      }
      _fetchUid() {
        return this._initializer.fetchUid;
      }
      _fetchLog() {
        return __async(this, null, function* () {
          const {
            log
          } = yield this._request._channel.fetchLog({
            fetchUid: this._fetchUid()
          });
          return log;
        });
      }
    };
    exports2.APIResponse = APIResponse;
    function filePayloadToJson(payload) {
      return {
        name: payload.name,
        mimeType: payload.mimeType,
        buffer: payload.buffer.toString("base64")
      };
    }
    function readStreamToJson(stream) {
      return __async(this, null, function* () {
        const buffer = yield new Promise((resolve, reject) => {
          const chunks = [];
          stream.on("data", (chunk) => chunks.push(chunk));
          stream.on("end", () => resolve(Buffer.concat(chunks)));
          stream.on("error", (err) => reject(err));
        });
        const streamPath = Buffer.isBuffer(stream.path) ? stream.path.toString("utf8") : stream.path;
        return {
          name: _path2.default.basename(streamPath),
          buffer: buffer.toString("base64")
        };
      });
    }
    function isJsonContentType(headers) {
      if (!headers)
        return false;
      for (const {
        name,
        value
      } of headers) {
        if (name.toLocaleLowerCase() === "content-type")
          return value === "application/json";
      }
      return false;
    }
  }
});

// node_modules/playwright-core/lib/client/network.js
var require_network2 = __commonJS({
  "node_modules/playwright-core/lib/client/network.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validateHeaders = validateHeaders;
    exports2.RawHeaders = exports2.RouteHandler = exports2.WebSocket = exports2.Response = exports2.Route = exports2.Request = void 0;
    var _url = require("url");
    var _channelOwner = require_channelOwner();
    var _frame = require_frame();
    var _fs2 = _interopRequireDefault2(require("fs"));
    var mime = _interopRequireWildcard2(require_mime());
    var _utils2 = require_utils();
    var _async = require_async();
    var _events = require_events();
    var _waiter = require_waiter();
    var _clientHelper = require_clientHelper();
    var _multimap = require_multimap();
    var _fetch = require_fetch2();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Request = class extends _channelOwner.ChannelOwner {
      static from(request) {
        return request._object;
      }
      static fromNullable(request) {
        return request ? Request.from(request) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._redirectedFrom = null;
        this._redirectedTo = null;
        this._failureText = null;
        this._provisionalHeaders = void 0;
        this._actualHeadersPromise = void 0;
        this._postData = void 0;
        this._timing = void 0;
        this._redirectedFrom = Request.fromNullable(initializer.redirectedFrom);
        if (this._redirectedFrom)
          this._redirectedFrom._redirectedTo = this;
        this._provisionalHeaders = new RawHeaders(initializer.headers);
        this._postData = initializer.postData ? Buffer.from(initializer.postData, "base64") : null;
        this._timing = {
          startTime: 0,
          domainLookupStart: -1,
          domainLookupEnd: -1,
          connectStart: -1,
          secureConnectionStart: -1,
          connectEnd: -1,
          requestStart: -1,
          responseStart: -1,
          responseEnd: -1
        };
      }
      url() {
        return this._initializer.url;
      }
      resourceType() {
        return this._initializer.resourceType;
      }
      method() {
        return this._initializer.method;
      }
      postData() {
        return this._postData ? this._postData.toString("utf8") : null;
      }
      postDataBuffer() {
        return this._postData;
      }
      postDataJSON() {
        const postData = this.postData();
        if (!postData)
          return null;
        const contentType = this.headers()["content-type"];
        if (contentType === "application/x-www-form-urlencoded") {
          const entries = {};
          const parsed = new _url.URLSearchParams(postData);
          for (const [k, v] of parsed.entries())
            entries[k] = v;
          return entries;
        }
        try {
          return JSON.parse(postData);
        } catch (e) {
          throw new Error("POST data is not a valid JSON object: " + postData);
        }
      }
      headers() {
        return this._provisionalHeaders.headers();
      }
      _actualHeaders() {
        if (!this._actualHeadersPromise) {
          this._actualHeadersPromise = this._wrapApiCall(() => __async(this, null, function* () {
            return new RawHeaders((yield this._channel.rawRequestHeaders()).headers);
          }));
        }
        return this._actualHeadersPromise;
      }
      allHeaders() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headers();
        });
      }
      headersArray() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headersArray();
        });
      }
      headerValue(name) {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).get(name);
        });
      }
      response() {
        return __async(this, null, function* () {
          return Response.fromNullable((yield this._channel.response()).response);
        });
      }
      _internalResponse() {
        return __async(this, null, function* () {
          return this._wrapApiCall(() => __async(this, null, function* () {
            return Response.fromNullable((yield this._channel.response()).response);
          }), true);
        });
      }
      frame() {
        return _frame.Frame.from(this._initializer.frame);
      }
      isNavigationRequest() {
        return this._initializer.isNavigationRequest;
      }
      redirectedFrom() {
        return this._redirectedFrom;
      }
      redirectedTo() {
        return this._redirectedTo;
      }
      failure() {
        if (this._failureText === null)
          return null;
        return {
          errorText: this._failureText
        };
      }
      timing() {
        return this._timing;
      }
      sizes() {
        return __async(this, null, function* () {
          const response = yield this.response();
          if (!response)
            throw new Error("Unable to fetch sizes for failed request");
          return (yield response._channel.sizes()).sizes;
        });
      }
      _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
      }
    };
    exports2.Request = Request;
    var Route = class extends _channelOwner.ChannelOwner {
      static from(route) {
        return route._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      request() {
        return Request.from(this._initializer.request);
      }
      _raceWithPageClose(promise) {
        const page = this.request().frame()._page;
        return Promise.race([promise, page ? page._closedOrCrashedPromise : Promise.resolve()]);
      }
      abort(errorCode) {
        return __async(this, null, function* () {
          yield this._raceWithPageClose(this._channel.abort({
            errorCode
          }));
        });
      }
      fulfill() {
        return __async(this, arguments, function* (options = {}) {
          let fetchResponseUid;
          let {
            status: statusOption,
            headers: headersOption,
            body
          } = options;
          if (options.response) {
            statusOption || (statusOption = options.response.status());
            headersOption || (headersOption = options.response.headers());
            if (options.body === void 0 && options.path === void 0 && options.response instanceof _fetch.APIResponse)
              fetchResponseUid = options.response._fetchUid();
          }
          let isBase64 = false;
          let length = 0;
          if (options.path) {
            const buffer = yield _fs2.default.promises.readFile(options.path);
            body = buffer.toString("base64");
            isBase64 = true;
            length = buffer.length;
          } else if ((0, _utils2.isString)(body)) {
            isBase64 = false;
            length = Buffer.byteLength(body);
          } else if (body) {
            length = body.length;
            body = body.toString("base64");
            isBase64 = true;
          }
          const headers = {};
          for (const header of Object.keys(headersOption || {}))
            headers[header.toLowerCase()] = String(headersOption[header]);
          if (options.contentType)
            headers["content-type"] = String(options.contentType);
          else if (options.path)
            headers["content-type"] = mime.getType(options.path) || "application/octet-stream";
          if (length && !("content-length" in headers))
            headers["content-length"] = String(length);
          yield this._raceWithPageClose(this._channel.fulfill({
            status: statusOption || 200,
            headers: (0, _utils2.headersObjectToArray)(headers),
            body,
            isBase64,
            fetchResponseUid
          }));
        });
      }
      continue() {
        return __async(this, arguments, function* (options = {}) {
          yield this._continue(options);
        });
      }
      _internalContinue() {
        return __async(this, arguments, function* (options = {}) {
          yield this._continue(options, true).catch(() => {
          });
        });
      }
      _continue(options, isInternal) {
        return __async(this, null, function* () {
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            const postDataBuffer = (0, _utils2.isString)(options.postData) ? Buffer.from(options.postData, "utf8") : options.postData;
            yield this._raceWithPageClose(this._channel.continue({
              url: options.url,
              method: options.method,
              headers: options.headers ? (0, _utils2.headersObjectToArray)(options.headers) : void 0,
              postData: postDataBuffer ? postDataBuffer.toString("base64") : void 0
            }));
          }), isInternal);
        });
      }
    };
    exports2.Route = Route;
    var Response = class extends _channelOwner.ChannelOwner {
      static from(response) {
        return response._object;
      }
      static fromNullable(response) {
        return response ? Response.from(response) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._provisionalHeaders = void 0;
        this._actualHeadersPromise = void 0;
        this._request = void 0;
        this._finishedPromise = new _async.ManualPromise();
        this._provisionalHeaders = new RawHeaders(initializer.headers);
        this._request = Request.from(this._initializer.request);
        Object.assign(this._request._timing, this._initializer.timing);
      }
      url() {
        return this._initializer.url;
      }
      ok() {
        return this._initializer.status === 0 || this._initializer.status >= 200 && this._initializer.status <= 299;
      }
      status() {
        return this._initializer.status;
      }
      statusText() {
        return this._initializer.statusText;
      }
      headers() {
        return this._provisionalHeaders.headers();
      }
      _actualHeaders() {
        return __async(this, null, function* () {
          if (!this._actualHeadersPromise) {
            this._actualHeadersPromise = (() => __async(this, null, function* () {
              return new RawHeaders((yield this._channel.rawResponseHeaders()).headers);
            }))();
          }
          return this._actualHeadersPromise;
        });
      }
      allHeaders() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headers();
        });
      }
      headersArray() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headersArray().slice();
        });
      }
      headerValue(name) {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).get(name);
        });
      }
      headerValues(name) {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).getAll(name);
        });
      }
      finished() {
        return __async(this, null, function* () {
          return this._finishedPromise.then(() => null);
        });
      }
      body() {
        return __async(this, null, function* () {
          return Buffer.from((yield this._channel.body()).binary, "base64");
        });
      }
      text() {
        return __async(this, null, function* () {
          const content = yield this.body();
          return content.toString("utf8");
        });
      }
      json() {
        return __async(this, null, function* () {
          const content = yield this.text();
          return JSON.parse(content);
        });
      }
      request() {
        return this._request;
      }
      frame() {
        return this._request.frame();
      }
      serverAddr() {
        return __async(this, null, function* () {
          return (yield this._channel.serverAddr()).value || null;
        });
      }
      securityDetails() {
        return __async(this, null, function* () {
          return (yield this._channel.securityDetails()).value || null;
        });
      }
    };
    exports2.Response = Response;
    var WebSocket = class extends _channelOwner.ChannelOwner {
      static from(webSocket) {
        return webSocket._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._page = void 0;
        this._isClosed = void 0;
        this._isClosed = false;
        this._page = parent;
        this._channel.on("frameSent", (event) => {
          if (event.opcode === 1)
            this.emit(_events.Events.WebSocket.FrameSent, {
              payload: event.data
            });
          else if (event.opcode === 2)
            this.emit(_events.Events.WebSocket.FrameSent, {
              payload: Buffer.from(event.data, "base64")
            });
        });
        this._channel.on("frameReceived", (event) => {
          if (event.opcode === 1)
            this.emit(_events.Events.WebSocket.FrameReceived, {
              payload: event.data
            });
          else if (event.opcode === 2)
            this.emit(_events.Events.WebSocket.FrameReceived, {
              payload: Buffer.from(event.data, "base64")
            });
        });
        this._channel.on("socketError", ({
          error
        }) => this.emit(_events.Events.WebSocket.Error, error));
        this._channel.on("close", () => {
          this._isClosed = true;
          this.emit(_events.Events.WebSocket.Close, this);
        });
      }
      url() {
        return this._initializer.url;
      }
      isClosed() {
        return this._isClosed;
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._page._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.WebSocket.Error)
              waiter.rejectOnEvent(this, _events.Events.WebSocket.Error, new Error("Socket error"));
            if (event !== _events.Events.WebSocket.Close)
              waiter.rejectOnEvent(this, _events.Events.WebSocket.Close, new Error("Socket closed"));
            waiter.rejectOnEvent(this._page, _events.Events.Page.Close, new Error("Page closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
    };
    exports2.WebSocket = WebSocket;
    function validateHeaders(headers) {
      for (const key of Object.keys(headers)) {
        const value = headers[key];
        if (!Object.is(value, void 0) && !(0, _utils2.isString)(value))
          throw new Error(`Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
      }
    }
    var RouteHandler = class {
      constructor(baseURL, url, handler, times = Number.MAX_SAFE_INTEGER) {
        this.handledCount = 0;
        this._baseURL = void 0;
        this._times = void 0;
        this.url = void 0;
        this.handler = void 0;
        this._baseURL = baseURL;
        this._times = times;
        this.url = url;
        this.handler = handler;
      }
      matches(requestURL) {
        return (0, _clientHelper.urlMatches)(this._baseURL, requestURL, this.url);
      }
      handle(route, request) {
        ++this.handledCount;
        this.handler(route, request);
      }
      isActive() {
        return this.handledCount < this._times;
      }
    };
    exports2.RouteHandler = RouteHandler;
    var RawHeaders = class {
      constructor(headers) {
        this._headersArray = void 0;
        this._headersMap = new _multimap.MultiMap();
        this._headersArray = headers;
        for (const header of headers)
          this._headersMap.set(header.name.toLowerCase(), header.value);
      }
      get(name) {
        const values = this.getAll(name);
        if (!values || !values.length)
          return null;
        return values.join(name.toLowerCase() === "set-cookie" ? "\n" : ", ");
      }
      getAll(name) {
        return [...this._headersMap.get(name.toLowerCase())];
      }
      headers() {
        const result = {};
        for (const name of this._headersMap.keys())
          result[name] = this.get(name);
        return result;
      }
      headersArray() {
        return this._headersArray;
      }
    };
    exports2.RawHeaders = RawHeaders;
  }
});

// node_modules/playwright-core/lib/client/types.js
var require_types3 = __commonJS({
  "node_modules/playwright-core/lib/client/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "Size", {
      enumerable: true,
      get: function() {
        return _types.Size;
      }
    });
    Object.defineProperty(exports2, "Point", {
      enumerable: true,
      get: function() {
        return _types.Point;
      }
    });
    Object.defineProperty(exports2, "Rect", {
      enumerable: true,
      get: function() {
        return _types.Rect;
      }
    });
    Object.defineProperty(exports2, "Quad", {
      enumerable: true,
      get: function() {
        return _types.Quad;
      }
    });
    Object.defineProperty(exports2, "URLMatch", {
      enumerable: true,
      get: function() {
        return _types.URLMatch;
      }
    });
    Object.defineProperty(exports2, "TimeoutOptions", {
      enumerable: true,
      get: function() {
        return _types.TimeoutOptions;
      }
    });
    Object.defineProperty(exports2, "HeadersArray", {
      enumerable: true,
      get: function() {
        return _types.HeadersArray;
      }
    });
    exports2.kLifecycleEvents = void 0;
    var _types = require_types();
    var kLifecycleEvents = /* @__PURE__ */ new Set(["load", "domcontentloaded", "networkidle", "commit"]);
    exports2.kLifecycleEvents = kLifecycleEvents;
  }
});

// node_modules/playwright-core/lib/client/frame.js
var require_frame = __commonJS({
  "node_modules/playwright-core/lib/client/frame.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.verifyLoadState = verifyLoadState;
    exports2.Frame = void 0;
    var _utils2 = require_utils();
    var _channelOwner = require_channelOwner();
    var _locator = require_locator();
    var _elementHandle = require_elementHandle();
    var _jsHandle = require_jsHandle();
    var _fs2 = _interopRequireDefault2(require("fs"));
    var network = _interopRequireWildcard2(require_network2());
    var _events = require("events");
    var _waiter = require_waiter();
    var _events2 = require_events();
    var _types = require_types3();
    var _clientHelper = require_clientHelper();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Frame = class extends _channelOwner.ChannelOwner {
      static from(frame) {
        return frame._object;
      }
      static fromNullable(frame) {
        return frame ? Frame.from(frame) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._eventEmitter = void 0;
        this._loadStates = void 0;
        this._parentFrame = null;
        this._url = "";
        this._name = "";
        this._detached = false;
        this._childFrames = /* @__PURE__ */ new Set();
        this._page = void 0;
        this._eventEmitter = new _events.EventEmitter();
        this._eventEmitter.setMaxListeners(0);
        this._parentFrame = Frame.fromNullable(initializer.parentFrame);
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
        this._name = initializer.name;
        this._url = initializer.url;
        this._loadStates = new Set(initializer.loadStates);
        this._channel.on("loadstate", (event) => {
          if (event.add) {
            this._loadStates.add(event.add);
            this._eventEmitter.emit("loadstate", event.add);
          }
          if (event.remove)
            this._loadStates.delete(event.remove);
        });
        this._channel.on("navigated", (event) => {
          this._url = event.url;
          this._name = event.name;
          this._eventEmitter.emit("navigated", event);
          if (!event.error && this._page)
            this._page.emit(_events2.Events.Page.FrameNavigated, this);
        });
      }
      page() {
        return this._page;
      }
      goto(_0) {
        return __async(this, arguments, function* (url, options = {}) {
          const waitUntil = verifyLoadState("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return network.Response.fromNullable((yield this._channel.goto(__spreadProps(__spreadValues({
            url
          }, options), {
            waitUntil
          }))).response);
        });
      }
      _setupNavigationWaiter(options) {
        const waiter = new _waiter.Waiter(this._page, "");
        if (this._page.isClosed())
          waiter.rejectImmediately(new Error("Navigation failed because page was closed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.Close, new Error("Navigation failed because page was closed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.Crash, new Error("Navigation failed because page crashed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.FrameDetached, new Error("Navigating frame was detached!"), (frame) => frame === this);
        const timeout = this._page._timeoutSettings.navigationTimeout(options);
        waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded.`);
        return waiter;
      }
      waitForNavigation() {
        return __async(this, arguments, function* (options = {}) {
          return this._page._wrapApiCall(() => __async(this, null, function* () {
            const waitUntil = verifyLoadState("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
            const waiter = this._setupNavigationWaiter(options);
            const toUrl = typeof options.url === "string" ? ` to "${options.url}"` : "";
            waiter.log(`waiting for navigation${toUrl} until "${waitUntil}"`);
            const navigatedEvent = yield waiter.waitForEvent(this._eventEmitter, "navigated", (event) => {
              var _this$_page;
              if (event.error)
                return true;
              waiter.log(`  navigated to "${event.url}"`);
              return (0, _clientHelper.urlMatches)((_this$_page = this._page) === null || _this$_page === void 0 ? void 0 : _this$_page.context()._options.baseURL, event.url, options.url);
            });
            if (navigatedEvent.error) {
              const e = new Error(navigatedEvent.error);
              e.stack = "";
              yield waiter.waitForPromise(Promise.reject(e));
            }
            if (!this._loadStates.has(waitUntil)) {
              yield waiter.waitForEvent(this._eventEmitter, "loadstate", (s) => {
                waiter.log(`  "${s}" event fired`);
                return s === waitUntil;
              });
            }
            const request = navigatedEvent.newDocument ? network.Request.fromNullable(navigatedEvent.newDocument.request) : null;
            const response = request ? yield waiter.waitForPromise(request._finalRequest()._internalResponse()) : null;
            waiter.dispose();
            return response;
          }));
        });
      }
      waitForLoadState() {
        return __async(this, arguments, function* (state = "load", options = {}) {
          state = verifyLoadState("state", state);
          if (this._loadStates.has(state))
            return;
          return this._page._wrapApiCall(() => __async(this, null, function* () {
            const waiter = this._setupNavigationWaiter(options);
            yield waiter.waitForEvent(this._eventEmitter, "loadstate", (s) => {
              waiter.log(`  "${s}" event fired`);
              return s === state;
            });
            waiter.dispose();
          }));
        });
      }
      waitForURL(_0) {
        return __async(this, arguments, function* (url, options = {}) {
          var _this$_page2;
          if ((0, _clientHelper.urlMatches)((_this$_page2 = this._page) === null || _this$_page2 === void 0 ? void 0 : _this$_page2.context()._options.baseURL, this.url(), url))
            return yield this.waitForLoadState(options.waitUntil, options);
          yield this.waitForNavigation(__spreadValues({
            url
          }, options));
        });
      }
      frameElement() {
        return __async(this, null, function* () {
          return _elementHandle.ElementHandle.from((yield this._channel.frameElement()).element);
        });
      }
      evaluateHandle(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      evaluate(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $(selector, options) {
        return __async(this, null, function* () {
          const result = yield this._channel.querySelector(__spreadValues({
            selector
          }, options));
          return _elementHandle.ElementHandle.fromNullable(result.element);
        });
      }
      waitForSelector(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          if (options.visibility)
            throw new Error("options.visibility is not supported, did you mean options.state?");
          if (options.waitFor && options.waitFor !== "visible")
            throw new Error("options.waitFor is not supported, did you mean options.state?");
          const result = yield this._channel.waitForSelector(__spreadValues({
            selector
          }, options));
          return _elementHandle.ElementHandle.fromNullable(result.element);
        });
      }
      dispatchEvent(_0, _1, _2) {
        return __async(this, arguments, function* (selector, type, eventInit, options = {}) {
          yield this._channel.dispatchEvent(__spreadValues({
            selector,
            type,
            eventInit: (0, _jsHandle.serializeArgument)(eventInit)
          }, options));
        });
      }
      $eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          const result = yield this._channel.evalOnSelector({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $$eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          const result = yield this._channel.evalOnSelectorAll({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $$(selector) {
        return __async(this, null, function* () {
          const result = yield this._channel.querySelectorAll({
            selector
          });
          return result.elements.map((e) => _elementHandle.ElementHandle.from(e));
        });
      }
      _queryCount(selector) {
        return __async(this, null, function* () {
          return (yield this._channel.queryCount({
            selector
          })).value;
        });
      }
      content() {
        return __async(this, null, function* () {
          return (yield this._channel.content()).value;
        });
      }
      setContent(_0) {
        return __async(this, arguments, function* (html, options = {}) {
          const waitUntil = verifyLoadState("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          yield this._channel.setContent(__spreadProps(__spreadValues({
            html
          }, options), {
            waitUntil
          }));
        });
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      isDetached() {
        return this._detached;
      }
      addScriptTag() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadValues({}, options);
          if (copy.path) {
            copy.content = (yield _fs2.default.promises.readFile(copy.path)).toString();
            copy.content += "//# sourceURL=" + copy.path.replace(/\n/g, "");
          }
          return _elementHandle.ElementHandle.from((yield this._channel.addScriptTag(__spreadValues({}, copy))).element);
        });
      }
      addStyleTag() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadValues({}, options);
          if (copy.path) {
            copy.content = (yield _fs2.default.promises.readFile(copy.path)).toString();
            copy.content += "/*# sourceURL=" + copy.path.replace(/\n/g, "") + "*/";
          }
          return _elementHandle.ElementHandle.from((yield this._channel.addStyleTag(__spreadValues({}, copy))).element);
        });
      }
      click(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return yield this._channel.click(__spreadValues({
            selector
          }, options));
        });
      }
      dblclick(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return yield this._channel.dblclick(__spreadValues({
            selector
          }, options));
        });
      }
      dragAndDrop(_0, _1) {
        return __async(this, arguments, function* (source, target, options = {}) {
          return yield this._channel.dragAndDrop(__spreadValues({
            source,
            target
          }, options));
        });
      }
      tap(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return yield this._channel.tap(__spreadValues({
            selector
          }, options));
        });
      }
      fill(_0, _1) {
        return __async(this, arguments, function* (selector, value, options = {}) {
          return yield this._channel.fill(__spreadValues({
            selector,
            value
          }, options));
        });
      }
      _highlight(selector) {
        return __async(this, null, function* () {
          return yield this._channel.highlight({
            selector
          });
        });
      }
      locator(selector, options) {
        return new _locator.Locator(this, selector, options);
      }
      frameLocator(selector) {
        return new _locator.FrameLocator(this, selector);
      }
      focus(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.focus(__spreadValues({
            selector
          }, options));
        });
      }
      textContent(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          const value = (yield this._channel.textContent(__spreadValues({
            selector
          }, options))).value;
          return value === void 0 ? null : value;
        });
      }
      innerText(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.innerText(__spreadValues({
            selector
          }, options))).value;
        });
      }
      innerHTML(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.innerHTML(__spreadValues({
            selector
          }, options))).value;
        });
      }
      getAttribute(_0, _1) {
        return __async(this, arguments, function* (selector, name, options = {}) {
          const value = (yield this._channel.getAttribute(__spreadValues({
            selector,
            name
          }, options))).value;
          return value === void 0 ? null : value;
        });
      }
      inputValue(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.inputValue(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isChecked(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isChecked(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isDisabled(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isDisabled(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isEditable(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isEditable(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isEnabled(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isEnabled(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isHidden(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isHidden(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isVisible(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isVisible(__spreadValues({
            selector
          }, options))).value;
        });
      }
      hover(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.hover(__spreadValues({
            selector
          }, options));
        });
      }
      selectOption(_0, _1) {
        return __async(this, arguments, function* (selector, values, options = {}) {
          return (yield this._channel.selectOption(__spreadValues(__spreadValues({
            selector
          }, (0, _elementHandle.convertSelectOptionValues)(values)), options))).values;
        });
      }
      setInputFiles(_0, _1) {
        return __async(this, arguments, function* (selector, files, options = {}) {
          yield this._channel.setInputFiles(__spreadValues({
            selector,
            files: yield (0, _elementHandle.convertInputFiles)(files)
          }, options));
        });
      }
      type(_0, _1) {
        return __async(this, arguments, function* (selector, text, options = {}) {
          yield this._channel.type(__spreadValues({
            selector,
            text
          }, options));
        });
      }
      press(_0, _1) {
        return __async(this, arguments, function* (selector, key, options = {}) {
          yield this._channel.press(__spreadValues({
            selector,
            key
          }, options));
        });
      }
      check(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.check(__spreadValues({
            selector
          }, options));
        });
      }
      uncheck(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.uncheck(__spreadValues({
            selector
          }, options));
        });
      }
      setChecked(selector, checked, options) {
        return __async(this, null, function* () {
          if (checked)
            yield this.check(selector, options);
          else
            yield this.uncheck(selector, options);
        });
      }
      waitForTimeout(timeout) {
        return __async(this, null, function* () {
          yield this._channel.waitForTimeout({
            timeout
          });
        });
      }
      waitForFunction(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg, options = {}) {
          if (typeof options.polling === "string")
            (0, _utils2.assert)(options.polling === "raf", "Unknown polling option: " + options.polling);
          const result = yield this._channel.waitForFunction(__spreadProps(__spreadValues({}, options), {
            pollingInterval: options.polling === "raf" ? void 0 : options.polling,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          }));
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      title() {
        return __async(this, null, function* () {
          return (yield this._channel.title()).value;
        });
      }
    };
    exports2.Frame = Frame;
    function verifyLoadState(name, waitUntil) {
      if (waitUntil === "networkidle0")
        waitUntil = "networkidle";
      if (!_types.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
      return waitUntil;
    }
  }
});

// node_modules/playwright-core/lib/client/elementHandle.js
var require_elementHandle = __commonJS({
  "node_modules/playwright-core/lib/client/elementHandle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.convertSelectOptionValues = convertSelectOptionValues;
    exports2.convertInputFiles = convertInputFiles;
    exports2.determineScreenshotType = determineScreenshotType;
    exports2.ElementHandle = void 0;
    var _frame = require_frame();
    var _jsHandle = require_jsHandle();
    var _fs2 = _interopRequireDefault2(require("fs"));
    var mime = _interopRequireWildcard2(require_mime());
    var _path2 = _interopRequireDefault2(require("path"));
    var _utils2 = require_utils();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ElementHandle = class extends _jsHandle.JSHandle {
      static from(handle) {
        return handle._object;
      }
      static fromNullable(handle) {
        return handle ? ElementHandle.from(handle) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._elementChannel = void 0;
        this._elementChannel = this._channel;
      }
      asElement() {
        return this;
      }
      ownerFrame() {
        return __async(this, null, function* () {
          return _frame.Frame.fromNullable((yield this._elementChannel.ownerFrame()).frame);
        });
      }
      contentFrame() {
        return __async(this, null, function* () {
          return _frame.Frame.fromNullable((yield this._elementChannel.contentFrame()).frame);
        });
      }
      getAttribute(name) {
        return __async(this, null, function* () {
          const value = (yield this._elementChannel.getAttribute({
            name
          })).value;
          return value === void 0 ? null : value;
        });
      }
      inputValue() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.inputValue()).value;
        });
      }
      textContent() {
        return __async(this, null, function* () {
          const value = (yield this._elementChannel.textContent()).value;
          return value === void 0 ? null : value;
        });
      }
      innerText() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.innerText()).value;
        });
      }
      innerHTML() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.innerHTML()).value;
        });
      }
      isChecked() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isChecked()).value;
        });
      }
      isDisabled() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isDisabled()).value;
        });
      }
      isEditable() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isEditable()).value;
        });
      }
      isEnabled() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isEnabled()).value;
        });
      }
      isHidden() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isHidden()).value;
        });
      }
      isVisible() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isVisible()).value;
        });
      }
      dispatchEvent(_0) {
        return __async(this, arguments, function* (type, eventInit = {}) {
          yield this._elementChannel.dispatchEvent({
            type,
            eventInit: (0, _jsHandle.serializeArgument)(eventInit)
          });
        });
      }
      scrollIntoViewIfNeeded() {
        return __async(this, arguments, function* (options = {}) {
          yield this._elementChannel.scrollIntoViewIfNeeded(options);
        });
      }
      hover() {
        return __async(this, arguments, function* (options = {}) {
          yield this._elementChannel.hover(options);
        });
      }
      click() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.click(options);
        });
      }
      dblclick() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.dblclick(options);
        });
      }
      tap() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.tap(options);
        });
      }
      selectOption(_0) {
        return __async(this, arguments, function* (values, options = {}) {
          const result = yield this._elementChannel.selectOption(__spreadValues(__spreadValues({}, convertSelectOptionValues(values)), options));
          return result.values;
        });
      }
      fill(_0) {
        return __async(this, arguments, function* (value, options = {}) {
          return yield this._elementChannel.fill(__spreadValues({
            value
          }, options));
        });
      }
      selectText() {
        return __async(this, arguments, function* (options = {}) {
          yield this._elementChannel.selectText(options);
        });
      }
      setInputFiles(_0) {
        return __async(this, arguments, function* (files, options = {}) {
          yield this._elementChannel.setInputFiles(__spreadValues({
            files: yield convertInputFiles(files)
          }, options));
        });
      }
      focus() {
        return __async(this, null, function* () {
          yield this._elementChannel.focus();
        });
      }
      type(_0) {
        return __async(this, arguments, function* (text, options = {}) {
          yield this._elementChannel.type(__spreadValues({
            text
          }, options));
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          yield this._elementChannel.press(__spreadValues({
            key
          }, options));
        });
      }
      check() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.check(options);
        });
      }
      uncheck() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.uncheck(options);
        });
      }
      setChecked(checked, options) {
        return __async(this, null, function* () {
          if (checked)
            yield this.check(options);
          else
            yield this.uncheck(options);
        });
      }
      boundingBox() {
        return __async(this, null, function* () {
          const value = (yield this._elementChannel.boundingBox()).value;
          return value === void 0 ? null : value;
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadValues({}, options);
          if (!copy.type)
            copy.type = determineScreenshotType(options);
          const result = yield this._elementChannel.screenshot(copy);
          const buffer = Buffer.from(result.binary, "base64");
          if (options.path) {
            yield (0, _utils2.mkdirIfNeeded)(options.path);
            yield _fs2.default.promises.writeFile(options.path, buffer);
          }
          return buffer;
        });
      }
      $(selector) {
        return __async(this, null, function* () {
          return ElementHandle.fromNullable((yield this._elementChannel.querySelector({
            selector
          })).element);
        });
      }
      $$(selector) {
        return __async(this, null, function* () {
          const result = yield this._elementChannel.querySelectorAll({
            selector
          });
          return result.elements.map((h) => ElementHandle.from(h));
        });
      }
      $eval(selector, pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._elementChannel.evalOnSelector({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $$eval(selector, pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._elementChannel.evalOnSelectorAll({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      waitForElementState(_0) {
        return __async(this, arguments, function* (state, options = {}) {
          return yield this._elementChannel.waitForElementState(__spreadValues({
            state
          }, options));
        });
      }
      waitForSelector(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          const result = yield this._elementChannel.waitForSelector(__spreadValues({
            selector
          }, options));
          return ElementHandle.fromNullable(result.element);
        });
      }
    };
    exports2.ElementHandle = ElementHandle;
    function convertSelectOptionValues(values) {
      if (values === null)
        return {};
      if (!Array.isArray(values))
        values = [values];
      if (!values.length)
        return {};
      for (let i = 0; i < values.length; i++)
        (0, _utils2.assert)(values[i] !== null, `options[${i}]: expected object, got null`);
      if (values[0] instanceof ElementHandle)
        return {
          elements: values.map((v) => v._elementChannel)
        };
      if ((0, _utils2.isString)(values[0]))
        return {
          options: values.map((value) => ({
            value
          }))
        };
      return {
        options: values
      };
    }
    function convertInputFiles(files) {
      return __async(this, null, function* () {
        const items = Array.isArray(files) ? files : [files];
        const filePayloads = yield Promise.all(items.map((item) => __async(this, null, function* () {
          if (typeof item === "string") {
            return {
              name: _path2.default.basename(item),
              buffer: (yield _fs2.default.promises.readFile(item)).toString("base64")
            };
          } else {
            return {
              name: item.name,
              mimeType: item.mimeType,
              buffer: item.buffer.toString("base64")
            };
          }
        })));
        return filePayloads;
      });
    }
    function determineScreenshotType(options) {
      if (options.path) {
        const mimeType = mime.getType(options.path);
        if (mimeType === "image/png")
          return "png";
        else if (mimeType === "image/jpeg")
          return "jpeg";
        throw new Error(`path: unsupported mime type "${mimeType}"`);
      }
      return options.type;
    }
  }
});

// node_modules/playwright-core/lib/client/worker.js
var require_worker = __commonJS({
  "node_modules/playwright-core/lib/client/worker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Worker = void 0;
    var _events = require_events();
    var _channelOwner = require_channelOwner();
    var _jsHandle = require_jsHandle();
    var Worker = class extends _channelOwner.ChannelOwner {
      static from(worker) {
        return worker._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._page = void 0;
        this._context = void 0;
        this._channel.on("close", () => {
          if (this._page)
            this._page._workers.delete(this);
          if (this._context)
            this._context._serviceWorkers.delete(this);
          this.emit(_events.Events.Worker.Close, this);
        });
      }
      url() {
        return this._initializer.url;
      }
      evaluate(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      evaluateHandle(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
    };
    exports2.Worker = Worker;
  }
});

// node_modules/playwright-core/lib/client/input.js
var require_input2 = __commonJS({
  "node_modules/playwright-core/lib/client/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Touchscreen = exports2.Mouse = exports2.Keyboard = void 0;
    var Keyboard = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      down(key) {
        return __async(this, null, function* () {
          yield this._page._channel.keyboardDown({
            key
          });
        });
      }
      up(key) {
        return __async(this, null, function* () {
          yield this._page._channel.keyboardUp({
            key
          });
        });
      }
      insertText(text) {
        return __async(this, null, function* () {
          yield this._page._channel.keyboardInsertText({
            text
          });
        });
      }
      type(_0) {
        return __async(this, arguments, function* (text, options = {}) {
          yield this._page._channel.keyboardType(__spreadValues({
            text
          }, options));
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          yield this._page._channel.keyboardPress(__spreadValues({
            key
          }, options));
        });
      }
    };
    exports2.Keyboard = Keyboard;
    var Mouse = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      move(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this._page._channel.mouseMove(__spreadValues({
            x,
            y
          }, options));
        });
      }
      down() {
        return __async(this, arguments, function* (options = {}) {
          yield this._page._channel.mouseDown(__spreadValues({}, options));
        });
      }
      up() {
        return __async(this, arguments, function* (options = {}) {
          yield this._page._channel.mouseUp(options);
        });
      }
      click(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this._page._channel.mouseClick(__spreadValues({
            x,
            y
          }, options));
        });
      }
      dblclick(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this.click(x, y, __spreadProps(__spreadValues({}, options), {
            clickCount: 2
          }));
        });
      }
      wheel(deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._page._channel.mouseWheel({
            deltaX,
            deltaY
          });
        });
      }
    };
    exports2.Mouse = Mouse;
    var Touchscreen = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      tap(x, y) {
        return __async(this, null, function* () {
          yield this._page._channel.touchscreenTap({
            x,
            y
          });
        });
      }
    };
    exports2.Touchscreen = Touchscreen;
  }
});

// node_modules/playwright-core/lib/client/fileChooser.js
var require_fileChooser2 = __commonJS({
  "node_modules/playwright-core/lib/client/fileChooser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FileChooser = void 0;
    var FileChooser = class {
      constructor(page, elementHandle, isMultiple) {
        this._page = void 0;
        this._elementHandle = void 0;
        this._isMultiple = void 0;
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
      }
      element() {
        return this._elementHandle;
      }
      isMultiple() {
        return this._isMultiple;
      }
      page() {
        return this._page;
      }
      setFiles(files, options) {
        return __async(this, null, function* () {
          return this._elementHandle.setInputFiles(files, options);
        });
      }
    };
    exports2.FileChooser = FileChooser;
  }
});

// node_modules/playwright-core/lib/client/coverage.js
var require_coverage = __commonJS({
  "node_modules/playwright-core/lib/client/coverage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Coverage = void 0;
    var Coverage = class {
      constructor(channel) {
        this._channel = void 0;
        this._channel = channel;
      }
      startJSCoverage() {
        return __async(this, arguments, function* (options = {}) {
          yield this._channel.startJSCoverage(options);
        });
      }
      stopJSCoverage() {
        return __async(this, null, function* () {
          return (yield this._channel.stopJSCoverage()).entries;
        });
      }
      startCSSCoverage() {
        return __async(this, arguments, function* (options = {}) {
          yield this._channel.startCSSCoverage(options);
        });
      }
      stopCSSCoverage() {
        return __async(this, null, function* () {
          return (yield this._channel.stopCSSCoverage()).entries;
        });
      }
    };
    exports2.Coverage = Coverage;
  }
});

// node_modules/playwright-core/lib/client/video.js
var require_video = __commonJS({
  "node_modules/playwright-core/lib/client/video.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Video = void 0;
    var Video = class {
      constructor(page, connection) {
        this._artifact = null;
        this._artifactCallback = (artifact) => {
        };
        this._isRemote = false;
        this._isRemote = connection.isRemote();
        this._artifact = Promise.race([new Promise((f) => this._artifactCallback = f), page._closedOrCrashedPromise.then(() => null)]);
      }
      _artifactReady(artifact) {
        this._artifactCallback(artifact);
      }
      path() {
        return __async(this, null, function* () {
          if (this._isRemote)
            throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
          const artifact = yield this._artifact;
          if (!artifact)
            throw new Error("Page did not produce any video frames");
          return artifact._initializer.absolutePath;
        });
      }
      saveAs(path) {
        return __async(this, null, function* () {
          const artifact = yield this._artifact;
          if (!artifact)
            throw new Error("Page did not produce any video frames");
          return artifact.saveAs(path);
        });
      }
      delete() {
        return __async(this, null, function* () {
          const artifact = yield this._artifact;
          if (artifact)
            yield artifact.delete();
        });
      }
    };
    exports2.Video = Video;
  }
});

// node_modules/playwright-core/lib/client/stream.js
var require_stream = __commonJS({
  "node_modules/playwright-core/lib/client/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Stream = void 0;
    var _stream = require("stream");
    var _channelOwner = require_channelOwner();
    var Stream = class extends _channelOwner.ChannelOwner {
      static from(Stream2) {
        return Stream2._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      stream() {
        return new StreamImpl(this._channel);
      }
    };
    exports2.Stream = Stream;
    var StreamImpl = class extends _stream.Readable {
      constructor(channel) {
        super();
        this._channel = void 0;
        this._channel = channel;
      }
      _read(size) {
        return __async(this, null, function* () {
          const result = yield this._channel.read({
            size
          });
          if (result.binary)
            this.push(Buffer.from(result.binary, "base64"));
          else
            this.push(null);
        });
      }
      _destroy(error, callback) {
        this._channel.close().catch((e) => null);
        super._destroy(error, callback);
      }
    };
  }
});

// node_modules/playwright-core/lib/client/artifact.js
var require_artifact2 = __commonJS({
  "node_modules/playwright-core/lib/client/artifact.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Artifact = void 0;
    var fs = _interopRequireWildcard2(require("fs"));
    var _stream = require_stream();
    var _utils2 = require_utils();
    var _channelOwner = require_channelOwner();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Artifact = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      pathAfterFinished() {
        return __async(this, null, function* () {
          if (this._connection.isRemote())
            throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
          return (yield this._channel.pathAfterFinished()).value || null;
        });
      }
      saveAs(path) {
        return __async(this, null, function* () {
          if (!this._connection.isRemote()) {
            yield this._channel.saveAs({
              path
            });
            return;
          }
          const result = yield this._channel.saveAsStream();
          const stream = _stream.Stream.from(result.stream);
          yield (0, _utils2.mkdirIfNeeded)(path);
          yield new Promise((resolve, reject) => {
            stream.stream().pipe(fs.createWriteStream(path)).on("finish", resolve).on("error", reject);
          });
        });
      }
      failure() {
        return __async(this, null, function* () {
          return (yield this._channel.failure()).error || null;
        });
      }
      createReadStream() {
        return __async(this, null, function* () {
          const result = yield this._channel.stream();
          if (!result.stream)
            return null;
          const stream = _stream.Stream.from(result.stream);
          return stream.stream();
        });
      }
      cancel() {
        return __async(this, null, function* () {
          return this._channel.cancel();
        });
      }
      delete() {
        return __async(this, null, function* () {
          return this._channel.delete();
        });
      }
    };
    exports2.Artifact = Artifact;
  }
});

// node_modules/playwright-core/lib/client/page.js
var require_page2 = __commonJS({
  "node_modules/playwright-core/lib/client/page.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BindingCall = exports2.Page = void 0;
    var _events = require_events();
    var _utils2 = require_utils();
    var _timeoutSettings = require_timeoutSettings();
    var _serializers = require_serializers();
    var _accessibility = require_accessibility2();
    var _channelOwner = require_channelOwner();
    var _consoleMessage = require_consoleMessage();
    var _dialog = require_dialog2();
    var _download = require_download2();
    var _elementHandle = require_elementHandle();
    var _worker = require_worker();
    var _frame = require_frame();
    var _input = require_input2();
    var _jsHandle = require_jsHandle();
    var _network = require_network2();
    var _fileChooser = require_fileChooser2();
    var _buffer = require("buffer");
    var _coverage = require_coverage();
    var _waiter = require_waiter();
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _path2 = _interopRequireDefault2(require("path"));
    var _clientHelper = require_clientHelper();
    var _errors = require_errors();
    var _video = require_video();
    var _artifact = require_artifact2();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Page = class extends _channelOwner.ChannelOwner {
      static from(page) {
        return page._object;
      }
      static fromNullable(page) {
        return page ? Page.from(page) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._browserContext = void 0;
        this._ownedContext = void 0;
        this._mainFrame = void 0;
        this._frames = /* @__PURE__ */ new Set();
        this._workers = /* @__PURE__ */ new Set();
        this._closed = false;
        this._closedOrCrashedPromise = void 0;
        this._viewportSize = void 0;
        this._routes = [];
        this.accessibility = void 0;
        this.coverage = void 0;
        this.keyboard = void 0;
        this.mouse = void 0;
        this.request = void 0;
        this.touchscreen = void 0;
        this._bindings = /* @__PURE__ */ new Map();
        this._timeoutSettings = void 0;
        this._video = null;
        this._opener = void 0;
        this._browserContext = parent;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(this._browserContext._timeoutSettings);
        this.accessibility = new _accessibility.Accessibility(this._channel);
        this.keyboard = new _input.Keyboard(this);
        this.mouse = new _input.Mouse(this);
        this.request = this._browserContext.request;
        this.touchscreen = new _input.Touchscreen(this);
        this._mainFrame = _frame.Frame.from(initializer.mainFrame);
        this._mainFrame._page = this;
        this._frames.add(this._mainFrame);
        this._viewportSize = initializer.viewportSize || null;
        this._closed = initializer.isClosed;
        this._opener = Page.fromNullable(initializer.opener);
        this._channel.on("bindingCall", ({
          binding
        }) => this._onBinding(BindingCall.from(binding)));
        this._channel.on("close", () => this._onClose());
        this._channel.on("console", ({
          message
        }) => this.emit(_events.Events.Page.Console, _consoleMessage.ConsoleMessage.from(message)));
        this._channel.on("crash", () => this._onCrash());
        this._channel.on("dialog", ({
          dialog
        }) => {
          const dialogObj = _dialog.Dialog.from(dialog);
          if (!this.emit(_events.Events.Page.Dialog, dialogObj)) {
            if (dialogObj.type() === "beforeunload")
              dialog.accept({}).catch(() => {
              });
            else
              dialog.dismiss().catch(() => {
              });
          }
        });
        this._channel.on("domcontentloaded", () => this.emit(_events.Events.Page.DOMContentLoaded, this));
        this._channel.on("download", ({
          url,
          suggestedFilename,
          artifact
        }) => {
          const artifactObject = _artifact.Artifact.from(artifact);
          this.emit(_events.Events.Page.Download, new _download.Download(this, url, suggestedFilename, artifactObject));
        });
        this._channel.on("fileChooser", ({
          element,
          isMultiple
        }) => this.emit(_events.Events.Page.FileChooser, new _fileChooser.FileChooser(this, _elementHandle.ElementHandle.from(element), isMultiple)));
        this._channel.on("frameAttached", ({
          frame
        }) => this._onFrameAttached(_frame.Frame.from(frame)));
        this._channel.on("frameDetached", ({
          frame
        }) => this._onFrameDetached(_frame.Frame.from(frame)));
        this._channel.on("load", () => this.emit(_events.Events.Page.Load, this));
        this._channel.on("pageError", ({
          error
        }) => this.emit(_events.Events.Page.PageError, (0, _serializers.parseError)(error)));
        this._channel.on("route", ({
          route,
          request
        }) => this._onRoute(_network.Route.from(route), _network.Request.from(request)));
        this._channel.on("video", ({
          artifact
        }) => {
          const artifactObject = _artifact.Artifact.from(artifact);
          this._forceVideo()._artifactReady(artifactObject);
        });
        this._channel.on("webSocket", ({
          webSocket
        }) => this.emit(_events.Events.Page.WebSocket, _network.WebSocket.from(webSocket)));
        this._channel.on("worker", ({
          worker
        }) => this._onWorker(_worker.Worker.from(worker)));
        this.coverage = new _coverage.Coverage(this._channel);
        this._closedOrCrashedPromise = Promise.race([new Promise((f) => this.once(_events.Events.Page.Close, f)), new Promise((f) => this.once(_events.Events.Page.Crash, f))]);
      }
      _onFrameAttached(frame) {
        frame._page = this;
        this._frames.add(frame);
        if (frame._parentFrame)
          frame._parentFrame._childFrames.add(frame);
        this.emit(_events.Events.Page.FrameAttached, frame);
      }
      _onFrameDetached(frame) {
        this._frames.delete(frame);
        frame._detached = true;
        if (frame._parentFrame)
          frame._parentFrame._childFrames.delete(frame);
        this.emit(_events.Events.Page.FrameDetached, frame);
      }
      _onRoute(route, request) {
        for (const routeHandler of this._routes) {
          if (routeHandler.matches(request.url())) {
            try {
              routeHandler.handle(route, request);
            } finally {
              if (!routeHandler.isActive()) {
                this._routes.splice(this._routes.indexOf(routeHandler), 1);
                if (!this._routes.length)
                  this._wrapApiCall(() => this._disableInterception(), true).catch(() => {
                  });
              }
            }
            return;
          }
        }
        this._browserContext._onRoute(route, request);
      }
      _onBinding(bindingCall) {
        return __async(this, null, function* () {
          const func = this._bindings.get(bindingCall._initializer.name);
          if (func) {
            yield bindingCall.call(func);
            return;
          }
          yield this._browserContext._onBinding(bindingCall);
        });
      }
      _onWorker(worker) {
        this._workers.add(worker);
        worker._page = this;
        this.emit(_events.Events.Page.Worker, worker);
      }
      _onClose() {
        this._closed = true;
        this._browserContext._pages.delete(this);
        this._browserContext._backgroundPages.delete(this);
        this.emit(_events.Events.Page.Close, this);
      }
      _onCrash() {
        this.emit(_events.Events.Page.Crash, this);
      }
      context() {
        return this._browserContext;
      }
      opener() {
        return __async(this, null, function* () {
          if (!this._opener || this._opener.isClosed())
            return null;
          return this._opener;
        });
      }
      mainFrame() {
        return this._mainFrame;
      }
      frame(frameSelector) {
        const name = (0, _utils2.isString)(frameSelector) ? frameSelector : frameSelector.name;
        const url = (0, _utils2.isObject)(frameSelector) ? frameSelector.url : void 0;
        (0, _utils2.assert)(name || url, "Either name or url matcher should be specified");
        return this.frames().find((f) => {
          if (name)
            return f.name() === name;
          return (0, _clientHelper.urlMatches)(this._browserContext._options.baseURL, f.url(), url);
        }) || null;
      }
      frames() {
        return [...this._frames];
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultNavigationTimeoutNoReply({
            timeout
          });
        }), true);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultTimeoutNoReply({
            timeout
          });
        }), true);
      }
      _forceVideo() {
        if (!this._video)
          this._video = new _video.Video(this, this._connection);
        return this._video;
      }
      video() {
        if (!this._browserContext._options.recordVideo)
          return null;
        return this._forceVideo();
      }
      $(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.$(selector, options);
        });
      }
      waitForSelector(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForSelector(selector, options);
        });
      }
      dispatchEvent(selector, type, eventInit, options) {
        return __async(this, null, function* () {
          return this._mainFrame.dispatchEvent(selector, type, eventInit, options);
        });
      }
      evaluateHandle(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          return this._mainFrame.evaluateHandle(pageFunction, arg);
        });
      }
      $eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          return this._mainFrame.$eval(selector, pageFunction, arg);
        });
      }
      $$eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          return this._mainFrame.$$eval(selector, pageFunction, arg);
        });
      }
      $$(selector) {
        return __async(this, null, function* () {
          return this._mainFrame.$$(selector);
        });
      }
      addScriptTag() {
        return __async(this, arguments, function* (options = {}) {
          return this._mainFrame.addScriptTag(options);
        });
      }
      addStyleTag() {
        return __async(this, arguments, function* (options = {}) {
          return this._mainFrame.addStyleTag(options);
        });
      }
      exposeFunction(name, callback) {
        return __async(this, null, function* () {
          yield this._channel.exposeBinding({
            name
          });
          const binding = (source, ...args) => callback(...args);
          this._bindings.set(name, binding);
        });
      }
      exposeBinding(_0, _1) {
        return __async(this, arguments, function* (name, callback, options = {}) {
          yield this._channel.exposeBinding({
            name,
            needsHandle: options.handle
          });
          this._bindings.set(name, callback);
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          (0, _network.validateHeaders)(headers);
          yield this._channel.setExtraHTTPHeaders({
            headers: (0, _utils2.headersObjectToArray)(headers)
          });
        });
      }
      url() {
        return this._mainFrame.url();
      }
      content() {
        return __async(this, null, function* () {
          return this._mainFrame.content();
        });
      }
      setContent(html, options) {
        return __async(this, null, function* () {
          return this._mainFrame.setContent(html, options);
        });
      }
      goto(url, options) {
        return __async(this, null, function* () {
          return this._mainFrame.goto(url, options);
        });
      }
      reload() {
        return __async(this, arguments, function* (options = {}) {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return _network.Response.fromNullable((yield this._channel.reload(__spreadProps(__spreadValues({}, options), {
            waitUntil
          }))).response);
        });
      }
      waitForLoadState(state, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForLoadState(state, options);
        });
      }
      waitForNavigation(options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForNavigation(options);
        });
      }
      waitForURL(url, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForURL(url, options);
        });
      }
      waitForRequest(_0) {
        return __async(this, arguments, function* (urlOrPredicate, options = {}) {
          const predicate = (request) => {
            if ((0, _utils2.isString)(urlOrPredicate) || (0, _utils2.isRegExp)(urlOrPredicate))
              return (0, _clientHelper.urlMatches)(this._browserContext._options.baseURL, request.url(), urlOrPredicate);
            return urlOrPredicate(request);
          };
          const trimmedUrl = trimUrl(urlOrPredicate);
          const logLine = trimmedUrl ? `waiting for request ${trimmedUrl}` : void 0;
          return this._waitForEvent(_events.Events.Page.Request, {
            predicate,
            timeout: options.timeout
          }, logLine);
        });
      }
      waitForResponse(_0) {
        return __async(this, arguments, function* (urlOrPredicate, options = {}) {
          const predicate = (response) => {
            if ((0, _utils2.isString)(urlOrPredicate) || (0, _utils2.isRegExp)(urlOrPredicate))
              return (0, _clientHelper.urlMatches)(this._browserContext._options.baseURL, response.url(), urlOrPredicate);
            return urlOrPredicate(response);
          };
          const trimmedUrl = trimUrl(urlOrPredicate);
          const logLine = trimmedUrl ? `waiting for response ${trimmedUrl}` : void 0;
          return this._waitForEvent(_events.Events.Page.Response, {
            predicate,
            timeout: options.timeout
          }, logLine);
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._waitForEvent(event, optionsOrPredicate, `waiting for event "${event}"`);
        });
      }
      _waitForEvent(event, optionsOrPredicate, logLine) {
        return __async(this, null, function* () {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            if (logLine)
              waiter.log(logLine);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.Page.Crash)
              waiter.rejectOnEvent(this, _events.Events.Page.Crash, new Error("Page crashed"));
            if (event !== _events.Events.Page.Close)
              waiter.rejectOnEvent(this, _events.Events.Page.Close, new Error("Page closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
      goBack() {
        return __async(this, arguments, function* (options = {}) {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return _network.Response.fromNullable((yield this._channel.goBack(__spreadProps(__spreadValues({}, options), {
            waitUntil
          }))).response);
        });
      }
      goForward() {
        return __async(this, arguments, function* (options = {}) {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return _network.Response.fromNullable((yield this._channel.goForward(__spreadProps(__spreadValues({}, options), {
            waitUntil
          }))).response);
        });
      }
      emulateMedia() {
        return __async(this, arguments, function* (options = {}) {
          yield this._channel.emulateMedia({
            media: options.media === null ? "null" : options.media,
            colorScheme: options.colorScheme === null ? "null" : options.colorScheme,
            reducedMotion: options.reducedMotion === null ? "null" : options.reducedMotion,
            forcedColors: options.forcedColors === null ? "null" : options.forcedColors
          });
        });
      }
      setViewportSize(viewportSize) {
        return __async(this, null, function* () {
          this._viewportSize = viewportSize;
          yield this._channel.setViewportSize({
            viewportSize
          });
        });
      }
      viewportSize() {
        return this._viewportSize;
      }
      evaluate(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          return this._mainFrame.evaluate(pageFunction, arg);
        });
      }
      addInitScript(script, arg) {
        return __async(this, null, function* () {
          const source = yield (0, _clientHelper.evaluationScript)(script, arg);
          yield this._channel.addInitScript({
            source
          });
        });
      }
      route(_0, _1) {
        return __async(this, arguments, function* (url, handler, options = {}) {
          this._routes.unshift(new _network.RouteHandler(this._browserContext._options.baseURL, url, handler, options.times));
          if (this._routes.length === 1)
            yield this._channel.setNetworkInterceptionEnabled({
              enabled: true
            });
        });
      }
      unroute(url, handler) {
        return __async(this, null, function* () {
          this._routes = this._routes.filter((route) => route.url !== url || handler && route.handler !== handler);
          if (!this._routes.length)
            yield this._disableInterception();
        });
      }
      _disableInterception() {
        return __async(this, null, function* () {
          yield this._channel.setNetworkInterceptionEnabled({
            enabled: false
          });
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadValues({}, options);
          if (!copy.type)
            copy.type = (0, _elementHandle.determineScreenshotType)(options);
          const result = yield this._channel.screenshot(copy);
          const buffer = _buffer.Buffer.from(result.binary, "base64");
          if (options.path) {
            yield (0, _utils2.mkdirIfNeeded)(options.path);
            yield _fs2.default.promises.writeFile(options.path, buffer);
          }
          return buffer;
        });
      }
      title() {
        return __async(this, null, function* () {
          return this._mainFrame.title();
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._channel.bringToFront();
        });
      }
      close() {
        return __async(this, arguments, function* (options = {
          runBeforeUnload: void 0
        }) {
          try {
            if (this._ownedContext)
              yield this._ownedContext.close();
            else
              yield this._channel.close(options);
          } catch (e) {
            if ((0, _errors.isSafeCloseError)(e))
              return;
            throw e;
          }
        });
      }
      isClosed() {
        return this._closed;
      }
      click(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.click(selector, options);
        });
      }
      dragAndDrop(source, target, options) {
        return __async(this, null, function* () {
          return this._mainFrame.dragAndDrop(source, target, options);
        });
      }
      dblclick(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.dblclick(selector, options);
        });
      }
      tap(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.tap(selector, options);
        });
      }
      fill(selector, value, options) {
        return __async(this, null, function* () {
          return this._mainFrame.fill(selector, value, options);
        });
      }
      locator(selector, options) {
        return this.mainFrame().locator(selector, options);
      }
      frameLocator(selector) {
        return this.mainFrame().frameLocator(selector);
      }
      focus(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.focus(selector, options);
        });
      }
      textContent(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.textContent(selector, options);
        });
      }
      innerText(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.innerText(selector, options);
        });
      }
      innerHTML(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.innerHTML(selector, options);
        });
      }
      getAttribute(selector, name, options) {
        return __async(this, null, function* () {
          return this._mainFrame.getAttribute(selector, name, options);
        });
      }
      inputValue(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.inputValue(selector, options);
        });
      }
      isChecked(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isChecked(selector, options);
        });
      }
      isDisabled(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isDisabled(selector, options);
        });
      }
      isEditable(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isEditable(selector, options);
        });
      }
      isEnabled(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isEnabled(selector, options);
        });
      }
      isHidden(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isHidden(selector, options);
        });
      }
      isVisible(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isVisible(selector, options);
        });
      }
      hover(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.hover(selector, options);
        });
      }
      selectOption(selector, values, options) {
        return __async(this, null, function* () {
          return this._mainFrame.selectOption(selector, values, options);
        });
      }
      setInputFiles(selector, files, options) {
        return __async(this, null, function* () {
          return this._mainFrame.setInputFiles(selector, files, options);
        });
      }
      type(selector, text, options) {
        return __async(this, null, function* () {
          return this._mainFrame.type(selector, text, options);
        });
      }
      press(selector, key, options) {
        return __async(this, null, function* () {
          return this._mainFrame.press(selector, key, options);
        });
      }
      check(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.check(selector, options);
        });
      }
      uncheck(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.uncheck(selector, options);
        });
      }
      setChecked(selector, checked, options) {
        return __async(this, null, function* () {
          return this._mainFrame.setChecked(selector, checked, options);
        });
      }
      waitForTimeout(timeout) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForTimeout(timeout);
        });
      }
      waitForFunction(pageFunction, arg, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForFunction(pageFunction, arg, options);
        });
      }
      workers() {
        return [...this._workers];
      }
      on(event, listener) {
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: true
          });
        super.on(event, listener);
        return this;
      }
      addListener(event, listener) {
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: true
          });
        super.addListener(event, listener);
        return this;
      }
      off(event, listener) {
        super.off(event, listener);
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: false
          });
        return this;
      }
      removeListener(event, listener) {
        super.removeListener(event, listener);
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: false
          });
        return this;
      }
      pause() {
        return __async(this, null, function* () {
          yield this.context()._channel.pause();
        });
      }
      pdf() {
        return __async(this, arguments, function* (options = {}) {
          const transportOptions = __spreadValues({}, options);
          if (transportOptions.margin)
            transportOptions.margin = __spreadValues({}, transportOptions.margin);
          if (typeof options.width === "number")
            transportOptions.width = options.width + "px";
          if (typeof options.height === "number")
            transportOptions.height = options.height + "px";
          for (const margin of ["top", "right", "bottom", "left"]) {
            const index = margin;
            if (options.margin && typeof options.margin[index] === "number")
              transportOptions.margin[index] = transportOptions.margin[index] + "px";
          }
          const result = yield this._channel.pdf(transportOptions);
          const buffer = _buffer.Buffer.from(result.pdf, "base64");
          if (options.path) {
            yield _fs2.default.promises.mkdir(_path2.default.dirname(options.path), {
              recursive: true
            });
            yield _fs2.default.promises.writeFile(options.path, buffer);
          }
          return buffer;
        });
      }
    };
    exports2.Page = Page;
    var BindingCall = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      call(func) {
        return __async(this, null, function* () {
          try {
            const frame = _frame.Frame.from(this._initializer.frame);
            const source = {
              context: frame._page.context(),
              page: frame._page,
              frame
            };
            let result;
            if (this._initializer.handle)
              result = yield func(source, _jsHandle.JSHandle.from(this._initializer.handle));
            else
              result = yield func(source, ...this._initializer.args.map(_jsHandle.parseResult));
            this._channel.resolve({
              result: (0, _jsHandle.serializeArgument)(result)
            }).catch(() => {
            });
          } catch (e) {
            this._channel.reject({
              error: (0, _serializers.serializeError)(e)
            }).catch(() => {
            });
          }
        });
      }
    };
    exports2.BindingCall = BindingCall;
    function trimEnd(s) {
      if (s.length > 50)
        s = s.substring(0, 50) + "\u2026";
      return s;
    }
    function trimUrl(param) {
      if ((0, _utils2.isRegExp)(param))
        return `/${trimEnd(param.source)}/${param.flags}`;
      if ((0, _utils2.isString)(param))
        return `"${trimEnd(param)}"`;
    }
  }
});

// node_modules/playwright-core/lib/client/cdpSession.js
var require_cdpSession = __commonJS({
  "node_modules/playwright-core/lib/client/cdpSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CDPSession = void 0;
    var _channelOwner = require_channelOwner();
    var CDPSession = class extends _channelOwner.ChannelOwner {
      static from(cdpSession) {
        return cdpSession._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on("event", ({
          method,
          params
        }) => {
          this.emit(method, params);
        });
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      send(method, params) {
        return __async(this, null, function* () {
          const result = yield this._channel.send({
            method,
            params
          });
          return result.result;
        });
      }
      detach() {
        return __async(this, null, function* () {
          return this._channel.detach();
        });
      }
    };
    exports2.CDPSession = CDPSession;
  }
});

// node_modules/playwright-core/lib/client/tracing.js
var require_tracing2 = __commonJS({
  "node_modules/playwright-core/lib/client/tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Tracing = void 0;
    var _artifact = require_artifact2();
    var Tracing = class {
      constructor(channel) {
        this._context = void 0;
        this._context = channel;
      }
      start() {
        return __async(this, arguments, function* (options = {}) {
          yield this._context._wrapApiCall(() => __async(this, null, function* () {
            yield this._context._channel.tracingStart(options);
            yield this._context._channel.tracingStartChunk({
              title: options.title
            });
          }));
        });
      }
      startChunk() {
        return __async(this, arguments, function* (options = {}) {
          yield this._context._channel.tracingStartChunk(options);
        });
      }
      stopChunk() {
        return __async(this, arguments, function* (options = {}) {
          yield this._doStopChunk(this._context._channel, options.path);
        });
      }
      stop() {
        return __async(this, arguments, function* (options = {}) {
          yield this._context._wrapApiCall(() => __async(this, null, function* () {
            yield this._doStopChunk(this._context._channel, options.path);
            yield this._context._channel.tracingStop();
          }));
        });
      }
      _doStopChunk(channel, filePath) {
        return __async(this, null, function* () {
          var _result$sourceEntries;
          const isLocal = !this._context._connection.isRemote();
          let mode = "doNotSave";
          if (filePath) {
            if (isLocal)
              mode = "compressTraceAndSources";
            else
              mode = "compressTrace";
          }
          const result = yield channel.tracingStopChunk({
            mode
          });
          if (!filePath) {
            return;
          }
          if (!result.artifact)
            return;
          const artifact = _artifact.Artifact.from(result.artifact);
          yield artifact.saveAs(filePath);
          yield artifact.delete();
          if ((_result$sourceEntries = result.sourceEntries) !== null && _result$sourceEntries !== void 0 && _result$sourceEntries.length)
            yield this._context._localUtils.zip(filePath, result.sourceEntries);
        });
      }
    };
    exports2.Tracing = Tracing;
  }
});

// node_modules/playwright-core/lib/client/browserContext.js
var require_browserContext2 = __commonJS({
  "node_modules/playwright-core/lib/client/browserContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.prepareBrowserContextParams = prepareBrowserContextParams;
    exports2.BrowserContext = void 0;
    var _page = require_page2();
    var _frame = require_frame();
    var network = _interopRequireWildcard2(require_network2());
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _channelOwner = require_channelOwner();
    var _clientHelper = require_clientHelper();
    var _browser = require_browser3();
    var _worker = require_worker();
    var _events = require_events();
    var _timeoutSettings = require_timeoutSettings();
    var _waiter = require_waiter();
    var _utils2 = require_utils();
    var _errors = require_errors();
    var _cdpSession = require_cdpSession();
    var _tracing = require_tracing2();
    var _artifact = require_artifact2();
    var _fetch = require_fetch2();
    var _clientInstrumentation = require_clientInstrumentation();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var BrowserContext = class extends _channelOwner.ChannelOwner {
      static from(context) {
        return context._object;
      }
      static fromNullable(context) {
        return context ? BrowserContext.from(context) : null;
      }
      constructor(parent, type, guid, initializer) {
        var _this$_browser;
        super(parent, type, guid, initializer, (0, _clientInstrumentation.createInstrumentation)());
        this._pages = /* @__PURE__ */ new Set();
        this._routes = [];
        this._browser = null;
        this._browserType = void 0;
        this._localUtils = void 0;
        this._bindings = /* @__PURE__ */ new Map();
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._ownerPage = void 0;
        this._closedPromise = void 0;
        this._options = {};
        this.request = void 0;
        this.tracing = void 0;
        this._backgroundPages = /* @__PURE__ */ new Set();
        this._serviceWorkers = /* @__PURE__ */ new Set();
        this._isChromium = void 0;
        if (parent instanceof _browser.Browser)
          this._browser = parent;
        this._isChromium = ((_this$_browser = this._browser) === null || _this$_browser === void 0 ? void 0 : _this$_browser._name) === "chromium";
        this.tracing = new _tracing.Tracing(this);
        this.request = _fetch.APIRequestContext.from(initializer.APIRequestContext);
        this._channel.on("bindingCall", ({
          binding
        }) => this._onBinding(_page.BindingCall.from(binding)));
        this._channel.on("close", () => this._onClose());
        this._channel.on("page", ({
          page
        }) => this._onPage(_page.Page.from(page)));
        this._channel.on("route", ({
          route,
          request
        }) => this._onRoute(network.Route.from(route), network.Request.from(request)));
        this._channel.on("backgroundPage", ({
          page
        }) => {
          const backgroundPage = _page.Page.from(page);
          this._backgroundPages.add(backgroundPage);
          this.emit(_events.Events.BrowserContext.BackgroundPage, backgroundPage);
        });
        this._channel.on("serviceWorker", ({
          worker
        }) => {
          const serviceWorker = _worker.Worker.from(worker);
          serviceWorker._context = this;
          this._serviceWorkers.add(serviceWorker);
          this.emit(_events.Events.BrowserContext.ServiceWorker, serviceWorker);
        });
        this._channel.on("request", ({
          request,
          page
        }) => this._onRequest(network.Request.from(request), _page.Page.fromNullable(page)));
        this._channel.on("requestFailed", ({
          request,
          failureText,
          responseEndTiming,
          page
        }) => this._onRequestFailed(network.Request.from(request), responseEndTiming, failureText, _page.Page.fromNullable(page)));
        this._channel.on("requestFinished", (params) => this._onRequestFinished(params));
        this._channel.on("response", ({
          response,
          page
        }) => this._onResponse(network.Response.from(response), _page.Page.fromNullable(page)));
        this._closedPromise = new Promise((f) => this.once(_events.Events.BrowserContext.Close, f));
      }
      _setBrowserType(browserType) {
        this._browserType = browserType;
        browserType._contexts.add(this);
      }
      _onPage(page) {
        this._pages.add(page);
        this.emit(_events.Events.BrowserContext.Page, page);
        if (page._opener && !page._opener.isClosed())
          page._opener.emit(_events.Events.Page.Popup, page);
      }
      _onRequest(request, page) {
        this.emit(_events.Events.BrowserContext.Request, request);
        if (page)
          page.emit(_events.Events.Page.Request, request);
      }
      _onResponse(response, page) {
        this.emit(_events.Events.BrowserContext.Response, response);
        if (page)
          page.emit(_events.Events.Page.Response, response);
      }
      _onRequestFailed(request, responseEndTiming, failureText, page) {
        request._failureText = failureText || null;
        if (request._timing)
          request._timing.responseEnd = responseEndTiming;
        this.emit(_events.Events.BrowserContext.RequestFailed, request);
        if (page)
          page.emit(_events.Events.Page.RequestFailed, request);
      }
      _onRequestFinished(params) {
        const {
          responseEndTiming
        } = params;
        const request = network.Request.from(params.request);
        const response = network.Response.fromNullable(params.response);
        const page = _page.Page.fromNullable(params.page);
        if (request._timing)
          request._timing.responseEnd = responseEndTiming;
        this.emit(_events.Events.BrowserContext.RequestFinished, request);
        if (page)
          page.emit(_events.Events.Page.RequestFinished, request);
        if (response)
          response._finishedPromise.resolve();
      }
      _onRoute(route, request) {
        for (const routeHandler of this._routes) {
          if (routeHandler.matches(request.url())) {
            try {
              routeHandler.handle(route, request);
            } finally {
              if (!routeHandler.isActive()) {
                this._routes.splice(this._routes.indexOf(routeHandler), 1);
                if (!this._routes.length)
                  this._wrapApiCall(() => this._disableInterception(), true).catch(() => {
                  });
              }
            }
            return;
          }
        }
        route._internalContinue();
      }
      _onBinding(bindingCall) {
        return __async(this, null, function* () {
          const func = this._bindings.get(bindingCall._initializer.name);
          if (!func)
            return;
          yield bindingCall.call(func);
        });
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultNavigationTimeoutNoReply({
            timeout
          });
        }), true);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultTimeoutNoReply({
            timeout
          });
        }), true);
      }
      browser() {
        return this._browser;
      }
      pages() {
        return [...this._pages];
      }
      newPage() {
        return __async(this, null, function* () {
          if (this._ownerPage)
            throw new Error("Please use browser.newContext()");
          return _page.Page.from((yield this._channel.newPage()).page);
        });
      }
      cookies(urls) {
        return __async(this, null, function* () {
          if (!urls)
            urls = [];
          if (urls && typeof urls === "string")
            urls = [urls];
          return (yield this._channel.cookies({
            urls
          })).cookies;
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          yield this._channel.addCookies({
            cookies
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._channel.clearCookies();
        });
      }
      grantPermissions(permissions, options) {
        return __async(this, null, function* () {
          yield this._channel.grantPermissions(__spreadValues({
            permissions
          }, options));
        });
      }
      clearPermissions() {
        return __async(this, null, function* () {
          yield this._channel.clearPermissions();
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          yield this._channel.setGeolocation({
            geolocation: geolocation || void 0
          });
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          network.validateHeaders(headers);
          yield this._channel.setExtraHTTPHeaders({
            headers: (0, _utils2.headersObjectToArray)(headers)
          });
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          yield this._channel.setOffline({
            offline
          });
        });
      }
      setHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          if (!(0, _utils2.isUnderTest)())
            (0, _clientHelper.deprecate)(`context.setHTTPCredentials`, `warning: method |context.setHTTPCredentials()| is deprecated. Instead of changing credentials, create another browser context with new credentials.`);
          yield this._channel.setHTTPCredentials({
            httpCredentials: httpCredentials || void 0
          });
        });
      }
      addInitScript(script, arg) {
        return __async(this, null, function* () {
          const source = yield (0, _clientHelper.evaluationScript)(script, arg);
          yield this._channel.addInitScript({
            source
          });
        });
      }
      exposeBinding(_0, _1) {
        return __async(this, arguments, function* (name, callback, options = {}) {
          yield this._channel.exposeBinding({
            name,
            needsHandle: options.handle
          });
          this._bindings.set(name, callback);
        });
      }
      exposeFunction(name, callback) {
        return __async(this, null, function* () {
          yield this._channel.exposeBinding({
            name
          });
          const binding = (source, ...args) => callback(...args);
          this._bindings.set(name, binding);
        });
      }
      route(_0, _1) {
        return __async(this, arguments, function* (url, handler, options = {}) {
          this._routes.unshift(new network.RouteHandler(this._options.baseURL, url, handler, options.times));
          if (this._routes.length === 1)
            yield this._channel.setNetworkInterceptionEnabled({
              enabled: true
            });
        });
      }
      unroute(url, handler) {
        return __async(this, null, function* () {
          this._routes = this._routes.filter((route) => route.url !== url || handler && route.handler !== handler);
          if (!this._routes.length)
            yield this._disableInterception();
        });
      }
      _disableInterception() {
        return __async(this, null, function* () {
          yield this._channel.setNetworkInterceptionEnabled({
            enabled: false
          });
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.BrowserContext.Close)
              waiter.rejectOnEvent(this, _events.Events.BrowserContext.Close, new Error("Context closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
      storageState() {
        return __async(this, arguments, function* (options = {}) {
          const state = yield this._channel.storageState();
          if (options.path) {
            yield (0, _utils2.mkdirIfNeeded)(options.path);
            yield _fs2.default.promises.writeFile(options.path, JSON.stringify(state, void 0, 2), "utf8");
          }
          return state;
        });
      }
      backgroundPages() {
        return [...this._backgroundPages];
      }
      serviceWorkers() {
        return [...this._serviceWorkers];
      }
      newCDPSession(page) {
        return __async(this, null, function* () {
          if (!(page instanceof _page.Page) && !(page instanceof _frame.Frame))
            throw new Error("page: expected Page or Frame");
          const result = yield this._channel.newCDPSession(page instanceof _page.Page ? {
            page: page._channel
          } : {
            frame: page._channel
          });
          return _cdpSession.CDPSession.from(result.session);
        });
      }
      _onClose() {
        var _this$_browserType, _this$_browserType$_c;
        if (this._browser)
          this._browser._contexts.delete(this);
        (_this$_browserType = this._browserType) === null || _this$_browserType === void 0 ? void 0 : (_this$_browserType$_c = _this$_browserType._contexts) === null || _this$_browserType$_c === void 0 ? void 0 : _this$_browserType$_c.delete(this);
        this.emit(_events.Events.BrowserContext.Close, this);
      }
      close() {
        return __async(this, null, function* () {
          try {
            yield this._wrapApiCall(() => __async(this, null, function* () {
              var _this$_browserType2, _this$_browserType2$_;
              yield (_this$_browserType2 = this._browserType) === null || _this$_browserType2 === void 0 ? void 0 : (_this$_browserType2$_ = _this$_browserType2._onWillCloseContext) === null || _this$_browserType2$_ === void 0 ? void 0 : _this$_browserType2$_.call(_this$_browserType2, this);
              if (this._options.recordHar) {
                const har = yield this._channel.harExport();
                const artifact = _artifact.Artifact.from(har.artifact);
                yield artifact.saveAs(this._options.recordHar.path);
                yield artifact.delete();
              }
            }), true);
            yield this._channel.close();
            yield this._closedPromise;
          } catch (e) {
            if ((0, _errors.isSafeCloseError)(e))
              return;
            throw e;
          }
        });
      }
      _enableRecorder(params) {
        return __async(this, null, function* () {
          yield this._channel.recorderSupplementEnable(params);
        });
      }
    };
    exports2.BrowserContext = BrowserContext;
    function prepareBrowserContextParams(options) {
      return __async(this, null, function* () {
        if (options.videoSize && !options.videosPath)
          throw new Error(`"videoSize" option requires "videosPath" to be specified`);
        if (options.extraHTTPHeaders)
          network.validateHeaders(options.extraHTTPHeaders);
        const contextParams = __spreadProps(__spreadValues({}, options), {
          viewport: options.viewport === null ? void 0 : options.viewport,
          noDefaultViewport: options.viewport === null,
          extraHTTPHeaders: options.extraHTTPHeaders ? (0, _utils2.headersObjectToArray)(options.extraHTTPHeaders) : void 0,
          storageState: typeof options.storageState === "string" ? JSON.parse(yield _fs2.default.promises.readFile(options.storageState, "utf8")) : options.storageState
        });
        if (!contextParams.recordVideo && options.videosPath) {
          contextParams.recordVideo = {
            dir: options.videosPath,
            size: options.videoSize
          };
        }
        return contextParams;
      });
    }
  }
});

// node_modules/playwright-core/lib/client/browser.js
var require_browser3 = __commonJS({
  "node_modules/playwright-core/lib/client/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Browser = void 0;
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _events = require_events();
    var _errors = require_errors();
    var _cdpSession = require_cdpSession();
    var Browser = class extends _channelOwner.ChannelOwner {
      static from(browser) {
        return browser._object;
      }
      static fromNullable(browser) {
        return browser ? Browser.from(browser) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._contexts = /* @__PURE__ */ new Set();
        this._isConnected = true;
        this._closedPromise = void 0;
        this._shouldCloseConnectionOnClose = false;
        this._browserType = void 0;
        this._name = void 0;
        this._localUtils = void 0;
        this._name = initializer.name;
        this._channel.on("close", () => this._didClose());
        this._closedPromise = new Promise((f) => this.once(_events.Events.Browser.Disconnected, f));
      }
      _setBrowserType(browserType) {
        this._browserType = browserType;
        for (const context of this._contexts)
          context._setBrowserType(browserType);
      }
      newContext() {
        return __async(this, arguments, function* (options = {}) {
          var _this$_browserType$_o, _this$_browserType;
          options = __spreadValues(__spreadValues({}, this._browserType._defaultContextOptions), options);
          const contextOptions = yield (0, _browserContext.prepareBrowserContextParams)(options);
          const context = _browserContext.BrowserContext.from((yield this._channel.newContext(contextOptions)).context);
          context._options = contextOptions;
          this._contexts.add(context);
          context._logger = options.logger || this._logger;
          context._setBrowserType(this._browserType);
          context._localUtils = this._localUtils;
          yield (_this$_browserType$_o = (_this$_browserType = this._browserType)._onDidCreateContext) === null || _this$_browserType$_o === void 0 ? void 0 : _this$_browserType$_o.call(_this$_browserType, context);
          return context;
        });
      }
      contexts() {
        return [...this._contexts];
      }
      version() {
        return this._initializer.version;
      }
      newPage() {
        return __async(this, arguments, function* (options = {}) {
          const context = yield this.newContext(options);
          const page = yield context.newPage();
          page._ownedContext = context;
          context._ownerPage = page;
          return page;
        });
      }
      isConnected() {
        return this._isConnected;
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          return _cdpSession.CDPSession.from((yield this._channel.newBrowserCDPSession()).session);
        });
      }
      startTracing(_0) {
        return __async(this, arguments, function* (page, options = {}) {
          yield this._channel.startTracing(__spreadProps(__spreadValues({}, options), {
            page: page ? page._channel : void 0
          }));
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          return Buffer.from((yield this._channel.stopTracing()).binary, "base64");
        });
      }
      close() {
        return __async(this, null, function* () {
          try {
            if (this._shouldCloseConnectionOnClose)
              this._connection.close(_errors.kBrowserClosedError);
            else
              yield this._channel.close();
            yield this._closedPromise;
          } catch (e) {
            if ((0, _errors.isSafeCloseError)(e))
              return;
            throw e;
          }
        });
      }
      _didClose() {
        this._isConnected = false;
        this.emit(_events.Events.Browser.Disconnected, this);
      }
    };
    exports2.Browser = Browser;
  }
});

// node_modules/playwright-core/lib/client/browserType.js
var require_browserType2 = __commonJS({
  "node_modules/playwright-core/lib/client/browserType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserType = void 0;
    var _browser3 = require_browser3();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _connection = require_connection();
    var _events = require_events();
    var _clientHelper = require_clientHelper();
    var _utils2 = require_utils();
    var _errors = require_errors();
    var _async = require_async();
    var BrowserType = class extends _channelOwner.ChannelOwner {
      constructor(...args) {
        super(...args);
        this._serverLauncher = void 0;
        this._contexts = /* @__PURE__ */ new Set();
        this._playwright = void 0;
        this._defaultContextOptions = {};
        this._defaultLaunchOptions = {};
        this._onDidCreateContext = void 0;
        this._onWillCloseContext = void 0;
      }
      static from(browserType) {
        return browserType._object;
      }
      executablePath() {
        if (!this._initializer.executablePath)
          throw new Error("Browser is not supported on current platform");
        return this._initializer.executablePath;
      }
      name() {
        return this._initializer.name;
      }
      launch() {
        return __async(this, arguments, function* (options = {}) {
          const logger = options.logger || this._defaultLaunchOptions.logger;
          (0, _utils2.assert)(!options.userDataDir, "userDataDir option is not supported in `browserType.launch`. Use `browserType.launchPersistentContext` instead");
          (0, _utils2.assert)(!options.port, "Cannot specify a port without launching as a server.");
          options = __spreadValues(__spreadValues({}, this._defaultLaunchOptions), options);
          const launchOptions = __spreadProps(__spreadValues({}, options), {
            ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
            env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : void 0
          });
          const browser = _browser3.Browser.from((yield this._channel.launch(launchOptions)).browser);
          browser._logger = logger;
          browser._setBrowserType(this);
          browser._localUtils = this._playwright._utils;
          return browser;
        });
      }
      launchServer() {
        return __async(this, arguments, function* (options = {}) {
          if (!this._serverLauncher)
            throw new Error("Launching server is not supported");
          options = __spreadValues(__spreadValues({}, this._defaultLaunchOptions), options);
          return this._serverLauncher.launchServer(options);
        });
      }
      launchPersistentContext(_0) {
        return __async(this, arguments, function* (userDataDir, options = {}) {
          var _this$_onDidCreateCon;
          const logger = options.logger || this._defaultLaunchOptions.logger;
          (0, _utils2.assert)(!options.port, "Cannot specify a port without launching as a server.");
          options = __spreadValues(__spreadValues(__spreadValues({}, this._defaultLaunchOptions), this._defaultContextOptions), options);
          const contextParams = yield (0, _browserContext.prepareBrowserContextParams)(options);
          const persistentParams = __spreadProps(__spreadValues({}, contextParams), {
            ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
            env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : void 0,
            channel: options.channel,
            userDataDir
          });
          const result = yield this._channel.launchPersistentContext(persistentParams);
          const context = _browserContext.BrowserContext.from(result.context);
          context._options = contextParams;
          context._logger = logger;
          context._setBrowserType(this);
          context._localUtils = this._playwright._utils;
          yield (_this$_onDidCreateCon = this._onDidCreateContext) === null || _this$_onDidCreateCon === void 0 ? void 0 : _this$_onDidCreateCon.call(this, context);
          return context;
        });
      }
      connect(optionsOrWsEndpoint, options) {
        return __async(this, null, function* () {
          if (typeof optionsOrWsEndpoint === "string")
            return this._connect(optionsOrWsEndpoint, options);
          (0, _utils2.assert)(optionsOrWsEndpoint.wsEndpoint, "options.wsEndpoint is required");
          return this._connect(optionsOrWsEndpoint.wsEndpoint, optionsOrWsEndpoint);
        });
      }
      _connect(_0) {
        return __async(this, arguments, function* (wsEndpoint, params = {}) {
          const logger = params.logger;
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            const deadline = params.timeout ? (0, _utils2.monotonicTime)() + params.timeout : 0;
            let browser;
            const {
              pipe
            } = yield this._channel.connect({
              wsEndpoint,
              headers: params.headers,
              slowMo: params.slowMo,
              timeout: params.timeout
            });
            const closePipe = () => pipe.close().catch(() => {
            });
            const connection = new _connection.Connection();
            connection.markAsRemote();
            connection.on("close", closePipe);
            const onPipeClosed = () => {
              var _browser2;
              for (const context of ((_browser = browser) === null || _browser === void 0 ? void 0 : _browser.contexts()) || []) {
                var _browser;
                for (const page of context.pages())
                  page._onClose();
                context._onClose();
              }
              (_browser2 = browser) === null || _browser2 === void 0 ? void 0 : _browser2._didClose();
              connection.close(_errors.kBrowserClosedError);
            };
            pipe.on("closed", onPipeClosed);
            connection.onmessage = (message) => pipe.send({
              message
            }).catch(onPipeClosed);
            pipe.on("message", ({
              message
            }) => {
              try {
                connection.dispatch(message);
              } catch (e) {
                console.error(`Playwright: Connection dispatch error`);
                console.error(e);
                closePipe();
              }
            });
            const createBrowserPromise = new Promise((fulfill, reject) => __async(this, null, function* () {
              try {
                if (params.__testHookBeforeCreateBrowser)
                  yield params.__testHookBeforeCreateBrowser();
                const playwright2 = yield connection.initializePlaywright();
                if (!playwright2._initializer.preLaunchedBrowser) {
                  reject(new Error("Malformed endpoint. Did you use launchServer method?"));
                  closePipe();
                  return;
                }
                playwright2._setSelectors(this._playwright.selectors);
                browser = _browser3.Browser.from(playwright2._initializer.preLaunchedBrowser);
                browser._logger = logger;
                browser._shouldCloseConnectionOnClose = true;
                browser._setBrowserType(playwright2[browser._name]);
                browser._localUtils = this._playwright._utils;
                browser.on(_events.Events.Browser.Disconnected, closePipe);
                fulfill(browser);
              } catch (e) {
                reject(e);
              }
            }));
            const result = yield (0, _async.raceAgainstDeadline)(createBrowserPromise, deadline);
            if (!result.timedOut) {
              return result.result;
            } else {
              closePipe();
              throw new Error(`Timeout ${params.timeout}ms exceeded`);
            }
          }));
        });
      }
      connectOverCDP(endpointURLOrOptions, options) {
        if (typeof endpointURLOrOptions === "string")
          return this._connectOverCDP(endpointURLOrOptions, options);
        const endpointURL = "endpointURL" in endpointURLOrOptions ? endpointURLOrOptions.endpointURL : endpointURLOrOptions.wsEndpoint;
        (0, _utils2.assert)(endpointURL, "Cannot connect over CDP without wsEndpoint.");
        return this.connectOverCDP(endpointURL, endpointURLOrOptions);
      }
      _connectOverCDP(_0) {
        return __async(this, arguments, function* (endpointURL, params = {}) {
          if (this.name() !== "chromium")
            throw new Error("Connecting over CDP is only supported in Chromium.");
          const headers = params.headers ? (0, _utils2.headersObjectToArray)(params.headers) : void 0;
          const result = yield this._channel.connectOverCDP({
            endpointURL,
            headers,
            slowMo: params.slowMo,
            timeout: params.timeout
          });
          const browser = _browser3.Browser.from(result.browser);
          if (result.defaultContext)
            browser._contexts.add(_browserContext.BrowserContext.from(result.defaultContext));
          browser._logger = params.logger;
          browser._setBrowserType(this);
          browser._localUtils = this._playwright._utils;
          return browser;
        });
      }
    };
    exports2.BrowserType = BrowserType;
  }
});

// node_modules/playwright-core/lib/utils/netUtils.js
var require_netUtils = __commonJS({
  "node_modules/playwright-core/lib/utils/netUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createSocket = createSocket;
    var _net = _interopRequireDefault2(require("net"));
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createSocket(host, port) {
      return __async(this, null, function* () {
        return new Promise((resolve, reject) => {
          const socket = _net.default.createConnection({
            host,
            port
          });
          socket.on("connect", () => resolve(socket));
          socket.on("error", (error) => reject(error));
        });
      });
    }
  }
});

// node_modules/playwright-core/lib/client/android.js
var require_android2 = __commonJS({
  "node_modules/playwright-core/lib/client/android.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AndroidWebView = exports2.AndroidInput = exports2.AndroidSocket = exports2.AndroidDevice = exports2.Android = void 0;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _utils2 = require_utils();
    var _events = require_events();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _timeoutSettings = require_timeoutSettings();
    var _waiter = require_waiter();
    var _events2 = require("events");
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Android = class extends _channelOwner.ChannelOwner {
      static from(android) {
        return android._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = void 0;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({
          timeout
        });
      }
      devices() {
        return __async(this, null, function* () {
          const {
            devices
          } = yield this._channel.devices();
          return devices.map((d) => AndroidDevice.from(d));
        });
      }
    };
    exports2.Android = Android;
    var AndroidDevice = class extends _channelOwner.ChannelOwner {
      static from(androidDevice) {
        return androidDevice._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = void 0;
        this._webViews = /* @__PURE__ */ new Map();
        this.input = void 0;
        this.input = new AndroidInput(this);
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(parent._timeoutSettings);
        this._channel.on("webViewAdded", ({
          webView
        }) => this._onWebViewAdded(webView));
        this._channel.on("webViewRemoved", ({
          pid
        }) => this._onWebViewRemoved(pid));
      }
      _onWebViewAdded(webView) {
        const view = new AndroidWebView(this, webView);
        this._webViews.set(webView.pid, view);
        this.emit(_events.Events.AndroidDevice.WebView, view);
      }
      _onWebViewRemoved(pid) {
        const view = this._webViews.get(pid);
        this._webViews.delete(pid);
        if (view)
          view.emit(_events.Events.AndroidWebView.Close);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({
          timeout
        });
      }
      serial() {
        return this._initializer.serial;
      }
      model() {
        return this._initializer.model;
      }
      webViews() {
        return [...this._webViews.values()];
      }
      webView(selector, options) {
        return __async(this, null, function* () {
          const webView = [...this._webViews.values()].find((v) => v.pkg() === selector.pkg);
          if (webView)
            return webView;
          return this.waitForEvent("webview", __spreadProps(__spreadValues({}, options), {
            predicate: (view) => view.pkg() === selector.pkg
          }));
        });
      }
      wait(selector, options) {
        return __async(this, null, function* () {
          yield this._channel.wait(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options));
        });
      }
      fill(selector, text, options) {
        return __async(this, null, function* () {
          yield this._channel.fill(__spreadValues({
            selector: toSelectorChannel(selector),
            text
          }, options));
        });
      }
      press(selector, key, options) {
        return __async(this, null, function* () {
          yield this.tap(selector, options);
          yield this.input.press(key);
        });
      }
      tap(selector, options) {
        return __async(this, null, function* () {
          yield this._channel.tap(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options));
        });
      }
      drag(selector, dest, options) {
        return __async(this, null, function* () {
          yield this._channel.drag(__spreadValues({
            selector: toSelectorChannel(selector),
            dest
          }, options));
        });
      }
      fling(selector, direction, options) {
        return __async(this, null, function* () {
          yield this._channel.fling(__spreadValues({
            selector: toSelectorChannel(selector),
            direction
          }, options));
        });
      }
      longTap(selector, options) {
        return __async(this, null, function* () {
          yield this._channel.longTap(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options));
        });
      }
      pinchClose(selector, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.pinchClose(__spreadValues({
            selector: toSelectorChannel(selector),
            percent
          }, options));
        });
      }
      pinchOpen(selector, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.pinchOpen(__spreadValues({
            selector: toSelectorChannel(selector),
            percent
          }, options));
        });
      }
      scroll(selector, direction, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.scroll(__spreadValues({
            selector: toSelectorChannel(selector),
            direction,
            percent
          }, options));
        });
      }
      swipe(selector, direction, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.swipe(__spreadValues({
            selector: toSelectorChannel(selector),
            direction,
            percent
          }, options));
        });
      }
      info(selector) {
        return __async(this, null, function* () {
          return (yield this._channel.info({
            selector: toSelectorChannel(selector)
          })).info;
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          const {
            binary
          } = yield this._channel.screenshot();
          const buffer = Buffer.from(binary, "base64");
          if (options.path)
            yield _fs2.default.promises.writeFile(options.path, buffer);
          return buffer;
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._channel.close();
          this.emit(_events.Events.AndroidDevice.Close);
        });
      }
      shell(command) {
        return __async(this, null, function* () {
          const {
            result
          } = yield this._channel.shell({
            command
          });
          return Buffer.from(result, "base64");
        });
      }
      open(command) {
        return __async(this, null, function* () {
          return AndroidSocket.from((yield this._channel.open({
            command
          })).socket);
        });
      }
      installApk(file, options) {
        return __async(this, null, function* () {
          yield this._channel.installApk({
            file: yield loadFile(file),
            args: options && options.args
          });
        });
      }
      push(file, path, options) {
        return __async(this, null, function* () {
          yield this._channel.push({
            file: yield loadFile(file),
            path,
            mode: options ? options.mode : void 0
          });
        });
      }
      launchBrowser() {
        return __async(this, arguments, function* (options = {}) {
          const contextOptions = yield (0, _browserContext.prepareBrowserContextParams)(options);
          const {
            context
          } = yield this._channel.launchBrowser(contextOptions);
          return _browserContext.BrowserContext.from(context);
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.AndroidDevice.Close)
              waiter.rejectOnEvent(this, _events.Events.AndroidDevice.Close, new Error("Device closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
    };
    exports2.AndroidDevice = AndroidDevice;
    var AndroidSocket = class extends _channelOwner.ChannelOwner {
      static from(androidDevice) {
        return androidDevice._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on("data", ({
          data
        }) => this.emit(_events.Events.AndroidSocket.Data, Buffer.from(data, "base64")));
        this._channel.on("close", () => this.emit(_events.Events.AndroidSocket.Close));
      }
      write(data) {
        return __async(this, null, function* () {
          yield this._channel.write({
            data: data.toString("base64")
          });
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._channel.close();
        });
      }
    };
    exports2.AndroidSocket = AndroidSocket;
    function loadFile(file) {
      return __async(this, null, function* () {
        if ((0, _utils2.isString)(file))
          return _fs2.default.promises.readFile(file, {
            encoding: "base64"
          }).toString();
        return file.toString("base64");
      });
    }
    var AndroidInput = class {
      constructor(device) {
        this._device = void 0;
        this._device = device;
      }
      type(text) {
        return __async(this, null, function* () {
          yield this._device._channel.inputType({
            text
          });
        });
      }
      press(key) {
        return __async(this, null, function* () {
          yield this._device._channel.inputPress({
            key
          });
        });
      }
      tap(point) {
        return __async(this, null, function* () {
          yield this._device._channel.inputTap({
            point
          });
        });
      }
      swipe(from, segments, steps) {
        return __async(this, null, function* () {
          yield this._device._channel.inputSwipe({
            segments,
            steps
          });
        });
      }
      drag(from, to, steps) {
        return __async(this, null, function* () {
          yield this._device._channel.inputDrag({
            from,
            to,
            steps
          });
        });
      }
    };
    exports2.AndroidInput = AndroidInput;
    function toSelectorChannel(selector) {
      const {
        checkable,
        checked,
        clazz,
        clickable,
        depth,
        desc,
        enabled,
        focusable,
        focused,
        hasChild,
        hasDescendant,
        longClickable,
        pkg,
        res,
        scrollable,
        selected,
        text
      } = selector;
      const toRegex = (value) => {
        if (value === void 0)
          return void 0;
        if ((0, _utils2.isRegExp)(value))
          return value.source;
        return "^" + value.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") + "$";
      };
      return {
        checkable,
        checked,
        clazz: toRegex(clazz),
        pkg: toRegex(pkg),
        desc: toRegex(desc),
        res: toRegex(res),
        text: toRegex(text),
        clickable,
        depth,
        enabled,
        focusable,
        focused,
        hasChild: hasChild ? {
          selector: toSelectorChannel(hasChild.selector)
        } : void 0,
        hasDescendant: hasDescendant ? {
          selector: toSelectorChannel(hasDescendant.selector),
          maxDepth: hasDescendant.maxDepth
        } : void 0,
        longClickable,
        scrollable,
        selected
      };
    }
    var AndroidWebView = class extends _events2.EventEmitter {
      constructor(device, data) {
        super();
        this._device = void 0;
        this._data = void 0;
        this._pagePromise = void 0;
        this._device = device;
        this._data = data;
      }
      pid() {
        return this._data.pid;
      }
      pkg() {
        return this._data.pkg;
      }
      page() {
        return __async(this, null, function* () {
          if (!this._pagePromise)
            this._pagePromise = this._fetchPage();
          return this._pagePromise;
        });
      }
      _fetchPage() {
        return __async(this, null, function* () {
          const {
            context
          } = yield this._device._channel.connectToWebView({
            pid: this._data.pid
          });
          return _browserContext.BrowserContext.from(context).pages()[0];
        });
      }
    };
    exports2.AndroidWebView = AndroidWebView;
  }
});

// node_modules/playwright-core/lib/client/electron.js
var require_electron3 = __commonJS({
  "node_modules/playwright-core/lib/client/electron.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElectronApplication = exports2.Electron = void 0;
    var _timeoutSettings = require_timeoutSettings();
    var _utils2 = require_utils();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _clientHelper = require_clientHelper();
    var _events = require_events();
    var _jsHandle = require_jsHandle();
    var _waiter = require_waiter();
    var Electron = class extends _channelOwner.ChannelOwner {
      static from(electron) {
        return electron._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      launch() {
        return __async(this, arguments, function* (options = {}) {
          const params = __spreadProps(__spreadValues({}, options), {
            extraHTTPHeaders: options.extraHTTPHeaders && (0, _utils2.headersObjectToArray)(options.extraHTTPHeaders),
            env: (0, _clientHelper.envObjectToArray)(options.env ? options.env : process.env)
          });
          const app = ElectronApplication.from((yield this._channel.launch(params)).electronApplication);
          app._context._options = params;
          return app;
        });
      }
    };
    exports2.Electron = Electron;
    var ElectronApplication = class extends _channelOwner.ChannelOwner {
      static from(electronApplication) {
        return electronApplication._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._context = void 0;
        this._windows = /* @__PURE__ */ new Set();
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._context = _browserContext.BrowserContext.from(initializer.context);
        for (const page of this._context._pages)
          this._onPage(page);
        this._context.on(_events.Events.BrowserContext.Page, (page) => this._onPage(page));
        this._channel.on("close", () => this.emit(_events.Events.ElectronApplication.Close));
      }
      _onPage(page) {
        this._windows.add(page);
        this.emit(_events.Events.ElectronApplication.Window, page);
        page.once(_events.Events.Page.Close, () => this._windows.delete(page));
      }
      windows() {
        return [...this._windows];
      }
      firstWindow() {
        return __async(this, null, function* () {
          if (this._windows.size)
            return this._windows.values().next().value;
          return this.waitForEvent("window");
        });
      }
      context() {
        return this._context;
      }
      close() {
        return __async(this, null, function* () {
          yield this._channel.close();
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.ElectronApplication.Close)
              waiter.rejectOnEvent(this, _events.Events.ElectronApplication.Close, new Error("Electron application closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
      browserWindow(page) {
        return __async(this, null, function* () {
          const result = yield this._channel.browserWindow({
            page: page._channel
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
    };
    exports2.ElectronApplication = ElectronApplication;
  }
});

// node_modules/playwright-core/lib/client/localUtils.js
var require_localUtils = __commonJS({
  "node_modules/playwright-core/lib/client/localUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LocalUtils = void 0;
    var _channelOwner = require_channelOwner();
    var LocalUtils = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      zip(zipFile, entries) {
        return __async(this, null, function* () {
          yield this._channel.zip({
            zipFile,
            entries
          });
        });
      }
    };
    exports2.LocalUtils = LocalUtils;
  }
});

// node_modules/playwright-core/lib/client/selectors.js
var require_selectors2 = __commonJS({
  "node_modules/playwright-core/lib/client/selectors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SelectorsOwner = exports2.Selectors = void 0;
    var _clientHelper = require_clientHelper();
    var _channelOwner = require_channelOwner();
    var Selectors = class {
      constructor() {
        this._channels = /* @__PURE__ */ new Set();
        this._registrations = [];
      }
      register(_0, _1) {
        return __async(this, arguments, function* (name, script, options = {}) {
          const source = yield (0, _clientHelper.evaluationScript)(script, void 0, false);
          const params = __spreadProps(__spreadValues({}, options), {
            name,
            source
          });
          for (const channel of this._channels)
            yield channel._channel.register(params);
          this._registrations.push(params);
        });
      }
      _addChannel(channel) {
        this._channels.add(channel);
        for (const params of this._registrations) {
          channel._channel.register(params).catch((e) => {
          });
        }
      }
      _removeChannel(channel) {
        this._channels.delete(channel);
      }
    };
    exports2.Selectors = Selectors;
    var SelectorsOwner = class extends _channelOwner.ChannelOwner {
      static from(browser) {
        return browser._object;
      }
    };
    exports2.SelectorsOwner = SelectorsOwner;
  }
});

// node_modules/playwright-core/lib/client/playwright.js
var require_playwright2 = __commonJS({
  "node_modules/playwright-core/lib/client/playwright.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Playwright = void 0;
    var _dns = _interopRequireDefault2(require("dns"));
    var _util = _interopRequireDefault2(require("util"));
    var _errors = require_errors();
    var _netUtils = require_netUtils();
    var _android = require_android2();
    var _browserType = require_browserType2();
    var _channelOwner = require_channelOwner();
    var _electron = require_electron3();
    var _fetch = require_fetch2();
    var _localUtils = require_localUtils();
    var _selectors = require_selectors2();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var dnsLookupAsync = _util.default.promisify(_dns.default.lookup);
    var Playwright = class extends _channelOwner.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._android = void 0;
        this._electron = void 0;
        this.chromium = void 0;
        this.firefox = void 0;
        this.webkit = void 0;
        this.devices = void 0;
        this.selectors = void 0;
        this.request = void 0;
        this.errors = void 0;
        this._utils = void 0;
        this._sockets = /* @__PURE__ */ new Map();
        this._redirectPortForTest = void 0;
        this.request = new _fetch.APIRequest(this);
        this.chromium = _browserType.BrowserType.from(initializer.chromium);
        this.chromium._playwright = this;
        this.firefox = _browserType.BrowserType.from(initializer.firefox);
        this.firefox._playwright = this;
        this.webkit = _browserType.BrowserType.from(initializer.webkit);
        this.webkit._playwright = this;
        this._android = _android.Android.from(initializer.android);
        this._electron = _electron.Electron.from(initializer.electron);
        this.devices = {};
        for (const {
          name,
          descriptor
        } of initializer.deviceDescriptors)
          this.devices[name] = descriptor;
        this.selectors = new _selectors.Selectors();
        this.errors = {
          TimeoutError: _errors.TimeoutError
        };
        this._utils = _localUtils.LocalUtils.from(initializer.utils);
        const selectorsOwner = _selectors.SelectorsOwner.from(initializer.selectors);
        this.selectors._addChannel(selectorsOwner);
        this._connection.on("close", () => {
          this.selectors._removeChannel(selectorsOwner);
          for (const uid of this._sockets.keys())
            this._onSocksClosed(uid);
        });
        global._playwrightInstance = this;
      }
      _hideHighlight() {
        return __async(this, null, function* () {
          yield this._channel.hideHighlight();
        });
      }
      _setSelectors(selectors) {
        const selectorsOwner = _selectors.SelectorsOwner.from(this._initializer.selectors);
        this.selectors._removeChannel(selectorsOwner);
        this.selectors = selectors;
        this.selectors._addChannel(selectorsOwner);
      }
      _enablePortForwarding(redirectPortForTest) {
        this._redirectPortForTest = redirectPortForTest;
        this._channel.on("socksRequested", ({
          uid,
          host,
          port
        }) => this._onSocksRequested(uid, host, port));
        this._channel.on("socksData", ({
          uid,
          data
        }) => this._onSocksData(uid, Buffer.from(data, "base64")));
        this._channel.on("socksClosed", ({
          uid
        }) => this._onSocksClosed(uid));
      }
      _onSocksRequested(uid, host, port) {
        return __async(this, null, function* () {
          if (host === "local.playwright")
            host = "localhost";
          try {
            if (this._redirectPortForTest)
              port = this._redirectPortForTest;
            const {
              address
            } = yield dnsLookupAsync(host);
            const socket = yield (0, _netUtils.createSocket)(address, port);
            socket.on("data", (data) => this._channel.socksData({
              uid,
              data: data.toString("base64")
            }).catch(() => {
            }));
            socket.on("error", (error) => {
              this._channel.socksError({
                uid,
                error: error.message
              }).catch(() => {
              });
              this._sockets.delete(uid);
            });
            socket.on("end", () => {
              this._channel.socksEnd({
                uid
              }).catch(() => {
              });
              this._sockets.delete(uid);
            });
            const localAddress = socket.localAddress;
            const localPort = socket.localPort;
            this._sockets.set(uid, socket);
            this._channel.socksConnected({
              uid,
              host: localAddress,
              port: localPort
            }).catch(() => {
            });
          } catch (error) {
            this._channel.socksFailed({
              uid,
              errorCode: error.code
            }).catch(() => {
            });
          }
        });
      }
      _onSocksData(uid, data) {
        var _this$_sockets$get;
        (_this$_sockets$get = this._sockets.get(uid)) === null || _this$_sockets$get === void 0 ? void 0 : _this$_sockets$get.write(data);
      }
      static from(channel) {
        return channel._object;
      }
      _onSocksClosed(uid) {
        var _this$_sockets$get2;
        (_this$_sockets$get2 = this._sockets.get(uid)) === null || _this$_sockets$get2 === void 0 ? void 0 : _this$_sockets$get2.destroy();
        this._sockets.delete(uid);
      }
    };
    exports2.Playwright = Playwright;
  }
});

// node_modules/playwright-core/lib/client/jsonPipe.js
var require_jsonPipe = __commonJS({
  "node_modules/playwright-core/lib/client/jsonPipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JsonPipe = void 0;
    var _channelOwner = require_channelOwner();
    var JsonPipe = class extends _channelOwner.ChannelOwner {
      static from(jsonPipe) {
        return jsonPipe._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      channel() {
        return this._channel;
      }
    };
    exports2.JsonPipe = JsonPipe;
  }
});

// node_modules/playwright-core/lib/client/connection.js
var require_connection = __commonJS({
  "node_modules/playwright-core/lib/client/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Connection = void 0;
    var _browser = require_browser3();
    var _browserContext = require_browserContext2();
    var _browserType = require_browserType2();
    var _channelOwner = require_channelOwner();
    var _elementHandle = require_elementHandle();
    var _frame = require_frame();
    var _jsHandle = require_jsHandle();
    var _network = require_network2();
    var _page = require_page2();
    var _worker = require_worker();
    var _consoleMessage = require_consoleMessage();
    var _dialog = require_dialog2();
    var _serializers = require_serializers();
    var _cdpSession = require_cdpSession();
    var _playwright = require_playwright2();
    var _electron = require_electron3();
    var _stream = require_stream();
    var _debugLogger = require_debugLogger();
    var _selectors = require_selectors2();
    var _android = require_android2();
    var _artifact = require_artifact2();
    var _events = require("events");
    var _jsonPipe = require_jsonPipe();
    var _fetch = require_fetch2();
    var _localUtils = require_localUtils();
    var Root = class extends _channelOwner.ChannelOwner {
      constructor(connection) {
        super(connection, "Root", "", {});
      }
      initialize() {
        return __async(this, null, function* () {
          return _playwright.Playwright.from((yield this._channel.initialize({
            sdkLanguage: "javascript"
          })).playwright);
        });
      }
    };
    var Connection = class extends _events.EventEmitter {
      constructor() {
        super();
        this._objects = /* @__PURE__ */ new Map();
        this._waitingForObject = /* @__PURE__ */ new Map();
        this.onmessage = (message) => {
        };
        this._lastId = 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._rootObject = void 0;
        this._closedErrorMessage = void 0;
        this._isRemote = false;
        this._rootObject = new Root(this);
      }
      markAsRemote() {
        this._isRemote = true;
      }
      isRemote() {
        return this._isRemote;
      }
      initializePlaywright() {
        return __async(this, null, function* () {
          return yield this._rootObject.initialize();
        });
      }
      pendingProtocolCalls() {
        return Array.from(this._callbacks.values()).map((callback) => callback.stackTrace).filter(Boolean);
      }
      getObjectWithKnownName(guid) {
        return this._objects.get(guid);
      }
      sendMessageToServer(object, method, params, stackTrace) {
        return __async(this, null, function* () {
          if (this._closedErrorMessage)
            throw new Error(this._closedErrorMessage);
          const {
            apiName,
            frames
          } = stackTrace || {
            apiName: "",
            frames: []
          };
          const guid = object._guid;
          const id = ++this._lastId;
          const converted = {
            id,
            guid,
            method,
            params
          };
          _debugLogger.debugLogger.log("channel:command", converted);
          const metadata = {
            stack: frames,
            apiName,
            internal: !apiName
          };
          this.onmessage(__spreadProps(__spreadValues({}, converted), {
            metadata
          }));
          return yield new Promise((resolve, reject) => this._callbacks.set(id, {
            resolve,
            reject,
            stackTrace
          }));
        });
      }
      _debugScopeState() {
        return this._rootObject._debugScopeState();
      }
      dispatch(message) {
        if (this._closedErrorMessage)
          return;
        const {
          id,
          guid,
          method,
          params,
          result,
          error
        } = message;
        if (id) {
          _debugLogger.debugLogger.log("channel:response", message);
          const callback = this._callbacks.get(id);
          if (!callback)
            throw new Error(`Cannot find command to respond: ${id}`);
          this._callbacks.delete(id);
          if (error && !result)
            callback.reject((0, _serializers.parseError)(error));
          else
            callback.resolve(this._replaceGuidsWithChannels(result));
          return;
        }
        _debugLogger.debugLogger.log("channel:event", message);
        if (method === "__create__") {
          this._createRemoteObject(guid, params.type, params.guid, params.initializer);
          return;
        }
        if (method === "__dispose__") {
          const object2 = this._objects.get(guid);
          if (!object2)
            throw new Error(`Cannot find object to dispose: ${guid}`);
          object2._dispose();
          return;
        }
        const object = this._objects.get(guid);
        if (!object)
          throw new Error(`Cannot find object to emit "${method}": ${guid}`);
        object._channel.emit(method, object._type === "JsonPipe" ? params : this._replaceGuidsWithChannels(params));
      }
      close(errorMessage = "Connection closed") {
        this._closedErrorMessage = errorMessage;
        for (const callback of this._callbacks.values())
          callback.reject(new Error(errorMessage));
        this._callbacks.clear();
        this.emit("close");
      }
      _replaceGuidsWithChannels(payload) {
        if (!payload)
          return payload;
        if (Array.isArray(payload))
          return payload.map((p) => this._replaceGuidsWithChannels(p));
        if (payload.guid && this._objects.has(payload.guid))
          return this._objects.get(payload.guid)._channel;
        if (typeof payload === "object") {
          const result = {};
          for (const key of Object.keys(payload))
            result[key] = this._replaceGuidsWithChannels(payload[key]);
          return result;
        }
        return payload;
      }
      _createRemoteObject(parentGuid, type, guid, initializer) {
        const parent = this._objects.get(parentGuid);
        if (!parent)
          throw new Error(`Cannot find parent object ${parentGuid} to create ${guid}`);
        let result;
        initializer = this._replaceGuidsWithChannels(initializer);
        switch (type) {
          case "Android":
            result = new _android.Android(parent, type, guid, initializer);
            break;
          case "AndroidSocket":
            result = new _android.AndroidSocket(parent, type, guid, initializer);
            break;
          case "AndroidDevice":
            result = new _android.AndroidDevice(parent, type, guid, initializer);
            break;
          case "APIRequestContext":
            result = new _fetch.APIRequestContext(parent, type, guid, initializer);
            break;
          case "Artifact":
            result = new _artifact.Artifact(parent, type, guid, initializer);
            break;
          case "BindingCall":
            result = new _page.BindingCall(parent, type, guid, initializer);
            break;
          case "Browser":
            result = new _browser.Browser(parent, type, guid, initializer);
            break;
          case "BrowserContext":
            result = new _browserContext.BrowserContext(parent, type, guid, initializer);
            break;
          case "BrowserType":
            result = new _browserType.BrowserType(parent, type, guid, initializer);
            break;
          case "CDPSession":
            result = new _cdpSession.CDPSession(parent, type, guid, initializer);
            break;
          case "ConsoleMessage":
            result = new _consoleMessage.ConsoleMessage(parent, type, guid, initializer);
            break;
          case "Dialog":
            result = new _dialog.Dialog(parent, type, guid, initializer);
            break;
          case "Electron":
            result = new _electron.Electron(parent, type, guid, initializer);
            break;
          case "ElectronApplication":
            result = new _electron.ElectronApplication(parent, type, guid, initializer);
            break;
          case "ElementHandle":
            result = new _elementHandle.ElementHandle(parent, type, guid, initializer);
            break;
          case "Frame":
            result = new _frame.Frame(parent, type, guid, initializer);
            break;
          case "JSHandle":
            result = new _jsHandle.JSHandle(parent, type, guid, initializer);
            break;
          case "JsonPipe":
            result = new _jsonPipe.JsonPipe(parent, type, guid, initializer);
            break;
          case "LocalUtils":
            result = new _localUtils.LocalUtils(parent, type, guid, initializer);
            break;
          case "Page":
            result = new _page.Page(parent, type, guid, initializer);
            break;
          case "Playwright":
            result = new _playwright.Playwright(parent, type, guid, initializer);
            break;
          case "Request":
            result = new _network.Request(parent, type, guid, initializer);
            break;
          case "Response":
            result = new _network.Response(parent, type, guid, initializer);
            break;
          case "Route":
            result = new _network.Route(parent, type, guid, initializer);
            break;
          case "Stream":
            result = new _stream.Stream(parent, type, guid, initializer);
            break;
          case "Selectors":
            result = new _selectors.SelectorsOwner(parent, type, guid, initializer);
            break;
          case "WebSocket":
            result = new _network.WebSocket(parent, type, guid, initializer);
            break;
          case "Worker":
            result = new _worker.Worker(parent, type, guid, initializer);
            break;
          default:
            throw new Error("Missing type " + type);
        }
        const callback = this._waitingForObject.get(guid);
        if (callback) {
          callback(result);
          this._waitingForObject.delete(guid);
        }
        return result;
      }
    };
    exports2.Connection = Connection;
  }
});

// node_modules/playwright-core/lib/remote/playwrightServer.js
var require_playwrightServer = __commonJS({
  "node_modules/playwright-core/lib/remote/playwrightServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PlaywrightServer = void 0;
    var _debug = _interopRequireDefault2(require_src());
    var http = _interopRequireWildcard2(require("http"));
    var ws = _interopRequireWildcard2(require("ws"));
    var _dispatcher = require_dispatcher();
    var _playwrightDispatcher = require_playwrightDispatcher();
    var _playwright2 = require_playwright();
    var _processLauncher = require_processLauncher();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var debugLog = (0, _debug.default)("pw:server");
    var PlaywrightServer = class {
      static startDefault() {
        return __async(this, null, function* () {
          const cleanup = () => __async(this, null, function* () {
            yield (0, _processLauncher.gracefullyCloseAll)().catch((e) => {
            });
          });
          const delegate = {
            path: "/ws",
            allowMultipleClients: false,
            onClose: cleanup,
            onConnect: (connection) => __async(this, null, function* () {
              let playwright2;
              new _dispatcher.Root(connection, (rootScope) => __async(this, null, function* () {
                playwright2 = (0, _playwright2.createPlaywright)("javascript");
                const dispatcher = new _playwrightDispatcher.PlaywrightDispatcher(rootScope, playwright2);
                if (process.env.PW_SOCKS_PROXY_PORT)
                  yield dispatcher.enableSocksProxy();
                return dispatcher;
              }));
              return () => {
                var _playwright;
                cleanup();
                (_playwright = playwright2) === null || _playwright === void 0 ? void 0 : _playwright.selectors.unregisterAll();
              };
            })
          };
          return new PlaywrightServer(delegate);
        });
      }
      constructor(delegate) {
        this._wsServer = void 0;
        this._clientsCount = 0;
        this._delegate = void 0;
        this._delegate = delegate;
      }
      listen(port = 0) {
        return __async(this, null, function* () {
          const server = http.createServer((request, response) => {
            response.end("Running");
          });
          server.on("error", (error) => debugLog(error));
          const path = this._delegate.path;
          const wsEndpoint = yield new Promise((resolve, reject) => {
            server.listen(port, () => {
              const address = server.address();
              if (!address) {
                reject(new Error("Could not bind server socket"));
                return;
              }
              const wsEndpoint2 = typeof address === "string" ? `${address}${path}` : `ws://127.0.0.1:${address.port}${path}`;
              resolve(wsEndpoint2);
            }).on("error", reject);
          });
          debugLog("Listening at " + wsEndpoint);
          this._wsServer = new ws.Server({
            server,
            path
          });
          this._wsServer.on("connection", (socket) => __async(this, null, function* () {
            if (this._clientsCount && !this._delegate.allowMultipleClients) {
              socket.close();
              return;
            }
            this._clientsCount++;
            debugLog("Incoming connection");
            const connection = new _dispatcher.DispatcherConnection();
            connection.onmessage = (message) => {
              if (socket.readyState !== ws.CLOSING)
                socket.send(JSON.stringify(message));
            };
            socket.on("message", (message) => {
              connection.dispatch(JSON.parse(Buffer.from(message).toString()));
            });
            const forceDisconnect = () => socket.close();
            let onDisconnect = () => {
            };
            const disconnected = () => {
              this._clientsCount--;
              connection.onmessage = () => {
              };
              onDisconnect();
            };
            socket.on("close", () => {
              debugLog("Client closed");
              disconnected();
            });
            socket.on("error", (error) => {
              debugLog("Client error " + error);
              disconnected();
            });
            onDisconnect = yield this._delegate.onConnect(connection, forceDisconnect);
          }));
          return wsEndpoint;
        });
      }
      close() {
        return __async(this, null, function* () {
          if (!this._wsServer)
            return;
          debugLog("Closing server");
          yield new Promise((f) => this._wsServer.close(f));
          yield new Promise((f) => this._wsServer.options.server.close(f));
          this._wsServer = void 0;
          yield this._delegate.onClose();
        });
      }
    };
    exports2.PlaywrightServer = PlaywrightServer;
  }
});

// node_modules/playwright-core/lib/browserServerImpl.js
var require_browserServerImpl = __commonJS({
  "node_modules/playwright-core/lib/browserServerImpl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserServerLauncherImpl = void 0;
    var _browser = require_browser2();
    var _ws = require("ws");
    var _dispatcher = require_dispatcher();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _clientHelper = require_clientHelper();
    var _utils2 = require_utils();
    var _selectorsDispatcher = require_selectorsDispatcher();
    var _selectors = require_selectors();
    var _instrumentation = require_instrumentation();
    var _playwright = require_playwright();
    var _playwrightDispatcher = require_playwrightDispatcher();
    var _playwrightServer = require_playwrightServer();
    var _browserContext = require_browserContext();
    var _cdpSessionDispatcher = require_cdpSessionDispatcher();
    var BrowserServerLauncherImpl = class {
      constructor(browserName) {
        this._browserName = void 0;
        this._browserName = browserName;
      }
      launchServer() {
        return __async(this, arguments, function* (options = {}) {
          const playwright2 = (0, _playwright.createPlaywright)("javascript");
          const browser = yield playwright2[this._browserName].launch((0, _instrumentation.internalCallMetadata)(), __spreadProps(__spreadValues({}, options), {
            ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
            env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : void 0
          }), toProtocolLogger(options.logger));
          let path = `/${(0, _utils2.createGuid)()}`;
          if (options.wsPath)
            path = options.wsPath.startsWith("/") ? options.wsPath : `/${options.wsPath}`;
          const delegate = {
            path,
            allowMultipleClients: true,
            onClose: () => {
            },
            onConnect: this._onConnect.bind(this, playwright2, browser)
          };
          const server = new _playwrightServer.PlaywrightServer(delegate);
          const wsEndpoint = yield server.listen(options.port);
          const browserServer = new _ws.EventEmitter();
          browserServer.process = () => browser.options.browserProcess.process;
          browserServer.wsEndpoint = () => wsEndpoint;
          browserServer.close = () => browser.options.browserProcess.close();
          browserServer.kill = () => browser.options.browserProcess.kill();
          browserServer._disconnectForTest = () => server.close();
          browser.options.browserProcess.onclose = (exitCode, signal) => __async(this, null, function* () {
            server.close();
            browserServer.emit("close", exitCode, signal);
          });
          return browserServer;
        });
      }
      _onConnect(playwright2, browser, connection, forceDisconnect) {
        return __async(this, null, function* () {
          let browserDispatcher;
          new _dispatcher.Root(connection, (scope) => __async(this, null, function* () {
            const selectors = new _selectors.Selectors();
            const selectorsDispatcher = new _selectorsDispatcher.SelectorsDispatcher(scope, selectors);
            browserDispatcher = new ConnectedBrowserDispatcher(scope, browser, selectors);
            browser.on(_browser.Browser.Events.Disconnected, () => {
              forceDisconnect();
            });
            return new _playwrightDispatcher.PlaywrightDispatcher(scope, playwright2, selectorsDispatcher, browserDispatcher);
          }));
          return () => {
            var _browserDispatcher;
            (_browserDispatcher = browserDispatcher) === null || _browserDispatcher === void 0 ? void 0 : _browserDispatcher.cleanupContexts().catch((e) => {
            });
          };
        });
      }
    };
    exports2.BrowserServerLauncherImpl = BrowserServerLauncherImpl;
    var ConnectedBrowserDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browser, selectors) {
        super(scope, browser, "Browser", {
          version: browser.version(),
          name: browser.options.name
        }, true);
        this._type_Browser = true;
        this._contexts = /* @__PURE__ */ new Set();
        this._selectors = void 0;
        this._selectors = selectors;
      }
      newContext(params, metadata) {
        return __async(this, null, function* () {
          if (params.recordVideo)
            params.recordVideo.dir = this._object.options.artifactsDir;
          const context = yield this._object.newContext(params);
          this._contexts.add(context);
          context._setSelectors(this._selectors);
          context.on(_browserContext.BrowserContext.Events.Close, () => this._contexts.delete(context));
          if (params.storageState)
            yield context.setStorageState(metadata, params.storageState);
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
          };
        });
      }
      close() {
        return __async(this, null, function* () {
        });
      }
      killForTests() {
        return __async(this, null, function* () {
        });
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
          const crBrowser = this._object;
          return {
            session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, yield crBrowser.newBrowserCDPSession())
          };
        });
      }
      startTracing(params) {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          yield crBrowser.startTracing(params.page ? params.page._object : void 0, params);
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          const buffer = yield crBrowser.stopTracing();
          return {
            binary: buffer.toString("base64")
          };
        });
      }
      cleanupContexts() {
        return __async(this, null, function* () {
          yield Promise.all(Array.from(this._contexts).map((context) => context.close((0, _instrumentation.internalCallMetadata)())));
        });
      }
    };
    function toProtocolLogger(logger) {
      return logger ? (direction, message) => {
        if (logger.isEnabled("protocol", "verbose"))
          logger.log("protocol", "verbose", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(message), [], {});
      } : void 0;
    }
  }
});

// node_modules/playwright-core/lib/inProcessFactory.js
var require_inProcessFactory = __commonJS({
  "node_modules/playwright-core/lib/inProcessFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createInProcessPlaywright = createInProcessPlaywright;
    var _dispatcher = require_dispatcher();
    var _playwright = require_playwright();
    var _playwrightDispatcher = require_playwrightDispatcher();
    var _connection = require_connection();
    var _browserServerImpl = require_browserServerImpl();
    function createInProcessPlaywright() {
      const playwright2 = (0, _playwright.createPlaywright)("javascript");
      const clientConnection = new _connection.Connection();
      const dispatcherConnection = new _dispatcher.DispatcherConnection();
      dispatcherConnection.onmessage = (message) => clientConnection.dispatch(message);
      clientConnection.onmessage = (message) => dispatcherConnection.dispatch(message);
      const rootScope = new _dispatcher.Root(dispatcherConnection);
      new _playwrightDispatcher.PlaywrightDispatcher(rootScope, playwright2);
      const playwrightAPI = clientConnection.getObjectWithKnownName("Playwright");
      playwrightAPI.chromium._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("chromium");
      playwrightAPI.firefox._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("firefox");
      playwrightAPI.webkit._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("webkit");
      dispatcherConnection.onmessage = (message) => setImmediate(() => clientConnection.dispatch(message));
      clientConnection.onmessage = (message) => setImmediate(() => dispatcherConnection.dispatch(message));
      playwrightAPI._toImpl = (x) => dispatcherConnection._dispatchers.get(x._guid)._object;
      return playwrightAPI;
    }
  }
});

// node_modules/playwright-core/lib/inprocess.js
var require_inprocess = __commonJS({
  "node_modules/playwright-core/lib/inprocess.js"(exports2, module2) {
    "use strict";
    var _inProcessFactory = require_inProcessFactory();
    module2.exports = (0, _inProcessFactory.createInProcessPlaywright)();
  }
});

// node_modules/playwright-core/index.js
var require_playwright_core = __commonJS({
  "node_modules/playwright-core/index.js"(exports2, module2) {
    require_verifyNodeJsVersion();
    module2.exports = require_inprocess();
  }
});

// node_modules/playwright-core/api.json
var require_api = __commonJS({
  "node_modules/playwright-core/api.json"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/playwright-core/lib/cli/driver.js
var require_driver = __commonJS({
  "node_modules/playwright-core/lib/cli/driver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printApiJson = printApiJson;
    exports2.runDriver = runDriver;
    exports2.runServer = runServer;
    exports2.launchBrowserServer = launchBrowserServer;
    var _fs2 = _interopRequireDefault2(require("fs"));
    var playwright2 = _interopRequireWildcard2(require_playwright_core());
    var _dispatcher = require_dispatcher();
    var _playwrightDispatcher = require_playwrightDispatcher();
    var _transport = require_transport();
    var _playwrightServer = require_playwrightServer();
    var _playwright = require_playwright();
    var _processLauncher = require_processLauncher();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function printApiJson() {
      console.log(JSON.stringify(require_api()));
    }
    function runDriver() {
      const dispatcherConnection = new _dispatcher.DispatcherConnection();
      new _dispatcher.Root(dispatcherConnection, (_0, _1) => __async(this, [_0, _1], function* (rootScope, {
        sdkLanguage
      }) {
        const playwright3 = (0, _playwright.createPlaywright)(sdkLanguage);
        return new _playwrightDispatcher.PlaywrightDispatcher(rootScope, playwright3);
      }));
      const transport = new _transport.Transport(process.stdout, process.stdin);
      transport.onmessage = (message) => dispatcherConnection.dispatch(JSON.parse(message));
      dispatcherConnection.onmessage = (message) => transport.send(JSON.stringify(message));
      transport.onclose = () => __async(this, null, function* () {
        dispatcherConnection.onmessage = () => {
        };
        setTimeout(() => process.exit(0), 3e4);
        yield (0, _processLauncher.gracefullyCloseAll)();
        process.exit(0);
      });
    }
    function runServer(port) {
      return __async(this, null, function* () {
        const server = yield _playwrightServer.PlaywrightServer.startDefault();
        const wsEndpoint = yield server.listen(port);
        process.on("exit", () => server.close().catch(console.error));
        console.log("Listening on " + wsEndpoint);
      });
    }
    function launchBrowserServer(browserName, configFile) {
      return __async(this, null, function* () {
        let options = {};
        if (configFile)
          options = JSON.parse(_fs2.default.readFileSync(configFile).toString());
        const browserType = playwright2[browserName];
        const server = yield browserType.launchServer(options);
        console.log(server.wsEndpoint());
      });
    }
  }
});

// node_modules/playwright-core/lib/utils/httpServer.js
var require_httpServer = __commonJS({
  "node_modules/playwright-core/lib/utils/httpServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.HttpServer = void 0;
    var http = _interopRequireWildcard2(require("http"));
    var _fs2 = _interopRequireDefault2(require("fs"));
    var _path2 = _interopRequireDefault2(require("path"));
    var _ws = require("ws");
    var mime = _interopRequireWildcard2(require_mime());
    var _utils2 = require_utils();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var HttpServer = class {
      constructor() {
        this._server = void 0;
        this._urlPrefix = void 0;
        this._port = 0;
        this._routes = [];
        this._activeSockets = /* @__PURE__ */ new Set();
        this._urlPrefix = "";
        this._server = http.createServer(this._onRequest.bind(this));
      }
      createWebSocketServer() {
        return new _ws.Server({
          server: this._server
        });
      }
      routePrefix(prefix, handler) {
        this._routes.push({
          prefix,
          handler
        });
      }
      routePath(path, handler) {
        this._routes.push({
          exact: path,
          handler
        });
      }
      port() {
        return this._port;
      }
      start(port) {
        return __async(this, null, function* () {
          console.assert(!this._urlPrefix, "server already started");
          this._server.on("connection", (socket) => {
            this._activeSockets.add(socket);
            socket.once("close", () => this._activeSockets.delete(socket));
          });
          this._server.listen(port);
          yield new Promise((cb) => this._server.once("listening", cb));
          const address = this._server.address();
          if (typeof address === "string") {
            this._urlPrefix = address;
          } else {
            (0, _utils2.assert)(address, "Could not bind server socket");
            this._port = address.port;
            this._urlPrefix = `http://127.0.0.1:${address.port}`;
          }
          return this._urlPrefix;
        });
      }
      stop() {
        return __async(this, null, function* () {
          for (const socket of this._activeSockets)
            socket.destroy();
          yield new Promise((cb) => this._server.close(cb));
        });
      }
      urlPrefix() {
        return this._urlPrefix;
      }
      serveFile(request, response, absoluteFilePath, headers) {
        try {
          for (const [name, value] of Object.entries(headers || {}))
            response.setHeader(name, value);
          if (request.headers.range)
            this._serveRangeFile(request, response, absoluteFilePath);
          else
            this._serveFile(response, absoluteFilePath);
          return true;
        } catch (e) {
          return false;
        }
      }
      _serveFile(response, absoluteFilePath) {
        const content = _fs2.default.readFileSync(absoluteFilePath);
        response.statusCode = 200;
        const contentType = mime.getType(_path2.default.extname(absoluteFilePath)) || "application/octet-stream";
        response.setHeader("Content-Type", contentType);
        response.setHeader("Content-Length", content.byteLength);
        response.end(content);
      }
      _serveRangeFile(request, response, absoluteFilePath) {
        const range = request.headers.range;
        if (!range || !range.startsWith("bytes=") || range.includes(", ") || [...range].filter((char) => char === "-").length !== 1) {
          response.statusCode = 400;
          return response.end("Bad request");
        }
        const [startStr, endStr] = range.replace(/bytes=/, "").split("-");
        let start;
        let end;
        const size = _fs2.default.statSync(absoluteFilePath).size;
        if (startStr !== "" && endStr === "") {
          start = +startStr;
          end = size - 1;
        } else if (startStr === "" && endStr !== "") {
          start = size - +endStr;
          end = size - 1;
        } else {
          start = +startStr;
          end = +endStr;
        }
        if (Number.isNaN(start) || Number.isNaN(end) || start >= size || end >= size || start > end) {
          response.writeHead(416, {
            "Content-Range": `bytes */${size}`
          });
          return response.end();
        }
        response.writeHead(206, {
          "Content-Range": `bytes ${start}-${end}/${size}`,
          "Accept-Ranges": "bytes",
          "Content-Length": end - start + 1,
          "Content-Type": mime.getType(_path2.default.extname(absoluteFilePath))
        });
        const readable = _fs2.default.createReadStream(absoluteFilePath, {
          start,
          end
        });
        readable.pipe(response);
      }
      serveVirtualFile(response, vfs, entry, headers) {
        return __async(this, null, function* () {
          try {
            const content = yield vfs.read(entry);
            response.statusCode = 200;
            const contentType = mime.getType(_path2.default.extname(entry)) || "application/octet-stream";
            response.setHeader("Content-Type", contentType);
            response.setHeader("Content-Length", content.byteLength);
            for (const [name, value] of Object.entries(headers || {}))
              response.setHeader(name, value);
            response.end(content);
            return true;
          } catch (e) {
            return false;
          }
        });
      }
      _onRequest(request, response) {
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Access-Control-Request-Method", "*");
        response.setHeader("Access-Control-Allow-Methods", "OPTIONS, GET");
        if (request.headers.origin)
          response.setHeader("Access-Control-Allow-Headers", request.headers.origin);
        if (request.method === "OPTIONS") {
          response.writeHead(200);
          response.end();
          return;
        }
        request.on("error", () => response.end());
        try {
          if (!request.url) {
            response.end();
            return;
          }
          const url = new URL("http://localhost" + request.url);
          for (const route of this._routes) {
            if (route.exact && url.pathname === route.exact && route.handler(request, response))
              return;
            if (route.prefix && url.pathname.startsWith(route.prefix) && route.handler(request, response))
              return;
          }
          response.statusCode = 404;
          response.end();
        } catch (e) {
          response.end();
        }
      }
    };
    exports2.HttpServer = HttpServer;
  }
});

// node_modules/playwright-core/lib/server/trace/viewer/traceViewer.js
var require_traceViewer = __commonJS({
  "node_modules/playwright-core/lib/server/trace/viewer/traceViewer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.showTraceViewer = showTraceViewer;
    var _path2 = _interopRequireDefault2(require("path"));
    var _fs2 = _interopRequireDefault2(require("fs"));
    var consoleApiSource = _interopRequireWildcard2(require_consoleApiSource());
    var _httpServer = require_httpServer();
    var _registry2 = require_registry();
    var _utils2 = require_utils();
    var _crApp = require_crApp();
    var _instrumentation = require_instrumentation();
    var _playwright = require_playwright();
    var _progress = require_progress2();
    function _getRequireWildcardCache2(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache2 = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard2(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function showTraceViewer(traceUrl, browserName, headless = false, port) {
      return __async(this, null, function* () {
        if (traceUrl && !traceUrl.startsWith("http://") && !traceUrl.startsWith("https://") && !_fs2.default.existsSync(traceUrl)) {
          console.error(`Trace file ${traceUrl} does not exist!`);
          process.exit(1);
        }
        const server = new _httpServer.HttpServer();
        server.routePrefix("/trace", (request, response) => {
          const url = new URL("http://localhost" + request.url);
          const relativePath = url.pathname.slice("/trace".length);
          if (relativePath.startsWith("/file")) {
            try {
              return server.serveFile(request, response, url.searchParams.get("path"));
            } catch (e) {
              return false;
            }
          }
          const absolutePath = _path2.default.join(__dirname, "..", "..", "..", "webpack", "traceViewer", ...relativePath.split("/"));
          return server.serveFile(request, response, absolutePath);
        });
        const urlPrefix = yield server.start(port);
        const traceViewerPlaywright = (0, _playwright.createPlaywright)("javascript", true);
        const traceViewerBrowser = (0, _utils2.isUnderTest)() ? "chromium" : browserName;
        const args = traceViewerBrowser === "chromium" ? ["--app=data:text/html,", "--window-size=1280,800", "--test-type="] : [];
        if ((0, _utils2.isUnderTest)())
          args.push(`--remote-debugging-port=0`);
        const context = yield traceViewerPlaywright[traceViewerBrowser].launchPersistentContext((0, _instrumentation.internalCallMetadata)(), "", {
          channel: (0, _registry2.findChromiumChannel)(traceViewerPlaywright.options.sdkLanguage),
          args,
          noDefaultViewport: true,
          ignoreDefaultArgs: ["--enable-automation"],
          headless,
          useWebSocket: (0, _utils2.isUnderTest)()
        });
        const controller = new _progress.ProgressController((0, _instrumentation.internalCallMetadata)(), context._browser);
        yield controller.run((progress) => __async(this, null, function* () {
          yield context._browser._defaultContext._loadDefaultContextAsIs(progress);
        }));
        yield context.extendInjectedScript(consoleApiSource.source);
        const [page] = context.pages();
        if (traceViewerBrowser === "chromium")
          yield (0, _crApp.installAppIcon)(page);
        if ((0, _utils2.isUnderTest)())
          page.on("close", () => context.close((0, _instrumentation.internalCallMetadata)()).catch(() => {
          }));
        else
          page.on("close", () => process.exit());
        yield page.mainFrame().goto((0, _instrumentation.internalCallMetadata)(), urlPrefix + `/trace/index.html${traceUrl ? "?trace=" + traceUrl : ""}`);
        return context;
      });
    }
  }
});

// node_modules/playwright-core/lib/grid/gridAgent.js
var require_gridAgent = __commonJS({
  "node_modules/playwright-core/lib/grid/gridAgent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.launchGridAgent = launchGridAgent;
    var _debug = _interopRequireDefault2(require_src());
    var _ws = _interopRequireDefault2(require("ws"));
    var _child_process2 = require("child_process");
    var _utils2 = require_utils();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function launchGridAgent(agentId, gridURL) {
      const log = (0, _debug.default)(`[agent ${agentId}]`);
      log("created");
      const params = new URLSearchParams();
      params.set("pwVersion", (0, _utils2.getPlaywrightVersion)(true));
      params.set("agentId", agentId);
      const ws = new _ws.default(gridURL + `/registerAgent?` + params.toString());
      ws.on("message", (workerId) => {
        log("Worker requested " + workerId);
        (0, _child_process2.fork)(require.resolve("./gridWorker.js"), [gridURL, agentId, workerId], {
          detached: true
        });
      });
      ws.on("close", () => process.exit(0));
    }
  }
});

// node_modules/playwright-core/lib/grid/gridServer.js
var require_gridServer = __commonJS({
  "node_modules/playwright-core/lib/grid/gridServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GridServer = void 0;
    var _debug = _interopRequireDefault2(require_src());
    var _assert = _interopRequireDefault2(require("assert"));
    var _events = require("events");
    var _url = require("url");
    var _httpServer = require_httpServer();
    var _utils2 = require_utils();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var WSErrors = {
      NO_ERROR: {
        code: 1e3,
        reason: ""
      },
      AUTH_FAILED: {
        code: 1008,
        reason: "Grid authentication failed"
      },
      AGENT_CREATION_FAILED: {
        code: 1013,
        reason: "Grid agent creation failed"
      },
      AGENT_NOT_FOUND: {
        code: 1013,
        reason: "Grid agent registration failed - agent with given ID not found"
      },
      AGENT_NOT_CONNECTED: {
        code: 1013,
        reason: "Grid worker registration failed - agent has unsupported status"
      },
      AGENT_CREATION_TIMED_OUT: {
        code: 1013,
        reason: "Grid agent creation timed out"
      },
      AGENT_RETIRED: {
        code: 1e3,
        reason: "Grid agent was retired"
      },
      CLIENT_SOCKET_ERROR: {
        code: 1011,
        reason: "Grid client socket error"
      },
      WORKER_SOCKET_ERROR: {
        code: 1011,
        reason: "Grid worker socket error"
      },
      CLIENT_PLAYWRIGHT_VERSION_MISMATCH: {
        code: 1013,
        reason: "Grid Playwright and grid client versions are different"
      },
      AGENT_PLAYWRIGHT_VERSION_MISMATCH: {
        code: 1013,
        reason: "Grid Playwright and grid agent versions are different"
      },
      GRID_SHUTDOWN: {
        code: 1e3,
        reason: "Grid was shutdown"
      },
      AGENT_MANUALLY_STOPPED: {
        code: 1e3,
        reason: "Grid agent was manually stopped"
      }
    };
    var GridWorker = class extends _events.EventEmitter {
      constructor(clientSocket) {
        super();
        this.workerId = (0, _utils2.createGuid)();
        this._workerSocket = void 0;
        this._clientSocket = void 0;
        this._log = void 0;
        this._log = (0, _debug.default)(`[worker ${this.workerId}]`);
        this._clientSocket = clientSocket;
        clientSocket.on("close", (code, reason) => this.closeWorker(WSErrors.NO_ERROR));
        clientSocket.on("error", (error) => this.closeWorker(WSErrors.CLIENT_SOCKET_ERROR));
      }
      workerConnected(workerSocket) {
        this._log("connected");
        this._workerSocket = workerSocket;
        workerSocket.on("close", (code, reason) => this.closeWorker(WSErrors.NO_ERROR));
        workerSocket.on("error", (error) => this.closeWorker(WSErrors.WORKER_SOCKET_ERROR));
        this._clientSocket.on("message", (data) => workerSocket.send(data));
        workerSocket.on("message", (data) => this._clientSocket.send(data));
        this._clientSocket.send("run");
      }
      closeWorker(errorCode) {
        var _this$_workerSocket;
        this._log("close");
        (_this$_workerSocket = this._workerSocket) === null || _this$_workerSocket === void 0 ? void 0 : _this$_workerSocket.close(errorCode.code, errorCode.reason);
        this._clientSocket.close(errorCode.code, errorCode.reason);
        this.emit("close");
      }
      debugInfo() {
        return {
          worker: !!this._workerSocket,
          client: !!this._clientSocket
        };
      }
    };
    var GridAgent = class extends _events.EventEmitter {
      constructor(capacity = Infinity, creationTimeout = 5 * 6e4, retireTimeout = 3e4) {
        super();
        this._capacity = void 0;
        this.agentId = (0, _utils2.createGuid)();
        this._ws = void 0;
        this._workers = /* @__PURE__ */ new Map();
        this._status = "none";
        this._workersWaitingForAgentConnected = /* @__PURE__ */ new Set();
        this._retireTimeout = 3e4;
        this._retireTimeoutId = void 0;
        this._log = void 0;
        this._agentCreationTimeoutId = void 0;
        this._capacity = capacity;
        this._log = (0, _debug.default)(`[agent ${this.agentId}]`);
        this.setStatus("created");
        this._retireTimeout = retireTimeout;
        this._agentCreationTimeoutId = setTimeout(() => {
          this.closeAgent(WSErrors.AGENT_CREATION_TIMED_OUT);
        }, creationTimeout);
      }
      status() {
        return this._status;
      }
      setStatus(status) {
        this._log(`status ${this._status} => ${status}`);
        this._status = status;
      }
      agentConnected(ws) {
        clearTimeout(this._agentCreationTimeoutId);
        this.setStatus("connected");
        this._ws = ws;
        for (const worker of this._workersWaitingForAgentConnected) {
          this._log(`send worker id: ${worker.workerId}`);
          ws.send(worker.workerId);
        }
        this._workersWaitingForAgentConnected.clear();
      }
      canCreateWorker() {
        return this._workers.size < this._capacity;
      }
      createWorker(clientSocket) {
        return __async(this, null, function* () {
          if (this._retireTimeoutId)
            clearTimeout(this._retireTimeoutId);
          if (this._ws)
            this.setStatus("connected");
          const worker = new GridWorker(clientSocket);
          this._log(`create worker: ${worker.workerId}`);
          this._workers.set(worker.workerId, worker);
          worker.on("close", () => {
            this._workers.delete(worker.workerId);
            this._workersWaitingForAgentConnected.delete(worker);
            if (!this._workers.size) {
              this.setStatus("retiring");
              if (this._retireTimeoutId)
                clearTimeout(this._retireTimeoutId);
              if (this._retireTimeout && isFinite(this._retireTimeout))
                this._retireTimeoutId = setTimeout(() => this.closeAgent(WSErrors.AGENT_RETIRED), this._retireTimeout);
            }
          });
          if (this._ws) {
            this._log(`send worker id: ${worker.workerId}`);
            this._ws.send(worker.workerId);
          } else {
            this._workersWaitingForAgentConnected.add(worker);
          }
        });
      }
      workerConnected(workerId, ws) {
        this._log(`worker connected: ${workerId}`);
        const worker = this._workers.get(workerId);
        worker.workerConnected(ws);
      }
      closeAgent(errorCode) {
        var _this$_ws;
        for (const worker of this._workersWaitingForAgentConnected)
          worker.closeWorker(errorCode);
        for (const worker of this._workers.values())
          worker.closeWorker(errorCode);
        this._log("close");
        (_this$_ws = this._ws) === null || _this$_ws === void 0 ? void 0 : _this$_ws.close(errorCode.code, errorCode.reason);
        this.emit("close");
      }
    };
    var GridServer = class {
      constructor(factory, authToken = "") {
        this._server = void 0;
        this._wsServer = void 0;
        this._agents = /* @__PURE__ */ new Map();
        this._log = void 0;
        this._authToken = void 0;
        this._factory = void 0;
        this._pwVersion = void 0;
        this._log = (0, _debug.default)(`[grid]`);
        this._authToken = authToken || "";
        this._server = new _httpServer.HttpServer();
        this._factory = factory;
        this._pwVersion = (0, _utils2.getPlaywrightVersion)(true);
        this._server.routePath(this._securePath("/"), (request, response) => {
          response.statusCode = 200;
          response.setHeader("Content-Type", "text/html");
          response.end(this._state());
          return true;
        });
        this._server.routePath(this._securePath("/stopAll"), (request, response) => {
          for (const agent of this._agents.values())
            agent.closeAgent(WSErrors.AGENT_MANUALLY_STOPPED);
          response.statusCode = 302;
          response.setHeader("Location", this._securePath("/"));
          response.end();
          return true;
        });
        this._wsServer = this._server.createWebSocketServer();
        this._wsServer.shouldHandle = (request) => {
          this._log(request.url);
          if (request.url.startsWith(this._securePath("/claimWorker"))) {
            return true;
          }
          if (request.url.startsWith("/registerAgent") || request.url.startsWith("/registerWorker")) {
            const params = new _url.URL("http://localhost/" + request.url).searchParams;
            const agentId = params.get("agentId");
            return !!agentId && this._agents.has(agentId);
          }
          return false;
        };
        this._wsServer.on("connection", (ws, request) => __async(this, null, function* () {
          var _request$url, _request$url2, _request$url3;
          if ((_request$url = request.url) !== null && _request$url !== void 0 && _request$url.startsWith(this._securePath("/claimWorker"))) {
            var _this$_createAgent;
            const params = new _url.URL("http://localhost/" + request.url).searchParams;
            if (params.get("pwVersion") !== this._pwVersion && !process.env.PWTEST_UNSAFE_GRID_VERSION) {
              ws.close(WSErrors.CLIENT_PLAYWRIGHT_VERSION_MISMATCH.code, WSErrors.CLIENT_PLAYWRIGHT_VERSION_MISMATCH.reason);
              return;
            }
            const agent = [...this._agents.values()].find((w) => w.canCreateWorker()) || ((_this$_createAgent = this._createAgent()) === null || _this$_createAgent === void 0 ? void 0 : _this$_createAgent.agent);
            if (!agent) {
              ws.close(WSErrors.AGENT_CREATION_FAILED.code, WSErrors.AGENT_CREATION_FAILED.reason);
              return;
            }
            agent.createWorker(ws);
            return;
          }
          if ((_request$url2 = request.url) !== null && _request$url2 !== void 0 && _request$url2.startsWith("/registerAgent")) {
            const params = new _url.URL("http://localhost/" + request.url).searchParams;
            if (params.get("pwVersion") !== this._pwVersion) {
              ws.close(WSErrors.AGENT_PLAYWRIGHT_VERSION_MISMATCH.code, WSErrors.AGENT_PLAYWRIGHT_VERSION_MISMATCH.reason);
              return;
            }
            const agentId = params.get("agentId");
            const agent = this._agents.get(agentId);
            if (!agent) {
              ws.close(WSErrors.AGENT_NOT_FOUND.code, WSErrors.AGENT_NOT_FOUND.reason);
              return;
            }
            agent.agentConnected(ws);
            return;
          }
          if ((_request$url3 = request.url) !== null && _request$url3 !== void 0 && _request$url3.startsWith("/registerWorker")) {
            const params = new _url.URL("http://localhost/" + request.url).searchParams;
            const agentId = params.get("agentId");
            const workerId = params.get("workerId");
            const agent = this._agents.get(agentId);
            if (!agent)
              ws.close(WSErrors.AGENT_NOT_FOUND.code, WSErrors.AGENT_NOT_FOUND.reason);
            else if (agent.status() !== "connected")
              ws.close(WSErrors.AGENT_NOT_CONNECTED.code, WSErrors.AGENT_NOT_CONNECTED.reason);
            else
              agent.workerConnected(workerId, ws);
            return;
          }
        }));
      }
      createAgent() {
        return __async(this, null, function* () {
          const {
            initPromise
          } = this._createAgent();
          return yield initPromise;
        });
      }
      _createAgent() {
        const agent = new GridAgent(this._factory.capacity, this._factory.launchTimeout, this._factory.retireTimeout);
        this._agents.set(agent.agentId, agent);
        agent.on("close", () => {
          this._agents.delete(agent.agentId);
        });
        const initPromise = Promise.resolve().then(() => this._factory.launch({
          agentId: agent.agentId,
          gridURL: this._server.urlPrefix(),
          playwrightVersion: (0, _utils2.getPlaywrightVersion)()
        })).then(() => {
          this._log("created");
          return {
            error: void 0
          };
        }).catch((error) => {
          this._log("failed to launch agent " + agent.agentId);
          console.error(error);
          agent.closeAgent(WSErrors.AGENT_CREATION_FAILED);
          return {
            error
          };
        });
        return {
          agent,
          initPromise
        };
      }
      _securePath(suffix) {
        return this._authToken ? "/" + this._authToken + suffix : suffix;
      }
      _state() {
        return `
        <section style="display: flex; flex-direction: row">
          <div style="display: flex; flex-direction: column; align-items: end; margin-right: 1ex;">
            <span>Grid Playwright Version:</span>
            <span>Agent Factory:</span>
            <span>Agents:</span>
          </div>
          <div style="display: flex; flex-direction: column">
            <span>${this._pwVersion}</span>
            <span>${this._factory.name}</span>
            <span>${this._agents.size} <a href="./stopAll">(Stop All)</a></span>
          </div>
        </section>
        <hr/>
        <ul>
          ${[...this._agents].map(([agentId, agent]) => `
            <li>
              <div>Agent <code>${mangle(agentId)}</code>: ${agent.status()}</div>
              <div>Workers: ${agent._workers.size}</div>
              <ul>
                ${[...agent._workers].map(([workerId, worker]) => `
                  <li>worker <code>${mangle(workerId)}</code> - ${JSON.stringify(worker.debugInfo())}</li>
                `)}
              </ul>
            </li>
          `)}
        </ul>
    `;
      }
      start(port) {
        return __async(this, null, function* () {
          yield this._server.start(port);
        });
      }
      urlPrefix() {
        return this._server.urlPrefix() + this._securePath("/");
      }
      stop() {
        return __async(this, null, function* () {
          for (const agent of this._agents.values())
            agent.closeAgent(WSErrors.GRID_SHUTDOWN);
          (0, _assert.default)(this._agents.size === 0);
          yield this._server.stop();
        });
      }
    };
    exports2.GridServer = GridServer;
    function mangle(sessionId) {
      return sessionId.replace(/\w{28}/, "x".repeat(28));
    }
  }
});

// node_modules/playwright-core/lib/cli/innerCli.js
"use strict";
var _fs = _interopRequireDefault(require("fs"));
var _os = _interopRequireDefault(require("os"));
var _path = _interopRequireDefault(require("path"));
var _commander = require_commander();
var _driver = require_driver();
var _traceViewer = require_traceViewer();
var playwright = _interopRequireWildcard(require_playwright_core());
var _child_process = require("child_process");
var _registry = require_registry();
var _utils = require_utils();
var _gridAgent = require_gridAgent();
var _gridServer = require_gridServer();
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function")
    return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return { default: obj };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var packageJSON = require_package();
_commander.program.version("Version " + (process.env.PW_CLI_DISPLAY_VERSION || packageJSON.version)).name(buildBasePlaywrightCLICommand(process.env.PW_CLI_TARGET_LANG));
commandWithOpenOptions("open [url]", "open page in browser specified via -b, --browser", []).action(function(url, options) {
  open(options, url, language()).catch(logErrorAndExit);
}).addHelpText("afterAll", `
Examples:

  $ open  $ open -b webkit https://example.com`);
commandWithOpenOptions("codegen [url]", "open page and generate code for user actions", [["-o, --output <file name>", "saves the generated script to a file"], ["--target <language>", `language to generate, one of javascript, test, python, python-async, csharp`, language()]]).action(function(url, options) {
  codegen(options, url, options.target, options.output).catch(logErrorAndExit);
}).addHelpText("afterAll", `
Examples:

  $ codegen
  $ codegen --target=python
  $ codegen -b webkit https://example.com`);
_commander.program.command("debug <app> [args...]", {
  hidden: true
}).description("run command in debug mode: disable timeout, open inspector").allowUnknownOption(true).action(function(app, options) {
  (0, _child_process.spawn)(app, options, {
    env: __spreadProps(__spreadValues({}, process.env), {
      PWDEBUG: "1"
    }),
    stdio: "inherit"
  });
}).addHelpText("afterAll", `
Examples:

  $ debug node test.js
  $ debug npm run test`);
function suggestedBrowsersToInstall() {
  return _registry.registry.executables().filter((e) => e.installType !== "none" && e.type !== "tool").map((e) => e.name).join(", ");
}
function checkBrowsersToInstall(args) {
  const faultyArguments = [];
  const executables = [];
  for (const arg of args) {
    const executable = _registry.registry.findExecutable(arg);
    if (!executable || executable.installType === "none")
      faultyArguments.push(arg);
    else
      executables.push(executable);
  }
  if (faultyArguments.length) {
    console.log(`Invalid installation targets: ${faultyArguments.map((name) => `'${name}'`).join(", ")}. Expecting one of: ${suggestedBrowsersToInstall()}`);
    process.exit(1);
  }
  return executables;
}
_commander.program.command("install [browser...]").description("ensure browsers necessary for this version of Playwright are installed").option("--with-deps", "install system dependencies for browsers").action(function(args, options) {
  return __async(this, null, function* () {
    try {
      if (!args.length) {
        const executables = _registry.registry.defaultExecutables();
        if (options.withDeps)
          yield _registry.registry.installDeps(executables, false);
        yield _registry.registry.install(executables);
      } else {
        const installDockerImage = args.some((arg) => arg === "docker-image");
        args = args.filter((arg) => arg !== "docker-image");
        if (installDockerImage) {
          const imageName = `mcr.microsoft.com/playwright:v${(0, _utils.getPlaywrightVersion)()}-focal`;
          const {
            code
          } = yield (0, _utils.spawnAsync)("docker", ["pull", imageName], {
            stdio: "inherit"
          });
          if (code !== 0) {
            console.log("Failed to pull docker image");
            process.exit(1);
          }
        }
        const executables = checkBrowsersToInstall(args);
        if (options.withDeps)
          yield _registry.registry.installDeps(executables, false);
        yield _registry.registry.install(executables);
      }
    } catch (e) {
      console.log(`Failed to install browsers
${e}`);
      process.exit(1);
    }
  });
}).addHelpText("afterAll", `

Examples:
  - $ install
    Install default browsers.

  - $ install chrome firefox
    Install custom browsers, supports ${suggestedBrowsersToInstall()}.`);
_commander.program.command("install-deps [browser...]").description("install dependencies necessary to run browsers (will ask for sudo permissions)").option("--dry-run", "Do not execute installation commands, only print them").action(function(args, options) {
  return __async(this, null, function* () {
    try {
      if (!args.length)
        yield _registry.registry.installDeps(_registry.registry.defaultExecutables(), !!options.dryRun);
      else
        yield _registry.registry.installDeps(checkBrowsersToInstall(args), !!options.dryRun);
    } catch (e) {
      console.log(`Failed to install browser dependencies
${e}`);
      process.exit(1);
    }
  });
}).addHelpText("afterAll", `
Examples:
  - $ install-deps
    Install dependencies for default browsers.

  - $ install-deps chrome firefox
    Install dependencies for specific browsers, supports ${suggestedBrowsersToInstall()}.`);
var browsers = [{
  alias: "cr",
  name: "Chromium",
  type: "chromium"
}, {
  alias: "ff",
  name: "Firefox",
  type: "firefox"
}, {
  alias: "wk",
  name: "WebKit",
  type: "webkit"
}];
for (const {
  alias,
  name,
  type
} of browsers) {
  commandWithOpenOptions(`${alias} [url]`, `open page in ${name}`, []).action(function(url, options) {
    open(__spreadProps(__spreadValues({}, options), {
      browser: type
    }), url, options.target).catch(logErrorAndExit);
  }).addHelpText("afterAll", `
Examples:

  $ ${alias} https://example.com`);
}
commandWithOpenOptions("screenshot <url> <filename>", "capture a page screenshot", [["--wait-for-selector <selector>", "wait for selector before taking a screenshot"], ["--wait-for-timeout <timeout>", "wait for timeout in milliseconds before taking a screenshot"], ["--full-page", "whether to take a full page screenshot (entire scrollable area)"]]).action(function(url, filename, command) {
  screenshot(command, command, url, filename).catch(logErrorAndExit);
}).addHelpText("afterAll", `
Examples:

  $ screenshot -b webkit https://example.com example.png`);
commandWithOpenOptions("pdf <url> <filename>", "save page as pdf", [["--wait-for-selector <selector>", "wait for given selector before saving as pdf"], ["--wait-for-timeout <timeout>", "wait for given timeout in milliseconds before saving as pdf"]]).action(function(url, filename, options) {
  pdf(options, options, url, filename).catch(logErrorAndExit);
}).addHelpText("afterAll", `
Examples:

  $ pdf https://example.com example.pdf`);
_commander.program.command("experimental-grid-server", {
  hidden: true
}).option("--port <port>", "grid port; defaults to 3333").option("--agent-factory <factory>", "path to grid agent factory or npm package").option("--auth-token <authToken>", "optional authentication token").action(function(options) {
  launchGridServer(options.agentFactory, options.port || 3333, options.authToken);
});
_commander.program.command("experimental-grid-agent", {
  hidden: true
}).requiredOption("--agent-id <agentId>", "agent ID").requiredOption("--grid-url <gridURL>", "grid URL").action(function(options) {
  (0, _gridAgent.launchGridAgent)(options.agentId, options.gridUrl);
});
_commander.program.command("show-trace [trace]").option("-b, --browser <browserType>", "browser to use, one of cr, chromium, ff, firefox, wk, webkit", "chromium").description("Show trace viewer").action(function(trace, options) {
  if (options.browser === "cr")
    options.browser = "chromium";
  if (options.browser === "ff")
    options.browser = "firefox";
  if (options.browser === "wk")
    options.browser = "webkit";
  (0, _traceViewer.showTraceViewer)(trace, options.browser, false, 9322).catch(logErrorAndExit);
}).addHelpText("afterAll", `
Examples:

  $ show-trace https://example.com/trace.zip`);
if (!process.env.PW_CLI_TARGET_LANG) {
  let playwrightTestPackagePath = null;
  try {
    playwrightTestPackagePath = require.resolve("@playwright/test/lib/cli", {
      paths: [__dirname, process.cwd()]
    });
  } catch (e) {
  }
  if (playwrightTestPackagePath) {
    require(playwrightTestPackagePath).addTestCommand(_commander.program);
    require(playwrightTestPackagePath).addShowReportCommand(_commander.program);
  } else {
    {
      const command = _commander.program.command("test").allowUnknownOption(true);
      command.description("Run tests with Playwright Test. Available in @playwright/test package.");
      command.action(() => __async(exports, null, function* () {
        console.error("Please install @playwright/test package to use Playwright Test.");
        console.error("  npm install -D @playwright/test");
        process.exit(1);
      }));
    }
    {
      const command = _commander.program.command("show-report").allowUnknownOption(true);
      command.description("Show Playwright Test HTML report. Available in @playwright/test package.");
      command.action(() => __async(exports, null, function* () {
        console.error("Please install @playwright/test package to use Playwright Test.");
        console.error("  npm install -D @playwright/test");
        process.exit(1);
      }));
    }
  }
}
if (process.argv[2] === "run-driver")
  (0, _driver.runDriver)();
else if (process.argv[2] === "run-server")
  (0, _driver.runServer)(process.argv[3] ? +process.argv[3] : void 0).catch(logErrorAndExit);
else if (process.argv[2] === "print-api-json")
  (0, _driver.printApiJson)();
else if (process.argv[2] === "launch-server")
  (0, _driver.launchBrowserServer)(process.argv[3], process.argv[4]).catch(logErrorAndExit);
else
  _commander.program.parse(process.argv);
function launchContext(options, headless, executablePath) {
  return __async(this, null, function* () {
    validateOptions(options);
    const browserType = lookupBrowserType(options);
    const launchOptions = {
      headless,
      executablePath
    };
    if (options.channel)
      launchOptions.channel = options.channel;
    const contextOptions = options.device ? __spreadValues({}, playwright.devices[options.device]) : {};
    if (!headless)
      contextOptions.deviceScaleFactor = _os.default.platform() === "darwin" ? 2 : 1;
    if (browserType.name() === "webkit" && process.platform === "linux") {
      delete contextOptions.hasTouch;
      delete contextOptions.isMobile;
    }
    if (contextOptions.isMobile && browserType.name() === "firefox")
      contextOptions.isMobile = void 0;
    if (options.proxyServer) {
      launchOptions.proxy = {
        server: options.proxyServer
      };
      if (options.proxyBypass)
        launchOptions.proxy.bypass = options.proxyBypass;
    }
    const browser = yield browserType.launch(launchOptions);
    if (options.viewportSize) {
      try {
        const [width, height] = options.viewportSize.split(",").map((n) => parseInt(n, 10));
        contextOptions.viewport = {
          width,
          height
        };
      } catch (e) {
        console.log('Invalid window size format: use "width, height", for example --window-size=800,600');
        process.exit(0);
      }
    }
    if (options.geolocation) {
      try {
        const [latitude, longitude] = options.geolocation.split(",").map((n) => parseFloat(n.trim()));
        contextOptions.geolocation = {
          latitude,
          longitude
        };
      } catch (e) {
        console.log('Invalid geolocation format: user lat, long, for example --geolocation="37.819722,-122.478611"');
        process.exit(0);
      }
      contextOptions.permissions = ["geolocation"];
    }
    if (options.userAgent)
      contextOptions.userAgent = options.userAgent;
    if (options.lang)
      contextOptions.locale = options.lang;
    if (options.colorScheme)
      contextOptions.colorScheme = options.colorScheme;
    if (options.timezone)
      contextOptions.timezoneId = options.timezone;
    if (options.loadStorage)
      contextOptions.storageState = options.loadStorage;
    if (options.ignoreHttpsErrors)
      contextOptions.ignoreHTTPSErrors = true;
    const context = yield browser.newContext(contextOptions);
    let closingBrowser = false;
    function closeBrowser() {
      return __async(this, null, function* () {
        if (closingBrowser)
          return;
        closingBrowser = true;
        if (options.saveTrace)
          yield context.tracing.stop({
            path: options.saveTrace
          });
        if (options.saveStorage)
          yield context.storageState({
            path: options.saveStorage
          }).catch((e) => null);
        yield browser.close();
      });
    }
    context.on("page", (page) => {
      page.on("dialog", () => {
      });
      page.on("close", () => {
        const hasPage = browser.contexts().some((context2) => context2.pages().length > 0);
        if (hasPage)
          return;
        closeBrowser().catch((e) => null);
      });
    });
    if (options.timeout) {
      context.setDefaultTimeout(parseInt(options.timeout, 10));
      context.setDefaultNavigationTimeout(parseInt(options.timeout, 10));
    }
    if (options.saveTrace)
      yield context.tracing.start({
        screenshots: true,
        snapshots: true
      });
    delete launchOptions.headless;
    delete launchOptions.executablePath;
    delete contextOptions.deviceScaleFactor;
    return {
      browser,
      browserName: browserType.name(),
      context,
      contextOptions,
      launchOptions
    };
  });
}
function openPage(context, url) {
  return __async(this, null, function* () {
    const page = yield context.newPage();
    if (url) {
      if (_fs.default.existsSync(url))
        url = "file://" + _path.default.resolve(url);
      else if (!url.startsWith("http") && !url.startsWith("file://") && !url.startsWith("about:") && !url.startsWith("data:"))
        url = "http://" + url;
      yield page.goto(url);
    }
    return page;
  });
}
function open(options, url, language2) {
  return __async(this, null, function* () {
    const {
      context,
      launchOptions,
      contextOptions
    } = yield launchContext(options, !!process.env.PWTEST_CLI_HEADLESS, process.env.PWTEST_CLI_EXECUTABLE_PATH);
    yield context._enableRecorder({
      language: language2,
      launchOptions,
      contextOptions,
      device: options.device,
      saveStorage: options.saveStorage
    });
    yield openPage(context, url);
    if (process.env.PWTEST_CLI_EXIT)
      yield Promise.all(context.pages().map((p) => p.close()));
  });
}
function codegen(options, url, language2, outputFile) {
  return __async(this, null, function* () {
    const {
      context,
      launchOptions,
      contextOptions
    } = yield launchContext(options, !!process.env.PWTEST_CLI_HEADLESS, process.env.PWTEST_CLI_EXECUTABLE_PATH);
    yield context._enableRecorder({
      language: language2,
      launchOptions,
      contextOptions,
      device: options.device,
      saveStorage: options.saveStorage,
      startRecording: true,
      outputFile: outputFile ? _path.default.resolve(outputFile) : void 0
    });
    yield openPage(context, url);
    if (process.env.PWTEST_CLI_EXIT)
      yield Promise.all(context.pages().map((p) => p.close()));
  });
}
function waitForPage(page, captureOptions) {
  return __async(this, null, function* () {
    if (captureOptions.waitForSelector) {
      console.log(`Waiting for selector ${captureOptions.waitForSelector}...`);
      yield page.waitForSelector(captureOptions.waitForSelector);
    }
    if (captureOptions.waitForTimeout) {
      console.log(`Waiting for timeout ${captureOptions.waitForTimeout}...`);
      yield page.waitForTimeout(parseInt(captureOptions.waitForTimeout, 10));
    }
  });
}
function screenshot(options, captureOptions, url, path) {
  return __async(this, null, function* () {
    const {
      browser,
      context
    } = yield launchContext(options, true);
    console.log("Navigating to " + url);
    const page = yield openPage(context, url);
    yield waitForPage(page, captureOptions);
    console.log("Capturing screenshot into " + path);
    yield page.screenshot({
      path,
      fullPage: !!captureOptions.fullPage
    });
    yield browser.close();
  });
}
function pdf(options, captureOptions, url, path) {
  return __async(this, null, function* () {
    if (options.browser !== "chromium") {
      console.error("PDF creation is only working with Chromium");
      process.exit(1);
    }
    const {
      browser,
      context
    } = yield launchContext(__spreadProps(__spreadValues({}, options), {
      browser: "chromium"
    }), true);
    console.log("Navigating to " + url);
    const page = yield openPage(context, url);
    yield waitForPage(page, captureOptions);
    console.log("Saving as pdf into " + path);
    yield page.pdf({
      path
    });
    yield browser.close();
  });
}
function lookupBrowserType(options) {
  let name = options.browser;
  if (options.device) {
    const device = playwright.devices[options.device];
    name = device.defaultBrowserType;
  }
  let browserType;
  switch (name) {
    case "chromium":
      browserType = playwright.chromium;
      break;
    case "webkit":
      browserType = playwright.webkit;
      break;
    case "firefox":
      browserType = playwright.firefox;
      break;
    case "cr":
      browserType = playwright.chromium;
      break;
    case "wk":
      browserType = playwright.webkit;
      break;
    case "ff":
      browserType = playwright.firefox;
      break;
  }
  if (browserType)
    return browserType;
  _commander.program.help();
}
function validateOptions(options) {
  if (options.device && !(options.device in playwright.devices)) {
    console.log(`Device descriptor not found: '${options.device}', available devices are:`);
    for (const name in playwright.devices)
      console.log(`  "${name}"`);
    process.exit(0);
  }
  if (options.colorScheme && !["light", "dark"].includes(options.colorScheme)) {
    console.log('Invalid color scheme, should be one of "light", "dark"');
    process.exit(0);
  }
}
function logErrorAndExit(e) {
  console.error(e);
  process.exit(1);
}
function language() {
  return process.env.PW_CLI_TARGET_LANG || "test";
}
function commandWithOpenOptions(command, description, options) {
  let result = _commander.program.command(command).description(description);
  for (const option of options)
    result = result.option(option[0], ...option.slice(1));
  return result.option("-b, --browser <browserType>", "browser to use, one of cr, chromium, ff, firefox, wk, webkit", "chromium").option("--channel <channel>", 'Chromium distribution channel, "chrome", "chrome-beta", "msedge-dev", etc').option("--color-scheme <scheme>", 'emulate preferred color scheme, "light" or "dark"').option("--device <deviceName>", 'emulate device, for example  "iPhone 11"').option("--geolocation <coordinates>", 'specify geolocation coordinates, for example "37.819722,-122.478611"').option("--ignore-https-errors", "ignore https errors").option("--load-storage <filename>", "load context storage state from the file, previously saved with --save-storage").option("--lang <language>", 'specify language / locale, for example "en-GB"').option("--proxy-server <proxy>", 'specify proxy server, for example "http://myproxy:3128" or "socks5://myproxy:8080"').option("--proxy-bypass <bypass>", 'comma-separated domains to bypass proxy, for example ".com,chromium.org,.domain.com"').option("--save-storage <filename>", "save context storage state at the end, for later use with --load-storage").option("--save-trace <filename>", "record a trace for the session and save it to a file").option("--timezone <time zone>", 'time zone to emulate, for example "Europe/Rome"').option("--timeout <timeout>", "timeout for Playwright actions in milliseconds", "10000").option("--user-agent <ua string>", "specify user agent string").option("--viewport-size <size>", 'specify browser viewport size in pixels, for example "1280, 720"');
}
function launchGridServer(factoryPathOrPackageName, port, authToken) {
  return __async(this, null, function* () {
    if (!factoryPathOrPackageName)
      factoryPathOrPackageName = _path.default.join("..", "grid", "simpleGridFactory");
    let factory;
    try {
      factory = require(_path.default.resolve(factoryPathOrPackageName));
    } catch (e) {
      factory = require(factoryPathOrPackageName);
    }
    if (factory && typeof factory === "object" && "default" in factory)
      factory = factory["default"];
    if (!factory || !factory.launch || typeof factory.launch !== "function")
      throw new Error("factory does not export `launch` method");
    factory.name = factory.name || factoryPathOrPackageName;
    const gridServer = new _gridServer.GridServer(factory, authToken);
    yield gridServer.start(port);
    console.log("Grid server is running at " + gridServer.urlPrefix());
  });
}
function buildBasePlaywrightCLICommand(cliTargetLang) {
  switch (cliTargetLang) {
    case "python":
      return `playwright`;
    case "java":
      return `mvn exec:java -e -Dexec.mainClass=com.microsoft.playwright.CLI -Dexec.args="...options.."`;
    case "csharp":
      return `playwright`;
    default:
      return `npx playwright`;
  }
}
/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */
